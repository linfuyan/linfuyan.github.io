<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







  

<link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="阿阿燃, uprogrammer, 有程, java, Android, web" />





  <link rel="alternate" href="/atom.xml" title="阿阿燃" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="阿阿燃">
<meta property="og:url" content="http://linfuyan.com/page/4/index.html">
<meta property="og:site_name" content="阿阿燃">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿阿燃">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linfuyan.com/page/4/"/>





  <title>阿阿燃</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿阿燃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/google-java-style-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/google-java-style-guide/" itemprop="url">Google Java 编程风格指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-12T11:24:09+08:00">
                2015-11-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-11-12T15:05:41+08:00">
                2015-11-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/" itemprop="url" rel="index">
                    <span itemprop="name">开发技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p>
<p>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</p>
<p>其他的术语说明会偶尔在后面的文档出现。</p>
<h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<h1 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2. 源文件基础"></a>2. 源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 .java。</p>
<h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p>
<h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \“, \‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p>
<h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。<br>例如：</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String unitAbbrev = “μs”;</td>
<td>赞，即使没有注释也非常清晰</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // “μs”</td>
<td>允许，但没有理由要这样做</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td>
<td>允许，但这样做显得笨拙还容易出错</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”;</td>
<td>很糟，读者根本看不出这是什么</td>
</tr>
<tr>
<td>return ‘\ufeff’ + content; // byte order mark</td>
<td>好，对于非打印字符，使用转义，并在必要时写上注释</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Tip: 永远不要由于害怕某些程序可能无法正确处理非 ASCII 字符而让你的代码可读性变差。当程序无法正确处理非 ASCII 字符时，它自然无法正确运行， 你就会去 fix 这些问题的了。(言下之意就是大胆去用非 ASCII 字符，如果真的有需要的话)</p>
</blockquote>
<h1 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3. 源文件结构"></a>3. 源文件结构</h1><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：import java.util.*;</p>
<h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import 语句不换行，列限制(4.4节)并不适用于 import 语句。(每个 import 语句独立成行)</p>
<h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import 语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<ol>
<li>所有的静态导入独立成组</li>
<li><code>com.google</code> imports (仅当这个源文件是在 <code>com.google</code> 包下)</li>
<li>第三方的包。每个顶级包为一组，字典序。例如： android, com, junit, org, sun</li>
<li><code>java</code> imports</li>
<li><code>javax</code> imports</li>
</ol>
<p>组内不空行，按字典序排列。</p>
<blockquote>
<p>飞博团队要求：</p>
</blockquote>
<p>导入包的顺序为：静态导入，java基础包，javax基础包，android包，第三方包（每个顶级包为一组，字典序。例如：com, junit, org, sun, feibo包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">javax</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">android</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.feibo</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含 .java 后缀)。</p>
<h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 </p>
<p>最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="4-格式"><a href="#4-格式" class="headerlink" title="4. 格式"></a>4. 格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="noopener">Egyptian brackets</a>):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>实例：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                something();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">                recover();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.8.1节给出了enum类的一些例外。</p>
<h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(<code>if/else 或 try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-块缩进：4个空格"><a href="#4-2-块缩进：4个空格" class="headerlink" title="4.2 块缩进：4个空格"></a>4.2 块缩进：4个空格</h2><p>每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如， Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。</li>
<li>package 和 import 语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到 shell 中的命令行。</li>
</ol>
<h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
<h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li><p>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如C++和JavaScript)。 </p>
<ul>
<li>这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的 <code>&amp;（&lt;T extends Foo &amp; Bar&gt;)</code> ，catch块中的管道符号 <code>(catch (FooException | BarException e)</code> </li>
</ul>
</li>
<li><p>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。</p>
<ul>
<li>这条规则也适用于foreach语句中的分号。</li>
</ul>
</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>当一个表达式无法容纳在一行内时，可以依据如下一般规则断开之：</p>
<ul>
<li>在一个逗号后面断开。</li>
<li>在一个操作符前面断开。</li>
<li>宁可选择较高级别的(higher-level)的断开，而非较低级别(lower-level)的断开。</li>
<li>新的一行应该与上一行同一级别表达式的开头处对齐。</li>
<li>如果以上规则导致你的代码混乱或者使你的代码都堆挤在右边，那就代之以缩进8个空格。</li>
</ul>
<p>以下是断开方法的一些例子：</p>
<pre><code>someMethod(longExpression1, longExpression2, longExpression3,
        longExpression4, longExpression5); // 8个空格
var = someMethod1(Expression1,
                  someMethod2(longExpression2,
                              longExpression3));
</code></pre><p>以下是两个断开算术表达式的例子。前者更好，因为断开处位于括号表达式的外边，这是个较高级别的断开。</p>
<pre><code>longName1 = longName2 * (longName3 + longName4 - longName5)
            + 4 * longname6; // PREFER
longName1 = longName2 * (longName3 + longName4
        - longName5) + 4 * longName6; //AVOID
</code></pre><p>以下是两个缩进方法声明的例子。前者是常规情形，后者若使用常规的缩进方式将会使第二行和第三行移得很靠右，所以代这以缩进8个空格。</p>
<pre><code>// CONVENTION INDENTATION
someMethod(int anArg, Object anotherArg,
           String yetAnotherArg,
           Object andStillAnother) {
    ……
}

// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS
private static synchronized horkingLongMethodName(int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother) {
    ……
}
</code></pre><p>if语句的换行通常使用8个空格的规则，因为常规缩进(4个空格)会使语句看起来比较费劲。比如：</p>
<pre><code>//DON’T USE THIS INDENTATION
if ((condition1 &amp;&amp; condition2)
    || (condition3 &amp;&amp; condition4)
    || !(condition5 &amp;&amp; condition6)) { //BAD WRAPS
    doSomethingAboutIt(); // MAKE THIS LING EASY TO MISS
}
// USE THIS INDENTATION INSTEAD
if ((condition1 &amp;&amp; condition2)
        || (condition3 &amp;&amp; condition4)
        || !(condition5 &amp;&amp; condition6)) {
    doSomethingAboutIt();
}

// OR USE THIS
if ((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)
        || !(condition5 &amp;&amp; condition6)) {
   doSomthingAoutIt();
}
</code></pre><p>这里有三种可行的方法用于处理三元运算表达式：</p>
<pre><code>alpha = (aLongBooleanExpression) ? beta : gamma;

alpha = (aLongBooleanExpression) ? beta
                                 : gamma;

alpha = (aLongBooleanExpression)
        ? beta
        : gamma;
</code></pre><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ol>
<p>空行将逻辑相关的代码段分隔开，以提高可读性。</p>
<p>下列情况应总是使用两个空行：</p>
<ul>
<li>一个源文件的两个片段(section)之间。</li>
<li>类声明和接口声明之间。</li>
</ul>
<p>下列情况应该总是使用一个空行：</p>
<ul>
<li>两个方法之间。方法与方法之间 以空行分隔。</li>
<li>方法内的局部变量和方法的第一条语句之间。</li>
<li>块注释(参见“5.1.1”)或单行注释(参见5.1.2)之前。</li>
<li>一个方法内的两个逻辑段之间，用以提高可读性。</li>
</ul>
<h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code> (不使用空格)。</li>
<li><code>String[][] x = foo;</code> (大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的<code>&amp;(&lt;T extends Foo &amp; Bar&gt;)</code>。</li>
<li>catch块中的管道符号<code>(catch (FooException | BarException e)</code>。</li>
<li>foreach语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则双斜杠(<code>//</code>)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：<code>List&lt;String&gt; list</code>。</li>
<li>数组初始化中，大括号内的空格是可选的，<ul>
<li><code>new int[] {5, 6}</code> 和 <code>new int[] { 5, 6 }</code> 都是可以的。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了 reviewer 的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-6-4-空格-Blank-Spaces"><a href="#4-6-4-空格-Blank-Spaces" class="headerlink" title="4.6.4 空格(Blank Spaces)"></a>4.6.4 空格(Blank Spaces)</h3><p>下列情况应该使用空格：</p>
<p>1. 一个紧跟着括号的关键应该被空格分开，例如：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：空格不应该置于方法名与其左括号之间，这将有助于区分关键字和方法调用。</p>
</blockquote>
<p>2. 空白应该位于参数列表中逗号的后面。</p>
<p>3. 所有的二元运算符，除了“.”，应该使用空格将之与操作数分开。一元操作符和操作数之间不应该加空格，比如：负号(“-”)，自增(“++”)和自减(“–”)。例如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">a</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span> <span class="literal">+</span> <span class="comment">d;</span></span><br><span class="line"><span class="comment">a</span> <span class="comment">=</span> <span class="comment">(a</span> <span class="literal">+</span> <span class="comment">b)</span> <span class="comment">/</span> <span class="comment">(c</span> <span class="comment">*</span> <span class="comment">d);</span></span><br><span class="line"><span class="comment"></span>        </span><br><span class="line"><span class="comment">while</span> <span class="comment">(d</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">=</span> <span class="comment">s</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">n</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printSize(“size</span> <span class="comment">is</span> <span class="comment">”</span> <span class="literal">+</span> <span class="comment">foo</span> <span class="literal">+</span> <span class="comment">“\n”);</span></span><br></pre></td></tr></table></figure>
<p>4. for语句中的表达式应该被空格分开，例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (expr1<span class="comment">; expr2; expr3)</span></span><br></pre></td></tr></table></figure>
<p>5. 强制转型后应该跟一个空格，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myMethod((<span class="name">byte</span>) aNum, (<span class="name">Object</span>) x)<span class="comment">;</span></span><br><span class="line">myMethod((<span class="name">int</span>) (<span class="name">cp</span> + <span class="number">5</span>), ((<span class="name">int</span>) (<span class="name">i</span> + <span class="number">3</span>)) + <span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h2 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h2><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> &#123; <span class="title">CLUBS</span>, <span class="title">HEARTS</span>, <span class="title">SPADES</span>, <span class="title">DIAMONDS</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如 <code>int a, b;</code>。</p>
<h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[]</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[]</code> args， 而非 <code>String args[]</code>。</p>
<h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p>术语说明：switch 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签( case FOO: 或 default: )，后面跟着一条或多条语句。</p>
<h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为4个空格。</p>
<p>每个switch标签后新起一行，再缩进4个空格，写下一条或多条语句。</p>
<h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个 switch 块内，每个语句组要么通过 <code>break, continue, return</code> 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是 OK 的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">input</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        prepareOneOrTwo()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        handleOneTwoOrThree()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">break</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        handleLargeNumber(<span class="keyword">input</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。</p>
<h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@Nullable</span></span><br><span class="line">public String getNameIfPresent() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Partial</span> <span class="variable">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。以下示例注释都是OK的。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This <span class="keyword">is</span>          // <span class="keyword">And</span> so           /* <span class="keyword">Or</span> you can</span><br><span class="line"> * okay.            // <span class="keyword">is</span> this.          * even <span class="keyword">do</span> this. */</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 <code>/* ... */</code>。</p>
</blockquote>
<h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-8-简单语句-Simple-Statement"><a href="#4-8-8-简单语句-Simple-Statement" class="headerlink" title="4.8.8 简单语句(Simple Statement)"></a>4.8.8 简单语句(Simple Statement)</h3><p>每行至多包含一条语句，例如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span> <span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>    <span class="comment">//</span> <span class="comment">AVOID!</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-9-复合语句-Compound-Statements"><a href="#4-8-9-复合语句-Compound-Statements" class="headerlink" title="4.8.9 复合语句(Compound Statements)"></a>4.8.9 复合语句(Compound Statements)</h3><p>复合语句是包含在大括号中的语句序列，形如“{ statements }”。例如下面各段。</p>
<ul>
<li>被括其中的语句应该较之复合语句缩进一个层次。</li>
<li>左大括号“{”应位于复合语句起始行的行尾；右大括号“}”应另起一行并与复合语句首行对齐。</li>
<li>大括号可以被用于所有语句，包括单个语句，只要这些语句是诸如if–else或for控制结构的一部分。这样便于添加语句而无需担心由于忘了加括号而引入bug.</li>
</ul>
<h3 id="4-8-10-返回语句-return-Statements-s"><a href="#4-8-10-返回语句-return-Statements-s" class="headerlink" title="4.8.10 返回语句(return Statements)s"></a>4.8.10 返回语句(return Statements)s</h3><p>一个带返回值的return语句不使用小括号“()”，除非它们以某种方式使返回值更显见。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span>;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> myDisk.<span class="built_in">size</span>();  </span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> (<span class="built_in">size</span> ? <span class="built_in">size</span> ; defaultSize);</span><br></pre></td></tr></table></figure>
<h3 id="4-8-11-if-if-else-if-else-if-else-语句-if-if-else-if-else-if-else-Statements"><a href="#4-8-11-if-if-else-if-else-if-else-语句-if-if-else-if-else-if-else-Statements" class="headerlink" title="4.8.11 if, if-else, if else-if else 语句(if, if-else, if else-if else Statements)"></a>4.8.11 <code>if, if-else, if else-if else</code> 语句(<code>if, if-else, if else-if else Statements</code>)</h3><p>if-else 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：if 语句问题用 “{” 和 “}” 括起来，避免使用如下容易引起错误的格式：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">condition</span>)  <span class="comment">// AVOI! THIS OMITS THE BRACES &#123;&#125;!</span></span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-12-for语句-for-Statements"><a href="#4-8-12-for语句-for-Statements" class="headerlink" title="4.8.12 for语句(for Statements)"></a>4.8.12 for语句(for Statements)</h3><p>一个for语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; <span class="keyword">update</span>) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空的for语句(所有工作都在初始化，条件判断，更新子句中完成)应该具有如下格式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">initialization</span>; condition; update);</span><br></pre></td></tr></table></figure>
<p>当在 for 语句的初始化或更新子句中使用逗号时，避免因使用三个以上变量，而导致复杂度提高。若需要，可以在 for 循环之前(为初始化子句)或 for 循环末尾(为更新子句)使用单独的语句。</p>
<h3 id="4-8-13-while语句-while-Statements"><a href="#4-8-13-while语句-while-Statements" class="headerlink" title="4.8.13 while语句(while Statements)"></a>4.8.13 while语句(while Statements)</h3><p>一个 while 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空的 while 语句应该具有如下格式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(condition)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-14-do-while语句-do-while-Statements"><a href="#4-8-14-do-while语句-do-while-Statements" class="headerlink" title="4.8.14 do-while语句(do-while Statements)"></a>4.8.14 do-while语句(do-while Statements)</h3><p>一个 do-while 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<h3 id="4-8-15-switch语句-switch-Statements"><a href="#4-8-15-switch语句-switch-Statements" class="headerlink" title="4.8.15 switch语句(switch Statements)"></a>4.8.15 switch语句(switch Statements)</h3><p>一个 switch 语句应该具有如下格式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">ABC:</span></span><br><span class="line">    statements;</span><br><span class="line">    <span class="comment">/* falls through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">DEF:</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">case</span> <span class="string">XYZ:</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">default:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">false :</span> condition;  <span class="comment">// Or throw error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个 case 顺着往下执行时(因为没有 break 语句)，通常应在 break 语句的位置添加注释。上面的示例代码中就包含注释 <code>/* falls through */</code> 。</p>
<p>每个 switch 语句，必须有对应的 default 语句。如果执行不到，可以加上  assert语句。</p>
<p>case 语句后面需要使用 “{“ , “}” 包含语句块。</p>
<h3 id="4-8-16-try-catch语句-try-catch-Statements"><a href="#4-8-16-try-catch语句-try-catch-Statements" class="headerlink" title="4.8.16 try-catch语句(try-catch Statements)"></a>4.8.16 try-catch语句(try-catch Statements)</h3><p>一个 try-catch 语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass e) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 try-catch 语句后面也可能跟着一个 finally 语句，不论 try 代码块是否顺利执行完，它都会被执行。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass e) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-命名规范-Naming"><a href="#5-命名规范-Naming" class="headerlink" title="5. 命名规范(Naming)"></a>5. 命名规范(Naming)</h1><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用 ASCII 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 \w+。</p>
<h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>一个唯一包名的前缀总是全部小写的 ASCⅡ 字母并且是一个顶级域名，通常是 com，gov，edu，mil，net，org，或1981年ISO 3166标准所指定的标识的国家的英文双字符代码。包名的后续部分根据不同机构各自内部的命名规范而不尽相同。这类命名规范可能以特定目录名的组成来区分部门(department)，项目(project)，机器(machine)，或注册名(login names)。</p>
<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.eng</span></span><br><span class="line">com<span class="selector-class">.feibo</span><span class="selector-class">.joke</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名是一个名词，采用大小写混合方式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。使用完整单词，避免缩写词(除非该缩写词被广泛的使用，如 URL，HTML)。例如：</p>
<p>类名都以 UpperCamelCase 风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以 Test 结束。例如， HashTest 或 HashIntegrationTest。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raster</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageSprite</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以 lowerCamelCase 风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是： <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code> ，例如 <code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为 <code>CONSTANT_CASE</code> ，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;<span class="built_in">String</span>&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span>[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以 lowerCamelCase 风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以 lowerCamelCase 风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><p>驼峰式命名法分大驼峰式命名法( UpperCamelCase )和小驼峰式命名法( lowerCamelCase )。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。 Google 指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯 ASCII 码，并且移除任何单引号。例如： “Müller’s algorithm” 将变成 “Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>实例：</p>
<table>
<thead>
<tr>
<th>Prose form</th>
<th>Correct</th>
<th>Incorrect</th>
</tr>
</thead>
<tbody>
<tr>
<td>“XML HTTP request”</td>
<td>XmlHttpRequest</td>
<td>XMLHTTPRequest</td>
</tr>
<tr>
<td>“new customer ID”</td>
<td>newCustomerId</td>
<td>newCustomerID</td>
</tr>
<tr>
<td>“inner stopwatch”</td>
<td>innerStopwatch</td>
<td>innerStopWatch</td>
</tr>
<tr>
<td>“supports IPv6 on iOS?”</td>
<td>supportsIpv6OnIos</td>
<td>supportsIPv6OnIOS</td>
</tr>
<tr>
<td>“YouTube importer”</td>
<td>YouTubeImporter</td>
<td>YoutubeImporter*</td>
</tr>
</tbody>
</table>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>注意：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名 checkNonempty 和 checkNonEmpty 也都是正确的。</p>
</blockquote>
<h1 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6. 编程实践"></a>6. 编程实践</h1><h2 id="6-1-Override：-能用则用"><a href="#6-1-Override：-能用则用" class="headerlink" title="6.1 @Override： 能用则用"></a>6.1 @Override： 能用则用</h2><p>只要是合法的，就把@Override注解给用上。</p>
<h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。)</p>
<p>如果它确实是不需要在 catch 块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">handleNumericResponse</span><span class="params">(i)</span></span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">    <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">handleTextResponse</span><span class="params">(response)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    emptyStack.pop();</span><br><span class="line">    fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = <span class="string">...</span>;</span><br><span class="line">Foo.aStaticMethod<span class="params">()</span>; <span class="string">//</span> good</span><br><span class="line">aFoo.aStaticMethod<span class="params">()</span>; <span class="string">//</span> bad</span><br><span class="line">somethingThatYieldsAFoo<span class="params">()</span><span class="string">.aStaticMethod</span><span class="params">()</span>; <span class="string">//</span> very bad</span><br></pre></td></tr></table></figure>
<h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重载 Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7. Javadoc"></a>7. Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc 块的基本格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** An especially short bit of Javadoc. *</span>/</span></span></span><br></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="7-1-3-Javadoc-标记"><a href="#7-1-3-Javadoc-标记" class="headerlink" title="7.1.3 Javadoc 标记"></a>7.1.3 Javadoc 标记</h3><p>标准的 Javadoc 标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 <code>A {@code Foo} is a...</code> 或 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record...</code> 。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的 Javadoc 写成 <code>/** @return the customer ID */</code> ，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="7-3-哪里需要使用-Javadoc"><a href="#7-3-哪里需要使用-Javadoc" class="headerlink" title="7.3 哪里需要使用 Javadoc"></a>7.3 哪里需要使用 Javadoc</h2><p>至少在每个 public 类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p>
<h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如 getFoo，Javadoc 是可选的(即，是可以不写的)。这种情况下除了写 “Returns the foo” ，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p>
</blockquote>
<h3 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h3><p>如果一个方法重载了超类中的方法，那么 Javadoc 并非必需的。</p>
<h3 id="7-3-3-可选的-Javadoc"><a href="#7-3-3-可选的-Javadoc" class="headerlink" title="7.3.3 可选的 Javadoc"></a>7.3.3 可选的 Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。</p>
<h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><p><a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Google Java StyleGuide 中文翻译</a></p>
<p><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java StyleGuide 官方英文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/objective-c-coding-style-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/objective-c-coding-style-guide/" itemprop="url">Objective-C 编码风格指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-11T21:11:50+08:00">
                2015-11-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-11-20T17:35:54+08:00">
                2015-11-20
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/" itemprop="url" rel="index">
                    <span itemprop="name">开发技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>源文件编码格式为 UTF-8</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>使用英语，变量的命名等已英语单词命名，不要使用汉语拼音。</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>使用 <code>#pragma mark</code> 来为方法分组。</p>
<h2 id="间距与空白"><a href="#间距与空白" class="headerlink" title="间距与空白"></a>间距与空白</h2><ul>
<li>一个缩进使用 4 个空格，不要使用制表符。可以在 Xcode 中配置自动将 Tab 转化为空格。在 Xcode &gt; Preferences &gt; Text Editing 将 Tab 和自动缩进都设置为 4 个空格。</li>
<li>行尾不允许留有空格。</li>
<li>关键字及符号之间需要留有 1 个空格。</li>
<li>方法或者代码块之间留有一行空白。</li>
</ul>
<h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><ul>
<li>方法和大括号及其他大括号( if / else / switch / while 等等)始终和声明在同一行开始，在新的一行结束。</li>
</ul>
<p>以下是正确的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是不正确的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为 Xcode 的对齐方式令它难以辨认。</li>
</ul>
<p>应该：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line"><span class="symbol">                 animations:</span>^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line"><span class="symbol">                 completion:</span>^(BOOL finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul>
<li>长的，描述性的方法和变量命名是好的。</li>
</ul>
<p>应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *setBut<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。</p>
</blockquote>
<ul>
<li>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@synthesize语句，除非你有一个好的理由。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id varnm<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>当使用属性时，实例变量应该使用 <code>self.</code> 来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有 <code>self.</code> 。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免 <code>getters/setters</code> 潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合 Apple 的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像 initWithWidth:height 以下这个例子：</p>
<p>应该：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setExampleText:<span class="params">(NSString *)</span>text image:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector to:<span class="params">(id)</span>anObject forAllCells:<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>viewWithTag:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width height:<span class="params">(CGFloat)</span>height;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">setT</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">text</span> <span class="selector-tag">i</span><span class="selector-pseudo">:(UIImage</span> *)<span class="selector-tag">image</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">sendAction</span><span class="selector-pseudo">:(SEL)aSelector</span> <span class="selector-pseudo">:(id)anObject</span> <span class="selector-pseudo">:(BOOL)flag</span>;</span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">taggedView</span><span class="selector-pseudo">:(NSInteger)tag</span>;</span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithWidth</span><span class="selector-pseudo">:(CGFloat)width</span> <span class="selector-tag">andHeight</span><span class="selector-pseudo">:(CGFloat)height</span>;</span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWith</span><span class="selector-pseudo">:(int)width</span> <span class="selector-tag">and</span><span class="selector-pseudo">:(int)height</span>;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p>私有变量应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性( _variable ，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法( init , initWithCoder: , 等…)， dealloc 方法和自定义的 setters 和 getters 。想了解关于如何在初始化方法和 dealloc 直接使用 Accessor 方法的更多信息，查看这里。</p>
<p>应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">    NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><ul>
<li>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是 storage、atomicity，与在 Interface Builder 连接 UI 元素时自动生成代码一致。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSString应该使用copy而不是strong的属性特性。</li>
</ul>
<blockquote>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<h2 id="点符号语法"><a href="#点符号语法" class="headerlink" title="点符号语法"></a>点符号语法</h2><ul>
<li>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用 getter 或 setter 方法，属性仍然被访问或修改。想了解更多，阅读<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">这里</a>。</li>
</ul>
<blockquote>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSInteger arrayCount = [self.array <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">view.<span class="keyword">backgroundColor </span>= [UIColor <span class="keyword">orangeColor];</span></span><br><span class="line"><span class="keyword">[UIApplication </span><span class="keyword">sharedApplication].delegate;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span>.array.count;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><ul>
<li>NSString、 NSDictionary、 NSArray 和 NSNumber 的字面值应该在创建这些类的不可变实例时被使用。请特别注意 nil 值不能传入 NSArray 和 NSDictionary 字面值，因为这样会导致 crash。</li>
</ul>
<p>应该：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names = @[@<span class="string">"Brian"</span>, @<span class="string">"Matt"</span>, @<span class="string">"Chris"</span>, @<span class="string">"Alex"</span>, @<span class="string">"Steve"</span>, @<span class="string">"Paul"</span>]<span class="comment">;</span></span><br><span class="line">NSDictionary *productManagers = @&#123;@<span class="string">"iPhone"</span>: @<span class="string">"Kate"</span>, @<span class="string">"iPad"</span>: @<span class="string">"Kamal"</span>, @<span class="string">"Mobile Web"</span>: @<span class="string">"Bill"</span>&#125;<span class="comment">;</span></span><br><span class="line">NSNumber *<span class="keyword">shouldUseLiterals </span>= @YES<span class="comment">;</span></span><br><span class="line">NSNumber *<span class="keyword">buildingStreetNumber </span>= @<span class="number">10018</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。</p>
<p>常量常用的命名方法是：若常量局限于某“编译单元”（translation unit，也就是“实现文件”， implementation file）之内，则在前面加字母k, 如kAnimationDuration；若常量在类之外可见，则通常以类名为前缀。应该如 <code>static NSString * const</code> 而不是 <code>static const NSString *</code>。</p>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CompanyName @<span class="meta-string">"RayWenderlich.com"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thumbnailHeight 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量指针：初始化之后不能赋值。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> pt1;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向常量的指针：初始化之后可以赋值，即指向别的常量，指针本身的值可以修改。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * pt2;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向常量的常量指针</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> pt3;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul>
<li>当使用 enum 时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在 SDK 有一个宏 NS_ENUM() 来帮助和鼓励你使用固定的基本类型。</li>
</ul>
<p>例如：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">RWTLeftMenuTopItemType</span>) &#123;</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemMain</span>,</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemShows</span>,</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemSchedule</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">RWTGlobalConstants</span>) &#123;</span><br><span class="line">    <span class="type">RWTPinSizeMin</span> = 1,</span><br><span class="line">    <span class="type">RWTPinSizeMax</span> = 5,</span><br><span class="line">    <span class="type">RWTPinCountMin</span> = 100,</span><br><span class="line">    <span class="type">RWTPinCountMax</span> = 500,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旧的 k-style 常量定义应该避免，除非编写 Core Foundation C 的代码。</p>
<p>不应该：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> &#123;</span></span><br><span class="line">    kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">    kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h2><ul>
<li>大括号在 case 语句中必须的，不仅仅是 case 语句包含多行代码时，大括号都应该加上。</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 这个是不应该的</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Multi-line example using braces</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// 应该的</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// ** fall-through! **</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当在switch使用枚举类型时，’default’是不需要的。例如：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul>
<li>Objective-C 使用 YES 和 NO。因为 true 和 false 应该只在 CoreFoundation， C 或 C++ 代码使用。既然 nil 解析成 NO ，所以没有必要在条件语句比较。不要拿某样东西直接与 YES 比较，因为 YES 被定义为 1 而一个 BOOL 能被设置为8位。</li>
</ul>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == true)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ul>
<li>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为 if 语句；还有，<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="noopener">even more dangerous defect</a> 可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</li>
</ul>
<p>应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="built_in">    return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="built_in">    return</span> success;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="literal">return</span> success;</span><br></pre></td></tr></table></figure>
<h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><p>当需要提高代码的清晰性和简洁性时，三元操作符 ?: 才会使用。单个条件求值常常需要它。多个条件求值时，如果使用 if 语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean 的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是 boolean 类型，那么就不需要括号。</p>
<p>应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSInteger value</span> = 5;</span><br><span class="line"><span class="attribute">result</span> = (value != 0) ? x : y;</span><br><span class="line"><span class="attribute">BOOL isHorizontal</span> = YES;</span><br><span class="line"><span class="attribute">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">result</span> = a &gt; b <span class="meta">? x = c &gt; d ?</span> c : d : y;</span><br></pre></td></tr></table></figure>
<h2 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法"></a>Init方法</h2><p>Init 方法应该遵循 Apple 生成代码模板的命名规则，返回类型应该使用 instancetype 而不是 id。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="type">Airplane</span></span><br><span class="line">+ (instance<span class="keyword">type</span>)airplaneWithType:(<span class="type">RWTAirplaneType</span>)<span class="keyword">type</span>;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>关于更多 instancetype，请查看<a href="http://nshipster.com/instancetype/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry：</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGRect frame</span> = self.view.frame;</span><br><span class="line"><span class="attribute">CGFloat x</span> = CGRectGetMinX(frame);</span><br><span class="line"><span class="attribute">CGFloat y</span> = CGRectGetMinY(frame);</span><br><span class="line"><span class="attribute">CGFloat width</span> = CGRectGetWidth(frame);</span><br><span class="line"><span class="attribute">CGFloat height</span> = CGRectGetHeight(frame);</span><br><span class="line"><span class="attribute">CGRect frame</span> = CGRectMake(0.0, 0.0, width, height);</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGRect frame</span> = self.view.frame;</span><br><span class="line"><span class="attribute">CGFloat x</span> = frame.origin.x;</span><br><span class="line"><span class="attribute">CGFloat y</span> = frame.origin.y;</span><br><span class="line"><span class="attribute">CGFloat width</span> = frame.size.width;</span><br><span class="line"><span class="attribute">CGFloat height</span> = frame.size.height;</span><br><span class="line"><span class="attribute">CGRect frame</span> = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="黄金路径"><a href="#黄金路径" class="headerlink" title="黄金路径"></a>黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="comment">(void)</span>someMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="comment">([someOther boolValue])</span> &#123;</span><br><span class="line">        <span class="comment">//Do something important</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="built_in">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="built_in">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在成功的情况下，有些 Apple 的 APIs 记录垃圾值( garbage values )到错误参数(如果 non-NULL )，那么判断错误值会导致 false 负值和 crash。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype)sharedInstance </span>&#123;</span><br><span class="line">    static id <span class="keyword">sharedInstance </span>= nil<span class="comment">;</span></span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        <span class="keyword">sharedInstance </span>= [[self alloc] init]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return <span class="keyword">sharedInstance;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这可以防止<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="noopener">有时可能产生的崩溃</a></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span></span><br><span class="line"><span class="comment">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。<br>注：对于模块使用 @import 语法。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Frameworks</span></span><br><span class="line">@<span class="keyword">import</span> QuartzCore;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Models</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTUser.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Views</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTButton.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTUserView.h"</span></span><br></pre></td></tr></table></figure>
<h2 id="飞博可接受的缩略词"><a href="#飞博可接受的缩略词" class="headerlink" title="飞博可接受的缩略词"></a>飞博可接受的缩略词</h2><table>
<thead>
<tr>
<th>缩略词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>VC</td>
<td>ViewController</td>
</tr>
<tr>
<td>VM</td>
<td>ViewModel</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h3><p><a href="http://www.iwangke.me/objc-style-guide/" target="_blank" rel="noopener">Google Objective-C Style Guide 中文版</a></p>
<p><a href="http://linfuyan.com/apple-cocoa-coding-style-guide/">Apple 官方 Cocoa 编码规范</a></p>
<p><a href="http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1" target="_blank" rel="noopener">Objective-C编码规范：26个方面解决iOS开发问题</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide/blob/master/README_zh-Hans.md" target="_blank" rel="noopener">纽约时报 移动团队 Objective-C 规范指南</a></p>
<h3 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h3><p><a href="https://google.github.io/styleguide/objcguide.xml" target="_blank" rel="noopener">Google Objective-C Style Guide</a></p>
<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Coding Guidelines for Cocoa</a></p>
<p><a href="https://github.com/raywenderlich/objective-c-style-guide" target="_blank" rel="noopener">Raywenderlich.com Objective-C style guide</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="noopener">NYTimes Objective-C Style Guide</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/apple-cocoa-coding-style-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/apple-cocoa-coding-style-guide/" itemprop="url">Apple 官方 Cocoa 编码规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-10T16:06:39+08:00">
                2015-11-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-11-18T16:32:05+08:00">
                2015-11-18
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/" itemprop="url" rel="index">
                    <span itemprop="name">开发技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编码命名基础"><a href="#编码命名基础" class="headerlink" title="编码命名基础"></a>编码命名基础</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH" target="_blank" rel="noopener">Code Naming Basics</a></p>
<h3 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h3><h4 id="清晰性"><a href="#清晰性" class="headerlink" title="清晰性"></a>清晰性</h4><ul>
<li>最好是既清晰又简短，但不要为简短而丧失清晰性</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insertObject:atIndex:</td>
<td>好</td>
</tr>
<tr>
<td>insert:at:</td>
<td>不清晰：要插入什么？”at”表示什么？</td>
</tr>
<tr>
<td>removeObjectAtIndex:</td>
<td>好</td>
</tr>
<tr>
<td>removeObject:</td>
<td>这样也不错，因为方法是移除作为参数的对象</td>
</tr>
<tr>
<td>remove</td>
<td>不清晰；要移除什么?</td>
</tr>
</tbody>
</table>
<ul>
<li>名称通常不缩写，即使名称很长，也要拼写完全</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>destinationSelection</td>
<td>好</td>
</tr>
<tr>
<td>destSel</td>
<td>不清晰</td>
</tr>
<tr>
<td>setBackgroundColor</td>
<td>好</td>
</tr>
<tr>
<td>setBkgdColor</td>
<td>不清晰</td>
</tr>
</tbody>
</table>
<p>你可能会认为某个缩写广为人知，但有可能并非如此，尤其是当你的代码被来自不同文化和语言背景的开<br>发人员所使用时。</p>
<ul>
<li><p>然而，你可以使用少数非常常见，历史悠久的缩写。请参考：”可接受的缩略名”一节</p>
</li>
<li><p>避免使用有歧义的 API 名称，如那些能被理解成多种意思的方法名称</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sendPort</td>
<td>是发送端口还是返回一个发送端口?</td>
</tr>
<tr>
<td>displayName</td>
<td>是显示一个名称还是返回用户界面中控件的标题?</td>
</tr>
</tbody>
</table>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><ul>
<li>尽可能使用与 Cocoa 编程接口命名保持一致的名称。如果你不太确定某个命名的一致性，请浏览一下头文件或参考文档中的范例</li>
<li>在使用多态方法的类中，命名的一致性非常重要。在不同类中实现相同功能的方法应该具有相同的名称</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (int)tag</td>
<td>在 NSView， NSCell， NSControl 中有定义</td>
</tr>
<tr>
<td>- (void)setStringValue:(NSString *)</td>
<td>在许多 Cocoa classes 中有定义</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请参考“方法参数”一节。</p>
</blockquote>
<h4 id="不要自我指涉"><a href="#不要自我指涉" class="headerlink" title="不要自我指涉"></a>不要自我指涉</h4><ul>
<li>不要名称自我指涉</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString</td>
<td>好</td>
</tr>
<tr>
<td>NSStringObject</td>
<td>自我指涉</td>
</tr>
</tbody>
</table>
<ul>
<li>掩码(可使用位操作进行组合)和用作通知名称的常量不受该约定限制</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSUnderlineByWordMask</td>
<td>好</td>
</tr>
<tr>
<td>NSTableViewColumnDidMoveNotification</td>
<td>好</td>
</tr>
</tbody>
</table>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>前缀是名称的重要组成部分。它们可以区分软件的功能范畴。通常，软件会被打包成一个框架或多个紧密 相关的框架(如 Foundation 和 Application Kit 框架)。前缀可以防止第三方开发者与苹果公司之间的命 名冲突(同样也可防止苹果内部不同框架之间的命名冲突)</p>
<ul>
<li>前缀有规定的格式。它由两到三个大写字符组成，不能使用下划线与子前缀</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>Cocoa 框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>NS</td>
<td>Foundation</td>
</tr>
<tr>
<td>NS</td>
<td>Application Kit</td>
</tr>
<tr>
<td>AB</td>
<td>Address Book</td>
</tr>
<tr>
<td>IB</td>
<td>Interface Builder</td>
</tr>
</tbody>
</table>
<ul>
<li>命名 class， protocol， structure， 函数，常量时使用前缀；命名成员方法时不使用前缀，因为方法已经在它所在类的命名空间种；同理，命名结构体字段时也不使用前缀</li>
</ul>
<h3 id="书写约定"><a href="#书写约定" class="headerlink" title="书写约定"></a>书写约定</h3><p>在为 API 元素命名时，请遵循如下一些简单的书写约定</p>
<ul>
<li><p>对于包含多个单词的名称，不要使用标点符号作为名称的一部分或作为分隔符(下划线，破折号等)； 此外，大写每个单词的首字符并将这些单词连续拼写在一起。请注意以下限制:</p>
<ul>
<li>方法名小写第一个单词的首字符，大写后续所有单词的首字符。方法名不使用前缀。如:  <code>fileExistsAtPath:isDirectory:</code> 如果方法名以一个广为人知的大写首字母缩略词开头，该规则不适用，如: <code>NSImage</code> 中的 <code>TIFFRepresentation</code></li>
<li>函数名和常量名使用与其关联类相同的前缀，并且要大写前缀后面所有单词的首字符。如: <code>NSRunAlertPanel</code> ， <code>NSCellDisabled</code></li>
<li>避免使用下划线来表示名称的私有属性。苹果公司保留该方式的使用。如果第三方这样使用可能会导致命名冲突，他们可能会在无意中用自己的方法覆盖掉已有的私有方法，这会导致严重的后果。请参考”私有方法”一节以了解私有 API 的命名约定的建议</li>
</ul>
</li>
</ul>
<h3 id="类与协议命名"><a href="#类与协议命名" class="headerlink" title="类与协议命名"></a>类与协议命名</h3><p>类名应包含一个明确 述该类(或类的对象)是什么或做什么的名词。类名要有合适的前缀(请参考“前缀” 一节)。Foundation 及 Application Kit 有很多这样例子，如:NSString， NSData， NSScanner， NSApplication， NSButton 以及 NSEvent。</p>
<p>协议应该根据对方法的行为分组方式来命名。</p>
<ul>
<li>大多数协议仅组合一组相关的方法，而不关联任何类，这种协议的命名应该使用动名词(ing)，以不与 类名混淆。</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSLocking</td>
<td>好</td>
</tr>
<tr>
<td>NSLock</td>
<td>不好，看起来像类名</td>
</tr>
</tbody>
</table>
<ul>
<li>有些协议组合一些彼此无关的方法(这样做是避免创建多个独立的小协议)。这样的协议倾向于与某 个类关联在一起，该类是协议的主要体现者。在这种情形，我们约定协议的名称与该类同名。NSObject 协议就是这样一个例子。这个协议组合一组彼此无关的方法，有用于查询对象在其类层次中位置的方 法，有使之能调用特殊方法的方法以及用于增减引用计数的方法。由于 NSObject 是这些方法的主要 体现者，所以我们用类的名称命名这个协议。</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件的命名方式很重要，我们可以根据其命名知晓头文件的内容。</p>
<ul>
<li>声明孤立的类或协议:将孤立的类或协议声明放置在单独的头文件中，该头文件名称与类或协议同名</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSApplication</td>
<td>NSApplication类</td>
</tr>
</tbody>
</table>
<ul>
<li>声明相关联的类或协议:将相关联的声明(类，类别及协议) 放置在一个头文件中，该头文件名称与主要的类/类别/协议的名字相同。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString.h</td>
<td>NSString 和 NSMutableString 类</td>
</tr>
<tr>
<td>NSLock.h</td>
<td>NSLocking 协议和 NSLock， NSConditionLock， NSRecursiveLock 类</td>
</tr>
</tbody>
</table>
<ul>
<li>包含框架头文件:每个框架应该包含一个与框架同名的头文件，该头文件包含该框架所有公开的头文件。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>Foundation.h</td>
<td>Foundation.framework</td>
</tr>
</tbody>
</table>
<ul>
<li><p>为已有框架中的某个类扩展 API:如果要在一个框架中声明属于另一个框架某个类的范畴类的方法， 该头文件的命名形式为:原类名+“Additions”。如 Application Kit 中的 NSBundleAdditions.h</p>
</li>
<li><p>相关联的函数与数据类型:将相联的函数，常量，结构体以及其他数据类型放置到一个头文件中，并以合适的名字命名。如 Application Kit 中的 NSGraphics.h </p>
</li>
</ul>
<h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF" target="_blank" rel="noopener">Naming Methods</a></p>
<h3 id="一般性规则"><a href="#一般性规则" class="headerlink" title="一般性规则"></a>一般性规则</h3><p>为方法命名时，请考虑如下一些一般性规则:</p>
<ul>
<li>小写第一个单词的首字符，大写随后单词的首字符，不使用前缀。请参考“书写约定”一节。有两种例 外情况:1，方法名以广为人知的大写字母缩略词(如 TIFF or PDF)开头;2，私有方法可以使用统 一的前缀来分组和辨识，请参考“私有方法”一节</li>
<li>表示对象行为的方法，名称以动词开头:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">invokeWithTarget:</span>(id)<span class="string">target:</span>- (<span class="keyword">void</span>)<span class="string">selectTabViewItem:</span>(NSTableViewItem *)tableViewItem</span><br></pre></td></tr></table></figure>
<p>名称中不要出现 do 或 does，因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰</p>
<ul>
<li>如果方法返回方法接收者的某个属性，直接用属性名称命名。不要使用 get，除非是间接返回一个或 多个值。请参考“访问方法”一节。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (NSSize)cellSize</td>
<td>对</td>
</tr>
<tr>
<td>- (NSSize)calcCellSize</td>
<td>错</td>
</tr>
<tr>
<td>- (NSSize)getCellSize</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数要用 述该参数的关键字命名</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数前面的单词要能述该参数。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)viewWithTag:(int)aTag;</td>
<td>对</td>
</tr>
<tr>
<td>- (id)taggedView:(int)aTag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>细化基类中的已有方法:创建一个新方法，其名称是在被细化方法名称后面追加参数关键词</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)initWithFrame:(NSRect)frameRect;</td>
<td>NSView</td>
</tr>
<tr>
<td>- (id)initWithFrame:(NSRect)frameRect mode:(ind)aMode cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns:(int)colsWide;</td>
<td>NSMatrix - NSView 的子类</td>
</tr>
</tbody>
</table>
<ul>
<li>不要使用 and 来连接用属性作参数关键字</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (int)runModalForDirectory:(NSString *)path file:(NSString *)name types:(NSArray *)fileTypes;</code></td>
<td>对</td>
</tr>
<tr>
<td><code>- (int)runModalForDirectory:(NSString *)path addFile:(NSString *)name addTypes:(NSArray *)fileTypes;</code></td>
<td>错</td>
</tr>
</tbody>
</table>
<p>虽然上面的例子中使用 add 看起来也不错，但当你方法有太多参数关键字时就有问题。</p>
<ul>
<li>如果方法 述两种独立的行为，使用 and 来串接它们</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (BOOL)openFile:(NSString <em>)fullPath withApplication:(NSString </em>)appName andDeactivate:(BOOL)flag;</td>
<td>NSWorkspace</td>
</tr>
</tbody>
</table>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>访问方法是对象属性的读取与设置方法。其命名有特定的格式依赖于属性的 述内容。</p>
<ul>
<li>如果属性是用名词述的，则命名格式为:</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNoun:(<span class="class"><span class="keyword">type</span>)<span class="title">aNoun</span>;</span>- (<span class="class"><span class="keyword">type</span>)<span class="title">noun</span>;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setgColor:<span class="params">(NSColor *)</span>aColor; </span><br><span class="line">- <span class="params">(NSColor *)</span>color;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用形容词述的，则命名格式为:</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setAdjective:<span class="params">(BOOL)</span>flag;- <span class="params">(BOOL)</span>isAdjective;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setEditable:<span class="params">(BOOL)</span>flag; </span><br><span class="line">- <span class="params">(BOOL)</span>isEditable;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用动词 述的，则命名格式为:(动词要用现在时时态)</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setVerbObject:<span class="params">(BOOL)</span>flag;- <span class="params">(BOOL)</span>verbObject;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<pre><code>- (void)setShowAlpha:(BOOL)flag; 
- (BOOL)showsAlpha;
</code></pre><ul>
<li>不要使用动词的过去分词形式作形容词使用</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)setAcceptsGlyphInfo:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL)acceptsGlyphInfo;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setGlyphInfoAccepted:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)glyphInfoAccepted;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>可以使用情态动词(can， should， will 等)来 高清晰性，但不要使用 do 或 does</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)setCanHide:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL)canHide;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setShouldCloseDocument:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)shouldCloseDocument;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setDoseAcceptGlyphInfo:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)doseAcceptGlyphInfo;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>只有在方法需要间接返回多个值的情况下，才使用 get</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</code></td>
<td>NSBezierPath</td>
</tr>
</tbody>
</table>
<p>像上面这样的方法，在其实现里应允许接受 NULL 作为其 in/out 参数，以表示调用者对一个或多个返回 值不感兴趣。</p>
<h3 id="委托方法"><a href="#委托方法" class="headerlink" title="委托方法"></a>委托方法</h3><p>委托方法是那些在特定事件发生时可被对象调用，并声明在对象的委托类中的方法。它们有独特的命名约<br>定，这些命名约定同样也适用于对象的数据源方法</p>
<ul>
<li>名称以标示发送消息的对象的类名开头，省略类名的前缀并小写类第一个字符</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>tableView:<span class="params">(NSTableView *)</span>tableView shouldSelectRow:<span class="params">(int)</span>row;</span><br><span class="line">- <span class="params">(BOOL)</span>application:<span class="params">(NSApplication *)</span>sender openFile:<span class="params">(NSString *)</span>filename;</span><br></pre></td></tr></table></figure>
<ul>
<li>冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的方法</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>applicationOpenUntitledFile:<span class="params">(NSApplication *)</span>sender;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的那条规则也不适用于响应通知的方法。在这种情况下，方法的唯一参数表示通知对象</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>windowDidChangeScreen:<span class="params">(NSNotification *)</span>notification;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>browserDidScroll:<span class="params">(NSBrowser *)</span>sender;</span><br><span class="line">- <span class="params">(NSUndoManager *)</span>windowWillReturnUndoManager:<span class="params">(NSWindow *)</span>window;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will，但最好使用 should</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>windowShouldClose:<span class="params">(id)</span>sender;</span><br></pre></td></tr></table></figure>
<h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><p>管理对象(集合中的对象被称之为元素)的集合类，约定要具备如下形式的方法:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addElement:<span class="params">(elementType)</span>adObj;</span><br><span class="line">- <span class="params">(void)</span>removeElement:<span class="params">(elementType)</span>anObj;</span><br><span class="line">- <span class="params">(NSArray *)</span>elements;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addLayoutManager:<span class="params">(NSLayoutManager *)</span>adObj;</span><br><span class="line">- <span class="params">(void)</span>removeLayoutManager:<span class="params">(NSLayoutManager *)</span>anObj;</span><br><span class="line">- <span class="params">(NSArray *)</span>layoutManagers;</span><br></pre></td></tr></table></figure>
<p>集合方法命名有如下一些限制和约定:</p>
<ul>
<li>如果集合中的元素无序，返回 NSSet，而不是 NSArray</li>
<li>如果将元素插入指定位置的功能很重要，则需具备如下方法:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">insertElement:</span>(elementType)anObj <span class="string">atIndex:</span>(<span class="keyword">int</span>)index; </span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeElementAtIndex:</span>(<span class="keyword">int</span>)index;</span><br></pre></td></tr></table></figure>
<p>集合方法的实现要考虑如下细节:</p>
<ul>
<li>以上集合类方法通常负责管理元素的所有者关系，在 add 或 insert 的实现代码里会 retain 元素，在 remove 的实现代码中会 release 元素</li>
<li>当被插入的对象需要持有指向集合对象的指针时，通常使用 set… 来命名其设置该指针的方法，且不 要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形，NSLayoutManager 类使 用如下方法:</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setTextStorage:<span class="params">(NSTextStorage *)</span>textStorage; </span><br><span class="line">- <span class="params">(NSTextStorage *)</span>textStorage;</span><br></pre></td></tr></table></figure>
<p>通常你不会直接调用 setTextStorage:，而是覆写它。</p>
<p>另一个关于集合约定的例子来自 NSWindow 类:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addChildWindow:<span class="params">(NSWindow *)</span>childWin ordered:<span class="params">(NSWindowOrderingMode)</span>place; </span><br><span class="line">- <span class="params">(void)</span>removeChildWindow:<span class="params">(NSWindow *)</span>childWin;</span><br><span class="line">- <span class="params">(NSArray *)</span>childWindows;- <span class="params">(NSWindow *)</span>parentWindow;</span><br><span class="line">- <span class="params">(void)</span>setParentWindow:<span class="params">(NSWindow *)</span>window;</span><br></pre></td></tr></table></figure>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>命名方法参数时要考虑如下规则:</p>
<ul>
<li>如同方法名，参数名小写第一个单词的首字符，大写后继单词的首字符。如:removeObject:(id)anObject</li>
<li>不要在参数名中使用 pointer 或 ptr，让参数的类型来说明它是指针</li>
<li>避免使用 one， two，…，作为参数名</li>
<li>避免为节省几个字符而缩写</li>
</ul>
<p>按照 Cocoa 惯例，以下关键字与参数联合使用:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">..<span class="selector-class">.action</span>:(SEL)aSelector</span><br><span class="line">..<span class="selector-class">.alignment</span>:(int)mode</span><br><span class="line">..<span class="selector-class">.atIndex</span>:(int)index</span><br><span class="line">..<span class="selector-class">.content</span>:(NSRect)aRect</span><br><span class="line">..<span class="selector-class">.doubleValue</span>:(double)aDouble</span><br><span class="line">..<span class="selector-class">.floatValue</span>:(<span class="attribute">float</span>)aFloat</span><br><span class="line">..<span class="selector-class">.font</span>:(NSFont *)fontObj</span><br><span class="line">..<span class="selector-class">.frame</span>:(NSRect)frameRect</span><br><span class="line">..<span class="selector-class">.intValue</span>:(int)anInt</span><br><span class="line">..<span class="selector-class">.keyEquivalent</span>:(NSString *)charCode</span><br><span class="line">..<span class="selector-class">.length</span>:(int)numBytes</span><br><span class="line">..<span class="selector-class">.point</span>:(NSPoint)aPoint</span><br><span class="line">..<span class="selector-class">.stringValue</span>:(NSString *)aString</span><br><span class="line">..<span class="selector-class">.tag</span>:(int)anInt..<span class="selector-class">.target</span>:(id)anObject..<span class="selector-class">.title</span>:(NSString *)aString</span><br></pre></td></tr></table></figure>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>大多数情况下，私有方法命名相同与公共方法命名约定相同，但通常我们约定给私有方法添加前缀，以便 与公共方法区分开来。即使这样，私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时，你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。<br>Cocoa framework 的私有方法名称通常以下划线作为前缀(如:_fooData)，以标示其私有属性。基于这 样的事实，遵循以下两条建议：</p>
<ul>
<li>不要使用下划线作为你自己的私有方法名称的前缀，Apple 保留这种用法。</li>
<li>若要继承 Cocoa framework 中一个超大的类(如:NSView)，并且想要使你的私有方法名称与基类 中的区别开来，你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性，如基于你 公司的名称，或工程的名称，并以“XX_”形式给出。比如你的工程名为”Byte Flogger”，那么就可以是 “BF_addObject:”</li>
</ul>
<p>尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突，这里的意图有所不同:为了防止不<br>小心地覆盖基类中的私有方法。</p>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingFunctions.html#//apple_ref/doc/uid/20001283-BAJGGCAD" target="_blank" rel="noopener">Naming Functions</a></p>
<p>Objective-C 允许通过函数(C 形式的函数) 述行为，就如成员方法一样。 你应当优先使用函数，而不 是类方法，如果隐含的类为单例或在处理函数子系统时。</p>
<p>函数命名应该遵循如下几条规则:</p>
<ul>
<li>函数命名与方法命名相似，但有两点不同:<ol>
<li>它们有前缀，其前缀与你使用的类和常量的前缀相同</li>
<li>大写前缀后紧跟的第一个单词首字符</li>
</ol>
</li>
<li>大多数函数名称以动词开头，这个动词 述该函数的行为</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHighlightRect</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span></span><br></pre></td></tr></table></figure>
<p>查询属性的函数有个更多的规则要遵循:</p>
<ul>
<li>查询第一个参数的属性的函数，省略动词</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">NSEventMaskFromType</span>(<span class="built_in">NSEventType</span> type) </span><br><span class="line"><span class="keyword">float</span> <span class="built_in">NSHeight</span>(<span class="built_in">NSRect</span> rect)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值为引用的方法，使用 Get</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">NSGetSizeAndAlignment</span>(<span class="keyword">const</span> <span class="keyword">char</span> *typePtr, <span class="keyword">unsigned</span> <span class="keyword">int</span>*sizep, <span class="keyword">unsigned</span> <span class="keyword">int</span> *alignp)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 boolean 值的函数，名称使用判断动词 is/does 开头</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecimalIsNotANumber</span>(<span class="keyword">const</span> <span class="built_in">NSDecimal</span> *decimal)</span><br></pre></td></tr></table></figure>
<h2 id="实例变量与数据类型命名"><a href="#实例变量与数据类型命名" class="headerlink" title="实例变量与数据类型命名"></a>实例变量与数据类型命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="noopener">Naming Properties and Data Types</a></p>
<p>这一节 述实例变量，常量，异常以及通知的命名约定。</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>在为类添加实例变量是要注意:</p>
<ul>
<li>避免创建 public 实例变量</li>
<li>使用 @private，@protected 显式限定实例变量的访问权限</li>
<li>确保实例变量名简明扼要地述了它所代表的属性</li>
</ul>
<p>如果实例变量别设计为可被访问的，确保编写了访问方法</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量命名规则根据常量创建的方式不同而大不同。</p>
<h4 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h4><ul>
<li>使用枚举来定义一组相关的整数常量</li>
<li>枚举常量与其 typedef 命名遵守函数命名规则。如来自 NSMatrix.h 中的例子：(本例中的 typedef tag (_NSMatrixMode) 不是必须的)</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_NSMatrixMode</span> &#123; </span></span><br><span class="line">	NSRadioModeMatrix = <span class="number">0</span>, </span><br><span class="line">	NSHighlightModeMatrix = <span class="number">1</span>,</span><br><span class="line">	NSListModeMatrix = <span class="number">2</span>, </span><br><span class="line">	NSTrackModeMatrix = <span class="number">3</span>&#125; NSMatrixMode;</span><br></pre></td></tr></table></figure>
<ul>
<li>位掩码常量可以使用不具名枚举。如:</li>
</ul>
<pre><code>enum {
    NSBorderlessWindowMask = 0,
    NSTitledWindowMask = 1 &lt;&lt; 0,
    NSClosableWindowMask = 1 &lt;&lt; 1,
    NSMiniaturizableWindowMask 1 &lt;&lt; 2,
    NSResizableWindowMask = 1&lt;&lt; 3
};
</code></pre><h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><ul>
<li>使用 const 来修饰浮点常量或彼此没有关联的整数常量</li>
<li>枚举常量命名规则与函数命名规则相同。const 常量命名范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">NSLightGray</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他常量"><a href="#其他常量" class="headerlink" title="其他常量"></a>其他常量</h4><ul>
<li>通常不使用 #define 来创建常量。如上面所述，整数常量请使用枚举，浮点数常量请使用 const</li>
<li>使用大写字母来定义预处理编译宏。如:#ifdef DEBUG</li>
<li>编译器定义的宏名首尾都有双下划线。如:<strong>MACH</strong></li>
<li>为 notification 名及 dictionary key 定义字符串常量，从而能够利用编译器的拼写检查，减少书写错误。Cocoa 框架供了很多这样的范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPKIT_EXTERN <span class="built_in">NSString</span> *<span class="built_in">NSPrintCopies</span>;</span><br></pre></td></tr></table></figure>
<p>实际的字符串值在实现文件中赋予。(注意:APPKIT_EXTERN 宏等价于 Objective-C 中 extern)</p>
<h3 id="异常与通知"><a href="#异常与通知" class="headerlink" title="异常与通知"></a>异常与通知</h3><p>异常与通知的命名遵循相似的规则,但是它们有各自推荐的使用模式。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>虽然你可以处于任何目的而使用异常(由 NSException 类及相关类实现)， Cocoa 通常不使用异常来处 理常规的， 可预料的错误。在这些情形下， 使用诸如 nil， NULL， NO 或错误代码之类的返回值。异常的典 型应用类似数组越界之类的编程错误。</p>
<p>异常由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[Prefix] + UniquePartOfName + Exception</p>
</blockquote>
<p>UniquePartOfName 部分是有连续的首字符大写的单词组成。例如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSColorListIOException</span></span><br><span class="line"><span class="built_in">NSColorListNotEditableException</span></span><br><span class="line"><span class="built_in">NSDraggingException</span></span><br><span class="line"><span class="built_in">NSFontUnavailableException</span></span><br><span class="line"><span class="built_in">NSIllegalSelectorException</span></span><br></pre></td></tr></table></figure>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>如果一个类有委托,那它的大部分通知可能由其委托的委托方法来处理。这些通知的名称应该能够反应其 响应的委托方法。比如,当应用程序 交 NSApplicationDidBecomeActiveNotification 通知时,全局 NSApplication 对象的委托会注册从而能够接收 applicaitonDidBecomeActive: 消息。</p>
<p>通知由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[相关联类的名称] + [Did 或 Will] + [UniquePartOfName] + Notification 例如: </p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSApplicationDidBecomeActiveNotification</span></span><br><span class="line"><span class="built_in">NSWindowDidMiniaturizeNotification</span></span><br><span class="line"><span class="built_in">NSTextViewDidChangeSelectionNotification</span></span><br><span class="line"><span class="built_in">NSColorPanelColorDidChangeNotification</span></span><br></pre></td></tr></table></figure>
<h2 id="可接受的缩略语"><a href="#可接受的缩略语" class="headerlink" title="可接受的缩略语"></a>可接受的缩略语</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE" target="_blank" rel="noopener">Acceptable Abbreviations and Acronyms</a></p>
<p>在设计编程接口时，通常名称不要缩写。然而，下面列出的缩写要么是固定下来的要么是过去被广泛使用<br>的，所以你可以继续使用。关于缩写有一些额外的注意事项:</p>
<ul>
<li>标准 C 库中长期使用的缩写形式是可以接受的。如:”alloc”， “getc”</li>
<li>你可以在参数名中更自由地使用缩写。如:imageRep， col(column)， obj， otherWin</li>
</ul>
<h3 id="常见的缩写"><a href="#常见的缩写" class="headerlink" title="常见的缩写"></a>常见的缩写</h3><table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc</td>
<td>Allocate</td>
<td>msg</td>
<td>Message</td>
</tr>
<tr>
<td>alt</td>
<td>Alternate</td>
<td>nib</td>
<td>Interface Builder archive</td>
</tr>
<tr>
<td>app</td>
<td>Application</td>
<td>pboard</td>
<td>Pasteboard</td>
</tr>
<tr>
<td>calc</td>
<td>Calculate</td>
<td>rect</td>
<td>Rectangle</td>
</tr>
<tr>
<td>dealloc</td>
<td>Deallocate</td>
<td>Rep</td>
<td>Representation</td>
</tr>
<tr>
<td>func</td>
<td>Function</td>
<td>temp</td>
<td>Temporary</td>
</tr>
<tr>
<td>horiz</td>
<td>Horizontal</td>
<td>vert</td>
<td>Vertical</td>
</tr>
<tr>
<td>info</td>
<td>Information</td>
<td>init</td>
<td>Initialize</td>
</tr>
<tr>
<td>max</td>
<td>Maximum</td>
</tr>
</tbody>
</table>
<h3 id="常见的略写"><a href="#常见的略写" class="headerlink" title="常见的略写"></a>常见的略写</h3><p>ASCII， PDF， XML， HTML， URL， RTF， HTTP， TIFF， JPG， GIF， LZW， ROM， RGB， CMYK， MIDI， FTP</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/task-and-back-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/task-and-back-stack/" itemprop="url">Android Task 与后退栈解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-10T00:17:00+08:00">
                2015-11-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-10-18T20:14:28+08:00">
                2018-10-18
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/" itemprop="url" rel="index">
                    <span itemprop="name">开发技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应用程序通常包含多个 Activity。每个 Activity 围绕用户能够执行的指定动作类型和启动其他 Activity 来设计。例如，一个邮件应用程序有一个用来显示新信息列表的 Activity ，当用户选择一条信息，一个新的 Activity 打开用来查看信息。</p>
<p>一个 Activity 可以打开存在设备上的其他应用程序。例如，你的应用想要发送邮件信息，你可以定义一个意图来执行”发送”动作，并包含一些如邮箱地址和信息的数据。其他应用程序的 Activity 声明自己能够处理这种类型的意图，并打开。这个例子中，意图是想要发送邮件，因此邮件应用的创作 Activity 启动(如果多个 Activity 支持相同的意图，系统将让用户来选择)。当邮件发送完成，这个 Activity 退出，看起来就像是自己应用程序的一部分， Android 通过将这些 Activity 保存在相同的 Task 中来维持一致的用户体验。</p>
<p>Task 是用户在执行特定工作时与之交互的一系列 Activity 集合。 Activity 被排列在后退栈中，以每个 Activity 被打开的顺序排列。</p>
<p>对于大部分 Task 而言，设备的主屏幕都是起始位置。当用户触摸应用程序启动器或者主屏幕上的快捷方式时，应用程序的 Task 进入前台。如果应用程序的 Task 不存在(即应用程序最近没有被使用)，那么新的 Task 将被创建，并且应用程序打开的主 Activity 将作为 Task 的根 Activity。</p>
<p>当当前 Activity 启动另外的 Activity ， 新的 Activity 将被推到栈顶并获取焦点。之前的 Activity 仍然在栈中，但是被停止的。当 Activity 被停止时，系统保持了它的用户界面的当前状态。当用户按下返回按钮，当前 Activity 被从栈顶弹出，之前的 Activity 则恢复为之前 UI 所保存下来的状态。 栈中的 Activity 不会被重新排列，只能够被推入到栈中或者从栈中弹出。当被当前 Activity 启动时推入栈中，用户按下后退键时从栈中弹出。后退栈的操作遵循后进先出的原则。下图可视化的展示了随着时间推移 Activity 与后退栈中的关系。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_backstack.png" alt=""></p>
<p>如果用户继续按返回键，每个 Activity 都会从栈中被弹出来展示上一个 Activity ，直到回到主屏幕(或者回到运行 Task 开始的 Activity )。当所有的 Activity 从栈中移出， Task 就不存在了。</p>
<p>Task 是一个相互结合的单元，当用户启动新的 Task 或者通过按下 Home 键来返回主屏幕时，原来的 Task 进入后台。一旦进入后台， Task 中的所有 Activity 被停止，但是 Task 的后退栈中是完整的，只是失去了焦点。一个 Task 可以重新回到前台以便用户打开。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_multitasking.png" alt=""></p>
<p>假设，当前的 Task A 包含 3 个 Activity 在它的栈中，即当前 Activity 下有另外两个。用户按下 Home 键，从应用程序启动器新的应用程序。当主屏幕显示， Task A 进入后台。当新的应用程序启动，系统为新的应用程序启动了 Task B (其中包含自己 Activity 的栈)。在新的应用程序中玩了不久，用户再次回到主屏幕，并选择了先前 Task A 中启动的应用程序。这是 Task A 进入前台，堆栈中的 3 个 Activity 都是完整的，栈顶的 Activity 被恢复。这种情况下，用户可以通过返回主屏幕，再点击应用程序图标来启动。这是 Android 上多任务的一个实例。</p>
<blockquote>
<p>注意：多个 Task 可以同时被维持在后台。但如果用户同时运行太多的后台任务，系统会为了回收内存而销毁后台的 Activity ，这会引起 Activity 状态的丢失。</p>
</blockquote>
<p>由于后退栈中的 Activity 永远不会被重排，如果你的应用程序允许用户从多个 Activity 中启动一个特殊的 Activity ，那么，新的 Activity 实例将被创建并推入栈中，而不是将之前的其他 Activity 实例放到顶部。这样，应用程序中的一个 Activity 可能被实例化多次，如下图所示。当用户使用返回键导航回去时，每个 Activity 的实例将按照被打开的顺序来展示。但是，如果你不想让一个 Activity 被实例化多次，你可以修改这些行为。具体怎么做，在下一节的[管理  Task] 中介绍。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_multiple_instances.png" alt=""></p>
<p>总结一下 Activity 和 Task 的默认行为：</p>
<ol>
<li>当 Activity A 启动 Activity B 时， Activity A 被停止，但系统保存了它的状态，包括滚动的位置和输入的文本等。如果用户在 Activity B 时按下返回键， Activity A 会返回到其原来保存的状态。</li>
<li>当用户按下 Home 键离开 Task ，当前的 Activity 及它所在的 Task 进入后台。系统保持 Task 中每个 Activity 的状态。如果用户通过选择启动图标再次启动 Task ， Task 进入前台，并且在栈顶部的 Activity 被恢复。</li>
<li>如果用户按下返回键，当前的 Activity 被从栈中弹出并销毁。栈中之前的 Activity 被恢复。当 Activity 被销毁，系统不在保持 Activity 的状态。</li>
<li>Activity 可以被实例化多次，即使是来自其他的 Task 。</li>
</ol>
<h2 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h2><p>如上面所讨论的，当 Activity 被停止时，系统的默认行为会保留其状态。这样子，当用户导航回到之前的 Activity 时，将展示之前离开时留下的界面。尽管如此，当 Activity 即将被销毁或者必须要重建时，你依然可以使用回调方法来保持 Activity 的状态。</p>
<p>当系统停止某个 Activity 时，如果需要恢复系统的内存，系统将完全的销毁 Activity 。这种情况下， Activity 状态相关的信息便丢失了。但系统依然知道在后退栈中有 Activity 的一个位置，当 Activity 被带到前台时系统需要重建它，而不是恢复它。为了避免丢失用户以完成的工作，需要在 Activity 中通过实现 onSaveInstanceState() 方法来主动保持状态。</p>
<p>关于如何来保存 Activity 的状态的更多信息，可以查看 Activity 相关文档。</p>
<h2 id="管理-Task"><a href="#管理-Task" class="headerlink" title="管理 Task"></a>管理 Task</h2><p>上面描述的 Android 管理 Task 和后退栈的方式-将所有成功打开的 Activity 放在同一个 Task 及后进先出的堆栈中-在大部分应用程序中工作正常，也不需要担心 Activity 如何与 Task 相关联，以及如何存在后退栈中。有的时候，你想要中断这种普通的行为。也许你想要应用程序中的一个 Activity 打开时开启一个新的 Task ，而不是被放在当前 Task 中。也许你启动一个 Activity 时，想要把已经存在的实例带到前台，而不是在顶上创建一个新的实例。也许你想当用户离开 Task 的时候，后退栈中除了根 Activity 之外的清空其他 Activity 。</p>
<p>通过清单文件中 <code>&lt;activity&gt;</code> 元素的属性以及传递给 startActivity() 的 Intent 中的 flag 可以完成上面的工作，甚至更多其他工作。</p>
<p>可以使用的 <code>&lt;activity&gt;</code> 元素主要属性包括：</p>
<ul>
<li>taskAffinity</li>
<li>launchMode</li>
<li>allowTaskReparenting</li>
<li>clearTaskOnLaunch</li>
<li>alwaysRetainTaskState</li>
<li>finishOnTaskLaunch</li>
</ul>
<p>可以使用的主要 Intent 的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>接下来的章节中，你将看到如何使用这些清单属性和 Intent 的 flag 来定义 Activity 如何与 Task 关联以及他们在后退栈中的行为。</p>
<blockquote>
<p><strong>警告：</strong> 大部分应用程序不应该干扰 Activity 和 Task 的默认行为。如果你觉得非常有必要修改这些默认行为，那么需要做出警告，并测试 Activity 启动以及通过返回键从其他 Activity 或 Task 返回的情况。测试导航是否会和用户所期待的行为冲突。</p>
</blockquote>
<h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p>启动模式用来定义一个新的 Activity 实例如何与当前的 Task 关联。可以通过两种方式来定义不同的启动模式：</p>
<ul>
<li>使用清单文件：当你在清单文件中声明一个 Activity 时，可以指定 Activity 在启动时如何关联 Task。</li>
<li>使用 Intent flag ：调用 startActivity() 时，可以在 Intent 中包含 flag 来声明新的 Activity 与当前 Task 如何关联。</li>
</ul>
<p>这样，如果 Activity A 启动 Activity B ， Activity B 可以在它的清单中定义如何与当前 Task 关联， Activity A 同样可以请求 Activity B 如何与当前 Task 关联。如果都定义了 Activity B 如何与 Task 关联， Activity A 中通过 Intent 定义的请求优先于 Activity 在清单中定义的请求。</p>
<blockquote>
<p><strong>注意</strong>：某些在清单文件中有效的启动模式，在 Intent 中的 flag 是无效的，同样，某些 Intent 中有效的启动模式在清单里定义是无效的。</p>
</blockquote>
<p><strong>使用清单文件</strong></p>
<p>在清单文件中申明 Activity 时，使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性可以指定 Activity 如何与 Task 关联：</p>
<ul>
<li>“standard”（默认模式）</li>
</ul>
<p>系统创建新的 Activity 实例，这个实例位于启动它的 Activity 相同的栈，并且将意图传递给它。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 也能有多个实例。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>如果 Activity 的实例已经存在于当前 Task 的顶部，系统通过调用实例的 onNewIntent() 方法来传递意图到实例，而不是为 Activity 创建一个新的实例。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 可以有多个实例(除非后退栈顶部的 Activity 不是一个已经存在的 Activity 实例)。</p>
<p>例如，假设一个 Task 的后退栈包含根 Activity A ， Activity B ， Activity C 以及 Activity D 在顶部。一个意图到达 Activity D 。如果 D 的启动模式为 “standard” ，新的类实例将被启动，堆栈变成 A-B-C-D-D 。如果 D 的启动模式为 “singleTop” ，已经存在的 D 实例将通过 onNewIntent() 接收意图，一次它还在栈顶，而栈依然是 A-B-C-D 。如果一个意图到达 B ，新的 B 的实例被添加到堆栈中，即使它的启动模式是 “singleTop” 。</p>
<blockquote>
<p><strong>注意</strong>：当新的 Activity 实例被创建，用户可以按下返回按钮来返回到之前的 Activity 。但是当已经存在的 Activity 实例处理了新的 Intent ，用户无法按下返回键返回到通过 onNewIntent() 到来新的 Intent 前的 Activity 状态。</p>
</blockquote>
<ul>
<li>“singleTask”</li>
</ul>
<p>系统创建新的 Task 并在新的 Task 的根实例化 Activity 。如果已经有 Activity 的实例存在于独立的 Task 中，系统通过调用 onNewIntent() 将 Intent 路由到已存在的实例，而不是创建一个新的实例。每次只能有一个 Activity 的实例存在。</p>
<blockquote>
<p><strong>注意</strong>：虽然 Activity 在新的 Task 中打开，后退按钮依然可以返回到用户之前的 Activity 。</p>
</blockquote>
<ul>
<li>“singleInstance”</li>
</ul>
<p>除了系统不再启动其他的 Activity 到持有实例的 Task 中，其他的和 “singleTask” 一样。 这个 Activity 是它的 Task 的唯一成员。任何由它打开的 Activity 在一个独立的 Task 。</p>
<p>另外一个实例， Android 浏览器应用程序声明网页浏览器的 Activity 需要永远在自己的 Task 中打开，即在 <code>&lt;activity&gt;</code> 元素中指定 singleTask 启动模式。这意味着，如果你的应用程序要打开 Android 浏览器，它的 Activity 与你的应用程序将在不同的 Task 中。不论新的 Task 启动浏览器，或者浏览器已经有一个运行在后台的 Task， Task 将被带到前台处理新的 Intent 。</p>
<p>不论 Activity 是在新的 Task 中启动还是在相同的 Task 中启动，返回按钮总是能让用户返回到之前的 Activity 。如果你启动了一个指定 singleTask 启动模式的 Activity ，恰好这时有个 Activity 的实例在后台 Task 中，整个 Task 将进入前台。这种情况下，后退栈中包含在 Task 中的所有 Activity 进入前台，在栈的顶部。下图展示了这个过程。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_backstack_singletask_multiactivity.png" alt=""></p>
<p>更多的在清单中使用启动模式的信息，可以查看 <a href=""><activity>元素</activity></a> 相关文档，这里讨论更多关于 launchMode 属性及可接受的值。</p>
<blockquote>
<p><strong>注意</strong>：Activity 中通过 launchMode 属性指定的行为，可以通过启动 Activity 的意图的 flag 来覆盖。 </p>
</blockquote>
<p><strong>使用意图 flag</strong></p>
<p>启动一个 Activity 时，可以通过在 startActivity() 中传递意图的 flag 来修改 Activity 与 Task 之间的默认关联。可以用来修改默认行为的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>在新的 Task 中启动 Activity 。如果要启动的 Activity 已经有在运行的 Task ， Task 将带着最后被保存的状态到前台， Activity 在 onNewIntent() 中接收新的意图。</p>
<p>这产生的效果与上节讨论的 “singleTask” 启动模式一致。</p>
<ul>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>如果被启动的 Activity 是当前 Activity (即在后退栈的顶部)，已存在的实例调用 onNewIntent() ，而不是创建一个新的 Activity 实例。</p>
<p>这产生的效果与上节讨论的 “singleTop” 启动模式一致。 </p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ul>
<p>如果被启动的 Activity 已经在当前 Task 中，那么所有在其顶部的 Activity 将被销毁，意图将通过 onNewIntent() 传递到被恢复的 Activity 实例，而不是创建一个新的实例。</p>
<p>没有启动模式可以产生这种行为。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 经常和 FLAG_ACTIVITY_NEW_TASK 结合使用。当在一起使用时，这些 flag 是一种在其他 Task 中定位已存在 Activity，并将其放入可以响应意图位置的方式。</p>
<h3 id="处理-affinities"><a href="#处理-affinities" class="headerlink" title="处理 affinities"></a>处理 affinities</h3><p>Affinity 表明 Activity 优先属于哪个 Task 。默认情况下，来自同一个应用程序的 Activity 相互间拥有一个 Affinity 。因此，同一个应用程序的 Activity 优先在同一个 Task 中。尽管如此，你可以修改一个 Activity 的默认 Affinity 。不同应用程序中定义的 Activity 可以共享一个 Affinity ，同一个应用程序中定义的 Activity 也可以被分配在不同的 Task Affinity 中。</p>
<p>通过给定 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性可以修改 Activity 的 Affinity 。</p>
<p>taskAffinity 属性是一个字符串，必须与申明在 <code>&lt;manifest&gt;</code> 元素中的默认包名不同。因为系统使用这个名称来识别应用程序的默认 Task Affinity 。</p>
<p>两种情况下使用 Affinity：</p>
<ul>
<li>当启动 Activity 的意图包含 FLAG_ACTIVITY_NEW_TASK flag 时。</li>
</ul>
<p>默认情况下，新的 Activity 被启动在调用 startActivity() 方法的 Activity 所在 Task 。被推入到调用者相同的后退栈。但如果传递给 startActivity() 的意图中包含 FLAG_ACTIVITY_NEW_TASK flag ，系统寻找另外的 Task 来存放 Activity 。通常是一个新的 Task 。但也不是必须的。当已经存在存在一个 Task 拥有相同的 Affinity 时， Activity 被启动到这个 Task 中，没有时，才启动新的 Task 。</p>
<p>如果这个 flag 使得 Activity 启动到新的 Task 中，用户又按下 Home 键离开它，这里将有许多种方式来让用户导航回 Task 。某些入口（如通知管理器）总是在外部 Task 中启动 Activity ，而不是在自己内部，因此调用 startActivity() 总是在意图中传递 FLAG_ACTIVITY_NEW_ACTIVITY 。如果你需要一个 Activity 可以被外部的入口调用，则使用这个 flag ，需要注意的是用户有独立的方式来返回到启动的 Task ，如通过启动器图标。</p>
<ul>
<li>当一个 Activity 有 allowTaskReparenting 属性并设置为 true 。</li>
</ul>
<h3 id="清空后退栈"><a href="#清空后退栈" class="headerlink" title="清空后退栈"></a>清空后退栈</h3><p>如果用户离开 Task 一段时间，系统将清空 Task 中除根 Activity 之外的所有 Activity 。当用户再次回到 Task ，只有根 Activity 将被回复。系统行为之所以如此，是因为在经历一段相对长的时间，用户将放弃之前所做的一些事情，而返回 Task 是为了开始其他新的事情。</p>
<p>这里有一些 Activity 的属性可以用来修改这个行为：</p>
<ul>
<li>alwaysRetainTaskState</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，上面提到的默认行为将不会发生。 即时经过很长一段时间， Task 也将在栈中保持所有的 Activity 。</p>
<ul>
<li>clearTaskOnLaunch</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，无论用户离开 Task 或是返回它，堆栈将被清空只剩下根 Activity。换句话说，这与 alwaysRetainTaskState 刚刚相反。即时在离开很短的时间，用户也将返回 Task 的初始状态。</p>
<ul>
<li>finishOnTaskLaunch</li>
</ul>
<p>这个属性类似 clearTaskOnLaunch ，但是这个仅作用于单个 Activity ，而不是整个 Task 。这能引起任何 Activity 消失，包括根 Activity 。当它被设置为 true ， Activity 仅仅为当前会话维持 Task 的部分。如果用户离开或者过会儿返回 Task 都不在了。</p>
<h3 id="启动-Task"><a href="#启动-Task" class="headerlink" title="启动 Task"></a>启动 Task</h3><p>通过给定某个 Activity 包含 “android.intent.action.MAIN” 为指定动作， “android.intent.category.LAUNCHER” 为指定类别的意图过滤器，可以将 Activity 作为 Task 的入口。实例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种类型的意图过滤器在应用程序启动器上显示 Activity 的图标和标签。由于这种原因，”singleTask” 和 “singleInstance” 两种启动模式标记 Activity 初始化 Task 只能在 Activity 拥有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时使用。想象一下如果没有这些过滤器将发生什么：一个意图启动了 “singleTask” 的 Activity ，初始化了 Task ，用户在这个 Task 上玩耍了一段时间，然后按下了 Home 键。Task 就进入了后台且不可见。现在用户无法再返回到 Task ，因为应用程序启动器上没有显示…</p>
<p>在那些不需要用户返回到 Activity 的情况，设置 <code>&lt;activity&gt;</code> 元素的 finishOnTaskLaunch 为 true 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/android-activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/android-activity/" itemprop="url">Android Activity 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-04T18:05:39+08:00">
                2015-11-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-10-18T20:14:28+08:00">
                2018-10-18
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/" itemprop="url" rel="index">
                    <span itemprop="name">开发技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技术/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol>
<li>Activity 是一个提供屏幕的应用程序组件，用户通过它与机器产生交互。</li>
<li>每个 Activity 包含一个窗口( window )，大部分情况下窗口是全屏的，也有可能窗口比屏幕小且在其他窗口的顶部。</li>
<li>一个应用程序由一个或者多个 Activity 组成，这些 Activity 之间是松散的组织在一起的。</li>
<li>每一个 Activity 可以启动其他的 Activity，不同的 Activity 可以执行不同的动作。</li>
<li>新的 Activity 启动以后，原来的 Activity 会被保留到后退栈中，后退栈遵循基本的后进先出的堆栈机制。在当前 Activity 中按返回键退出，当前 Activity 将被从堆栈中弹出、销毁，之前的 Activity 则被恢复。</li>
<li>当 Activity 被启动，或者被停止时，都会通过生命周期回调的方式来通知自己的状态变化。这些状态包括被创建、停止、恢复、销毁，每个回调都提供了在特定状态下执行特定任务的时机。</li>
</ol>
<h2 id="如何创建-Activity"><a href="#如何创建-Activity" class="headerlink" title="如何创建 Activity"></a>如何创建 Activity</h2><ol>
<li>创建 Activity 可以通过创建 Activity 的子类，或者一个已经存在的 Activity 子类来实现。</li>
<li>在创建的子类中实现生命周期的回调方法。其中最重要的是 onCreate 和 onPause。<ul>
<li>必须实现 onCreate 方法，并且在其中调用 setContentView() 来定义用户布局。</li>
<li>在 onPause 中提交当前会话中需要被持久化的更改，以避免用户可能不再回来导致的数据丢失。</li>
</ul>
</li>
</ol>
<h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><ol>
<li>Activity 的用户界面是由一系列的视图层级来提供的。</li>
<li>视图源自于 View 类的对象。每个视图控制 Activity 的窗口上的特定矩形空间，并响应用户交互。</li>
<li>用户提供了一系列内置的视图，包括”控件”和”布局”。<ul>
<li>控件指的是在屏幕上提供的可见、可交互的元素的视图。</li>
<li>布局源自 ViewGroup， 为它的子类提供唯一的布局模型。</li>
</ul>
</li>
<li>可以实现 View 或者 ViewGroup 的子类来创建自己的控件和布局。</li>
<li>常用的视图布局定义方式包括：<ul>
<li>通过资源文件中的 XML 布局，并在 setContentView() 方法中传递资源ID。可以使界面设计的维护和逻辑代码分离。</li>
<li>通过代码创建 View， 并插入到 ViewGroup 来构建视图层级，然后传递根 ViewGroup 给 setContentView()。</li>
</ul>
</li>
</ol>
<h3 id="在清单中声明-Activity"><a href="#在清单中声明-Activity" class="headerlink" title="在清单中声明 Activity"></a>在清单中声明 Activity</h3><ol>
<li>使用 Activity 前，需要在应用清单文件中对其进行声明。在 <code>&lt;application&gt;</code> 元素中添加 <code>&lt;activity&gt;</code> 子元素。</li>
<li><code>&lt;activity&gt;</code> 元素中还有许多属性用来定义Activity 的标签、图标、主题等， <code>android:name</code> 是唯一必须的属性，用于定义 Activity 的名称。</li>
<li>Activity 的名称定义以后，不要随便改动。如果改动，可能造成某些功能无法正常使用。</li>
</ol>
<h3 id="使用意图过滤器"><a href="#使用意图过滤器" class="headerlink" title="使用意图过滤器"></a>使用意图过滤器</h3><ol>
<li><code>&lt;activity&gt;</code> 元素通过 <code>&lt;intent-filter&gt;</code> 元素来定义不同的意图过滤器，用来声明其他应用程序如何激活它。</li>
<li>Android SDK 工具在创建应用程序时自动生成的 Activity 中包含的意图过滤器，声明了 Activity 响应 main 动作，并放在 launcher 类别中。<ul>
<li><code>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</code> 指定这是应用程序的主入口。</li>
<li><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</code> 指定 Activity 被列在系统的应用程序启动器中，这样用户可以启动它。</li>
</ul>
</li>
<li>如果不允许其他的应用程序来启动 Activity，则不要声明任何的意图过滤器。</li>
<li>在应用程序内部，可以通过显式的意图来启动想要的 Activity。</li>
<li>如果定义了意图过滤器，则可以让其他应用程序通过隐式意图来激活 Activity。</li>
<li><code>&lt;intent-filter&gt;</code> 元素中包含有 <code>&lt;action&gt;</code> 元素及可选的 <code>&lt;category&gt;</code> 或者 <code>&lt;data&gt;</code>，这些元素一同指定了 Activity 能响应的意图类型。</li>
</ol>
<h2 id="启动一个-Activity"><a href="#启动一个-Activity" class="headerlink" title="启动一个 Activity"></a>启动一个 Activity</h2><ol>
<li>通过 startActivity() 方法来启动 Activity， 并传递一个 Intent 意图对象。</li>
<li>Intent 对象通过两种方式描述想要启动的 Activity：<ul>
<li>准确的 Activity 对象。</li>
<li>想要执行的动作类型。系统会自动选择合适的 Activity， 可能来自其他的应用程序。</li>
</ul>
</li>
<li>Intent 还可以传递少量的数据给即将启动的 Activity。</li>
<li>使用类名来启动已知的 Activity：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(this, SignInActivity.<span class="keyword">class</span>);</span><br><span class="line">startActivity(<span class="keyword">intent</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用 Intent 来描述要执行的动作，系统从其他应用程序中选择打开合适的 Activity， 如果有多个 Activity， 则由用户来选择：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(<span class="keyword">Intent</span>.ACTION_SEND);</span><br><span class="line"><span class="keyword">intent</span>.putExtra(<span class="keyword">Intent</span>.EXTRA_EMAIL, recipientArray);</span><br><span class="line">startActivity(<span class="keyword">intent</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为结果启动-Activity"><a href="#为结果启动-Activity" class="headerlink" title="为结果启动 Activity"></a>为结果启动 Activity</h3><ol>
<li>如果启动一个 Activity， 并期望从新的 Activity 上接收一个结果，则使用 startActivityForResult()。</li>
<li>要接收新 Activity 上的结果，需要在原 Activity 上实现 onActivityResult() 方法，从其中的 Intent 参数中获取返回结果。</li>
<li>onActivityResult() 方法处理 Activity 返回结果：<ul>
<li>处理成功，则 resultCode 为 RESULT_OK。</li>
<li>需要检查 requestCode 是否与 startActivityForResult() 的第二个参数匹配。</li>
<li>返回的结果以 Intent 带回。</li>
</ul>
</li>
</ol>
<h2 id="关闭-Activity"><a href="#关闭-Activity" class="headerlink" title="关闭 Activity"></a>关闭 Activity</h2><p>通过 finish() 和 finishActivity() 来关闭 Activity。实际上由于 Android 系统自己管理 Activity 的生命，你不应该显示的调用这些方法。</p>
<h2 id="管理-Activity-生命周期"><a href="#管理-Activity-生命周期" class="headerlink" title="管理 Activity 生命周期"></a>管理 Activity 生命周期</h2><ol>
<li>通过实现回调方法来管理 Activity 的生命周期，可以开发一个健壮且灵活的应用程序。 Activity 的生命周期则直接影响到它所关联的其他 Activity， 任务以及后退栈。</li>
<li>Activity 的主要状态：<ul>
<li>Resumed： Activity 处于前台屏幕，且拥有用户焦点。</li>
<li>Paused：其他 Activity 位于前台，但这个 Activity 还是可见的。其他 Activity 位于顶部且没有覆盖整个屏幕。这时候， Activity 还在内存中，<strong>与窗口管理器关联</strong>，但在内存极低的情况下将被系统杀掉。</li>
<li>Stopped： Activity 被其他 Activity 完全覆盖，位于后台。这时候， Activity 还在内存中，<strong>与窗口管理器分离</strong>，当需要内存时将被系统杀掉。</li>
</ul>
</li>
<li>当 Activity 被暂停或者被停止，系统可以通过调用 finish() 或者直接删掉进程的方式丢弃它。重新打开时需要重建。</li>
</ol>
<h3 id="基础的生命周期方法"><a href="#基础的生命周期方法" class="headerlink" title="基础的生命周期方法"></a>基础的生命周期方法</h3><table>
<thead>
<tr>
<th>生命周期方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>Activity 将被创建。</td>
</tr>
<tr>
<td>onStart()</td>
<td>Activity 即将可见。</td>
</tr>
<tr>
<td>onResume()</td>
<td>Activity 已经可见，处于 resumed 状态。</td>
</tr>
<tr>
<td>onPause()</td>
<td>其他 Activity 可见，自己则即将处于 paused 状态。</td>
</tr>
<tr>
<td>onStop()</td>
<td>Activity 不在可见，处于 stopped 状态。</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>Activity 即将被销毁。</td>
</tr>
</tbody>
</table>
<ol>
<li>在实现生命周期方法时，需要调用父类的实现。</li>
<li>实现这些生命周期方法，你可以监控 3 个嵌套的循环。<ul>
<li>完整生命：从 onCreate() 到 onDestroy() 。在 onCreate() 中建立全局状态，并在 onDestroy() 中释放资源。</li>
<li>可见生命：从 onStart() 到 onStop() 。这个过程中，用户可以看到 Activity 并与之交互。</li>
<li>前台生命：从 onResume() 到 onPause()。</li>
</ul>
</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/activity_lifecycle.png" alt="Activity 生命周期"></p>
<h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><ol>
<li>Activity 处于 paused， stopped 时依然存在内存中，所有的数据及状态都存在，因此当被恢复时依然保持退出时的状态。</li>
<li>但处于 paused， stopped 状态的 Activity 可能会被系统杀掉，从而用户重新打开时，与当时提出时不一样了。为了保证能够还原现场，则需要实现 onSaveInstanceState() 回调方法。</li>
<li>系统在 Activity 被销毁之前调用 onSaveInstance() ，通过将需要记住的状态通过键值对的形式保存到 Bundle 参数中。当应用程序被系统杀死，并再次被启动时，会将保存的 Bundle 传递到 onCreate() 和 onRestoreInstanceState() 。从这些方法的 Bundle 参数中，就可以获取到 Activity 被销毁前的状态，并据此恢复 Activity。</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/restore_instance.png" alt="Activity 恢复实例"></p>
<ol start="4">
<li>onSaveInstanceState() 并不是在 Activity 被销毁之前一定会被调用。该方法在 onStop() 之前被调用，是否在 onPause() 前则不确定。</li>
<li>即使你没有实现 onSaveInstanceState() ，在 Activity 的 onSaveInstanceState() 的默认实现中也可以恢复一些状态。由于 onSaveInstanceState() 的默认实现中保存了 UI 的状态，因此，在自己实现 onSaveInstanceState() 时，需要调用父类的 onSaveInstanceState()。</li>
<li>由于 onSaveInstanceState() 不保证一定会被调用，因此不能在这个回调中记录 Activity 状态的变换，也不应该使用它来持久化数据，而应该使用 onPause()。</li>
<li>一个好的，用来测试应用程序恢复状态能力的方法是简单地旋转设备的屏幕方向。</li>
</ol>
<h3 id="处理配置改变"><a href="#处理配置改变" class="headerlink" title="处理配置改变"></a>处理配置改变</h3><p>某些设备配置在运行时会发生改变，如屏幕方向、键盘可用性和语言。当这些改变发生时， Android 重建运行中的 Activity (系统调用 onDestroy() 后马上调用 onCreate() )。这个行为被设计用来帮助应用程序适应新的配置，自动为应用程序重新加载已提供的可替换资源，如为不同屏幕方向和尺寸使用的不同布局。</p>
<p>处理重启的最好方法是使用 onSaveInstanceState() 和 onRestoreInstanceState() (或者 onCreate()) 来保存和恢复 Activity 的状态。</p>
<h3 id="协调多个-Activity"><a href="#协调多个-Activity" class="headerlink" title="协调多个 Activity"></a>协调多个 Activity</h3><p>当一个 Activity 启动另外一个时，两个 Activity 都会经历生命周期的变换。当另一个 Activity 被创建时，第一个 Activity 将暂停，乃至停止(如果它在后台且可见，则不会停止)。如果两个 Activity 之间共享保存在磁盘上的数据，对于理解在第二个 Activity 创建完成之前，第一个 Activity 不会完全停止是非常重要的。第二个 Activity 的启动过程和第一个 Activity 的停止过程重叠。</p>
<p>生命周期回调的顺序是被良好定义的，特别是当两个 Activity 在相同的进程中，且一个启动另外一个。下面是当 Activity A 启动 Activity B 时的操作顺序：</p>
<ol>
<li>执行 Activity A 的 onPause() 方法。</li>
<li>Activity B 的 onCreate() ， onStart() 和 onResume() 方法按顺序执行。(这是 Activity 获取了用户焦点)。</li>
<li>如果 Activity A 不再屏幕上可见， onStop() 方法被执行。</li>
</ol>
<p>可预期的生命周期回调顺序使得你可以管理一个 Activity 到另一个的变换信息。例如，你必须在第一个 Activity 停止时对数据库进行写入，这样接下来的 Activity 可以读取，那么你需要在 onPause() 中写入数据库，而不是在 onStop() 中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/faq/open-files-via-cmdline-using-sublime-text/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/faq/open-files-via-cmdline-using-sublime-text/" itemprop="url">Mac 上 sublime text 通过命令行打开文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-03T18:28:00+08:00">
                2015-11-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-11-03T18:39:01+08:00">
                2015-11-03
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FAQ/" itemprop="url" rel="index">
                    <span itemprop="name">FAQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Mac 上让 sublime text 通过命令行打开文件，可以提升比较高的效率。</p>
<p>具体过程如下：</p>
<p>1. 首先，在主用户目录下新建 .bash_alias 文件</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.bash<span class="number">_</span><span class="keyword">alias</span></span><br></pre></td></tr></table></figure>
<p>2. 在其中添加如下代码</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">subl</span>=<span class="comment">'open -a /Applications/"Sublime Text 2.app"'</span></span><br><span class="line"><span class="keyword">alias</span> <span class="title">st</span>=subl</span><br></pre></td></tr></table></figure>
<p>3. 使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_alias</span><br></pre></td></tr></table></figure>
<p>4. 可以将上面的命令，添加到 <code>~/.bash_profile</code> 中，这样每次启动就自动使上面的配置生效了。</p>
<p>5. 完成上面步骤，就可以通过如下命令，打开目标文件/目录了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">st</span> path/<span class="keyword">to</span>/dest/dir_or_file</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他的应用也是可以通过类似的方式配置，来提高操作的效率，如下面添加了 mou 来打开文件。</p>
</blockquote>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">mou</span>=<span class="comment">'open -a /Applications/Mou.app'</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/faq/resolve-the-same-input-jar-is-specified-twice-issue/" itemprop="url">解决 The same input jar is specified twice 问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-02T21:06:00+08:00">
                2015-11-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-11-02T21:18:19+08:00">
                2015-11-02
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FAQ/" itemprop="url" rel="index">
                    <span itemprop="name">FAQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> <span class="keyword">task</span> <span class="string">':joke:proguardRelease'</span>.</span><br><span class="line">&gt; java.io.IOException: The same input jar [<span class="regexp">/Users/</span>lfy<span class="regexp">/Develop/gi</span>ts<span class="regexp">/joke-android/</span>joke<span class="regexp">/libs/</span>eventbus.jar] is specified twice.</span><br></pre></td></tr></table></figure>
<p>今天在打混淆包时，遇到这个错误，刚开始以为是因为有多个项目都引用了 eventbus.jar 库，但当我对项目中的 eventbus.jar 的依赖进行排除时，同样出错。这次报的则是没有 eventbus.jar。 所以打消了我的第一个猜测。</p>
<p>后来发现，是因为以前在用 eclipse 开发时，混淆配置文件中包含有 <code>-libraryjars libs/eventbus.jar</code> 的配置，用来保持 eventbus.jar 不被混淆。在 Android Studio 中， build.gradle 中声明了对这个 jar 包的依赖，则不需要在混淆配置文件中继续声明。</p>
<p>在将所有的 <code>-libraryjars libs/*.jar</code> 注释掉以后，项目可以正常混淆了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-your-blog/hexo-with-duoshuo/" itemprop="url">Hexo 使用多说评论框</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T09:37:28+08:00">
                2015-11-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-10-18T20:14:28+08:00">
                2018-10-18
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工具/" itemprop="url" rel="index">
                    <span itemprop="name">软件工具</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工具/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-your-blog/hexo-with-duoshuo/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/faq/hexo-symbol-not-found_usdt_create_provider/" itemprop="url">Hexo Symbol not found _usdt_create_provider 错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-31T07:13:12+08:00">
                2015-10-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-10-31T19:26:55+08:00">
                2015-10-31
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FAQ/" itemprop="url" rel="index">
                    <span itemprop="name">FAQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/faq/hexo-symbol-not-found_usdt_create_provider/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿阿燃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/" itemprop="url">Hexo 使用七牛云同步插件 hexo-qiniu-sync 出错</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-31T06:45:20+08:00">
                2015-10-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2015-10-31T19:23:12+08:00">
                2015-10-31
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FAQ/" itemprop="url" rel="index">
                    <span itemprop="name">FAQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError: <span class="keyword">Arguments</span> to path.join must be strings</span><br><span class="line">    <span class="built_in">at</span> Object.posix.join (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">at</span> sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">at</span> Object.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">at</span> <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.ret (eval <span class="built_in">at</span> &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    <span class="built_in">at</span> /Users/lfy/ihaowu/node_modules/hexo/lib/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    <span class="built_in">at</span> tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    <span class="built_in">at</span> new Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.call (/Users/lfy/ihaowu/node_modules/hexo/lib/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">at</span> runHexoCommand (/usr/local/lib/node_modules/hexo/node_modules/hexo-cli/lib/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="built_in">at</span> tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">at</span> Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">at</span> <span class="keyword">Immediate</span>.Async.drainQueues [<span class="built_in">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> processImmediate [<span class="built_in">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Aaron</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">233</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/linfuyan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



  <div class="footer-custom">Hosted by <a href="https://pages.coding.me" style="font-weight:bold">Coding Pages</a></div>


        







  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1256375489&web_id=1256375489" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
