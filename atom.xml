<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[悠城札记]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-09-28T03:44:52.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[linfuyan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[响应式编程2分钟简介]]></title>
    <link href="http://yoursite.com/2-minute-introduction-to-rx/"/>
    <id>http://yoursite.com/2-minute-introduction-to-rx/</id>
    <published>2015-09-28T03:40:00.000Z</published>
    <updated>2015-09-28T03:44:52.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877" target="_blank" rel="external">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>
<a id="more"></a>
<p>现在来考虑包含鼠标位置信息的点击事件。如果你把这些事件画在一条时间轴上，则看起来像这样：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<p>这是个事件流( <em>stream</em> of <em>event</em> )，或者叫” <strong>Observable</strong> “。</p>
<p>这些点击事件来自于鼠标，因此整个事件流是不可变的，这种情况下，当它被定义，你无法从中添加或者删除。</p>
<p>但是，如果我们仅仅对 <code>x &lt; 250</code> 的点击事件感兴趣呢？我们能否通过过滤来建立一个新的流，就像我们之前对数组所做的那样呢？</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<blockquote>
<p>filter((event) -&gt; event.x &lt; 250)</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_2.png" alt="click event after filter"></p>
<p>既然这样，不可变数组与 <strong>Obserable</strong> 有什么不同呢？不仅仅这样，你可以应用 map、 filter、 reduce 等操作到这两者上。对于 <strong>Obserable</strong> ，你还可以应用这些操作： <code>merge</code>,  <code>delay</code>,  <code>concat</code>,  <code>buffer</code>,  <code>distinct</code>,  <code>first</code>,  <code>last</code>,  <code>zip</code>,  <code>startWith</code>,  <code>window</code>,  <code>takeUntil</code>,  <code>skip</code>,  <code>scan</code>,  <code>sample</code>,  <code>amb</code>,  <code>join</code>,  <code>flatMap</code> 等。</p>
<p><strong>把它想象成异步的不可变数组。</strong></p>
<p>在 underscore.js 中 Rx 被认为是事件。但想一想，到底什么是事件呢？你的应用中的大部分东西能否是个事件呢？</p>
<p>“应用启动”事件，”接口数据返回”事件，”按键按下”事件，”界面刷新”事件，”设备休眠”事件，等等。</p>
<p>实际上，几乎所有的东西都可以看做是事件的流。问题只在于如何以合适的方式来组合它们。</p>
<p>这就是响应式编程的2分钟介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>]]>
    
    </summary>
    
      <category term="rx" scheme="http://yoursite.com/tags/rx/"/>
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="响应式编程" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Ubuntu 14.04 上通过 apt-get 安装 Apache Tomcat 7]]></title>
    <link href="http://yoursite.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/"/>
    <id>http://yoursite.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/</id>
    <published>2015-09-26T15:32:00.000Z</published>
    <updated>2015-09-26T15:46:19.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>
<a id="more"></a>
<h3 id="步骤一_-_先决条件">步骤一 - 先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照 Ubuntu 14.04 上搭建服务器中的 1-4 步来学习完成它。我们这里使用创建的 <code>demo</code> 用户来完成后续的教程。</p>
<h3 id="步骤二_-_安装_Tomcat">步骤二 - 安装 Tomcat</h3><p>首先，你需要升级 apt-get 软件包列表：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<p>现在你已经准备好安装 Tomcat。运行以下命令，开始安装：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install tomcat7</span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装 Tomcat 。这将同时安装 Tomcat 和它的依赖，例如 Java，同时，它将创建一个 <code>tomcat7</code> 用户，并以默认设置启动 Tomcat 。</p>
<p>这时候， Tomcat 并没有完全安装完成，但你可以通过在浏览器中输入本地域名或IP地址之后加 <code>:8080</code> 的方法来访问默认页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你会看到一个闪屏页面，显示 “It works” ，和其他附加信息。现在，我们要深入到 Tomcat 的安装过程。</p>
<h3 id="步骤三_-_安装额外软件包">步骤三 - 安装额外软件包</h3><p><em>注意：</em>如果你对 Tomcat 足够了解，且不需要 Web 管理接口，文档和示例，那这个章节不是必须的。如果你是第一次接触 Tomcat ，请继续。</p>
<p>通过以下代码，你将安装 Tomcat 的在线文档， Web接 口（管理 Web 应用），以及一些示例应用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> tomcat7-docs tomcat7-<span class="keyword">admin</span> tomcat7-examples</span></span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装这些软件包。后面我们会讲到这些工具的用法和配置。接下来，我们要安装 JDK 。</p>
<h3 id="步骤四_-_安装_JDK_(可选)">步骤四 - 安装 JDK (可选)</h3><p>如果你打算在服务器上开发应用，你需要安装本章节中提到的软件。</p>
<p>JDK 确保我们可以开发运行在 Tomcat 服务器上的 Java 应用。运行以下命令来安装 <code>openjdk-7-jdk</code>:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure>
<p>作为 JDK 的附件， Tomcat 文档上建议同时安装用来构建 Java 应用 Apache Ant 工具及包括 Git 在内的源码控制系统。通过下面的命令来安装它们：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install ant git</span><br></pre></td></tr></table></figure>
<p>Apache Ant 的更多信息，可查阅其<a href="http://ant.apache.org/manual/index.html" target="_blank" rel="external">官方文档</a>。 Git 使用教程可以参考<a href="https://www.digitalocean.com/community/articles/how-to-use-git-effectively" target="_blank" rel="external">这里</a>。</p>
<h3 id="步骤五_-_配置_Tomcat_Web_管理器">步骤五 - 配置 Tomcat Web 管理器</h3><p>想要使用步骤三中安装的 Web 应用管理器，需要先登录到 Tomcat 服务器。首先需要编辑修改 <code>tomcat-users.xml</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>tomcat7<span class="regexp">/tomcat-users.xml</span></span><br></pre></td></tr></table></figure>
<p>该文件充满了用于说明如何配置的注释。你需要删除下面两行之间的所有注释。如需要用作参考，则保留。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;tomcat-users&gt;</span></span><br><span class="line"><span class="tag">&lt;/tomcat-users&gt;</span></span><br></pre></td></tr></table></figure>
<p>你需要添加一个用户，可以访问 <code>manager-gui</code> 和 <code>admin-gui</code> （我们在步骤三种安装的管理界面）。你可以通过如下的配置来定义一个用户。如果需要，确保修改用户名和密码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tomcat-users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">user</span> <span class="attribute">username</span>=<span class="value">"admin"</span> <span class="attribute">password</span>=<span class="value">"password"</span> <span class="attribute">roles</span>=<span class="value">"manager-gui,admin-gui"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存并退出 <code>tomcat-users.xml</code> 文件。重启 Tomcat 服务，以便修改配置生效。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> service tomcat7 restart</span><br></pre></td></tr></table></figure>
<h3 id="步骤六_-_访问_Web_界面">步骤六 - 访问 Web 界面</h3><p>现在，我们已经配置了一个管理员用户，从 Web 浏览器访问 Web 管理器页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your-ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你可以看到的页面如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_3.png" alt="image"></p>
<p>从上面可以看到，里面有四个链接到步骤三中安装的软件包：</p>
<ul>
<li>tomcat7-docs: Tomcat 的在线文档。通过 <code>http://your_ip_address:8080/docs/</code> 来访问</li>
<li>tomcat7-examples: Tomcat 7 Servlet 和 JSP 示例。你可以点击这些示例 Web 应用来了解它们是怎么工作的（通过源码可以了解它们是怎么实现的）。通过 <code>http://your_ip_address:8080/examples/</code> 来访问</li>
<li>tomcat7-admin ( Web 应用管理器): Tomcat Web 应用管理器。通过这里来管理你的 Java 应用。</li>
<li>tomcat7-admin (主机管理器): Tomcat 虚拟主机管理器。</li>
</ul>
<p>通过打开链接 <code>http://your_ip_address:8080/manager/html</code> ，来查看 Web 应用管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_1.png" alt="image"></p>
<p>这个Web应用管理器使用来管理Java应用的。你可以在这里执行应用的启动，停止，重新加载，部署，下架等操作。还可以对应用做一些诊断（如内存泄露）。最后，你服务器的相关信息被显示在页面的最底部。</p>
<p>通过打开链接 <code>http://your_ip_address:8080/host-manager/html</code> ，来查看虚拟主机管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_2.png" alt="image"></p>
<p>在虚拟主机管理页面，你可以为应用程序添加虚拟主机。</p>
<h3 id="结束">结束</h3><p>Tomcat 的安装到此结束。你现在就可以免费得来部署自己的 Web 应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>]]>
    
    </summary>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是 Jenkins?]]></title>
    <link href="http://yoursite.com/what-is-jenkins/"/>
    <id>http://yoursite.com/what-is-jenkins/</id>
    <published>2015-09-26T15:13:09.000Z</published>
    <updated>2015-09-26T15:26:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
<ul>
<li><strong>持续构建/测试软件项目</strong>，类似于 <code>CruiseControl</code> 或者 <code>DamageControl</code> 。简而言之， Jenkins 提供一个使用简单地持续集成系统，使得开发人员更方便的集成项目修改，让用户更容易地获取较新的构建版本。自动化持续构建极大提高了生产力。</li>
<li><strong>监控外部运行任务的执行</strong>，比如配置在本地或者远程的 <code>cron</code> 或 <code>procmail</code> 任务。拿 <code>cron</code> 举个例子，你将收到的是一些包含输出结果的常规电子邮件，提醒你勤快地处理它们，当它们出错时，也可以第一时间提醒你。 Jenkins 保存这些输出，并使得出现问题时的通知变得简单。</li>
</ul>
<h3 id="特性">特性</h3><p>Jenkins 所提供(拥有)的特性如下：</p>
<ol>
<li><strong>易于安装</strong>：只需要一个名为 jenkins.war 的 Java jar 包，或者将它发布到 servlet 容器。不需要其他附件安装，不需要数据库。</li>
<li><strong>易于配置</strong>：整个 Jenkins 的配置都可以通过它友好的 Web 界面来完成。不在需要别扭的 XML 手动配置，如果你依然愿意，可以继续使用。</li>
<li><strong>修改设置的支持</strong>： Jenkins 可以从 <code>Subversion/CVS</code> 生成一系列的修改列表来完成构建。这种方式也非常的前卫，因为减少了从存储库加载资源的步骤。</li>
<li><strong>永久的链接地址</strong>： Jenkins 为大部分的页面提供了简洁可读的 URL ，包括诸如” <code>latest build/latest successful build</code> “这样的永久性链接，可以很轻易的从其他地方链接过来。</li>
<li><strong>RSS/邮件/即时通行集成</strong>：通过 RSS 或者邮件来获取失败时的实时通知，轻而易举地监控构建结果。</li>
<li><strong>标记构建过程</strong>：当构建完成以后，可以对其进行标记存储。</li>
<li><strong>JUnit/TestNG 测试报告</strong>： JUnit 的测试报告及历史信息，可以表格形式总结与展示，比如构建在什么时候开始出错等等。历史趋势以图表形式绘制出来。</li>
<li><strong>分布式构建</strong>： Jenkins 可以分配构建/测试到多台电脑商。</li>
<li><strong>文件指纹</strong>： Jenkins 可以跟踪那次构建生成了哪些 jar 包，哪些构建使用了哪个版本的 jar 包等等。这些对不是 Jenkins 内部产生的 jar 包也有效，非常适合于项目中的依赖跟踪。</li>
<li><strong>插件支持</strong>： Jenkins 可以轻易地通过第三方插件进行扩展。你甚至可以为自己的团队使用编写合适的 Jenkins 插件。</li>
</ol>
<h3 id="Jenkins_由来">Jenkins 由来</h3><p>目前持续集成（ CI ）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，只在缓和和稳固软件的构建过程，并且能够帮助你的开发团队应对如下挑战：</p>
<ul>
<li>软件构建自动化：配置完成后， CI 系统会依照预先定制的时间表，或者针对某一特定事件，对目标软件进行构建。</li>
<li>构建可持续的自动化检查： CI 系统能持续地获取新增或者修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时， CI 系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力。</li>
<li>构建可持续的自动化测试：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知给相关的当事人。</li>
<li>生成后后续过程的自动化：当自动化检查和测试成功完成以后，软件构建的周期中可能需要一些额外的任务，诸如生成文档，打包软件，部署构建到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。</li>
</ul>
<p>部署一个 CI 系统需要的最低要求是，一个可获取的源代码仓库，一个包含构建脚本的项目。</p>
<p>CI 系统的基本结构，如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/jenkins-basic-structure.jpg" alt="image"></p>
<p>该系统的各个组成部分是按如下顺序发挥作用的：</p>
<ol>
<li>开发这检入代码到源代码仓库。</li>
<li>CI 系统会为每一个项目创建一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</li>
<li>CI 系统会在对应的工作区内执行构建过程。</li>
<li>如果配置存在，构建完成后， CI 系统会在一个新的构建中执行定义的一套测试。完成后出发通知（RSS，邮箱等等）给相关的当事人。</li>
<li>如果配置存在，在构建成功后，这个构建会被打包并转移到一个部署目标（如应用服务器）或存储为软件仓库中的一个新版本。软件仓库可以是 CI 系统的一部分，也可以是一个外部的仓库，诸如一个文件或者服务器或者像 Java.net 、 SourceForge 之类的网站。</li>
<li>CI 系统通常会根据请求发起相应地操作，诸如及时构建、生成报告，或者检索一些构建好的构件。</li>
</ol>
<p>Jenkins 就是这样的一个 CI 系统。它的主要目标在于监控软件开发流程，快速显示问题。所以能保证开发人员以及相关人员省时省力提高开发效率。</p>
<p>在整个开发过程中， CI 的作用主要是控制：当系统在代码库中探测到修改是，它将运行构建的任务委托给构建过程本身。如果构建失败了，那么 CI 将通知相关人员，然后继续监视存储库。</p>
<h4 id="参考">参考</h4><ol>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins01.html" target="_blank" rel="external">Jenkins是什么</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins" target="_blank" rel="external">Meet Jenkins</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
]]>
    </summary>
    
      <category term="CI" scheme="http://yoursite.com/tags/CI/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="构建" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/jenkins/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Hueman 主题添加侧边栏添加微信公众号二维码]]></title>
    <link href="http://yoursite.com/hexo-your-blog/add-weixin-qrcode-to-hueman-sidebar/"/>
    <id>http://yoursite.com/hexo-your-blog/add-weixin-qrcode-to-hueman-sidebar/</id>
    <published>2015-09-26T14:38:53.000Z</published>
    <updated>2015-09-26T14:57:45.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章中，我们来在 Hueman 主题的侧边栏中添加微信公众号的二维码。</p>
<p>1. 找到 themes/hueman 下的配置文件 _config.yml，添加 weixin 变量配置为二维码地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置关注微信公众号</span></span><br><span class="line">weixin: http://<span class="number">7</span>sbydj.com1.z0.glb.clouddn.com/static/images/qrcode_<span class="keyword">for</span>_gh_3ad92a8<span class="built_in">fc</span>23c_860.jpg</span><br></pre></td></tr></table></figure>
<p>2. 在 themes/huema/layout/_widget 目录下新建 weixin.ejs 文件，添加如下代码</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (theme.weixin)&#123; </span>%&gt;<span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"widget-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> theme.weixin </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">width</span>=<span class="value">"100%"</span> <span class="attribute">height</span>=<span class="value">"100%"</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span>&lt;%<span class="ruby"> &#125; </span>%&gt;<span class="xml"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里根据是否存在1中的微信二维码链接来控制这个模块的显示。可以根据实际需要设置样式。</p>
</blockquote>
<p>3. 修改 themes/hueman/_config.yml , 在 widgets 添加 weixin。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">-<span class="ruby"> weixin</span><br><span class="line"></span>-<span class="ruby"> recent_posts</span><br><span class="line"></span>-<span class="ruby"> tagcloud</span><br><span class="line"></span>-<span class="ruby"> category</span><br><span class="line"></span>-<span class="ruby"> archive</span><br><span class="line"></span>-<span class="ruby"> tag</span><br><span class="line"></span>-<span class="ruby"> links</span></span><br></pre></td></tr></table></figure>
<h4 id="总结：">总结：</h4><p>本节中通过将微信公众账号的二维码作为一个组件( weixin.ejs )，利用 hueman 主题已有的侧边栏配置，非常方便的实现了微信公众账号二维码的添加。</p>
<p>同时也欢迎大家关注：非典型程序员</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/qrcode_for_gh_3ad92a8fc23c_860.jpg" alt="非典型程序员"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章中，我们来在 Hueman 主题的侧边栏中添加微信公众号的二维码。</p>
<p>1. 找到 themes/hueman 下的配置文件 _config.yml，添加 weixin 变量配置为二维码地址。</p>
<figure class="highlight ba]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Hueman" scheme="http://yoursite.com/tags/Hueman/"/>
    
      <category term="二维码" scheme="http://yoursite.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="微信公众号" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[声明式编程范式初探]]></title>
    <link href="http://yoursite.com/declarative-programming-intro/"/>
    <id>http://yoursite.com/declarative-programming-intro/</id>
    <published>2015-09-26T14:03:09.000Z</published>
    <updated>2015-09-26T14:10:51.000Z</updated>
    <content type="html"><![CDATA[<p>语言编程语言可以分成两类：</p>
<ul>
<li>命令式</li>
<li>声明式</li>
</ul>
<p>事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/categaries-of-programming-paradigm.jpg" alt="编程范式的简单分类"></p>
<p>与命令式编程相对的声明式编程（ declarative programming ）。顾名思义，声明式编程由若干规范（ specification ）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。</p>
<a id="more"></a>
<h4 id="声明式编程的发源">声明式编程的发源</h4><p>声明式编程发轫于人工智能的研究，主要包括函数式编程（ functional programming ，简称 FP ）和逻辑式编程（ logic programming ，简称 LP ）。其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。</p>
<p>其实支持它们的语言出现得并不比命令式的晚多少——最早的函数式语言 Lisp （ <strong>LIS</strong>t <strong>P</strong>rocessor ）已有半个世纪的历史，最早之一的逻辑式语言 Prolog （ <strong>PRO</strong>gramming in <strong>LOG</strong>ic ）也与 C 同龄。只是由于大多数更多地用于学术研究而非商业应用，颇有些‘养在深闺人未识’的味道。</p>
<p>起源的不同决定了这两大类范式代表着迥然不同的编程理念和风格：命令式编程是行动导向（ Action-Oriented ）的，因而算法是显性而目标是隐性的；声明式编程是目标驱动（ Goal-Driven ）的，因而目标是显性而算法是隐性的。为便于说明，我们分别用三种代表性的语言来实现阶乘（ factorial ）运算。</p>
<h4 id="阶乘的三种编程实现">阶乘的三种编程实现</h4><p>C(命令式) –</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; n &gt; <span class="number">0</span>; --n) f *= n;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Liap(函数式) –</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun factorial(<span class="keyword">n</span>)</span><br><span class="line">  (<span class="keyword">if</span> (= <span class="keyword">n</span> 0)</span><br><span class="line">	1                               <span class="comment">//  若n等于0，则n!等于1</span></span><br><span class="line">	(* <span class="keyword">n</span> (factorial(- <span class="keyword">n</span> 1)))))      <span class="comment">//  否则n!等于n* (n-1)</span></span><br></pre></td></tr></table></figure>
<p>Prolog(逻辑式) –</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0! 等于1</span></span><br><span class="line">factorial(0,1).</span><br><span class="line"><span class="comment">// 若M等于N-1且 M!等于Fm且F等于N*Fm，则N! 等于F</span></span><br><span class="line">factorial(<span class="keyword">N</span>,F) :-   <span class="keyword">M</span> is <span class="keyword">N</span>-1, factorial(<span class="keyword">M</span>,Fm), F is <span class="keyword">N</span> * Fm.</span><br></pre></td></tr></table></figure>
<p>以上三段代码区别在哪里？ C 明确给出了阶乘的迭代算法，而 Lisp 仅描述了阶乘的递归定义， Prolog 则陈述了两个关于阶乘的断言。</p>
<h4 id="声明式编程的本质">声明式编程的本质</h4><p>我们最早接触的变量是代数方程中的 x、y、z 等，本质上是抽象化的符号，变量值是该符号在给定约束条件下的允许值。而命令式编程中的变量本质上是抽象化的内存，变量值是该内存的储存内容。通俗地说，前者好比姓名，所指之人是固定的；后者好比住址，所住之人是变化的。此外，等号在代数中是一种约束，而在许多命令式语言中则表示赋值。因此 i = i + 1 可以在命令式编程中出现，但绝不可能在数学推理中出现 —— 除非在反证法中。</p>
<p>声明式编程让我们重回数学思维：函数式编程类似代数中的表达式变换和计算，逻辑式编程则类似数理逻辑推理。其中的变量也如数学中的一样，是抽象符号而非内存地址，因此没有赋值运算，不会产生变量被改写的副作用（ side-effect ），也不存在内存分配和释放的问题。这既简化了代码，也减少了调试——不妨想一想，有多少bug是由于某个变量被意外改写或内存管理不慎而造成的？</p>
<p><strong>声明式语言与命令式语言的相通之处</strong></p>
<ul>
<li>首先，所有高级语言都建立于低级语言之上，最终转化为机器语言，声明式语言也不例外。</li>
<li>其次，声明式语言与命令式语言并非泾渭分明，而是互相交叉渗透的。一些‘非纯粹’ 的声明式语言也提供变量赋值和流程控制，而一些命令式语言也在逐渐发展，通过利用其他程序或增加新的语言特征来实现声明式编程。</li>
</ul>
<p>总的说来，在命令式语言中融入声明式的元素应当是一种趋势。尤其是函数式，它的一些特征已经在许多命令式语言中得到了支持。比较而言，声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简洁清晰、易于修改和维护。从这种意义上说，声明式语言天然地就比命令式语言更高级。</p>
<blockquote>
<p>既然声明式编程有这么多好处，为什么命令式语言不仅占大多数，而且流行程度也不减呢？</p>
<p>编程语言的流行程度与其擅长的领域关系密切。声明式语言——尤其是函数式语言和逻辑式语言——擅长基于数理逻辑的应用，如人工智能、符号处理、数据库、编译器等，对基于业务逻辑的、尤其是交互式或事件驱动型的应用就不那么得心应手了。而大多数软件是面向用户的，交互性强、多为事件驱动、业务逻辑千差万别，显然命令式语言在此更有用武之地。</p>
</blockquote>
<p>值得指出的是，声明式编程并不仅仅局限于函数式和逻辑式。比方说， C# 中的 attribute 、 Java 中的 annotation 和 XDoclet 库等采用的也是具有声明式特征的属性导向式编程（ Attribute-Oriented Programming ，简称 @OP ）。再比如， Prograph 、 SISAL 等数据流语言（ dataflow language ）采用的数据流式编程（ Dataflow Programming ）与函数式编程有不少共同点，同样属于声明式的范畴。还有一些语言如 Oz 、 CHIP 等支持与逻辑式编程相交的约束式编程（ Constraint Programming ）。此外，大家熟悉的数据库语言 SQL ，样式语言 XSLT、 CSS，标记语言 HTML 、 XML 、 SVG ，规范语言 IDL （ Interface Description Language ）等等都是声明式的。算上它们，声明式语言所占的比例也是非常可观的。此前之所以没有提及，一方面，不少声明式语言采用的范式并没有专门的名称；另一方面，这些语言大多是领域特定语言，并且不少并非图灵完备的，有的连运算都没有。毕竟，目前我们的重点还是放在通用编程语言上。</p>
<p>其实用 Lisp 实现阶乘的方法也可以用在 C 上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : <span class="function">n * <span class="title">factorial</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 C 的递归实现。除了细微的语法差别外，二者的确很相似，这说明用命令式语言也可以讲出声明式的味道。实际上，命令式语言提倡迭代而不鼓励递归，早期的 Fortran 甚至都不支持递归。一则迭代比递归更符合命令式的思维模式，因为前者贴近机器语言而后者贴近数学语言；二则除尾递归（ tail recursion ）外，一般递归比迭代的开销（ overhead ）大。相反，声明式语言提倡递归而不支持迭代。就语法而言，它不允许迭代中的循环变量；就视角而言，迭代着眼微观过程而递归着眼宏观规律。</p>
<p>归根结底，<strong>编程是寻求一种机制，将指定的输入转化为指定的输出。</strong>三种范式对此提供了截然不同的解决方案：</p>
<ul>
<li>命令式把程序看作一个自动机，输入是初始状态，输出是最终状态，编程就是设计一系列指令，通过自动机执行以完成状态转变；</li>
<li>函数式把程序看作一个数学函数，输入是自变量，输出是因变量，编程就是设计一系列函数，通过表达式变换以完成计算；</li>
<li>逻辑式把程序看作一个逻辑证明，输入是题设，输出是结论，编程就是设计一系列命题，通过逻辑推理以完成证明。</li>
</ul>
<p>绘成表格如下：</p>
<table>
<thead>
<tr>
<th>范式</th>
<th>程序</th>
<th>输入</th>
<th>输出</th>
<th>程序设计</th>
<th>程序运行</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令式</td>
<td>自动机</td>
<td>初始状态</td>
<td>最终状态</td>
<td>设计指令</td>
<td>命令执行</td>
</tr>
<tr>
<td>函数式</td>
<td>数学函数</td>
<td>自变量</td>
<td>因变量</td>
<td>设计函数</td>
<td>表达式变换</td>
</tr>
<tr>
<td>逻辑式</td>
<td>逻辑证明</td>
<td>题设</td>
<td>结论</td>
<td>设计命题</td>
<td>逻辑推理</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>语言编程语言可以分成两类：</p>
<ul>
<li>命令式</li>
<li>声明式</li>
</ul>
<p>事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/categaries-of-programming-paradigm.jpg" alt="编程范式的简单分类"></p>
<p>与命令式编程相对的声明式编程（ declarative programming ）。顾名思义，声明式编程由若干规范（ specification ）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。</p>]]>
    
    </summary>
    
      <category term="命令式" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E5%BC%8F/"/>
    
      <category term="声明式" scheme="http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="范式" scheme="http://yoursite.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="基础理论" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Ubuntu 14.04 上安装Linux, Apache, MySQL, PHP (LAMP)组件]]></title>
    <link href="http://yoursite.com/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04/"/>
    <id>http://yoursite.com/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04/</id>
    <published>2015-09-26T13:29:00.000Z</published>
    <updated>2015-09-26T13:52:05.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04</a></p>
<h4 id="介绍">介绍</h4><p>“ LAMP “组件是一组典型的安装在一起的开源软件，用于服务器搭建动态网站和 Web 应用。实际上，这是一个首字母缩写的组合，代表了 Linux 操作系统安装 <strong>A</strong>pache Web 服务器。网站的数据存储在 <strong>M</strong>ySQL 数据库中，并由 <strong>P</strong>HP 提供动态内容。</p>
<a id="more"></a>
<p>在这篇向导中，我们将在 Ubuntu 14.04 Droplet 上搭建 LAMP 。 Ubuntu 提供了我们的第一个需求：一个 <strong>L</strong>inux 操作系统。</p>
<h3 id="先决条件">先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照<a href="https://www.digitalocean.com/community/articles/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="external">Ubuntu 14.04上搭建服务器</a>中的1-4步来学习完成它。</p>
<h3 id="步骤一_-_安装Apache">步骤一 - 安装<strong>A</strong>pache</h3><p>Apache web 服务器是目前世界上最流行的 web 服务器，是挂载站点的最佳默认选择。</p>
<p>我们将通过 Ubuntu 的包管理器 <code>apt</code> 来便捷地安装 Apache。这个包管理器让我们可以毫无痛苦的从 Ubuntu 维护的存储库中来安装大多数的软件。更多关于 <code>apt</code> 的信息，可以看这里<a href="https://www.digitalocean.com/community/articles/how-to-manage-packages-in-ubuntu-and-debian-with-apt-get-apt-cache" target="_blank" rel="external">如何使用 apt</a>。</p>
<p>为了我们的目标，我们可以从输入这些命令开始：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install apache2</span><br></pre></td></tr></table></figure>
<p>由于我们使用 <code>sudo</code> 命令，这些操作在 root 权限下执行。这将要求你输入常规用户的密码来验证你的意图。</p>
<p>在此之后，你的 web 服务器就安装好了。</p>
<p>你可以马上做一些验证来确定一起如预期进行。在浏览器中输入你服务器的公网IP地址：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_server_IP_address</span></span><br></pre></td></tr></table></figure>
<p>你将看到默认的 Ubuntu 14.04 Apache 页面，这个页面展示的目的是出于测试及显示信息。看起来他是这样的：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/default_apache.png" alt="image"></p>
<p>如果你看到这个页面，说明你的 web 服务器正确安装了。</p>
<h4 id="如何找到你的服务器的公网_IP_地址">如何找到你的服务器的公网 IP 地址</h4><p>如果你不知道服务器的公网IP地址是什么，可以有多重方式来找到。通常，这个地址是你用来通过SSH来连接你的服务器的。</p>
<p>在命令行下，有一些方法来找到。首先，你可以使用 <code>iproute2</code> 工具来获取地址，输入以下命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ip</span> addr show eth0 | grep inet | awk <span class="string">'&#123; print <span class="variable">$2</span>; &#125;'</span> | sed <span class="string">'s/\/.*$//'</span></span><br></pre></td></tr></table></figure>
<p>这个将返回一行或两行输出。这两个都是正确地地址，但是你的电脑只能用其中之一，因此放松地尝试每一个。</p>
<p>另一种方法是通过外部的第三方工具来查看你的服务器。你可以通过访问一个确定的服务器来查看自己的IP地址。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">http:</span><span class="comment">//icanhazip.com</span></span><br></pre></td></tr></table></figure>
<p>不论你用哪种方法获取到了自己的IP地址，你可以在浏览器的地址栏中来访问服务器。</p>
<h3 id="步骤二_-_安装_MySQL">步骤二 - 安装 <strong>M</strong>ySQL</h3><p>现在我们已经安装了 web 服务器，并正常运行，是时候安装 MySQL 了。 MySQL 是一个数据库管理系统。最基本的，它用来组织和访问用来存储我们站点信息的数据库。</p>
<p>我们再次用 <code>apt</code> 工具来获取和安装软件。这次，我们还需要安装一些其他的辅助工具包，来让安装的组件相互通信:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> mysql-<span class="keyword">server</span> php5-mysql</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在这里，你不需要在执行这个命令之前，执行 <code>sudo apt-get update</code> 。因为我们在之前安装 Apache 的时候已经执行过了。你电脑上的包索引已经是最新的了。</p>
<p>在安装过程中，你的服务器会让你为 MySQL 的 root 用户选择并设置密码。这在 MySQL 中是一个具有管理员权限的账号。这个有点类似于操作系统中的 root 账号（尽管如此，你目前所配置的账号仅针对 MySQL ）。</p>
<p>当安装结束，我们需要运行一些额外的命令，来保证我们的 MySQL 环境足够安全。</p>
<p>首先，我们需要告诉 MySQL 来创建它用于存储信息的数据库目录结构。你需要输入：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mysql_install_db</span><br></pre></td></tr></table></figure>
<p>然后我们要运行一些简单地安全脚本来消除默认的危险配置，并锁定数据的访问。通过输入如下命令，来开始使用交互脚本：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>你会被要求输入所设置的 MySQL 的 root 账号密码。接下来，会被问到是否想要修改密码，如果你对现有的密码满意，输入 <code>n</code> 代表 <code>no</code> 并提交。</p>
<p>接下来的问题中，你只需简单地回车来使用默认配置。这样做会移除一些测试用户和数据库，禁止 root 用户远程登录，加载这些新的配置，以便我们的修改在 MySQL 中立即生效。</p>
<p>到这里，你的数据库系统已经建立，可以继续下一步。</p>
<h3 id="步骤三_-_安装_PHP">步骤三 - 安装 <strong>P</strong>HP</h3><p>PHP 是我们安装的一个组件，用于处理代码以显示动态内容。它可以运行脚本，连接到 MySQL 数据库来获取信息，并传输处理好的内容到web服务器来显示。</p>
<p>我们可以再次利用 <code>apt</code> 工具来安装我们的组件。同样，我们会包含一些辅助包：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install php5 libapache2-<span class="keyword">mod</span>-php5 php5-mcrypt</span><br></pre></td></tr></table></figure>
<p>这样安装 PHP 将不会有任何问题，我们将马上测试。</p>
<p>在大部分情况下，当请求文件夹时，我们需要修改 Apache 服务器上处理文件的方式。现在，如果一个用户向服务器请求目录， Apache 会首先寻找名为 <code>index.html</code> 的文件。我们需要告诉我们的 web 服务器优先处理 PHP 文件，因此我们让 Apache 首先寻找 <code>index.php</code> 。</p>
<p>要完成这个，输入以下命令来在文本编辑器中打开 <code>dir.conf</code> 文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apache2<span class="regexp">/mods-enabled/</span>dir.conf</span><br></pre></td></tr></table></figure>
<p>找到如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">    DirectoryIndex index<span class="class">.html</span> index<span class="class">.cgi</span> index<span class="class">.pl</span> index<span class="class">.php</span> index<span class="class">.xhtml</span> index<span class="class">.htm</span></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>我们将其中的 <code>index.php</code> 移到第一项的位置，在 <code>DirectoryIndex</code> 之后，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">	DirectoryIndex index<span class="class">.php</span> index<span class="class">.html</span> index<span class="class">.cgi</span> index<span class="class">.pl</span> index<span class="class">.xhtml</span> index<span class="class">.htm</span></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>当操作完成，按下 <code>CTRL-X</code> 保存并退出文件。你需要输入 <code>Y</code> 来确认保存，并点击回车来确认文件保存位置。</p>
<p>在这之后，我们需要重启 Apache web 服务器来使配置修改生效。输入以下命令来完成：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> service apache2 restart</span><br></pre></td></tr></table></figure>
<h4 id="安装_PHP_模块">安装 PHP 模块</h4><p>为了扩展 PHP 的功能，我们可以选择安装一些额外的模块。</p>
<p>查看可选的 PHP 模块和库，可以在系统中输入如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">search</span> php5-</span></span><br></pre></td></tr></table></figure>
<p>结果是所有你可以安装的可选组件，并给出每项的简短介绍。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php5-cgi - server-side, HTML-embedded scripting <span class="keyword">language</span> (CGI binary)</span><br><span class="line">php5-cli - <span class="keyword">command</span>-<span class="built_in">line</span> interpreter <span class="keyword">for</span> the php5 scripting <span class="keyword">language</span></span><br><span class="line">php5-common - Common <span class="keyword">files</span> <span class="keyword">for</span> packages built from the php5 <span class="keyword">source</span></span><br><span class="line">php5-curl - CURL module <span class="keyword">for</span> php5</span><br><span class="line">php5-dbg - Debug symbols <span class="keyword">for</span> PHP5</span><br><span class="line">php5-dev - Files <span class="keyword">for</span> PHP5 module development</span><br><span class="line">php5-gd - GD module <span class="keyword">for</span> php5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>如果想要获取每个模块更多的信息，你可以在互联网上搜索或者通过如下命令查看包内的详细介绍：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">show</span> package_name</span></span><br></pre></td></tr></table></figure>
<p>这将会有许多输出，其中有个名为 <code>Description-en</code> 的区域对模块所提供的功能有详细的解释。</p>
<p>比如说，想要知道 <code>php5-cli</code> 模块的用处，我们可以输入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">show</span> php5-cli</span></span><br></pre></td></tr></table></figure>
<p>从大片的输出信息中，你会看到与如下类似的的内容：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line">SHA256: <span class="number">91</span>cfdbda65df65c9a4a5bd3478d6e7d3e92c53efcddf3436bbe9bbe27eca409d</span><br><span class="line">Description-en: <span class="command"><span class="keyword">command</span>-line <span class="title">interpreter</span> <span class="title">for</span> <span class="title">the</span> <span class="title">php5</span> <span class="title">scripting</span> <span class="title">language</span></span></span><br><span class="line">This package provides <span class="operator">the</span> /usr/bin/php5 <span class="command"><span class="keyword">command</span> <span class="title">interpreter</span>, <span class="title">useful</span> <span class="title">for</span></span></span><br><span class="line">testing PHP scripts <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">shell</span> <span class="operator">or</span> performing general <span class="built_in">shell</span> scripting tasks.</span><br><span class="line">.</span><br><span class="line">The following extensions are built <span class="operator">in</span>: bcmath bz2 calendar Core ctype <span class="built_in">date</span></span><br><span class="line">dba dom ereg exif fileinfo <span class="built_in">filter</span> <span class="keyword">ftp</span> gettext hash iconv libxml mbstring</span><br><span class="line">mhash openssl pcntl pcre Phar posix Reflection session shmop SimpleXML soap</span><br><span class="line">sockets SPL standard sysvmsg sysvsem sysvshm tokenizer wddx xml xmlreader</span><br><span class="line">xmlwriter zip zlib.</span><br><span class="line">.</span><br><span class="line">PHP (recursive acronym <span class="keyword">for</span> PHP: Hypertext Preprocessor) is <span class="operator">a</span> widely-used</span><br><span class="line"><span class="built_in">open</span> source general-purpose scripting language that is especially suited</span><br><span class="line"><span class="keyword">for</span> web development <span class="operator">and</span> can be embedded <span class="keyword">into</span> HTML.</span><br><span class="line">Description-md5: f8450d3b28653dcf1a4615f3b1d4e347</span><br><span class="line">Homepage: <span class="keyword">http</span>://www.php.net/</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>搜索之后，如果你决定要安装某些包，你可以像之前安装软件一样，使用 <code>apt-get</code> 命令来安装这些包。</p>
<p>假设我们想要安装所需的 <code>php5-cli</code> 包，我们输入：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install php5-cli</span><br></pre></td></tr></table></figure>
<p>如果你想要安装多个模块，你可以在 <code>apt-get install</code> 命令之后，列出每个包名，包名之间以空格隔开。像这样：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install <span class="keyword">package</span><span class="number">1</span> <span class="keyword">package</span><span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>到此，我们的组件安装并配置完毕。接下来，我们要测试 PHP。</p>
<h3 id="步骤四_-_在_Web_服务器上测试_PHP">步骤四 - 在 Web 服务器上测试 PHP</h3><p>为了测试我们的系统已经正确配置 PHP ，我们可以新建一个基本的 PHP 脚本。</p>
<p>这个脚本命名为 <code>inifo.php</code> 。为了 Apache 可以正确找到并处理它，它将被保存在名为 <code>web root</code> 的确定目录中。</p>
<p>在 Ubuntu 14.04中，这个目录是 <code>/var/www/html/</code> 。通过以下命令在目标位置新建文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>这将打开一个空文件，我们需要在文件中输入如下有效的PHP代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line">	phpinfo();</span><br><span class="line"><span class="preprocessor">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>操作完成，保存并关闭文件。</p>
<p>现在要测试我们的服务器是否可以正确显示由 PHP 脚本生成的内容。在 web 浏览器中访问这个页面，这时，你需要服务器的公网 IP 地址。</p>
<p>你需要访问的地址如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_server_IP_address/info.php</span></span><br></pre></td></tr></table></figure>
<p>你看到的页面显示如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/default_php.png" alt="image"></p>
<p>这个页面给出了你 web 服务器上的 PHP 信息。这对于你调试，并确保配置信息正确非常有用。</p>
<p>如果这个成功，那么 PHP 已经可以正常运行。</p>
<p>测试完毕，你需要删除这个文件。因为，这会向未授权用户泄露你服务器的信息。输入以下命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>如果你需要查看配置信息，可以再次建立这个文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04</a></p>
<h4 id="介绍">介绍</h4><p>“ LAMP “组件是一组典型的安装在一起的开源软件，用于服务器搭建动态网站和 Web 应用。实际上，这是一个首字母缩写的组合，代表了 Linux 操作系统安装 <strong>A</strong>pache Web 服务器。网站的数据存储在 <strong>M</strong>ySQL 数据库中，并由 <strong>P</strong>HP 提供动态内容。</p>]]>
    
    </summary>
    
      <category term="14.04" scheme="http://yoursite.com/tags/14-04/"/>
    
      <category term="Apache" scheme="http://yoursite.com/tags/Apache/"/>
    
      <category term="LAMP" scheme="http://yoursite.com/tags/LAMP/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="LAMP" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/LAMP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么预期的软件开发周期总是不够?]]></title>
    <link href="http://yoursite.com/why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/"/>
    <id>http://yoursite.com/why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/</id>
    <published>2015-09-23T03:56:57.000Z</published>
    <updated>2015-09-23T04:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>有国外开发者在 Quora 提了这个问题：“为什么软件开发周期通常是预期的两三倍？” 并补充问：“这是开发人员的错误？ 是管理失误？ 是因为做事方法不对， 或者说缺乏好的方法？还是说这就是软件开发流程的特点？” Michael Wolfe 在2012年1月28日给的回复，非常经典，截至我们发布时已有8016个赞。以下是译文。</p>
<p>让我们先沿着海岸线，从旧金山（SF）走路去洛杉矶（LA），去拜访我们住在Newport Beach的朋友，我拿出地图在上面画出了行进路线。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl01.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>全程大约有400英里，如果我们每天走10小时每小时4公里的话，只用10天就可以到达目的地。立刻打电话给我们的朋友预定下周六的晚餐，告诉他们下周六晚上六点我们一定会准时出现，朋友们已经等不及了！</p>
<p>第二天清晨，我们带着准备冒险的兴奋起床，背起行囊，拿出地图，准备计划我们冒险的第一天，看一眼地图，噢，不！</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl02.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>哇，海岸线上有这么多迂回曲折的线路。每天行进40英里的话，10天后只能勉强到达Half Moon Bay（半月湾？）。这趟旅行至少有500英里，而不是400。赶紧打电话给我们的朋友，将晚餐顺延至下下周周二。人还是应该现实一点。朋友们有点失望，不过仍然盼望见到我们，况且花 12 天从 SF 到 LA 也不赖。</p>
<p>把不开心的事丢到一边，准备出发。两小时过后，我们才刚刚走出动物园。出了什么事？我们低头看了一下脚下的路：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcg03.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天哪，这样走路也太慢了！有沙子、海水、阶梯、溪流，还有海边愤怒的海狮！这样我们只能按每小时2公里的速度前进，只有我们预估一般的速度。要么我们现在每天走20小时，要么再把晚餐推迟一个星期。好吧，让我们各退一步：每天走12个小时，把晚餐安排到下下周的周末。只好再打电话给朋友告诉他们这个情况。朋友们有些不高兴，但还是表示可以，到时候见。</p>
<p>在辛苦走了12小时后，我们准备在 Moss Beach 扎营休息。靠，要把帐篷在风中立起来根本不可能。直到半夜才开始休息。不过没什么大不了：明天在加快点速度就可以了。</p>
<p>第二天早上睡过头了，早上10点才醒，起来浑身酸痛精疲力尽。艹，今天没法走12个小时了，先走10个小时，明天可以走14个小时。收拾东西出发。</p>
<p>再缓慢行进了几个小时之后，我发现伙伴脚有点跛。妈的，是水泡。必须现在解决它，在这些问题开始减慢我们的速度前，必须将它们扼杀在萌芽状态。我慢跑了45分钟到达内陆3英里远的Pescadero，买了一些创可贴再快速跑回去给朋友包扎了一下。我快累坏了，太阳也快下山了，又浪费了一天的时间。到我们准备休息前今天只走了6英里。但是我们确实需要补充一下供给。一切都很好，明天我们就能赶上。</p>
<p>第二天醒来，扎紧脚上的绷带准备出发。转角之后突然发现，靠！这是个啥？</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl04.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>你妹的地图上怎么没标出它！现在我们只能往内陆走3英里，绕过这些被联邦政府用栅栏保护起来的区域，中途迷路了两次，在中午前才好不容易又回到了海岸线。今天的时间过了一大半，而我们才前进了差不多1英里。好吧，不过我们不会再打电话给朋友推迟了，今天我们会一直走到午夜试着赶上进度。</p>
<p>晚上在大雾里断断续续地睡了一夜。一大早被我的伙伴叫醒，他一阵阵的头疼，还有点发烧，我问他能不能坚持一下。“你在想什么呢，混蛋，我已经连续三天在这么冷的雾中赶路，没有休息过了。“好吧，今天看来只能黄了，只能在原地好好恢复了。现在我们已经有经验了，今天好好休息明天再走14个小时，还有几天的时间，我们一定能够做到！</p>
<p>第二天我们昏昏沉沉地起来了。我看了一眼随身的地图：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl05.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天啊！我们已经走了10天旅程里的第5天还没有离开海湾区域！太荒唐了！我们要重新估计一下准确的时间再打给朋友，搞不好会被骂，但至少得找一个现实一点的目标。</p>
<p>同伴说，我们在四天里走了40英里，这趟旅程至少又600英里，那就至少要60天，安全一点的说法说不定要70天，“没门…是，以前我是没走路从SF去过LA，但肯定不会要70天的时间，如果告诉他们我们要到复活节才能到，那要被他们笑死的“，我说。</p>
<p>我接着说，“如果你能保证每天走16个小时，我们就能把落下的时间补回来！我知道很困难，但现在是最关键的时刻，别抱怨了！”伙伴对我吼道 “一开始又不是我告诉别人下周日我们就能到的！因为你犯的这个错差点要我的命！”</p>
<p>两个人就这样不说话了。我还是没打出电话，等我的伙伴明天冷静一点我再决定，我也愿意做一些更合理的承诺。</p>
<p>第二天上午，我们一直待在各自的帐篷中直到一场暴风雨袭来。我们赶紧收拾好东西直到10点才摆脱危险。浑身酸痛，又长了好多新水泡。之前发生的事谁也没提，直到发现我那愚蠢的伙伴把水壶落下了，又被我指责了一顿，我们不得不再花30分钟回去取它。</p>
<p>我心里记得我们的厕纸已经快用完了，下次到一个小镇的时候应该囤一点。在我们又转个弯后，才发现一条湍急的河流挡住了去路，这时我突然感到肚子一阵难受……</p>
<p>本文来自伯乐在线：<a href="http://blog.jobbole.com/45756/" target="_blank" rel="external">趣文：为什么软件开发周期通常是预期的两三倍？</a>，译者：</p>
<p>英文出处：<a href="http://www.quora.com/Engineering-Management/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3" target="_blank" rel="external">Engineering Management: Why are software development task estimations regularly off by a factor of 2-3?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有国外开发者在 Quora 提了这个问题：“为什么软件开发周期通常是预期的两三倍？” 并补充问：“这是开发人员的错误？ 是管理失误？ 是因为做事方法不对， 或者说缺乏好的方法？还是说这就是软件开发流程的特点？” Michael Wolfe 在2012年1月28日给的回复，非]]>
    </summary>
    
      <category term="估计" scheme="http://yoursite.com/tags/%E4%BC%B0%E8%AE%A1/"/>
    
      <category term="周期" scheme="http://yoursite.com/tags/%E5%91%A8%E6%9C%9F/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="管理" scheme="http://yoursite.com/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="深度文摘" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E6%96%87%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 安装出现 Cannot find module 错误]]></title>
    <link href="http://yoursite.com/faq/install-hexo-occur-connot-find-module-error/"/>
    <id>http://yoursite.com/faq/install-hexo-occur-connot-find-module-error/</id>
    <published>2015-09-19T06:46:57.000Z</published>
    <updated>2015-09-19T06:59:38.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Hexo 的过程中，有时会遇到下面的错误：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Release/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/default/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Debug/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>从提示上看，问题的原因是缺少某些库，估计是由于天朝网络的问题，导致某些库没有完成下载就停止了。</p>
<p>可以换一个<a href="http://www.linfuyan.com/faq/npm-taobao-registry/" target="_blank" rel="external">国内的 npm 源</a>，然后重新安装 Hexo：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install hexo —<span class="literal">no</span>-optional</span><br></pre></td></tr></table></figure>
<p>原文：<a href="http://segmentfault.com/a/1190000002979092#articleHeader5" target="_blank" rel="external">http://segmentfault.com/a/1190000002979092#articleHeader5</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装 Hexo 的过程中，有时会遇到下面的错误：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span cl]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="解决方案" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="错误" scheme="http://yoursite.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="FAQ" scheme="http://yoursite.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[npm 官网镜像无法连接怎么办?]]></title>
    <link href="http://yoursite.com/faq/npm-taobao-registry/"/>
    <id>http://yoursite.com/faq/npm-taobao-registry/</id>
    <published>2015-09-19T03:34:29.000Z</published>
    <updated>2015-09-19T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Hexo 是需要先安装 Node.js，这个过程中会因为 npm 无法连接到官方 registry 而导致失败。</p>
<p>后来在网上搜到有淘宝的镜像，具体的配置方法有如下几种：</p>
<p>1. 通过 config 命令</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> https://<span class="keyword">registry</span>.npm.taobao.org </span><br><span class="line">npm <span class="keyword">info</span> underscore //如果上面配置正确这个命令会有字符串response</span><br></pre></td></tr></table></figure>
<p>2. 命令行指定</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">npm</span> --registry <span class="url">https://registry.npm.taobao.org</span> <span class="built_in">info</span> underscore</span><br></pre></td></tr></table></figure>
<p>3. 编辑 ~/.npmrc 加入下面内容</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>第三种方案只需配置一次。</p>
<p>原文：<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank" rel="external">使用npm安装一些包失败了的看过来（npm国内镜像介绍）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装 Hexo 是需要先安装 Node.js，这个过程中会因为 npm 无法连接到官方 registry 而导致失败。</p>
<p>后来在网上搜到有淘宝的镜像，具体的配置方法有如下几种：</p>
<p>1. 通过 config 命令</p>
<figure class=]]>
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="registry" scheme="http://yoursite.com/tags/registry/"/>
    
      <category term="taobao" scheme="http://yoursite.com/tags/taobao/"/>
    
      <category term="镜像" scheme="http://yoursite.com/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="FAQ" scheme="http://yoursite.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 技能树]]></title>
    <link href="http://yoursite.com/iOS-skills/"/>
    <id>http://yoursite.com/iOS-skills/</id>
    <published>2015-09-17T01:36:00.000Z</published>
    <updated>2015-09-17T01:41:59.000Z</updated>
    <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 iOS 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="external">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/Android-skills" target="_blank" rel="external">Android 技能</a>请猛戳这里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/iOS-skills.png" alt="iOS 技能树"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是和团队小伙伴们一起整理的 iOS 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blan]]>
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习路线" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="技能" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="进阶" scheme="http://yoursite.com/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 技能树]]></title>
    <link href="http://yoursite.com/Android-skills/"/>
    <id>http://yoursite.com/Android-skills/</id>
    <published>2015-09-17T01:25:00.000Z</published>
    <updated>2015-09-17T01:51:47.000Z</updated>
    <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 Android 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="external">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/iOS-skills" target="_blank" rel="external">iOS 技能</a>请猛戳这里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/Android-skills.png" alt="Android 技能树"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是和团队小伙伴们一起整理的 Android 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_]]>
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习路线" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="技能" scheme="http://yoursite.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="进阶" scheme="http://yoursite.com/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Are you trying to connect to a TLS-enabled daemon without TLS？]]></title>
    <link href="http://yoursite.com/faq/docker-trying-to-connect-to-a-tls-enabled-daemon-without-tls/"/>
    <id>http://yoursite.com/faq/docker-trying-to-connect-to-a-tls-enabled-daemon-without-tls/</id>
    <published>2015-09-16T08:34:00.000Z</published>
    <updated>2015-09-16T09:54:26.000Z</updated>
    <content type="html"><![CDATA[<p>在 Mac 上通过 boot2docker 启动 docker 时，运行 docker 命令出现下面的提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post http:///var/run/docker.sock/v1.19/containers/<span class="operator"><span class="keyword">create</span>: dial unix /<span class="keyword">var</span>/run/docker.sock: <span class="keyword">no</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span>. </span><br><span class="line"><span class="keyword">Are</span> you trying <span class="keyword">to</span> <span class="keyword">connect</span> <span class="keyword">to</span> a TLS-enabled daemon <span class="keyword">without</span> TLS?</span></span><br></pre></td></tr></table></figure>
<p>这时候需要重启 boot2docker：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">boot2docker </span>stop</span><br><span class="line">$ <span class="keyword">boot2docker </span>start</span><br></pre></td></tr></table></figure>
<p>然后根据提示设置变量，如下图：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/mac-docker-tls.png" alt="在 Mac 上通过 boot2docker 启动 docker 时异常"></p>
<p>OK，最后在终端中输入：<code>docker version</code> 验证是否成功。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Mac 上通过 boot2docker 启动 docker 时，运行 docker 命令出现下面的提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="]]>
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
      <category term="boot2docker" scheme="http://yoursite.com/tags/boot2docker/"/>
    
      <category term="FAQ" scheme="http://yoursite.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X 上 使用 Docker 安装 Hexo]]></title>
    <link href="http://yoursite.com/hexo-your-blog/dockerize-hexo-on-mac/"/>
    <id>http://yoursite.com/hexo-your-blog/dockerize-hexo-on-mac/</id>
    <published>2015-09-10T06:57:42.000Z</published>
    <updated>2015-09-16T09:54:01.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇中介绍如何在 Mac OS X 上使用 Docker 来安装 Hexo。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇中介绍如何在 Mac OS X 上使用 Docker 来安装 Hexo。</p>
</blockquote>
]]>
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="个人" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X 上 Hexo 安装]]></title>
    <link href="http://yoursite.com/hexo-your-blog/install-hexo-on-mac/"/>
    <id>http://yoursite.com/hexo-your-blog/install-hexo-on-mac/</id>
    <published>2015-09-10T06:38:20.000Z</published>
    <updated>2015-09-19T07:34:14.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章描述 Mac OS X 环境下的 Hexo 安装，其他的系统环境安装略有不同。可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<h2 id="安装前提">安装前提</h2><p>Hexo 依赖于 Node.js 及 Git，故在安装 Hexo 前必须检查并安装 Node.js 及 Git。</p>
<h3 id="安装_Git">安装 Git</h3><p>安装 Git 的方法也是多种多样，这边简单提一下，大家可以寻着这些思路来自己完成 Git 的安装。</p>
<p><strong>方案一、</strong>通过 Xcode 来安装 Git</p>
<ol>
<li>从 AppStore 下载 Xcode。</li>
<li>打开 Xcode -&gt; Preferences 点击下载选项，下载 Command Line Tools 安装。</li>
</ol>
<p><strong>方案二、</strong>安装 SourceTree 等客户端。</p>
<p><strong>方案三、</strong>通过 <a href="http://code.google.com/p/git-osx-installer/" target="_blank" rel="external">git-osx-installer</a> 安装。</p>
<p>安装完成以后，在终端中输入 <code>git --version</code> 查看 Git 版本，来确认是否安装成功。</p>
<blockquote>
<p>在开始 Git 的使用之前，需要有一些公共的参数配置，如 username， email 等。这些不在本文讨论范围。</p>
</blockquote>
<h3 id="安装_Node-js">安装 Node.js</h3><p>node.js 的安装也是方法多样，这里简单提下思路。</p>
<p><strong>方案一、</strong><a href="https://nodejs.org/en/download/" target="_blank" rel="external">官方</a>的 .pkg 文件安装，个人觉得是最方便的。</p>
<p><strong>方案二、</strong>下载 <a href="https://github.com/nodejs/node" target="_blank" rel="external">node.js 源码</a>，自己编译。</p>
<p><strong>方案三、</strong>通过 Homebrew 安装。</p>
<p><strong>方案四、</strong>通过 nvm 安装。</p>
<h3 id="安装_Hexo">安装 Hexo</h3><p>所有必备的应用程序安装完以后，就可用 npm 安装 Hexo 了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -<span class="keyword">g</span> hexo-<span class="keyword">cli</span>		<span class="comment">// 安装 Hexo 程序</span></span><br><span class="line">$ <span class="keyword">mkdir</span> blog					<span class="comment">// 新建博客目录</span></span><br><span class="line">$ <span class="keyword">cd</span> blog						<span class="comment">// 到博客目录下</span></span><br><span class="line">$ hexo init						<span class="comment">// 初始化 Hexo 博客目录</span></span><br><span class="line">$ npm install 					<span class="comment">// 安装依赖和插件</span></span><br><span class="line">$ hexo s						<span class="comment">// 启动服务器在本地进行预览</span></span><br></pre></td></tr></table></figure>
<p>在浏览器中打开 <code>http://localhost:4000</code>，看到博客首页的话，至此安装就完成了。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/hexo-preview.png" alt="hexo 预览"></p>
<blockquote>
<p>为了说明问题，上面的截图是后面补的。 </p>
</blockquote>
<p>这节也比较简单，也可以查看<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官网</a>的对应章节。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇文章描述 Mac OS X 环境下的 Hexo 安装，其他的系统环境安装略有不同。可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a>]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="个人" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 简介]]></title>
    <link href="http://yoursite.com/hexo-your-blog/hexo-introduce/"/>
    <id>http://yoursite.com/hexo-your-blog/hexo-introduce/</id>
    <published>2015-09-10T03:10:20.000Z</published>
    <updated>2015-09-10T06:26:31.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章是<a href="http://www.linfuyan.com/hexo-your-blog" target="_blank" rel="external">《一步一步打造自己的 Hexo 博客》</a>系列的开篇，为了让这篇《 Hexo 简介》看上去足够充实，当然会有许多的内容来源于网络，甚至有的我也以找不到出处或者考证其真实性。这里想稍稍补充一下自己寻找博客，并最终落脚 Hexo 之旅。</p>
<p>我想很多技术人员都会有写一些博客的想法，而最初我曾尝试过在 CSDN，JavaEye(现在已经是 ItEye 了，不小心暴露年龄)，但实在难以忍受的是上面的排版，当然还有网络时快时慢等等，写文章之外需要忍受其他许许多多的不痛快。虽然这也只是我没有写技术博客的原因之一，但没有坚持下来却是实实在在的事情了。</p>
<p>后来继续开始写一些东西，是在我发现了 Markdown 这个好东西，10分钟内入门，不用再手动选择插入图片、链接，不用再选中斜体、加粗，不用选字号… 我想我是一个极懒的人。现在，我只需要打开 Mou，一路写下来，轻巧方便，再也不用担心烦杂的操作，不用担心联网的问题了。</p>
<p>有了 Markdown，我便开始寻找能够支持 Markdown 的博客， Wordpress、Typecho… Markdown 是支持的，但却要么庞大、要么不尽如人意(写完文章以后，需要手动再复制粘贴到内容编辑器里面保存等)。直到 Github Pages，再到现在的 Hexo，当 Hexo 搭建，并配置完成以后，再写文章、发布，就是本地的一条命令了，简直再方便不过。</p>
<a id="more"></a>
<p>说了这么多，回到 Hexo 介绍上来，这些摘自 <a href="https://hexo.io" target="_blank" rel="external">Hexo 官网</a>。</p>
<h2 id="什么是_Hexo？">什么是 Hexo？</h2><blockquote>
<h3 id="快速、简洁且高效的博客框架">快速、简洁且高效的博客框架</h3></blockquote>
<h2 id="Hexo_有什么优势？">Hexo 有什么优势？</h2><blockquote>
<h4 id="超快速度">超快速度</h4><p>Node.js 所带来的超快生成速度，让上百个页面在几秒瞬间完成渲染。</p>
<h4 id="支持_Markdown">支持 Markdown</h4><p>Hexo 支持 Github Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
<h4 id="一键部署">一键部署</h4><p>只需一条指令即可部署到 Github Pages，Heroku 或者其他网站。</p>
<h4 id="丰富的插件">丰富的插件</h4><p>Hexo 用用强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。</p>
</blockquote>
<h2 id="Hexo_适合谁？">Hexo 适合谁？</h2><p>这是一个免费开源的博客程序，任何人都可以使用和修改。但是不同于 Wordpress，Hexo 由于需要使用Github, Git, Markdown, Node.js 这样的工具，好多插件、widget 都需要自己安装、设置。所以适合那些有一定计算机基础，喜欢折腾的人。但是，不要恐惧，只要跟着本教程走，就能很方便地让自己的博客飞起来。<a href="http://zipperary.com/2013/05/28/Hexo-guide-1/" target="_blank" rel="external">摘自：Hexo系列教程：（一）Hexo介绍</a></p>
<p>好吧，这篇就写到这里。想了解关于 Hexo 的更多，不方便找谷歌，就度娘就是啦。后面我们将开始自己的 Hexo 博客打造之旅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章是<a href="http://www.linfuyan.com/hexo-your-blog">《一步一步打造自己的 Hexo 博客》</a>系列的开篇，为了让这篇《 Hexo 简介》看上去足够充实，当然会有许多的内容来源于网络，甚至有的我也以找不到出处或者考证其真实性。这里想稍稍补充一下自己寻找博客，并最终落脚 Hexo 之旅。</p>
<p>我想很多技术人员都会有写一些博客的想法，而最初我曾尝试过在 CSDN，JavaEye(现在已经是 ItEye 了，不小心暴露年龄)，但实在难以忍受的是上面的排版，当然还有网络时快时慢等等，写文章之外需要忍受其他许许多多的不痛快。虽然这也只是我没有写技术博客的原因之一，但没有坚持下来却是实实在在的事情了。</p>
<p>后来继续开始写一些东西，是在我发现了 Markdown 这个好东西，10分钟内入门，不用再手动选择插入图片、链接，不用再选中斜体、加粗，不用选字号… 我想我是一个极懒的人。现在，我只需要打开 Mou，一路写下来，轻巧方便，再也不用担心烦杂的操作，不用担心联网的问题了。</p>
<p>有了 Markdown，我便开始寻找能够支持 Markdown 的博客， Wordpress、Typecho… Markdown 是支持的，但却要么庞大、要么不尽如人意(写完文章以后，需要手动再复制粘贴到内容编辑器里面保存等)。直到 Github Pages，再到现在的 Hexo，当 Hexo 搭建，并配置完成以后，再写文章、发布，就是本地的一条命令了，简直再方便不过。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="个人" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 开发者证书制作、App ID 与推送配置及 Provisioning Profiles 创建]]></title>
    <link href="http://yoursite.com/ios-cer-appid-push-profile/"/>
    <id>http://yoursite.com/ios-cer-appid-push-profile/</id>
    <published>2015-09-08T13:59:00.000Z</published>
    <updated>2015-09-08T14:10:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>1. <strong>开发者证书</strong></p>
<p>分为开发和发布两种，类型为 <code>iPhone Development</code>， <code>iPhone Distribution</code>。这个是最基础的，开发证书用于真机调试，发布证书则用于上传到 AppStore，是一个基础证书，用来证明开发者身份。</p>
<p>2. <strong>App ID</strong></p>
<p>这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了 PassBook，GameCenter，以及更为场景的 push 服务。如果选中了 push 服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的 App ID。</p>
<p>3. <strong>推送证书</strong></p>
<p>分为开发和发布两种，类型分别为 <code>Apple Development iOS Push Services</code>， <code>Apple Production iOS Push Services</code>，该证书在 App ID 配置中创建生成，和开发者证书一样，放在服务端程序上。</p>
<p>4. <strong>Provisioning Porfiles</strong></p>
<p>在后续部分中，简称为 profile 文件。该文件将 App ID，开发者证书，硬件绑定在一起。在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在 profile 文件中添加真机的 <code>udid</code>，是真机调试和上架 AppStore 所必需的。</p>
<a id="more"></a>
<p>平常我们的制作流程一般都是按照这样的顺序：</p>
<ol>
<li>利用开发者账号登录开发者中心</li>
<li>创建开发者证书、App ID</li>
<li>在 App ID 中开通推送服务</li>
<li>在开通推送服务的选项下面创建推送证书</li>
<li>之后在 profile 文件中绑定所有的证书ID，添加调试真机等</li>
</ol>
<h2 id="制作开发者证书">制作开发者证书</h2><p>要制作开发者证书，首先登录开发者中心，找到证书配置版块，点击证书，显示如下页面：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS_cer_list.png" alt="开发者证书列表"></p>
<p>点击右上角加号，进入创建页面：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS_cer_create.png" alt="开发者证书创建"></p>
<p>创建开发证书和发布证书步骤是一样的，开发证书用于真机调试，发布证书用于提交到 AppStore，这里以开发证书的制作为例。</p>
<p>选择 “iOS App Development” 选项，点击下方的继续按钮，提示需要创建证书签名请求( CSR )。</p>
<h3 id="手动创建证书签名请求(_CSR_)">手动创建证书签名请求( CSR )</h3><p>在 Mac 上的应用程序文件夹中，打开钥匙串访问。</p>
<p>在钥匙串访问的下拉菜单中，选择 “钥匙串访问” &gt; “证书助理” &gt; “从证书颁发机构请求证书…”。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_1.png" alt="创建 CSR"></p>
<ul>
<li><p>在”证书助理”窗口，输入如下信息：</p>
<ul>
<li>在用户邮箱地址中，输入邮箱地址。</li>
<li>常用名称中，输入私钥的名称。</li>
<li>保留 CA 点子邮件地址为空。</li>
<li>在请求选项组中，选中”存储到磁盘”</li>
</ul>
</li>
<li><p>点击”继续”完成 CSR 的创建。</p>
</li>
</ul>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_2.png" alt="创建 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_3.png" alt="创建 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_4.png" alt="创建 CSR"></p>
<blockquote>
<p>CSR 文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字，之后在开发者中心将该 CSR 文件提交。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_5.png" alt="上传 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_6.png" alt="生成 cer"></p>
<p>上传 CSR 到开发者中心，就会生成开发者证书。将开发者证书下载保存，双击安装。可以在钥匙串访问的登录证书中可以查看，其中专用密钥的名字即为 CSR 请求文件中的常用名称。同样的方法可以配置发布证书。</p>
<blockquote>
<p>在生成不同的证书的时候可以上传同一个 CSR 文件。(这边似乎不会有什么影响?)</p>
</blockquote>
<h2 id="App_ID_与推送证书配置">App ID 与推送证书配置</h2><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/app_id.png" alt="App ID 版块"></p>
<p>进入 App ID 版块，点击右上角的加号，添加新的应用：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_1.png" alt="创建 App ID"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_2.png" alt="创建 App ID"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_3.png" alt="创建 App ID"></p>
<p>新建 App ID 时，勾选 push 可选项，为该 App ID 所对应的应用添加推送功能，。</p>
<p>新应用添加完毕，选择该应用进行编辑，此时其中的 <code>Push Notifications</code> 为可配置的。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_4.png" alt="创建 App ID"></p>
<p>根据上一节中”制作开发者证书”的步骤，完成上图中证书的创建，然后下载保存，并双击安装。</p>
<blockquote>
<p>虽然在创建证书版块也可以直接创建推送证书，但是还是建议在 App ID 中勾选 push 服务后再在此处创建，这样可以避免因为忘了开通 push 服务而导致推送不可用的情况发生。</p>
</blockquote>
<h2 id="创建_profile_文件">创建 profile 文件</h2><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_1.png" alt="创建 profiles"></p>
<p>打开 provisioning profiles 版块，点击右上角加号创建 profile 文件。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_2.png" alt="创建 profiles"></p>
<p>可以选择开发、发布及 Ad Hoc 三种 profile 文件。开发 profile 文件用于真机测试，发布 profile 文件则用于提交发布。Ad Hoc 这里暂不讨论。</p>
<p>会自动选择匹配的 App ID。另外下拉项中还可以选择 wildCard 格式，该格式为自动生成，使用 * 通配符，适用于批量的，没有推送，PassCard 等服务的应用；我们选择我们刚刚创建的 App ID, 之后下一步选择证书：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_3.png" alt="创建 profiles"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_4.png" alt="创建 profiles"></p>
<p>继续，这里有一个区别，因为开发 profile 文件用于真机调试，所以我们需要绑定真机。由于之前已经有添加过设备，所以这里直接全选添加。如果没有的话，需要将真机的 udid 复制出来在此添加。发布 profile 文件则没有这一步。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_5.png" alt="创建 profiles"></p>
<p>填写 profile 文件名称，点击生成：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_6.png" alt="创建 profiles"></p>
<p>最终生成 .mobileprovision 文件，可以点击下载保存。双击安装。</p>
<p>在 Xcode 中可以看到效果如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_7.png" alt="创建 profiles"></p>
<p>到这里为止，iOS 开发者证书的制作，配置 App ID 和推送证书，以及 profile 文件的创建就都完成了。</p>
<p>本文根据 <a href="http://blog.csdn.net/holydancer/article/details/9219333" target="_blank" rel="external">《苹果所有常用证书，appID,Provisioning Profiles配置说明及制作图文教程（精）》</a> 进行整理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>1. <strong>开发者证书</strong></p>
<p>分为开发和发布两种，类型为 <code>iPhone Development</code>， <code>iPhone Distribution</code>。这个是最基础的，开发证书用于真机调试，发布证书则用于上传到 AppStore，是一个基础证书，用来证明开发者身份。</p>
<p>2. <strong>App ID</strong></p>
<p>这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了 PassBook，GameCenter，以及更为场景的 push 服务。如果选中了 push 服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的 App ID。</p>
<p>3. <strong>推送证书</strong></p>
<p>分为开发和发布两种，类型分别为 <code>Apple Development iOS Push Services</code>， <code>Apple Production iOS Push Services</code>，该证书在 App ID 配置中创建生成，和开发者证书一样，放在服务端程序上。</p>
<p>4. <strong>Provisioning Porfiles</strong></p>
<p>在后续部分中，简称为 profile 文件。该文件将 App ID，开发者证书，硬件绑定在一起。在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在 profile 文件中添加真机的 <code>udid</code>，是真机调试和上架 AppStore 所必需的。</p>]]>
    
    </summary>
    
      <category term="App ID" scheme="http://yoursite.com/tags/App-ID/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="profile" scheme="http://yoursite.com/tags/profile/"/>
    
      <category term="provision" scheme="http://yoursite.com/tags/provision/"/>
    
      <category term="push" scheme="http://yoursite.com/tags/push/"/>
    
      <category term="图文教程" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/"/>
    
      <category term="开发者证书" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveX 之 Operator]]></title>
    <link href="http://yoursite.com/reactivex-operator/"/>
    <id>http://yoursite.com/reactivex-operator/</id>
    <published>2015-09-07T13:24:44.000Z</published>
    <updated>2015-09-07T13:29:12.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">http://reactivex.io/documentation/operators.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
<p>更新历史：1月13日</p>
</blockquote>
<p>每个特定语言版本的响应式扩展实现了一套具体的操作集合。虽然有一些重叠，依然有一些操作只在特定的版本中实现，并且每种语言趋向于将相似的操作命名成其他语言中已经为大家所熟悉的名称。</p>
<p>这篇文章列举出响应式扩展集合中被认为核心的操作，并链接到更多说明的页面上。这些页面将解释这些操作如何工作，哪些特定版本的响应式扩展又是怎样实现这些操作。</p>
<a id="more"></a>
<h2 id="创建Observable">创建<em>Observable</em></h2><p>创建新的<em>Observable</em>的<em>Operator</em>。</p>
<ul>
<li><code>Create</code> - 通过编程方式调用<em>observer</em>的方法，从零创建<em>Observable</em></li>
<li><code>Defer</code> - 直到<em>observer</em>订阅，为每个<em>observer</em>创建全新的<em>Observable</em></li>
<li><code>Empty/Never/Throw</code> - 创建具有精确与有限行为的<em>Observable</em></li>
<li><code>From</code> - 转化其他对象或者数据结构为<em>Observable</em></li>
<li><code>Interval</code> - 创建产生整型数序列的<em>Observable</em>，序列元素间的间隔为interval</li>
<li><code>Just</code> - 转化对象或者对象的集合成为<em>Observable</em>，且<em>Observable</em>产生的值为这些对象或是对象的集合</li>
<li><code>Range</code> - 创建一个可以产生整型数序列区间的<em>Observable</em></li>
<li><code>Repeat</code> - 创建可以重复产生特殊项或项目序列的<em>Observable</em></li>
<li><code>Start</code> - 创建产生函数返回值的<em>Observable</em></li>
<li><code>Timer</code> - 创建一段给定时间以后产生单一项的<em>Observable</em></li>
</ul>
<h2 id="变换Observable">变换<em>Observable</em></h2><p>变换<em>Observable</em>产生的项的<em>Operator</em>。</p>
<ul>
<li><code>Buffer</code> - 周期性的收集<em>Observable</em>中的项放入bundle中，并产生这些bundle而不是一次性产生这些项</li>
<li><code>FlatMap</code> - 将<em>Observable</em>所产生的多个项目变换为多个<em>Observable</em>，然后将这些<em>Observable</em>的产生值拉平为一个<em>Observable</em></li>
<li><code>GroupBy</code> - 将<em>Observable</em>分隔为<em>Observable</em>的集合，这些新的<em>Observable</em>通过key来对原来的<em>Observable</em>组织成不同的项的组</li>
<li><code>Map</code> - 将<em>Observable</em>产生的每个项应用函数变换映射</li>
<li><code>Scan</code> - 对<em>Observable</em>产生的每个项进行函数变换，有序的产生成功的值</li>
<li><code>Window</code> - 周期性的将<em>Observable</em>产生的项进行分隔成子集，放入<em>Observable window</em>，并产生这些<em>window</em>而不是一次性产生这些项</li>
</ul>
<h2 id="过滤Observable">过滤<em>Observable</em></h2><p>选择性的从源<em>Observable</em>中产生项的<em>Operator</em>。</p>
<ul>
<li><code>Debounce</code> - 在一段特定的时间之内从<em>Observable</em>中只产生一个项</li>
<li><code>Distinct</code> - 过滤掉<em>Observable</em>中产生的重复的项</li>
<li><code>ElementAt</code> - 从<em>Observable</em>中拿到第N个项</li>
<li><code>Filter</code> - 从<em>Observable</em>中产生符合预设条件的项</li>
<li><code>First</code> - 从<em>Observable</em>中产生第一个项或者产生符合条件的第一个项</li>
<li><code>IgnoreElements</code> - 直到结束是通知，否则忽略<em>Observable</em>产生的所有项</li>
<li><code>Last</code> - 产生<em>Observable</em>中的最后一项</li>
<li><code>Sample</code> - 在特定的时间间隔内从<em>Observable</em>产生最近的项</li>
<li><code>Skip</code> - 跳过<em>Observable</em>产生的前n个项</li>
<li><code>SkipLast</code> - 跳过<em>Observable</em>产生的最后n个项</li>
<li><code>Take</code> - 产生<em>Observable</em>产生的前n个项</li>
<li><code>TakeLast</code> - 产生<em>Observable</em>产生的最后n个项</li>
</ul>
<h2 id="组合Observable">组合<em>Observable</em></h2><p>操作多个源<em>Observable</em>来创建新的<em>Observable</em>的<em>Operator</em></p>
<ul>
<li><code>And/Then/When</code> - 以<code>Pattern</code>和<code>Plan</code>的形式，组合两个或多个<em>Observable</em>产生的项集</li>
<li><code>CombineLatest</code> - 不论两个<em>Observable</em>中产生了项，通过特定的函数来组合每个<em>Observable</em>中的最后一项，并产生他们的结果</li>
<li><code>Join</code> - </li>
<li><code>Merge</code> -</li>
<li><code>StartWith</code> - </li>
<li><code>Switch</code> - </li>
<li><code>Zip</code> - 通过特定的函数将多个<em>Observable</em>的产生项组合成单一项，每个组合依赖于函数结果。</li>
</ul>
<h2 id="错误处理Operator">错误处理<em>Operator</em></h2><p>帮助从<em>Observable</em>错误通知中修复的<em>Operator</em></p>
<ul>
<li><code>Catch</code> - 通过没有错误的继续产生序列来从<code>onError</code>通知中修复</li>
<li><code>Retry</code> - 如果源<em>Observable</em>发送了<code>onError</code>通知，重新订阅它并期待它可以没有错误的完成</li>
</ul>
<h2 id="Observable工具集Operator"><em>Observable</em>工具集<em>Operator</em></h2><p>一系列操作<em>Observable</em>的有用的工具箱<em>Operator</em></p>
<ul>
<li><code>Delay</code> - 将<em>Observable</em>产生项延迟一个特定的时间</li>
<li><code>Do</code> - 注册一个动作来响应<em>Observable</em>的生命周期事件</li>
<li><code>Materialize/Dematerialize</code> - 将产生的项或者发出的通知看成产生项，或者逆转这个过程</li>
<li><code>ObserveOn</code> - 明确<em>Observer</em>观察<em>Observable</em>所在的<em>Scheduler</em></li>
<li><code>SubscribeOn</code> - 明确<em>Observable</em>被订阅后所使用的<em>Scheduler</em></li>
<li><code>TimeInterval</code> - 将产生项的<em>Observable</em>转化为这些项之间产生的时间间隔</li>
<li><code>Timeout</code> - 镜像源<em>Observable</em>，并在特定的时间范围内没有项产生时发出错误通知</li>
<li><code>Timestamp</code> - 给每个<em>Observable</em>产生项附加时间戳</li>
<li><code>Using</code> - 创建一个与<em>Observable</em>具有相同寿命的一次性资源</li>
</ul>
<h2 id="条件和布尔Operator">条件和布尔<em>Operator</em></h2><p>评估一个或多个<em>Observable</em>或<em>Observable</em>产生的项</p>
<ul>
<li><code>All</code> - 确定是否所有的<em>Observable</em>产生项符合标准</li>
<li><code>Amb</code> - 有两个或者多个源<em>Observable</em>，只对其中的第一个<em>Observable</em>产生其项</li>
<li><code>Contains</code> - 确定<em>Observable</em>是否包含一个特殊的项</li>
<li><code>DefaultIfEmpty</code> - 从源<em>Observable</em>产生项，如果为空，则产生默认项</li>
<li><code>SequenceEqual</code> - 确定是否两个<em>Observable</em>产生同样的项序列</li>
<li><code>SkipUntil</code> - 丢弃一个<em>Observable</em>所有的产生项，直到第二个<em>Observable</em>产生了项</li>
<li><code>SkipWhile</code> - 丢弃一个<em>Observable</em>所有产生项，直到某个特定条件不成立</li>
<li><code>TakeUntil</code> - 当第二个<em>Observable</em>产生了项，第一个<em>Observable</em>丢弃所有的产生项</li>
<li><code>TakeWhile</code> - 当某个特定条件不成立，<em>Observable</em>丢弃所有的产生项</li>
</ul>
<h2 id="数学与聚合Operator">数学与聚合<em>Operator</em></h2><p>操作<em>Observable</em>所有产生项的序列的<em>Operator</em></p>
<ul>
<li><code>Average</code> - 计算<em>Observable</em>所有产生项的平均值，并产生这个平均值</li>
<li><code>Concat</code> - 拼接两个或者多个<em>Observable</em></li>
<li><code>Count</code> - 计算源<em>Observable</em>产生的项的个数，并产生这个值</li>
<li><code>Max</code> - 确定并产生<em>Observable</em>产生值中的最大值</li>
<li><code>Min</code> - 确定并产生<em>Observable</em>产生值中的最小值</li>
<li><code>Reduce</code> - 对<em>Observable</em>产生的每个项应用函数变换，并且有序的产生最终变换结果</li>
<li><code>Sum</code> - 计算<em>Observable</em>所有产生项的和，并产生这个和的值</li>
</ul>
<h2 id="Connectable_Observable_Operator"><em>Connectable Observable Operator</em></h2><p>特殊的<em>Observable</em>具有更多的动态的精确控制的订阅方式。</p>
<ul>
<li><code>Connect</code> - 指示一个可连接的<em>Observable</em>开始产生项到它的订阅者</li>
<li><code>Publish</code> - 转化一个普通的<em>Observable</em>为一个可连接的<em>Observable</em></li>
<li><code>RefCount</code> - 使一个可链接的<em>Observable</em>的行为跟普通的<em>Observable</em>一样</li>
<li><code>Replay</code> - 确保所有观察者看到的产生项序列一样，即使它们在<em>Observable</em>产生项以后才订阅</li>
</ul>
<h2 id="Blocking_Observable_Operator"><em>Blocking Observable Operator</em></h2><ul>
<li><code>To</code> - 将<em>Observable</em>转化为其他对象或者数据结构</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
<p>更新历史：1月13日</p>
</blockquote>
<p>每个特定语言版本的响应式扩展实现了一套具体的操作集合。虽然有一些重叠，依然有一些操作只在特定的版本中实现，并且每种语言趋向于将相似的操作命名成其他语言中已经为大家所熟悉的名称。</p>
<p>这篇文章列举出响应式扩展集合中被认为核心的操作，并链接到更多说明的页面上。这些页面将解释这些操作如何工作，哪些特定版本的响应式扩展又是怎样实现这些操作。</p>]]>
    
    </summary>
    
      <category term="Operator" scheme="http://yoursite.com/tags/Operator/"/>
    
      <category term="frp" scheme="http://yoursite.com/tags/frp/"/>
    
      <category term="reactivex" scheme="http://yoursite.com/tags/reactivex/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/tags/rxjava/"/>
    
      <category term="响应式编程" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/rxjava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveX 之 Observable]]></title>
    <link href="http://yoursite.com/reactivex-observable/"/>
    <id>http://yoursite.com/reactivex-observable/</id>
    <published>2015-09-07T13:06:12.000Z</published>
    <updated>2015-09-07T13:12:42.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">http://reactivex.io/documentation/observable.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
<p>更新历史：1月13日</p>
</blockquote>
<p>在RxJava中一个对象实现了<em>Observer</em>接口则被一个<em>Observable</em>类对象所订阅。订阅者则针对<em>Obserable</em>对象产生的值（包括项及项的序列）做响应。这种模式便利了异步操作，因为不用在等待<em>Obserable</em>产生对象时进行阻塞，它以订阅者的形式创建了一个哨兵，用于在<em>Observable</em>在将来的时间产生任何输出时提供合适的响应。</p>
<p>这篇文章解释什么是响应式模式以及什么是<em>Observable</em>与观察者(观察者怎样对<em>Observable</em>进行订阅)。</p>
<blockquote>
<p>文档中的解释将采用”marble diagrams”的形式。下图说明”marble diagrams”怎样展示<em>Observable</em>以及<em>Observable</em>之间的转换。</p>
<p><img src="http://reactivex.io/assets/operators/legend.png" alt="Observables"></p>
</blockquote>
<a id="more"></a>
<h1 id="背景">背景</h1><p>在许多软件编程任务中，你或多或少都希望自己编写的代码能够逐步的运行完成，因为你是一个一个的写下来的。但是在响应式编程范式中，许多代码并行的执行，其结果将在后来被观察者以任意的顺序捕获下来。在这种情况下，你不是调用一个方法，而是以<em>Observable</em>的形式为获取和转换数据定义一种机制，并将<em>Observable</em>订阅给订阅者。在预置的机制下当<em>Observable</em>产生的值到达时，观察者的哨兵捕获并对此进行响应。</p>
<p>这种解决方案的优点在于，当你有许多没有相互依赖的任务需要运行时，你可以在同一时刻启动它们，而不是需要在一个任务开始之前，等待其中的一个任务的结束。这样，你执行所有任务的所花费的时间只是其中耗时最长的任务的时间。</p>
<p>有许多种形式来描述这种异步编程和设计的模型。这篇文档将使用下面的形式：<em>Subscriber</em>(有时是<em>Observer</em>)订阅<em>Observable</em>类对象。也就是<em>Subscriber</em>对象订阅<em>Observable</em>。<em>Observable</em>产生值，并通过调用<em>Subscriber</em>的方法来发送通知给<em>Subscriber</em>。</p>
<p>在其他文档或者上下文，有时我们也会将<em>Subscriber</em>称为<em>watcher</em>或<em>reactor</em>。这个模型通常被被认为是<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="external">响应模式</a>。</p>
<h1 id="建立订阅者">建立订阅者</h1><p>这篇文档通常使用Groovy来做代码示例，实际上，你可以在任何基于JVM的语言上使用RxJava，如Clojure，Scala，JRuby或是Java本身。</p>
<p>与典型的响应式编程中无序的异步、并行不同，在传统的方法调用中，流程一般是这样的：</p>
<ol>
<li>调用一个方法。</li>
<li>将方法的返回值保存在一个变量中。</li>
<li>使用这个变量以及它的新值做一些有用的事情。</li>
</ol>
<p>或是用代码表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// make the <span class="operator"><span class="keyword">call</span>, assign its <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">to</span> <span class="string">`returnVal`</span></span><br><span class="line">returnVal = someMethod(itsParameters);</span></span><br><span class="line">// <span class="operator"><span class="keyword">do</span> something useful <span class="keyword">with</span> returnVal</span></span><br></pre></td></tr></table></figure>
<p>在异步模型中，流程则更像是这样：</p>
<ol>
<li>定义一个方法来使用异步调用的返回值进行处理，这个方法是<em>Subscriber</em>的一部分。</li>
<li>用一个<em>Observable</em>类对象来定义异步调用本身。</li>
<li>通过订阅来将<em>Subscriber</em>关联<em>Observable</em>(这也同时初始化方法调用)。</li>
<li>继续你的业务逻辑；无论方法调用何时返回，<em>Subscriber</em>的方法开始对<em>Observable</em>所产生的项(返回值)进行操作。</li>
</ol>
<p>用代码表示是这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defines, but does not invoke, the Subscriber's onNext handler</span></span><br><span class="line"><span class="comment">// (in this example, the Subscriber is very simple and has only an onNext handler)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myOnNext</span> =</span> &#123; it -&gt; do something useful <span class="keyword">with</span> it &#125;;</span><br><span class="line"><span class="comment">// defines, but does not invoke, the Observable</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myObservable</span> =</span> someObservable(itsParameters);</span><br><span class="line"><span class="comment">// subscribes the Subscriber to the Observable, and invokes the Observable</span></span><br><span class="line">myObservable.subscribe(myOnNext);</span><br><span class="line"><span class="comment">// go on about my business</span></span><br></pre></td></tr></table></figure>
<h1 id="onNext,onCompleted,以及onError">onNext,onCompleted,以及onError</h1><p><code>subscribe()</code>方法可以接受1-3个方法，或者是一个<code>Subscriber</code>对象，或是任何实现了<code>Observer</code>接口（包含了这3个方法）的对象：</p>
<p><strong>onNext</strong>:当<em>Observable</em>产生了一个值时，<em>Observable</em>将调用它的<em>Subscriber</em>上的这个方法。这个方法将<em>Observable</em>所产生的值作为它的参数。</p>
<p><strong>onError</strong>:当<em>Observable</em>无法产生所预期的数据或是遇到了其他一些错误，<em>Observable</em>将调用它的<em>Subscriber</em>上的这个方法。这会使<em>Observable</em>停止，且不再掉调用<code>onNext</code>和<code>onCompleted</code>。<code>onError</code>将产生错误的误差指示作为它的参数。</p>
<p><strong>onCompleted</strong>:在没有发生任何错误的情形下，<em>Observable</em>将在最后一次调用<code>onNext</code>之后调用其观察者的这个方法。</p>
<p>一个更加完整的<code>subscribe()</code>示例如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myOnNext</span>     =</span> &#123; item -&gt; <span class="comment">/* do something useful with item */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myError</span>      =</span> &#123; throwable -&gt; <span class="comment">/* react sensibly to a failed call */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myComplete</span>   =</span> &#123; <span class="comment">/* clean up after the final response */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myObservable</span> =</span> someMethod(itsParameters);</span><br><span class="line">myObservable.subscribe(myOnNext, myError, myComplete);</span><br><span class="line"><span class="comment">// go on about my business</span></span><br></pre></td></tr></table></figure>
<h1 id="Unsubscribing(退订)">Unsubscribing(退订)</h1><p>在一些响应式扩展实现中，有专门的观察者接口，<code>Subscriber</code>来实现<code>unsubscribe()</code>方法。你可以调用这个方法来表明<em>Subscriber</em>不再对当前订阅的任何<em>Observable</em>感兴趣了。当不再有其他对其感兴趣的<em>Observer</em>，这些<em>Observable</em>可以选择停止产生新的值。</p>
<p>这个退订的结果会级联的影响到<em>Observer</em>所订阅的<em>Observable</em>上的操作链，这将导致操作链上的每个链接都停止产生项目。但这个并无法保证立即发生，当不再有<em>Subscriber</em>关注这些产生的值时，在短时间内，<em>Observable</em>可能仍然会产生新的值。</p>
<h1 id="命名规范的注意事项">命名规范的注意事项</h1><p>每一种特定语言的响应式扩展的实现都有自己的命名怪癖。这之间没有统一的命名标准，但在每个实现之间有许多的共性。</p>
<p>此外，在某些上下文中这些名称具有不同的含义，或者在一些特定的语言实现中显得尴尬。</p>
<p>举个例子：存在<code>onEvent</code>的命名模式(如：<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>)。在许多上下文中，这些命名表明的是被注册的事件处理器上的方法。在<em>ReactiveX</em>中，这些命名则表示事件处理器本身。</p>
<h1 id="“热”和”冷”Observable">“热”和”冷”<em>Observable</em></h1><p><em>Observable</em>什么时候开始产生它的值序列呢？这个依赖于<em>Observable</em>。一个”热”的<em>Observable</em>将在它被新建之后便开始产生值，因此，任何订阅这种<em>Observable</em>的<em>Observer</em>将从这些序列的中间开始观察。另一方面，一个”冷”的<em>Observable</em>在开发产生值之前，会一直等待<em>Observer</em>订阅它。这样可以保证一个<em>Observer</em>看到从头开始的完整序列。</p>
<p>在响应式扩展的某些实现中，存在称为<em>Connectable</em>的<em>Observable</em>。这样的<em>Observable</em>直到它的<code>connect</code>方法被调用才开始产生值，不能是否有<em>Observer</em>已经订阅它。</p>
<h1 id="组装Observable_Operator">组装<em>Observable Operator</em></h1><p><em>Observable</em>和<em>Observer</em>仅仅是响应式扩展的开始。它是标准观察者模式的轻量扩展，比起一个简单的回调，它更适合与处理事件序列。</p>
<p>响应式扩展的真正力量在于，所有的<em>Operator</em>可以被变换，组合，操作，并和<em>Observable</em>所产生的值序列一起工作。</p>
<p>这些响应式扩展操作能让你通过利用所有回调的优点，以声明的方式将异步序列组织在一起。同时避免传统异步编程系统中的嵌套回调处理。</p>
<p>该文章将不同的操作及他们的示例用户组织在如下的页面中：</p>
<ul>
<li><a href="">Creating创建</a></li>
<li><a href="">Transforming变换</a></li>
<li><a href="">Filtering过滤</a></li>
<li><a href="">Combining组合</a></li>
<li><a href="">Error Handling错误处理</a></li>
<li><a href="">Utility工具</a></li>
<li><a href="">Conditional and Boolean条件与布尔</a></li>
<li><a href="">Mathematical and Aggregate</a></li>
<li><a href="">Backpressure</a></li>
<li><a href="">Connectable Observables</a></li>
<li><a href="">Blocking Observables</a></li>
</ul>
<p>这些页面所包含的信息一些操作并不是响应式扩展的核心组成部分，但却是一些特定语言的实现或是可选模块。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/observable.html">http://reactivex.io/documentation/observable.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
<p>更新历史：1月13日</p>
</blockquote>
<p>在RxJava中一个对象实现了<em>Observer</em>接口则被一个<em>Observable</em>类对象所订阅。订阅者则针对<em>Obserable</em>对象产生的值（包括项及项的序列）做响应。这种模式便利了异步操作，因为不用在等待<em>Obserable</em>产生对象时进行阻塞，它以订阅者的形式创建了一个哨兵，用于在<em>Observable</em>在将来的时间产生任何输出时提供合适的响应。</p>
<p>这篇文章解释什么是响应式模式以及什么是<em>Observable</em>与观察者(观察者怎样对<em>Observable</em>进行订阅)。</p>
<blockquote>
<p>文档中的解释将采用”marble diagrams”的形式。下图说明”marble diagrams”怎样展示<em>Observable</em>以及<em>Observable</em>之间的转换。</p>
<p><img src="http://reactivex.io/assets/operators/legend.png" alt="Observables"></p>
</blockquote>]]>
    
    </summary>
    
      <category term="frp" scheme="http://yoursite.com/tags/frp/"/>
    
      <category term="reactivex" scheme="http://yoursite.com/tags/reactivex/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/tags/rxjava/"/>
    
      <category term="响应式编程" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/rxjava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出 RxJava (二、操作符)]]></title>
    <link href="http://yoursite.com/grokking-rxjava-part-2/"/>
    <id>http://yoursite.com/grokking-rxjava-part-2/</id>
    <published>2015-08-30T14:20:35.000Z</published>
    <updated>2015-09-08T14:16:13.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://www.linfuyan.com/grokking-rxjava-part-1" target="_blank" rel="external">第一篇博客</a>中，我介绍了 RxJava 的一些基础知识，同时也介绍了 map() 操作符。当然如果你并没有意愿去使用 RxJava 我一点都不诧异，毕竟才接触了这么点儿。看完这篇博客，我相信你肯定想立即在你的项目中使用 RxJava 了，这边博客将介绍许多 RxJava 中的操作符， RxJava 的强大性就来自于它所定义的操作符。</p>
<a id="more"></a>
<p>首先先看一个例子：</p>
<h3 id="准备工作">准备工作</h3><p>假设我有这样的一个方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法根据输入的字符串返回一个网站的 url 列表</span></span><br><span class="line">Observable&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; query(<span class="built_in">String</span> text);</span><br></pre></td></tr></table></figure>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇博客的内容，我们可能会写出下面的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(urls -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> url : urls) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个 URL，只能在 Subscriber 中来做。我们竟然没有使用如此酷的 map() 操作符！！！</p>
<p>当然，我可以使用 map 操作符，map 的输入是 urls 列表，处理的时候还是要 for each 遍历，一样很蛋疼。</p>
<h3 id="万幸的是">万幸的是</h3><p>我们有 Observable.from() 方法，它接收一个集合作为输入，然后每次输出一个元素给 subscriber：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.<span class="keyword">from</span>(<span class="string">"url1"</span>, <span class="string">"url2"</span>, <span class="string">"url3"</span>)</span><br><span class="line">    .subscribe(url -&gt; System.<span class="keyword">out</span>.println(url));</span><br></pre></td></tr></table></figure>
<p>我们来把这个方法使用到刚才的场景：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(urls<span class="function"> -&gt;</span> &#123;</span><br><span class="line">        Observable.<span class="keyword">from</span>(urls)</span><br><span class="line">            .subscribe(url<span class="function"> -&gt;</span> System.out.println(url));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>虽然去掉了 for each 循环，但是代码依然看起来很乱。多个嵌套的 subscription 不仅看起来很丑，难以修改，更严重的是它会破坏我们现在还没有讲到的 RxJava 的特性。</p>
<h3 id="改进">改进</h3><p>救星来了，他就是 flatMap()。</p>
<p>Observable.flatMap() 接收了一个 Observable 的输出作为输入，同时输出另外一个 Observable。直接看代码：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span>flatMap(<span class="literal">new</span> Func1&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;, Observable&lt;<span class="built_in">String</span>&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> Observable&lt;<span class="built_in">String</span>&gt; call(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; urls) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable<span class="built_in">.</span>from(urls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">.</span>subscribe(url <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(url));</span><br></pre></td></tr></table></figure>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用 lambda 可以大大简化代码长度：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">query</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.flatMap</span>(<span class="tag">urls</span> <span class="tag">-</span>&gt; <span class="tag">Observable</span><span class="class">.from</span>(<span class="tag">urls</span>))</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">url</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">url</span>));</span><br></pre></td></tr></table></figure>
<p>flatMap() 是不是看起来很奇怪？为什么它要返回另外一个 Observable 呢？理解 flatMap 的关键点在于，flatMap 输出的新的 Observable 正是我们在 Subscriber 想要接收的。现在 Subscriber 不再收到 List<string>，而是收到一系列单个的字符串，就像 Observable.from() 的输出一样。</string></p>
<p>这部分也是我当初学 RxJava 的时候最难理解的部分，一旦我突然领悟了， RxJava 的很多疑问也就一并解决了。</p>
<h3 id="还可以更好">还可以更好</h3><p>flatMap() 实在不能更赞了，它可以返回任何它想返回的 Observable 对象。</p>
<p>比如下面的方法：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 返回网站的标题，如果<span class="number">404</span>了返回<span class="literal">null</span></span><br><span class="line">Observable&lt;<span class="built_in">String</span>&gt; getTitle(<span class="built_in">String</span> URL)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>接着前面的例子，现在我不想打印 URL 了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个 URL，并且返回值不是一个 String，而是一个输出 String 的 Observable 对象。使用 flatMap() 可以简单的解决这个问题。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span>flatMap(urls <span class="subst">-&gt; </span>Observable<span class="built_in">.</span>from(urls))</span><br><span class="line">    <span class="built_in">.</span>flatMap(<span class="literal">new</span> Func1&lt;<span class="built_in">String</span>, Observable&lt;<span class="built_in">String</span>&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> Observable&lt;<span class="built_in">String</span>&gt; call(<span class="built_in">String</span> url) &#123;</span><br><span class="line">            <span class="keyword">return</span> getTitle(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">.</span>subscribe(title <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(title));</span><br></pre></td></tr></table></figure>
<p>使用 lambda：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">query</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.flatMap</span>(<span class="tag">urls</span> <span class="tag">-</span>&gt; <span class="tag">Observable</span><span class="class">.from</span>(<span class="tag">urls</span>))</span><br><span class="line">    <span class="class">.flatMap</span>(<span class="tag">url</span> <span class="tag">-</span>&gt; <span class="tag">getTitle</span>(<span class="tag">url</span>))</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">title</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">title</span>));</span><br></pre></td></tr></table></figure>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回 Observable 对象的方法组合在一起！帅呆了！</p>
<p>不止这些，我还将两个 API 的调用组合到一个链式调用中了。我们可以将任意多个 API 调用链接起来。大家应该都应该知道同步所有的 API 调用，然后将所有 API 调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了 callback hell （多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h3 id="丰富的操作符">丰富的操作符</h3><p>目前为止，我们已经接触了两个操作符， RxJava 中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？</p>
<p>getTitle() 返回 null 如果 url 不存在。我们不想输出 “null”，那么我们可以从返回的 title 列表中过滤掉 null 值！</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls<span class="function"> -&gt;</span> Observable.<span class="keyword">from</span>(urls))</span><br><span class="line">    .flatMap(url<span class="function"> -&gt;</span> getTitle(url))</span><br><span class="line">    .filter(title<span class="function"> -&gt;</span> title != <span class="literal">null</span>)</span><br><span class="line">    .subscribe(title<span class="function"> -&gt;</span> System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>filter() 输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span>flatMap(urls <span class="subst">-&gt; </span>Observable<span class="built_in">.</span>from(urls))</span><br><span class="line">    <span class="built_in">.</span>flatMap(url <span class="subst">-&gt; </span>getTitle(url))</span><br><span class="line">    <span class="built_in">.</span>filter(title <span class="subst">-&gt; </span>title != <span class="built_in">null</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="keyword">take</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">.</span>subscribe(title <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(title));</span><br></pre></td></tr></table></figure>
<p>take() 输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span>flatMap(urls <span class="subst">-&gt; </span>Observable<span class="built_in">.</span>from(urls))</span><br><span class="line">    <span class="built_in">.</span>flatMap(url <span class="subst">-&gt; </span>getTitle(url))</span><br><span class="line">    <span class="built_in">.</span>filter(title <span class="subst">-&gt; </span>title != <span class="built_in">null</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="keyword">take</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">.</span>doOnNext(title <span class="subst">-&gt; </span>saveTitle(title))</span><br><span class="line">    <span class="built_in">.</span>subscribe(title <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(title));</span><br></pre></td></tr></table></figure>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava 包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了 RxJava 的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇博客不打算讲自定义操作符，如果你想的话，请自行 Google 吧。</p>
<h3 id="感觉如何？">感觉如何？</h3><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava 也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个 API，对 API 返回的数据进行了处理，然后保存到磁盘。但是我们的 Subscriber 并不知道这些，它只是认为自己在接收一个 Observable<string> 对象。良好的封装性也带来了编码的便利！</string></p>
<p>在第三部分中，我将介绍 RxJava 的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
<p>原文链接：<a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="external">Grokking RxJava, Part 2: Operator, Operator</a><br>译文来源：<a href="http://http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="external">深入浅出RxJava（二：操作符）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://www.linfuyan.com/grokking-rxjava-part-1">第一篇博客</a>中，我介绍了 RxJava 的一些基础知识，同时也介绍了 map() 操作符。当然如果你并没有意愿去使用 RxJava 我一点都不诧异，毕竟才接触了这么点儿。看完这篇博客，我相信你肯定想立即在你的项目中使用 RxJava 了，这边博客将介绍许多 RxJava 中的操作符， RxJava 的强大性就来自于它所定义的操作符。</p>]]>
    
    </summary>
    
      <category term="reactivex" scheme="http://yoursite.com/tags/reactivex/"/>
    
      <category term="rxandroid" scheme="http://yoursite.com/tags/rxandroid/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/tags/rxjava/"/>
    
      <category term="反应式编程" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="操作符" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="开发技术" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="rxjava" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/rxjava/"/>
    
      <category term="深入浅出RxJava" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/rxjava/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxJava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成]]></title>
    <link href="http://yoursite.com/continuous-integration-of-ios-application-with-jenkins-git-cocoapods-fir.im/"/>
    <id>http://yoursite.com/continuous-integration-of-ios-application-with-jenkins-git-cocoapods-fir.im/</id>
    <published>2015-08-29T06:55:23.000Z</published>
    <updated>2015-08-29T07:02:28.000Z</updated>
    <content type="html"><![CDATA[<p>本文说明如何在 Mac OSX 环境下，使用 Jenkins 对基于 CocoaPods 进行依赖管理的 iOS 项目做自动打包与持续集成，并将最终的安装包发布到 fir.im 上供下载。</p>
<h4 id="前置说明">前置说明</h4><ol>
<li>实现 iOS 项目自动打包，需要有 Mac OSX 环境。本文中使用的是一台普通的 Mac mini，并安装 Mac OSX 10.10 Yosemite。</li>
<li>本文中使用的自动打包脚本依赖于 <code>xcodebuild</code> 及 <code>xcrun</code>，故需要确保安装 Xcode，并且系统中安装有 Xcode 的命令行工具。具体命令行如何打包，可以查看 <a href="http://" target="_blank" rel="external">iOS 命令行打包</a></li>
<li>本文中代码的版本控制工具使用 Git。Mac OSX 安装完成 Xcode 以后自带 Git，故不用另外安装。</li>
<li>iOS 项目使用 CocoaPods 进行依赖管理，故 Mac OSX 需要安装 CocoaPods。具体可以查看 <a href="http://" target="_blank" rel="external">CocoaPods 使用</a></li>
<li>需要确保 Jenkins 服务器所在的机器上拥有对应的证书和 Profile 文件，才能够顺利打包。什么是证书和 Profile 文件，可以查看 <a href="http://" target="_blank" rel="external">iOS 证书和 Profile 文件</a></li>
<li>在 Mac OSX 下安装并配置好 Jenkins。Jenkins 的安装不在本文论述范围内，具体可以查看 <a href="http://" target="_blank" rel="external">Mac OSX 安装 Jenkins</a></li>
<li>Jenkins 配置好相关插件，本文中使用到 <code>Git plugin</code>， <code>Git client plugin</code>， <code>Xcode integration</code> 等插件。如何安装 Jenkins 插件，可以查看 <a href="http://" target="_blank" rel="external">Jenkins 插件安装</a></li>
<li>本文中代码所使用的文件目录结构如下。不同的文档结构会对 Jenkins 中嵌入的 Shell 脚本造成影响。即在实际项目源码位于根目录再下一级目录。</li>
</ol>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Art				<span class="comment">// 项目目录</span></span><br><span class="line">    <span class="string">|--Art		// 实际项目源码目录</span></span><br><span class="line">    	<span class="string">|--Art</span></span><br><span class="line">    	<span class="string">|--project.xcdoeproj</span></span><br><span class="line">    	<span class="string">|--project.xcworkspace</span></span><br><span class="line">    	<span class="string">|--Podfile</span></span><br><span class="line">    	<span class="string">|--...</span></span><br><span class="line">    <span class="string">|--bin			// 存放部分二进制文件的目录，实际中并未使用</span></span><br><span class="line">    <span class="string">|--doc			// 本项目相关的文档目录</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="具体步骤">具体步骤</h2><h3 id="新建项目">新建项目</h3><p>使用具有配置权限的用户登录 Jenkins，选择”新建”，”构建一个自由风格的软件项目”，并确定。这里新建了一个名为 <code>iOS-project-ci</code> 的 job。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-1.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<h3 id="配置构建基本信息">配置构建基本信息</h3><p>填写相关 job 的信息，如名称、描述。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-2.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>可以选择构建过程，并进行一些设置。这里选择”参数化构建过程”，添加一个 <code>Text Parameter</code>，并做相关设置。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-3.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-4.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>高级项目选项，本文中没有做任何设置。</p>
<h3 id="配置项目源码">配置项目源码</h3><p>源码管理中选择 Git，配置仓库地址，认证账户，需要构建的分支等。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-5.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>根据项目需要构建触发器，本文中没有做任何设置，项目的构建由用户手动触发。</p>
<h3 id="配置构建过程">配置构建过程</h3><h4 id="配置_CocoaPods">配置 CocoaPods</h4><p>由于本文中项目代码目录没有在根目录下，且使用 CocoaPods 进行依赖管理，故先增加一个 Shell 脚本的构建步骤。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-6.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>其中 <code>cd Art</code> 是进入到 Podfile 文件所在目录，即实际项目源码目录。 <code>pod install</code> 用于更新实际项目的源码依赖。完整的 pod 更新可能会很好使，可以考虑 <code>pod install --no-repo-update</code></p>
<h4 id="配置_Xcode_integration">配置 Xcode integration</h4><p>新增 Xcode integration 构建过程</p>
<p><strong>基础配置</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-7.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<ol>
<li>本文的项目中使用 <code>workspace</code>， 所以 Target 可以不填。</li>
<li>Configuration 是在 Xcode 中的配置，默认有 Debug 和 Release，这里的 InHouse 为我自己在项目中的配置，使用企业签名的对应用进行打包。</li>
<li>将应用打包成 .ipa 文件。</li>
<li>这里设置 .ipa 文件的名称。其中 $BUILD_NUMBER 为 Jenkins 提供的系统变量，为当前的构建版本号。</li>
<li>这里设置 构建过程输出目录。其中 $WORKSPACE 为 Jenkins 提供的系统变量，为构建根目录。</li>
</ol>
<p><strong>代码签名及密钥配置</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-8.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>本文中采用在 Xcode 项目中新增共享 scheme 的方式，在 scheme 内部对代码签名和 Profile 做了配置，同时 Jenkins 所在的 Mac OSX 中有对应的证书和 Profile，所以1，2中不需要做特殊配置，如果配置，将替换 scheme中的配置。</p>
<p>在打包的过程中，命令会由于系统的安全设置提醒输入密码，3中可以设置密钥所在路径及系统用户密码。</p>
<blockquote>
<p>具体如何新增共享 scheme 及配置，可以查看<a href="http://" target="_blank" rel="external">iOS 配置 scheme 和 configuration</a></p>
</blockquote>
<p><strong>Xcode 高级构建配置</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-9.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<ol>
<li>这里的 <code>Art-Ci</code> 就是我在 Xcode 项目中新建的 scheme。</li>
<li>本文中的项目包含有 workspace，这里设置对应路径，注意不需要带上 .xcworkspace 后缀。</li>
<li>Xcode 项目所在目录</li>
<li>Xcode 项目文件，这里需要带上 .xcodeproj 后缀。</li>
<li>设置构建输出目录。</li>
</ol>
<h4 id="发布到_fir-im">发布到 fir.im</h4><p>添加一个 Shell 构建步骤，输入如下命令：</p>
<p><code>fir p $WORKSPACE/build/art_$BUILD_NUMBER.ipa -c &quot;$release_note&quot;</code></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-10.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>这里发布到 fir.im，使用了其官方提供的 fir-cli 工具。 <code>$WORKSPACE/build/art_$BUILD_NUMBER.ipa</code> 获取到最终打包的 .ipa 文件路径， $release_note 为我们在”带参数构建”中添加的参数。 fir-cli 的使用，具体查看<a href="http://blog.fir.im/fir_cli/" target="_blank" rel="external">官方工具 fir-cli 使用说明</a></p>
<p>完成以上配置，应用并保存配置。</p>
<h4 id="添加其他构建后步骤">添加其他构建后步骤</h4><p>可以在构建完成以后，配置邮件通知等操作以便及时将构建结果通知到相应的人员。</p>
<h4 id="启动构建">启动构建</h4><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-11.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS-project-ci-12.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>设置参数，点击”开始构建”，构建过程便被触发。如果构建成功，最终 iOS 应用将被发布到 fir.im 上，并进行访问。例如，本文中的项目最终可以通过 <a href="http://fir.im/yiwai" target="_blank" rel="external">http://fir.im/yiwai</a> 来访问并下载安装。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文说明如何在 Mac OSX 环境下，使用 Jenkins 对基于 CocoaPods 进行依赖管理的 iOS 项目做自动打包与持续集成，并将最终的安装包发布到 fir.im 上供下载。</p>
<h4 id="前置说明">前置说明</h4><ol>
<li>实现 iOS 项目自动打包，需要有 Mac OSX 环境。本文中使用的是一台普通的 Mac mini，并安装 Mac OSX 10.10 Yosemite。</li>
<li>本文中使用的自动打包脚本依赖于 <code>xcodebuild</code> 及 <code>xcrun</code>，故需要确保安装 Xcode，并且系统中安装有 Xcode 的命令行工具。具体命令行如何打包，可以查看 <a href="http://">iOS 命令行打包</a></li>
<li>本文中代码的版本控制工具使用 Git。Mac OSX 安装完成 Xcode 以后自带 Git，故不用另外安装。</li>
<li>iOS 项目使用 CocoaPods 进行依赖管理，故 Mac OSX 需要安装 CocoaPods。具体可以查看 <a href="http://">CocoaPods 使用</a></li>
<li>需要确保 Jenkins 服务器所在的机器上拥有对应的证书和 Profile 文件，才能够顺利打包。什么是证书和 Profile 文件，可以查看 <a href="http://">iOS 证书和 Profile 文件</a></li>
<li>在 Mac OSX 下安装并配置好 Jenkins。Jenkins 的安装不在本文论述范围内，具体可以查看 <a href="http://">Mac OSX 安装 Jenkins</a></li>
<li>Jenkins 配置好相关插件，本文中使用到 <code>Git plugin</code>， <code>Git client plugin</code>， <code>Xcode integration</code> 等插件。如何安装 Jenkins 插件，可以查看 <a href="http://">Jenkins 插件安装</a></li>
<li>本文中代码所使用的文件目录结构如下。不同的文档结构会对 Jenkins 中嵌入的 Shell 脚本造成影响。即在实际项目源码位于根目录再下一级目录。</li>
</ol>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Art				<span class="comment">// 项目目录</span></span><br><span class="line">    <span class="string">|--Art		// 实际项目源码目录</span></span><br><span class="line">    	<span class="string">|--Art</span></span><br><span class="line">    	<span class="string">|--project.xcdoeproj</span></span><br><span class="line">    	<span class="string">|--project.xcworkspace</span></span><br><span class="line">    	<span class="string">|--Podfile</span></span><br><span class="line">    	<span class="string">|--...</span></span><br><span class="line">    <span class="string">|--bin			// 存放部分二进制文件的目录，实际中并未使用</span></span><br><span class="line">    <span class="string">|--doc			// 本项目相关的文档目录</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="fir.im" scheme="http://yoursite.com/tags/fir-im/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="软件工具" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/jenkins/"/>
    
  </entry>
  
</feed>
