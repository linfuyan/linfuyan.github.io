<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Elasticsearch 高可用集群搭建]]></title>
      <url>http://linfuyan.com/es-cluster-ha/</url>
      <content type="html"><![CDATA[<p>以下我们将基于 elasticsearch-6.6.0 版本，在单机上部署 3 个节点组成的集群。3个节点都用作候选主节点，且同时作为数据节点。</p>
<a id="more"></a>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><ol>
<li><p>下载 elasticsearch-6.6.0 二进制包，解压，复制 3 份，分别命名为 es1， es2， es3。</p>
</li>
<li><p>分别修改 config/elasticsearch.yml 的配置，</p>
</li>
</ol>
<p>es1 如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群名称，相同集群的节点名称一致</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">es1</span></span><br><span class="line"><span class="comment"># 数据存储路径</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/path/to/es1/data</span></span><br><span class="line"><span class="comment"># 日志存储路径</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/path/to/es1/logs</span></span><br><span class="line"><span class="comment"># 是否用作候选主节点，默认为 true</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否用作数据节点，默认为 true</span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># HTTP 端口，提供 RESTful 服务交互</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">5201</span></span><br><span class="line"><span class="comment"># TCP 端口，集群节点之间通信</span></span><br><span class="line"><span class="string">transport.tcp.port:</span> <span class="number">5301</span></span><br><span class="line"><span class="comment"># 集群中相互通信的节点</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["localhost:5301","locahost:5302","locahost:5303"]</span></span><br><span class="line"><span class="comment"># 集群最小主节点个数</span></span><br><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>es2 如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群名称，相同集群的节点名称一致</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">es2</span></span><br><span class="line"><span class="comment"># 数据存储路径</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/path/to/es2/data</span></span><br><span class="line"><span class="comment"># 日志存储路径</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/path/to/es2/logs</span></span><br><span class="line"><span class="comment"># 是否用作候选主节点，默认为 true</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否用作数据节点，默认为 true</span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># HTTP 端口，提供 RESTful 服务交互</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">5202</span></span><br><span class="line"><span class="comment"># TCP 端口，集群节点之间通信</span></span><br><span class="line"><span class="string">transport.tcp.port:</span> <span class="number">5302</span></span><br><span class="line"><span class="comment"># 集群中相互通信的节点</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["localhost:5301","locahost:5302","locahost:5303"]</span></span><br><span class="line"><span class="comment"># 集群最小主节点个数</span></span><br><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>es3 如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群名称，相同集群的节点名称一致</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">es3</span></span><br><span class="line"><span class="comment"># 数据存储路径</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/path/to/es3/data</span></span><br><span class="line"><span class="comment"># 日志存储路径</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/path/to/es3/logs</span></span><br><span class="line"><span class="comment"># 是否用作候选主节点，默认为 true</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否用作数据节点，默认为 true</span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># HTTP 端口，提供 RESTful 服务交互</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">5203</span></span><br><span class="line"><span class="comment"># TCP 端口，集群节点之间通信</span></span><br><span class="line"><span class="string">transport.tcp.port:</span> <span class="number">5303</span></span><br><span class="line"><span class="comment"># 集群中相互通信的节点</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["localhost:5301","locahost:5302","locahost:5303"]</span></span><br><span class="line"><span class="comment"># 集群最小主节点个数，为了防止脑裂，最小主节点个数应该为(候选主节点个数 / 2 + 1)</span></span><br><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>分别启动 3 个节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/es1</span><br><span class="line">bin/elasticsearch -d</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在浏览器中查看集群状态</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/20200406162446.png" alt="查看集群状态"></p>
<h2 id="可视化管理"><a href="#可视化管理" class="headerlink" title="可视化管理"></a>可视化管理</h2><p>通过 elasticsearch-head 可以可视化的管理 es 集群。</p>
<p>elasticsearch-head 项目地址 <a href="http://mobz.github.io/elasticsearch-head" target="_blank" rel="noopener">http://mobz.github.io/elasticsearch-head</a>。</p>
<p>如果本地有 nodejs 环境，通过以下步骤安装 elasticsearch-head。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>安装完成，在浏览器中访问 <a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a></p>
<p><img src="http://img.uprogrammer.cn/static/20200406163443.png" alt="可视化集群管理"></p>
<blockquote>
<p>elasticsearch-head 在访问 es 实例 RESTful API 时会存在跨域问题，es 实例启动时，配置文件需要添加一下参数</p>
<p><code>http.cors.enabled: true</code><br><code>http.cors.allow-origin: &quot;*&quot;</code></p>
</blockquote>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p><strong>创建索引</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "settings": &#123;</span><br><span class="line">    "number_of_shards": 3,</span><br><span class="line">    "number_of_replicas": 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>number_of_shards: 主分片数量，默认为 5<br>number_of_replicas: 分片副本数量，默认为 1</p>
</blockquote>
<p><strong>动态更新副本数量</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/settings</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "number_of_replicas": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高可用性验证"><a href="#高可用性验证" class="headerlink" title="高可用性验证"></a>高可用性验证</h2><p>这里以另外一个真实在用的集群来演示集群的高可用性。</p>
<h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><ul>
<li>索引 <code>app_jgus_yn</code> 与 <code>app_jgus</code> 都是在单节点集群情况下创建的，默认主分片数量为 5，副本数量为 0。</li>
<li>后来，集群扩展到 3 个节点，我为 <code>app_jgus</code> 动态更新了副本数量为 1。</li>
<li>该集群处于 green 状态：</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406094035.png" alt="集群正常"></p>
<h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><ul>
<li>集群中 es3 节点失败了，集群处于 red 状态，有主分片缺失，此时集群不可用。</li>
<li>对 <code>app_jgus</code> 索引的查询依然可以正常进行，因为 <code>app_jgus</code> 的每个主分片都有 1 个副本，剩余 2 个节点中保存有所有的索引数据。</li>
<li>索引 <code>app_jgus_yn</code> 由于没有为主分片生成副本，随 es3 节点失败，缺少了 2 个主分片，缺失的分片数据将无法被操作。</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406224952.png" alt="集群中节点挂了"></p>
<h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><ul>
<li>重启 es3 节点，刷新查看集群状态</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406094828.png" alt="节点 es3 恢复中"></p>
<ul>
<li>最终，集群状态恢复为步骤一中的正常状态</li>
</ul>
<h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><ul>
<li>为索引 <code>app_jgus_yn</code> 动态更新副本数量，将 <code>number_of_replicas</code> 设为 1，即每个主分片都有 1 份副本。</li>
<li>每个分片都拥有了 1 份副本，集群处于 green 状态</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406095034.png" alt="动态修改副本数量"></p>
<h3 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h3><ul>
<li>原主节点宕机，es3 被选为新的主节点。</li>
<li>由于原来每个主分片，都有副本，虽然一个节点宕机了，但其他 2 个节点有所有的数据，依赖可以完成所有的数据操作。此时，集群状态为 yellow。</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406095352.png" alt="原主节点宕机，集群依然可以提供服务"></p>
<ul>
<li>一段时间以后，新的集群将达到 green 状态</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406101251.png" alt="新的集群达到完美状态"></p>
<h3 id="步骤六"><a href="#步骤六" class="headerlink" title="步骤六"></a>步骤六</h3><ul>
<li>恢复原节点，相当于在已经稳定的集群中再新增节点。</li>
<li>集群将在新节点上分配数据，并最终达到新的 green 状态。</li>
</ul>
<p><img src="http://img.uprogrammer.cn/static/20200406095823.png" alt="集群新增节点"></p>
<h2 id="问题排查记录"><a href="#问题排查记录" class="headerlink" title="问题排查记录"></a>问题排查记录</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在集群搭建完成以后，创建索引过程中，遇到了数据分片 <code>unassigned</code> 的异常。大致情况如下：</p>
<p><img src="http://img.uprogrammer.cn/static/20200406171650.png" alt="分片 unassigned"></p>
<p>查看分片 <code>unassigned</code> 原因</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/allocation/explain?pretty</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/20200406104253.png" alt="查看分片 unassigned 的具体原因"></p>
<p>这里是因为空间不够引起的。</p>
<p>解决方案是调整集群磁盘水印的参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "persistent": &#123;</span><br><span class="line">    "cluster.routing.allocation.disk.watermark.high": "95%",</span><br><span class="line">    "cluster.routing.allocation.disk.watermark.low": "93%"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>集群搭建过程中，配置文件显式指定 <code>transport.tcp.port</code> ，但未显式设置 <code>discovery.zen.ping.unicast.hosts</code> 时，几个节点之间无法组成集群，各自独立。</p>
<p>我在配置时，3 个 es 节点的 <code>transport.tcp.port</code> 分别为 5301、5302、5303。当没有显式设置 <code>discovery.zen.ping.unicast.hosts</code> 时，会自动按照 9300、9301、9302 的端口顺序设置这个广播地址，因此无法与真实的实例端口通信。以上是我通过查看进程占用的端口得出的结论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/zwgdft/article/details/54585644" target="_blank" rel="noopener">谈一谈Elasticsearch的集群部署</a></p>
<p><a href="https://blog.csdn.net/weixin_43334786/article/details/104891519" target="_blank" rel="noopener">ES集群的高可用</a></p>
<p><a href="https://www.cnblogs.com/toov5/p/10296903.html" target="_blank" rel="noopener">ElasticSearch高可用集群环境搭建和分片原理</a></p>
<p><a href="https://www.cnblogs.com/yfb918/p/10475083.html" target="_blank" rel="noopener">如何在Elasticsearch中解析未分配的分片（unassigned shards）</a></p>
<p><a href="https://www.cnblogs.com/pythonPath/p/11595652.html" target="_blank" rel="noopener">Elasticsearch unassigned 故障排查</a></p>
<p><a href="https://blog.csdn.net/csj941227/article/details/78247031" target="_blank" rel="noopener">Elasticsearch 学习笔记 索引创建、插入、查询、修改、删除</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> elasticsearch </tag>
            
            <tag> es </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis PageHelper 自动添加 limit 引发的血案]]></title>
      <url>http://linfuyan.com/mybatis-pagehelper-limit/</url>
      <content type="html"><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><p>在浏览器上多次刷新同一个页面，发现同一区域的数据会时多时少。</p>
<p>查看接口响应发现同一接口多次请求会返回不一样的数据。</p>
<a id="more"></a>
<h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p>页面显示</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101334.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>接口响应</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101452.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>页面显示</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101614.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>接口响应</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101650.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>正常接口响应与异常接口响应数据量对比</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101753.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><h3 id="猜测一：负载均衡问题"><a href="#猜测一：负载均衡问题" class="headerlink" title="猜测一：负载均衡问题"></a>猜测一：负载均衡问题</h3><p>多个不同版本的应用实例，代码实现或者数据库数据不同导致。</p>
<p>经过排查，开发和测试环境都存在一样的问题，并且这两个环境都是单实例的。</p>
<h3 id="猜测二：代码逻辑有误"><a href="#猜测二：代码逻辑有误" class="headerlink" title="猜测二：代码逻辑有误"></a>猜测二：代码逻辑有误</h3><p>走查了代码，发现这里只是一个简单的单表查询，并没有复杂逻辑。</p>
<p>同时针对单个接口反复测试，无法重现响应数据时多时少的问题。</p>
<p>目前看，这块的代码并没有很直观的错误。</p>
<h3 id="猜测三：sql-多次执行返回不同结果"><a href="#猜测三：sql-多次执行返回不同结果" class="headerlink" title="猜测三：sql 多次执行返回不同结果"></a>猜测三：sql 多次执行返回不同结果</h3><p>使用查询语句，多次重试，没有复现异常。</p>
<h3 id="猜测四："><a href="#猜测四：" class="headerlink" title="猜测四："></a>猜测四：</h3><p>经过猜测二、三的排查，怀疑是页面上多个请求同时发起共同导致的问题。</p>
<p>于是反复刷新页面，查看后端日志，发现正常情况与异常情况时执行的 sql 不一致。</p>
<p><strong>异常情况下，会在正常的 sql 后面添加 <code>limit</code> 子句。</strong></p>
<p><img src="http://img.uprogrammer.cn/static/20200326101902.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>到这里，我只能猜测是 mybatis 动态生成的 sql 有问题。</p>
<p>那么什么原因导致会在正常的 sql 后添加 limit 子句，并且这个 <code>5</code> 是从哪里来的呢？</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>在度娘上以 “mybatis 自动添加 limit” 为关键字搜索，发现由于 PageHelper 插件自动添加 limit 的问题很多。</p>
<p>在 <a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">Mybatis-PageHelper</a> 的<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" target="_blank" rel="noopener">使用方法</a>文章中有如下说明：</p>
<p><img src="http://img.uprogrammer.cn/static/20200326101959.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p><img src="http://img.uprogrammer.cn/static/20200326102043.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>由此，<strong>可能的原因是在这个页面上的其他请求带有分页，同时由于后端对 Mybatis PageHelper 的使用不规范导致。</strong></p>
<p>页面上有分页的请求</p>
<p><img src="http://img.uprogrammer.cn/static/20200326102135.png" alt="Mybatis PageHelper 自动添加 limit 引发的血案"></p>
<p>在排查了该接口的代码后发现：代码中调用 <code>PageHelper.startPage</code> 方法的地方与真正执行查询的代码中间有很多复杂的业务处理。</p>
<p>问题原因基本清楚了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>永久的解决方案：规范 <code>PageHelper.startPage</code> 方法的使用，只在真实查询要执行前，调用该方法，确保安全分页。</li>
<li>临时的解决方案：在出现问题的查询前面，调用 <code>PageHelper.clearPage</code></li>
</ol>
<p>目前按照临时解决方案进行了处理，反复测试以后，问题得到了解决。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> pagehelper </tag>
            
            <tag> limit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 查看占用端口的进程]]></title>
      <url>http://linfuyan.com/linux-port-taken-up/</url>
      <content type="html"><![CDATA[<p>在 linux 上，我们经常会遇到端口被占用，导致应用程序无法启动的情况，这时候就需要知道到底是哪个进程或是哪个程序占用了这个端口，以便进行后面的处理。</p>
<p>这里总结了几种方式。</p>
<a id="more"></a>
<h2 id="使用-ss-查看"><a href="#使用-ss-查看" class="headerlink" title="使用 ss 查看"></a>使用 ss 查看</h2><p>ss 一般用于转储套接字统计信息。它还可以显示所有类型的套接字统计信息，包括 PACKET、TCP、UDP、DCCP、RAW、Unix 域等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~# ss -lntpd | grep :80</span><br><span class="line">tcp    LISTEN   0        100               0.0.0.0:8080           0.0.0.0:*      users:(("java",pid=9184,fd=28))</span><br><span class="line">tcp    LISTEN   0        128                     *:80                   *:*      users:(("docker-proxy",pid=8935,fd=4))</span><br></pre></td></tr></table></figure>
<h2 id="使用-netstat-查看"><a href="#使用-netstat-查看" class="headerlink" title="使用 netstat 查看"></a>使用 netstat 查看</h2><p>netstat 能够显示网络连接、路由表、接口统计信息、伪装连接以及多播成员。目前 netstat 已经过时了，都推荐使用 ss 来代替。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~# netstat -tnlp | grep :80</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      9184/java</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      8935/docker-proxy</span><br></pre></td></tr></table></figure>
<h2 id="使用-lsof-查看"><a href="#使用-lsof-查看" class="headerlink" title="使用 lsof 查看"></a>使用 lsof 查看</h2><p>lsof (list open files) 是一个列出系统上被进程打开的文件的相关信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~# lsof -i tcp:80</span><br><span class="line">COMMAND    PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME</span><br><span class="line">docker-pr 8935 root    4u  IPv6 324024693      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure>
<h2 id="使用-fuser-查看"><a href="#使用-fuser-查看" class="headerlink" title="使用 fuser 查看"></a>使用 fuser 查看</h2><p>fuser 可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息。fuser 只把 PID 输出到标准输出，其他的都输出到标准错误输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# fuser 80/tcp</span><br><span class="line">80/tcp:               8935</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> 端口占用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker 中运行 go mod 管理 golang 项目及交叉编译]]></title>
      <url>http://linfuyan.com/docker-go-mod-golang/</url>
      <content type="html"><![CDATA[<p>最近在找一个将 html 转化为 md 的工具，后来发现 <a href="https://github.com/TruthHun/html2md" target="_blank" rel="noopener">html2md</a> 这个项目还不错，打算基于它做些改造。不过 html2md 是个 golang 项目，而我自己不想在电脑上安装 golang 环境，故便考虑通过 docker 来编译这个项目。以下对过程做些记录。</p>
<a id="more"></a>
<blockquote>
<p>说明：下文中的 <code>$go-lab</code> 为自己电脑上的某个目录。</p>
</blockquote>
<h2 id="docker-中安装-golang-环境"><a href="#docker-中安装-golang-环境" class="headerlink" title="docker 中安装 golang 环境"></a>docker 中安装 golang 环境</h2><p>下载镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull golang</span><br></pre></td></tr></table></figure>
<p>新建 gopath 目录及项目源码目录 projects，将在运行容器时做映射</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker 中默认 /go 为 gopath</span></span><br><span class="line">mkdir $go-lab/go </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于存放 golang 项目源码</span></span><br><span class="line">mkdir $go-lab/projects</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要将项目源码目录与 gopath 目录分开，这是 go mod 的要求。</p>
</blockquote>
<p>进入 <code>projects</code> 下载 html2md 项目源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $go-lab/projects</span><br><span class="line">git clone https://github.com/TruthHun/html2md</span><br></pre></td></tr></table></figure>
<h2 id="在-docker-容器中运行"><a href="#在-docker-容器中运行" class="headerlink" title="在 docker 容器中运行"></a>在 docker 容器中运行</h2><p>运行容器并进入容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $go-lab</span><br><span class="line">docker run --rm -it -v $PWD/go:/go -v $PWD/projects:/root --name html2md golang bash</span><br></pre></td></tr></table></figure>
<p>在容器中设置环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键</strong>：GOPROXY 代理最好要设置，因为 golang 的许多依赖是被 GFW 给墙了，不设置带来会导致依赖无法下载。</p>
</blockquote>
<h2 id="编译-go-mod-管理的项目"><a href="#编译-go-mod-管理的项目" class="headerlink" title="编译 go mod 管理的项目"></a>编译 go mod 管理的项目</h2><p>下载依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/html2md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载依赖包，内容会存放在容器内 /go/pkg/mod 目录中</span></span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>go mod init project_name</code>： 用 go mod 初始化目录</p>
<p><code>go mod tidy</code>： 会同步依赖包，添加需要的，移除多余的</p>
<p><code>go mod download</code>：下载依赖</p>
<p><code>go clean -modcache</code>： 清除缓存</p>
</blockquote>
<p>编写 golang 项目，引用 html2md 库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir $go-lab/demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 html2md.go 文件</span></span><br><span class="line">vi $go-lab/demo/html2md.go</span><br></pre></td></tr></table></figure>
<p><code>html2md.go</code> 文件内容如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"github.com/TruthHun/html2md"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    args := os.Args</span><br><span class="line">    <span class="keyword">if</span> args == <span class="literal">nil</span> || <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        Usage()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    input := args[<span class="number">1</span>]</span><br><span class="line">    output := args[<span class="number">2</span>]</span><br><span class="line">    fmt.Println(<span class="string">"input file is: "</span>, input, <span class="string">"\noutput file is: "</span>, output)</span><br><span class="line"></span><br><span class="line">    b, _ := ioutil.ReadFile(input)</span><br><span class="line">    md := html2md.Convert(<span class="keyword">string</span>(b))</span><br><span class="line">    ioutil.WriteFile(output, []<span class="keyword">byte</span>(md), <span class="number">0777</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Usagge: ---"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build html2md.go</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译完成后，在目录下生成 html2md 可执行文件。</p>
</blockquote>
<p>测试 html2md 工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html2md code.html code.md</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看是否正确生成 code.md</p>
</blockquote>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>golang 提供了完备的交叉编译环境。docker 中直接通过 <code>go build</code> 生成的执行文件只能在 linux 环境下运行。通过交叉编译，可以很方便的编译在 mac 或者 windows 下运行的可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译 mac 可用的可执行文件，生成 html2md</span></span><br><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build html2md.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 windows 下的可执行文件，生成 html2md.exe</span></span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build html2md.go</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/rxbook/p/7081499.html" target="_blank" rel="noopener">Go语言获取命令行参数</a></p>
<p><a href="https://www.cnblogs.com/GodBug/p/7890311.html" target="_blank" rel="noopener">go build 不同系统下的可执行文件</a></p>
<p><a href="https://studygolang.com/articles/26335" target="_blank" rel="noopener">五分钟用Docker快速搭建Go开发环境</a></p>
<p><a href="https://studygolang.com/articles/20716" target="_blank" rel="noopener">golang内置包管理工具go mod简明教程</a></p>
<p><a href="https://segmentfault.com/a/1190000019724582" target="_blank" rel="noopener">go - 使用 go mod 管理项目依赖</a></p>
<p><a href="https://www.cnblogs.com/wt11/p/11340386.html" target="_blank" rel="noopener">go安装以及使用gomod、 goland设置</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> golang </tag>
            
            <tag> html2md </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql 中身份证字段脱敏]]></title>
      <url>http://linfuyan.com/desensitization-in-mysql/</url>
      <content type="html"><![CDATA[<p>在数据的使用与传输过程中，经常需要将敏感信息脱敏的过程。比如需要将用户信息表中的身份证号码中间 几位进行隐藏等等。</p>
<h2 id="脱敏方法"><a href="#脱敏方法" class="headerlink" title="脱敏方法"></a>脱敏方法</h2><p>mysql 中常用的脱敏方法有以下两种。</p>
<h3 id="CONCAT-、LEFT-和-RIGHT-字符串函数组合使用"><a href="#CONCAT-、LEFT-和-RIGHT-字符串函数组合使用" class="headerlink" title="CONCAT()、LEFT() 和 RIGHT() 字符串函数组合使用"></a>CONCAT()、LEFT() 和 RIGHT() 字符串函数组合使用</h3><ul>
<li>CONCAT(str1, str2, …)：返回结果为连接参数产生的字符串</li>
<li>LEFT(str, len)：返回从字符串 str 开始的最左 len 字符</li>
<li>RIGHT(str, len)：从字符串 str 开始，返回最右 len 字符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CONCAT</span>(<span class="keyword">LEFT</span>(identity_card_no, <span class="number">6</span>), <span class="string">'********'</span> , <span class="keyword">RIGHT</span>(identity_card_no, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT()"></a>INSERT()</h3><ul>
<li>INSERT(str, pos, len, newstr)：返回字符串 str, 其子字符串起始于 pos 位置和长期被字符串 newstr 取代的 len 字符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">INSERT</span>(identity_card_no, <span class="number">7</span>, <span class="number">8</span>, <span class="string">'********'</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>
<h2 id="从查询结果中更新数据"><a href="#从查询结果中更新数据" class="headerlink" title="从查询结果中更新数据"></a>从查询结果中更新数据</h2><pre><code># update select 语句（注意：必须使用 inner join）
# 语法 update ta inner join (select yy from tb) tc on ta.id = tc.id set ta.xx = tc.yy

-- 行政处罚信息表
UPDATE T_XYXX_XZCFXX ori
INNER JOIN (
SELECT
  uuid,
  INSERT ( FDDBR, 1, 1, &apos;*&apos; ) AS NAME,
  CONCAT(
  &apos;000000&apos;,
  &apos;****&apos;,
  RIGHT ( FDDBRZJHM, 8 ) 
  ) AS idcardno 
FROM
  T_XYXX_XZCFXX 
  ) nosense ON ori.uuid = nosense.uuid 
  SET ori.FDDBR = nosense.NAME,
  ori.FDDBRZJHM = nosense.idcardno;
</code></pre>]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 身份证 </tag>
            
            <tag> 脱敏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从代码组织看团队治理之案例一]]></title>
      <url>http://linfuyan.com/code-organize-and-team-management-one/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/15579278505835.jpg" alt="微服务代码组织"></p>
<p>这是一张打满马赛克的图。</p>
<p>嗯，把你的思绪拉回来先。我来介绍下团队的一些简单背景。</p>
<a id="more"></a>
<p>我们部门在基于 spring cloud 做微服务的实践。业务上在公司内部相对独立，部门内部有几个团队负责不同的项目。在部门内部希望生产的代码等可以跨几个团队共用，以满足不同项目快速开发的需求。</p>
<p>开头的图片展示的是其中一个团队目前代码的组织方式。</p>
<ul>
<li>xxxx-yyyy-config 项目是分布式配置中心。</li>
<li>xxxx-yyyy-zuul 项目是 API 网关。</li>
<li>xxxx-yyyy-eureka 项目是服务注册中心。</li>
<li>xxxx-yyyy-fileupload、xxxx-yyyy-workflow 等是提供特定功能的微服务。</li>
<li>xxxx-yyyy-common 项目，从命名上来看，是一个提供公共功能的服务。在其中 <code>xxxx.yyyy.common.feign</code> 包下聚合了其他微服务所实现能力的声明。</li>
</ul>
<p>在一个团队内部，这样的设计具有一定的合理性。</p>
<p>将这个团队作为一个内聚的单元，通过 common 项目来聚合内部各个微服务提供的能力，统一暴露，很好的使用了一个外观模式。外部不必关心内部实现细节，只需专注在接口上。对内部来讲，各个服务的能力汇总到 common 中，便于管理。</p>
<p>但是，请回顾一下之前我提到的团队的背景。这个团队只是部门中的一个，其生产的代码需要能在部门中共享与复用。</p>
<p>这时的 common 项目却对部门其他团队关上了门。纵然这个团队生产的多数代码可以通过复制的形式减少其他团队的工作量，但由于 common 包含了众多这个团队业务本身的东西，在其他团队中使用时必定需要做较大的调整。</p>
<p>是时候打破 common 这扇门了，让门内已有的微服务走入到其他团队中。那该怎么做呢？</p>
<p>每个微服务对外声明自己的能力，不聚合在 common 中。每个微服务独立维护。内部负责实现自己对外声明的能力，外部使用微服务声明能力的接口。调整一下代码的组织，实例如下：</p>
<p><img src="http://img.uprogrammer.cn/15579307669911.jpg" alt=""></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|- xxx-yyy-zzz                       // 主项目</span></span><br><span class="line">  <span class="string">|- xxx-yyy-zzz-api               // 子项目，负责声明微服务提供的能力，Feign 接口</span></span><br><span class="line">  <span class="string">|- xxx-yyy-zzz-service         // 实现微服务对外承诺的能力</span></span><br></pre></td></tr></table></figure>
<p>如上面代码块中的显示，api 子项目负责声明微服务提供的能力，以 Feign 接口的形式暴露，可以独立打包为 jar，并需要的项目引用。service 子项目负责实现微服务声明的能力。</p>
<p>这样，每个微服务成为高内聚的单元，可以供其他团队复用。微服务的维护人员，不必局限在原来小团队中，而是放眼整个部门，同时专注维护微服务本身。在团队治理上，也打破了原来几个团队之间的无形屏障。</p>
]]></content>
      
        <categories>
            
            <category> 技术管理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码组织 </tag>
            
            <tag> 团队管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xxx.app 已损坏，打不开。您应该将它移到废纸篓]]></title>
      <url>http://linfuyan.com/xxx-app-is-broken/</url>
      <content type="html"><![CDATA[<p>Mac 在安装一些 app 的时候，由于自身安全机制，会出现类似如下的提示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cornerstone<span class="selector-class">.app</span> 已损坏，打不开。您应该将它移到废纸篓。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果你要继续安装，需要打开<code>系统偏好设置-安全性与隐私-通用</code>，在<code>允许从以下位置下载应用中</code>选择<code>任何来源</code>。之后就可以正常安装了。</p>
<p>如果上面的操作没有看到<code>任何来源</code>的选项。通过以下命令开启。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl <span class="comment">--master-disable</span></span><br></pre></td></tr></table></figure>
<p>安装完成以后，通过以下命令隐藏<code>任何来源</code>选项。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl <span class="comment">--master-enable</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mac </tag>
            
            <tag> 安装 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建 spring cloud eureka server 高可用集群]]></title>
      <url>http://linfuyan.com/build-spring-cloud-eureka-server-ha/</url>
      <content type="html"><![CDATA[<h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h3><p>通过 <a href="http://start.spring.io" target="_blank" rel="noopener">start.spring.io</a> 生成项目代码，添加 <code>web</code>, <code>actuator</code>, <code>eureka server</code> 依赖。</p>
<p><img src="http://img.uprogrammer.cn/15560087270363.jpg" alt="通过 start.spring.io 生成代码"></p>
<p>解压源码包，在 idea 中打开项目。</p>
<a id="more"></a>
<p>在 <code>application.properties</code> 中添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=spring-cloud-eureka-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示是否注册自身到eureka服务器，默认为 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> eureka.client.register-with-eureka=<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否从eureka上获取注册信息，默认为 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> eureka.client.fetch-registry=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<h3 id="创建不同实例配置"><a href="#创建不同实例配置" class="headerlink" title="创建不同实例配置"></a>创建不同实例配置</h3><p>新建 <code>application-server1.properties</code>，<code>application-server2.properties</code>，<code>application-server3.properties</code> 三个文件，用于配置 3 个 eureka server 实例。</p>
<p><code>application-server1.properties</code> 内容如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.<span class="attribute">profiles</span>=server1</span><br><span class="line">server.<span class="attribute">port</span>=8761</span><br><span class="line"></span><br><span class="line">eureka.instance.<span class="attribute">hostname</span>=server1</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://server2:8762/eureka,http://server3:8763/eureka</span><br></pre></td></tr></table></figure>
<p><code>application-server2.properties</code> 内容如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.<span class="attribute">profiles</span>=server2</span><br><span class="line">server.<span class="attribute">port</span>=8762</span><br><span class="line"></span><br><span class="line">eureka.instance.<span class="attribute">hostname</span>=server2</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://server1:8761/eureka,http://server3:8763/eureka</span><br></pre></td></tr></table></figure>
<p><code>application-server3.properties</code> 内容如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.<span class="attribute">profiles</span>=server3</span><br><span class="line">server.<span class="attribute">port</span>=8763</span><br><span class="line"></span><br><span class="line">eureka.instance.<span class="attribute">hostname</span>=server3</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.<span class="attribute">defaultZone</span>=http://server1:8761/eureka,http://server2:8762/eureka</span><br></pre></td></tr></table></figure>
<h3 id="激活注册服务器"><a href="#激活注册服务器" class="headerlink" title="激活注册服务器"></a>激活注册服务器</h3><p>主启动类添加 <code>@EnableEurekaServer</code> 来激活注册服务器。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ltd.pinshi.springcloudeurekaserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaServerApplication</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringCloudEurekaServerApplication.<span class="keyword">class</span>, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置-hosts"><a href="#配置-hosts" class="headerlink" title="配置 hosts"></a>配置 hosts</h2><p>由于 3 个实例都运行在一台机器上，需要在 hosts 文件上做下配置。Mac 下为 <code>/etc/hosts</code>，在结尾添加以下映射，保存退出。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>       <span class="selector-tag">server1</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>       <span class="selector-tag">server2</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>       <span class="selector-tag">server3</span></span><br></pre></td></tr></table></figure>
<h2 id="启动-Eureka-Server-实例"><a href="#启动-Eureka-Server-实例" class="headerlink" title="启动 Eureka Server 实例"></a>启动 Eureka Server 实例</h2><h3 id="通过-idea-运行"><a href="#通过-idea-运行" class="headerlink" title="通过 idea 运行"></a>通过 idea 运行</h3><p><img src="http://img.uprogrammer.cn/15560094309585.jpg" alt="通过 idea 运行 eureka server 实例"></p>
<p>在 idea 右上角 <strong>Edit Configurations…</strong> 新建 3 个运行配置。在 <em>Program arguments</em> 中设置 <code>--spring.profiles.active=server1</code> 相应的启动场景。</p>
<p>点击右上角 <strong>Run</strong> 来启动实例。</p>
<h3 id="通过-jar-运行"><a href="#通过-jar-运行" class="headerlink" title="通过 jar 运行"></a>通过 jar 运行</h3><p>进入项目根目录，执行 <code>mvn clean package</code>。在 target 子目录下会生成 <code>spring-cloud-eureka-server-0.0.1-SNAPSHOT.jar</code> 文件。</p>
<p>通过以下命令分别启动 3 个实例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-cloud-eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT<span class="selector-class">.jar</span> --spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=server1 </span><br><span class="line">java -jar spring-cloud-eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT<span class="selector-class">.jar</span> --spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=server2</span><br><span class="line">java -jar spring-cloud-eureka-server-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT<span class="selector-class">.jar</span> --spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=server3</span><br></pre></td></tr></table></figure>
<h2 id="查看实例"><a href="#查看实例" class="headerlink" title="查看实例"></a>查看实例</h2><p>浏览器输入 <a href="http://localhost:8761" target="_blank" rel="noopener">http://localhost:8761</a>，内容如下：</p>
<p><img src="http://img.uprogrammer.cn/15560104281048.jpg" alt=""><br><img src="http://img.uprogrammer.cn/15560104567968.jpg" alt=""></p>
<p><a href="http://localhost:8762" target="_blank" rel="noopener">http://localhost:8762</a>，<a href="http://localhost:8763" target="_blank" rel="noopener">http://localhost:8763</a> 内容相似。</p>
<p>需要注意的是 <strong>DS Replicas</strong> 部分的内容。</p>
<p>通过 <strong>Instances currently registered with Eureka</strong> 可以看到注册了 3 个实例。</p>
<p><strong>General Info</strong> 中的 <code>registered-replicas</code>，<code>unavailable-replicas</code>，<code>available-replicas</code> 可以通过停止某个实例观察变化。</p>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>在 <code>application.properties</code> 中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示是否注册自身到eureka服务器，默认为 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> eureka.client.register-with-eureka=<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否从eureka上获取注册信息，默认为 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> eureka.client.fetch-registry=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p>大家可以取消这两个选项的注释，查看浏览器的内容显示。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> eureka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决 ssh 连接因闲置时间过长导致掉线的问题]]></title>
      <url>http://linfuyan.com/ssh-disconnect/</url>
      <content type="html"><![CDATA[<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>修改 <code>/etc/ssh/sshd_config</code></p>
<p>找到如下两行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ClientAliveInterval 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ClientAliveCountMax 3</span></span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 客户端每隔多少秒向服务发送一个心跳数据</span></span><br><span class="line">ClientAliveInterval 30 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端多少秒没有相应，服务器自动断掉连接</span></span><br><span class="line">ClientAliveCountMax 86400</span><br></pre></td></tr></table></figure>
<p>重启 sshd 服务</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service sshd restart</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://www.cnblogs.com/wanghetao/p/3872919.html" target="_blank" rel="noopener">解决ssh登录后闲置时间过长而断开连接</a></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> ssh </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 下 SSH 通过 .pem 登录]]></title>
      <url>http://linfuyan.com/mac-ssh-with-pem/</url>
      <content type="html"><![CDATA[<p>1. 基础命令如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -<span class="selector-tag">i</span> key<span class="selector-class">.pem</span> </span><br><span class="line">ssh -<span class="selector-tag">i</span> key<span class="selector-class">.pem</span> root@ip</span><br></pre></td></tr></table></figure>
<p>如果出现报错，说明文件的权限太大了，修改下权限。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod <span class="number">600</span> <span class="type">key</span>.pem</span><br></pre></td></tr></table></figure>
<p>2. 通过 ssh-add 添加 .pem 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span><span class="bash"> -k key.pem</span></span><br></pre></td></tr></table></figure>
<p>这样就可以通过 <code>ssh root@ip</code> 直接登录了。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> ssh </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启 Mac 自带的 Apache，配置 PHP 和虚拟主机]]></title>
      <url>http://linfuyan.com/mac_apache_php_enable/</url>
      <content type="html"><![CDATA[<p>Mac 系统本身就预装了 Apache 和 PHP 。分别通过 <code>apachectl -version</code> 和 <code>php -v</code> 进行查看。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  apachectl -version</span><br><span class="line">Server version: Apache/2.4.34 (Unix)</span><br><span class="line">Server built:   Aug 17 2018 18:35:43</span><br><span class="line">➜  php -v</span><br><span class="line">PHP 7.1.23 (cli) (built: Nov  7 2018 18:20:35) ( NTS )</span><br><span class="line">Copyright (c) 1997-2018 The PHP Group</span><br><span class="line">Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Apache-相关命令"><a href="#Apache-相关命令" class="headerlink" title="Apache 相关命令"></a>Apache 相关命令</h3><p>启动：<code>sudo apachectl start</code></p>
<p>停止：<code>sudo apachectl stop</code></p>
<p>重启：<code>sudo apachectl restart</code></p>
<p>查看版本号：<code>sudo apachectl -v</code></p>
<h3 id="添加-php-模块"><a href="#添加-php-模块" class="headerlink" title="添加 php 模块"></a>添加 php 模块</h3><p>通过 vi 打开 apache 的配置文件，配置文件需要超级权限才能进行读写。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> /etc/apache2/httpd.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>找到下面这行</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LoadModule php7_module libexec/apache2/libphp7.so</span></span><br></pre></td></tr></table></figure>
<p>去掉前面的 <code>#</code> 注释。</p>
<p>保存，退出，重启 apache 就可以生效了。</p>
<h3 id="配置-mysite-虚拟站点"><a href="#配置-mysite-虚拟站点" class="headerlink" title="配置 mysite 虚拟站点"></a>配置 mysite 虚拟站点</h3><h4 id="1-新建一个文件夹，作为你虚拟站点的物理存储位置"><a href="#1-新建一个文件夹，作为你虚拟站点的物理存储位置" class="headerlink" title="1. 新建一个文件夹，作为你虚拟站点的物理存储位置"></a>1. 新建一个文件夹，作为你虚拟站点的物理存储位置</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="selector-tag">p</span> /Users/your_user/...your_site</span><br></pre></td></tr></table></figure>
<h4 id="2-在-httpd-conf-中开启虚拟主机支持"><a href="#2-在-httpd-conf-中开启虚拟主机支持" class="headerlink" title="2. 在 httpd.conf 中开启虚拟主机支持"></a>2. 在 <code>httpd.conf</code> 中开启虚拟主机支持</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> /etc/apache2/httpd.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>找到下面这行</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">Include</span> /private/etc/apache2/extra/httpd-vhosts.conf</span></span><br></pre></td></tr></table></figure>
<p>去掉前面的 <code>#</code> 注释。</p>
<h4 id="3-添加-DocumentRoot"><a href="#3-添加-DocumentRoot" class="headerlink" title="3. 添加 DocumentRoot"></a>3. 添加 DocumentRoot</h4><p>找到 <code>httpd.conf</code> 中的如下内容</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot <span class="string">"/Library/WebServer/Documents"</span></span><br><span class="line">&lt;Directory <span class="string">"/Library/WebServer/Documents"</span> &gt;</span><br><span class="line"><span class="string">...</span></span><br><span class="line">&lt;<span class="string">/Directory</span>&gt;</span><br></pre></td></tr></table></figure>
<p>复制一份，直接添加到这段后面。</p>
<p>修改其中的 <code>/Library/WebServer/Documents</code> 为上面建好的文件夹路径 <code>/Users/your_user/...your_site</code>。</p>
<p>保存，退出 <code>httpd.conf</code>。</p>
<h4 id="4-添加虚拟主机配置"><a href="#4-添加虚拟主机配置" class="headerlink" title="4. 添加虚拟主机配置"></a>4. 添加虚拟主机配置</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/</span>apache2<span class="regexp">/extra/</span>httpd-vhost.conf</span><br></pre></td></tr></table></figure>
<p>在最后添加如下代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 'localhost' 虚拟主机</span></span><br><span class="line"><span class="section">&lt;VirtualHost *:80&gt;</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">DocumentRoot</span></span> <span class="string">"/Library/WebServer/Documents"</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">ServerName</span></span> localhost</span><br><span class="line">    <span class="attribute">ErrorLog</span> <span class="string">"/private/var/log/apache2/localhost-error_log"</span></span><br><span class="line">    <span class="attribute">CustomLog</span> <span class="string">"/private/var/log/apache2/localhost-access_log"</span> common </span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br><span class="line"><span class="comment"># 'mysite' 虚拟主机</span></span><br><span class="line"><span class="section">&lt;VirtualHost *:80&gt;</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">DocumentRoot</span></span> <span class="string">"/Users/your_user/...your_site"</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">ServerName</span></span> mysite</span><br><span class="line">    <span class="attribute">ErrorLog</span> <span class="string">"/private/var/log/apache2/mysite-error_log"</span></span><br><span class="line">    <span class="attribute">CustomLog</span> <span class="string">"/private/var/log/apache2/mysite-access_log"</span> common </span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存退出。重启 apache 服务。</p>
<h4 id="5-修改-etc-hosts"><a href="#5-修改-etc-hosts" class="headerlink" title="5. 修改 /etc/hosts"></a>5. 修改 <code>/etc/hosts</code></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure>
<p>添加 <code>127.0.0.1 mysite</code>，保存退出。</p>
<h4 id="6-添加-info-php"><a href="#6-添加-info-php" class="headerlink" title="6. 添加 info.php"></a>6. 添加 info.php</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/Users/y</span>our_user<span class="regexp">/...your_site/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p><code>info.php</code> 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> phpinfo();</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>保存退出。</p>
<h4 id="7-浏览器中测试"><a href="#7-浏览器中测试" class="headerlink" title="7. 浏览器中测试"></a>7. 浏览器中测试</h4><p>在浏览器中输入 <a href="http://mysite/info.php]" target="_blank" rel="noopener">http://mysite/info.php</a>，查看结果。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> LAMP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Apache </tag>
            
            <tag> Mac </tag>
            
            <tag> PHP </tag>
            
            <tag> VirtualHost </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker 搭建 zookeeper 集群]]></title>
      <url>http://linfuyan.com/docker-zookeeper-cluster/</url>
      <content type="html"><![CDATA[<h2 id="1-Zookeeper-基本使用"><a href="#1-Zookeeper-基本使用" class="headerlink" title="1. Zookeeper 基本使用"></a>1. Zookeeper 基本使用</h2><h3 id="下载-zookeeper-镜像"><a href="#下载-zookeeper-镜像" class="headerlink" title="下载 zookeeper 镜像"></a>下载 zookeeper 镜像</h3><p>默认下载最新版本，指定版本可以在 zookeeper 后面添加 tag，如 <code>zookeeper:latest</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="启动-zookeeper-镜像。"><a href="#启动-zookeeper-镜像。" class="headerlink" title="启动 zookeeper 镜像。"></a>启动 zookeeper 镜像。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name first-zk -d zookeeper</span><br></pre></td></tr></table></figure>
<p>这个命令会创建名为 first-zk 的 zookeeper 容器，在后台运行，并默认导出 2181 端口。</p>
<a id="more"></a>
<h3 id="测试-zookeeper-容器"><a href="#测试-zookeeper-容器" class="headerlink" title="测试 zookeeper 容器"></a>测试 zookeeper 容器</h3><p>以下命令通过输出日志可以查看 zk 运行情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f first-zk</span><br></pre></td></tr></table></figure>
<h3 id="客户端连接-zk-服务器"><a href="#客户端连接-zk-服务器" class="headerlink" title="客户端连接 zk 服务器"></a>客户端连接 zk 服务器</h3><p>1. 在已创建的 first-zk 容器中，执行 zkCli.sh：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it first-zk zkCli.sh</span><br></pre></td></tr></table></figure>
<p>2. 新建 zookeeper 容器作为客户端，并连接到 first-zk：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --link first-zk zookeeper zkCli.sh -server first-zk</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 <code>--link first-zk</code> 通过 docker 的 link 机制来访问 first-zk 容器；<br><code>--rm</code> 在容器退出后会自动删除容器；<br><code>zkCli.sh -server first-zk</code> 则启动 zkCli.sh 命令，连接到 first-zk。</p>
</blockquote>
<p>zkCli.sh 常用命令的使用，请参考<a href="">这里</a>。</p>
<h2 id="2-Zookeeper-集群搭建"><a href="#2-Zookeeper-集群搭建" class="headerlink" title="2. Zookeeper 集群搭建"></a>2. Zookeeper 集群搭建</h2><h3 id="编写-docker-compose-yml-文件"><a href="#编写-docker-compose-yml-文件" class="headerlink" title="编写 docker-compose.yml 文件"></a>编写 docker-compose.yml 文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    zk1:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">zk1</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"2181:2181"</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">            ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">            ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888</span> <span class="string">server.2=zk2:2888:3888</span> <span class="string">server.3=zk3:2888:3888</span></span><br><span class="line"><span class="attr">    zk2:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">zk2</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"2182:2181"</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">            ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">            ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888</span> <span class="string">server.2=zk2:2888:3888</span> <span class="string">server.3=zk3:2888:3888</span></span><br><span class="line"><span class="attr">    zk3:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">        restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">        container_name:</span> <span class="string">zk3</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"2183:2181"</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">            ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">            ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888</span> <span class="string">server.2=zk2:2888:3888</span> <span class="string">server.3=zk3:2888:3888</span></span><br></pre></td></tr></table></figure>
<p>在这个配置文件中，docker 运行了 3 个 zookeeper 镜像，通过 <code>ports</code> 字段分别将本地的 2181, 2182, 2183 端口绑定到对应容器的 2181 端口上。</p>
<blockquote>
<p><code>ZOO_MY_ID</code> 和 <code>ZOO_SERVERS</code> 是搭建 Zookeeper 集群需要的两个环境变量。<br><code>ZOO_MY_ID</code> 标识服务的 id，为 1-255 之间的整数，必须在集群中唯一。<br><code>ZOO_SERVERS</code> 是集群中的主机列表。</p>
</blockquote>
<p>在 <code>docker-compose.yml</code> 所在目录下执行 <code>COMPOSE_PROJECT_NAME=docker-zk-cluster docker-compose up</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  docker-zk-cluster COMPOSE_PROJECT_NAME=docker-zk-cluster docker-compose up</span><br><span class="line"></span><br><span class="line">Creating network "docker-zk-cluster_default" with the default driver</span><br><span class="line">Creating zk2 ... done</span><br><span class="line">Creating zk1 ... done</span><br><span class="line">Creating zk3 ... done</span><br><span class="line">Attaching to zk3, zk1, zk2</span><br><span class="line">zk3    | ZooKeeper JMX enabled by default</span><br><span class="line">zk1    | ZooKeeper JMX enabled by default</span><br><span class="line">zk2    | ZooKeeper JMX enabled by default</span><br><span class="line">zk2    | Using config: /conf/zoo.cfg</span><br><span class="line">zk3    | Using config: /conf/zoo.cfg</span><br><span class="line">zk1    | Using config: /conf/zoo.cfg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>COMPOSE_PROJECT_NAME=docker-zk-cluster</code> 设置该环境变量是为当前的 compose 工程取的名字，与其他工程做区分。</p>
</blockquote>
<p>启动后，打开另一终端窗口，运行 <code>COMPOSE_PROJECT_NAME=docker-zk-cluster docker-compose ps</code>，查看服务运行状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  COMPOSE_PROJECT_NAME=docker-zk-cluster docker-compose ps</span><br><span class="line"></span><br><span class="line">Name              Command               State                Ports</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">zk1    /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2181-&gt;2181/tcp,</span><br><span class="line">                                                2888/tcp, 3888/tcp</span><br><span class="line">zk2    /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2182-&gt;2181/tcp,</span><br><span class="line">                                                2888/tcp, 3888/tcp</span><br><span class="line">zk3    /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2183-&gt;2181/tcp,</span><br><span class="line">                                                2888/tcp, 3888/tcp</span><br></pre></td></tr></table></figure>
<h3 id="使用-Docker-命令行客户端连接-ZK-集群"><a href="#使用-Docker-命令行客户端连接-ZK-集群" class="headerlink" title="使用 Docker 命令行客户端连接 ZK 集群"></a>使用 Docker 命令行客户端连接 ZK 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --link zk1 --link zk2 --link zk3 --net docker-zk-cluster_default zookeeper zkCli.sh -server zk1:2181,zk2:2181,zk3:2181</span><br><span class="line">Connecting to zk1:2181,zk2:2181,zk3:2181</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--net docker-zk-cluster_default</code> 其中 <code>docker-zk-cluster</code> 是 compose 工程名，不作这个配置会导致 <code>docker: Error response from daemon: Cannot link to /zk1, as it does not belong to the default network.</code> 异常。具体原因请看<a href="https://segmentfault.com/q/1010000008238334/a-1020000008253855" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><p>通过 nc 命令连接到指定 Zookeeper 服务器，发送 stat 来查看状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo stat | nc localhost 2181</span><br><span class="line">Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.19.0.5:40210[1](queued=0,recved=31,sent=31)</span><br><span class="line"> /172.19.0.1:34682[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/2/76</span><br><span class="line">Received: 32</span><br><span class="line">Sent: 31</span><br><span class="line">Connections: 2</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x100000001</span><br><span class="line">Mode: follower</span><br><span class="line">Node count: 4</span><br><span class="line">➜  ~ echo stat | nc localhost 2182</span><br><span class="line">Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.19.0.1:37312[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 1</span><br><span class="line">Sent: 0</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x100000001</span><br><span class="line">Mode: follower</span><br><span class="line">Node count: 4</span><br><span class="line">➜  ~ echo stat | nc localhost 2183</span><br><span class="line">Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /172.19.0.1:54278[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 1</span><br><span class="line">Sent: 0</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x100000001</span><br><span class="line">Mode: leader</span><br><span class="line">Node count: 4</span><br><span class="line">Proposal sizes last/min/max: 36/36/36</span><br></pre></td></tr></table></figure>
<p>如上，我们发现 zk3（端口为 2183）为 leader，其他为 follower。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> 分布式架构 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记某店面试题]]></title>
      <url>http://linfuyan.com/interview-moudian/</url>
      <content type="html"><![CDATA[<h4 id="1-有-n-个整数元素的数组，如何获取其中最大的-k-个数？"><a href="#1-有-n-个整数元素的数组，如何获取其中最大的-k-个数？" class="headerlink" title="1. 有 n 个整数元素的数组，如何获取其中最大的 k 个数？"></a>1. 有 n 个整数元素的数组，如何获取其中最大的 k 个数？</h4><p>a. 先对数组的元素进行排序，然后再取其中的 k 个数。时间复杂度主要在排序算法上，可以做到 nlog(n)</p>
<p>b. 循环 1 - k，每个循环内对数组做一次冒泡取最大值，则时间复杂度 kn</p>
<p>c. 先取 k 个元素，建立小顶堆，再遍历剩下的元素，如果元素比堆顶大，则放入堆中根据需要调整堆形态。最终堆中的元素就是最大的 k 个。</p>
<blockquote>
<p>面试时很自然想到了 a 方案；b 想过，不过现场没有描述清楚；c 是参考了网络上的答案。</p>
</blockquote>
<a id="more"></a>
<h4 id="2-有-n-级台阶，一次可以走-1-步或者-2-步，问有多少种走法？"><a href="#2-有-n-级台阶，一次可以走-1-步或者-2-步，问有多少种走法？" class="headerlink" title="2. 有 n 级台阶，一次可以走 1 步或者 2 步，问有多少种走法？"></a>2. 有 n 级台阶，一次可以走 1 步或者 2 步，问有多少种走法？</h4><p>分析：n=1 的时候，只有走 1 步的方案；n=2 的时候，有走 2 个 1 步或 1 个 2 步 2个方案；而 n 步可以归纳为走 n-1 步的所有方案和走 n-2 步的所有方案的和。</p>
<p>a. 递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> x = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b. 迭代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试时最先想到的了 a 方案；b 方案脑海中一直没有想起来递归对应的迭代这个词。</p>
</blockquote>
<h4 id="3-Mysql-数据库中-一张-user-表，包含-id，name，reg-date（格式：yyyy-MM-dd，如2019-03-20）-字段，使用一条语句找出注册用户个数大于-100-的-reg-data"><a href="#3-Mysql-数据库中-一张-user-表，包含-id，name，reg-date（格式：yyyy-MM-dd，如2019-03-20）-字段，使用一条语句找出注册用户个数大于-100-的-reg-data" class="headerlink" title="3. Mysql 数据库中 一张 user 表，包含 id，name，reg_date（格式：yyyy-MM-dd，如2019-03-20） 字段，使用一条语句找出注册用户个数大于 100 的 reg_data"></a>3. Mysql 数据库中 一张 user 表，包含 id，name，reg_date（格式：yyyy-MM-dd，如2019-03-20） 字段，使用一条语句找出注册用户个数大于 100 的 reg_data</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">    reg_date, total</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    (select </span><br><span class="line">        reg_date, count(*) as total </span><br><span class="line">    <span class="keyword">from</span><span class="built_in"> user </span></span><br><span class="line">   <span class="built_in"> group </span>by reg_date) as tmp </span><br><span class="line">where total &gt; 100 </span><br><span class="line">order by total desc;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试时没有给出这条语句，group by 与 order by 各想了一部分，没有拼成一条语句。回来后用实例测试了一下。平时在应用中基本走简单查询。</p>
</blockquote>
<h4 id="4-数据库事务相关，如下："><a href="#4-数据库事务相关，如下：" class="headerlink" title="4. 数据库事务相关，如下："></a>4. 数据库事务相关，如下：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="number">4</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">开启事务</span></span><br><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="number">5</span><span class="string">;</span> <span class="bullet">----</span> <span class="string">①</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--②</span></span><br><span class="line"><span class="string">a</span> <span class="string">=</span> <span class="number">6</span><span class="string">;</span> <span class="meta">---</span> <span class="string">③</span></span><br><span class="line"><span class="string">//</span> <span class="string">提交事务</span></span><br></pre></td></tr></table></figure>
<p>问线程 A 运行到②时，线程 B 将读取到 a 的值是多少？</p>
<blockquote>
<p>面试时想到了数据库的事务隔离级别。未提交读、读已提交（不可重复读）、可重复读、串行化。<br>答曰：未提交读时结果是 5，读已提交时是 4。</p>
</blockquote>
<p>拓展：<a href="https://www.cnblogs.com/huanongying/p/7021555.html" target="_blank" rel="noopener">MySQL的四种事务隔离级别</a></p>
<h4 id="5-100-的阶乘的最终结果有多少个-0？"><a href="#5-100-的阶乘的最终结果有多少个-0？" class="headerlink" title="5. 100 的阶乘的最终结果有多少个 0？"></a>5. 100 的阶乘的最终结果有多少个 0？</h4><p>最终的结果是 24 个。</p>
<p>每个 5 和 10，会使结果多一个 0，其中 25，50，75，100 会多两个，所以 10 个 5 + 10 个 10 + 4 = 24 个。</p>
<blockquote>
<p>面试时给了 22 个的结果。未考虑到 25 和 75。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>题目 1，2，5 都是网上现成的题目，其实还是比较简单的。工作 10 年，很久没有参加面试了，也没有遇到面这些题目的。没有准备到，回答时只能根据自己临时的思路，回答的不尽如人意，比较遗憾。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[env: bash \r: No such file or directory]]></title>
      <url>http://linfuyan.com/env-bash-r-No-such-file-or-directory/</url>
      <content type="html"><![CDATA[<p>今天在 mac 下想打包一个 Android apk，执行 <code>./gradlew clean build</code>，报了如下提示：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">en</span><span class="variable">v:</span> bash \r: No such <span class="keyword">file</span> <span class="built_in">or</span> directory</span><br></pre></td></tr></table></figure>
<p>刚开始一头雾水，之前没有遇到过这个问题，而且这是提示没有什么可以跟踪的信息。在百思不得其解之际想到源码是朋友通过 windows 传给我的，随即想到 dos 下的换行与 unix 下换行不一致的特性。</p>
<p>所以通过 vi 打开 gradlew 文件，在命令模式下，执行：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="builtin-name">set</span> <span class="attribute">fileformat</span>=unix</span><br></pre></td></tr></table></figure>
<p>来切换文件格式为unix格式，并保存退出。</p>
<p>继续在终端中执行 <code>./gradlew clean build</code>，问题就解决了。</p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fileformat </tag>
            
            <tag> \r\n </tag>
            
            <tag> dos </tag>
            
            <tag> unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot 打包成 war]]></title>
      <url>http://linfuyan.com/springboot-package-to-war/</url>
      <content type="html"><![CDATA[<h2 id="pom-xml-修改"><a href="#pom-xml-修改" class="headerlink" title="pom.xml 修改"></a>pom.xml 修改</h2><h3 id="将-jar-修改为-war"><a href="#将-jar-修改为-war" class="headerlink" title="将 jar 修改为 war"></a>将 jar 修改为 war</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 Maven 创建 SpringBoot 项目，默认打包为 jar。</p>
<a id="more"></a>
<h3 id="在-spring-boot-starter-web-依赖中移除-tomcat-模块"><a href="#在-spring-boot-starter-web-依赖中移除-tomcat-模块" class="headerlink" title="在 spring-boot-starter-web 依赖中移除 tomcat 模块"></a>在 <code>spring-boot-starter-web</code> 依赖中移除 tomcat 模块</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot 自带 tomcat，需要移除</p>
<h3 id="添加-servlet-依赖"><a href="#添加-servlet-依赖" class="headerlink" title="添加 servlet 依赖"></a>添加 servlet 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-build-gt-节点中的-finalName-修改为-server-context-path-中的路径。"><a href="#lt-build-gt-节点中的-finalName-修改为-server-context-path-中的路径。" class="headerlink" title="&lt;build&gt; 节点中的 finalName 修改为 server.context-path 中的路径。"></a><code>&lt;build&gt;</code> 节点中的 <code>finalName</code> 修改为 server.context-path 中的路径。</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ...</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$</span><span class="template-variable">&#123;project.name&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="修改-SpringBoot-项目启动类，继承-SpringBootServletInitializer"><a href="#修改-SpringBoot-项目启动类，继承-SpringBootServletInitializer" class="headerlink" title="修改 SpringBoot 项目启动类，继承 SpringBootServletInitializer"></a>修改 SpringBoot 项目启动类，继承 <code>SpringBootServletInitializer</code></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">SpringApplicationBuilder</span> configure(<span class="type">SpringApplicationBuilder</span> builder) &#123;</span><br><span class="line">        <span class="comment">// 注意这里要指向原先用main方法执行的Application启动类</span></span><br><span class="line">        <span class="keyword">return</span> builder.sources(<span class="type">MySpringBootApplication</span>.<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">		<span class="type">SpringApplication</span>.run(<span class="type">MySpringBootApplication</span>.<span class="keyword">class</span>, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-mvn-打包"><a href="#使用-mvn-打包" class="headerlink" title="使用 mvn 打包"></a>使用 <code>mvn</code> 打包</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven<span class="selector-class">.test</span><span class="selector-class">.skip</span>=true</span><br></pre></td></tr></table></figure>
<p>在项目的 target 目录下就可以看到 .war 文件</p>
<h2 id="将-war-文件部署到-tomcat-的-webapps-目录下"><a href="#将-war-文件部署到-tomcat-的-webapps-目录下" class="headerlink" title="将 .war 文件部署到 tomcat 的 webapps 目录下"></a>将 .war 文件部署到 tomcat 的 webapps 目录下</h2>]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> springboot </tag>
            
            <tag> maven </tag>
            
            <tag> war </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 14.04 安装 jdk 1.8]]></title>
      <url>http://linfuyan.com/ubuntu14.04-install-jdk-1.8/</url>
      <content type="html"><![CDATA[<h2 id="删除低版本的-open-jdk"><a href="#删除低版本的-open-jdk" class="headerlink" title="删除低版本的 open jdk"></a>删除低版本的 open jdk</h2><p>ubuntu 14.04 默认的 java 版本为1.7，为了升级到 1.8并保持干净，我们先删除低版本的 open jdk。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> autoremove openjdk-7-jre</span><br></pre></td></tr></table></figure>
<p>执行完可以通过 <code>java -version</code> 来确认是否已经删除</p>
<a id="more"></a>
<h2 id="从-PPA-源安装-1-8-版本的-jdk"><a href="#从-PPA-源安装-1-8-版本的-jdk" class="headerlink" title="从 PPA 源安装 1.8 版本的 jdk"></a>从 PPA 源安装 1.8 版本的 jdk</h2><p>Oracle java 的 PPA 源： <a href="https://launchpad.net/~webupd8team/+archive/ubuntu/java" target="_blank" rel="noopener">https://launchpad.net/~webupd8team/+archive/ubuntu/java</a></p>
<p>在 shell 中执行如下命令：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:webupd8team/java</span><br><span class="line">// 更新 apt 源</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<p>执行上以上操作，同样可以输入 <code>java -version</code> 来确认是否新版 jdk 已经安装成功。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> jdk1.8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Laravel思维导图之Laravel入门指南]]></title>
      <url>http://linfuyan.com/mindmap-laravel-start-guide/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/static/images/%e7%b2%be%e8%bf%9b%e8%84%91%e5%9b%be%e4%b9%8bLaravel%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97.jpg" alt="精进脑图之Laravel入门指南"></p>
<blockquote>
<p>本系列思维导图整理自 Laravel 5.4 版本官方文档。</p>
<p>思维导图导出为图片时会导致其变模糊。需要高清的思维导图源文件，请关注微信公众号：<strong>up2048</strong>，并回复“<strong>精进脑图</strong>”来获取。</p>
</blockquote>
<p>今天我们就通过 4 张思维导图来快速看 Laravel 5.4 入门指南。</p>
<a id="more"></a>
<h2 id="Laravel-安装"><a href="#Laravel-安装" class="headerlink" title="Laravel 安装"></a>Laravel 安装</h2><p><img src="http://img.uprogrammer.cn/static/images/Laravel%e5%ae%89%e8%a3%85.png" alt="Laravel 安装"></p>
<h2 id="Laravel-配置信息"><a href="#Laravel-配置信息" class="headerlink" title="Laravel 配置信息"></a>Laravel 配置信息</h2><p><img src="http://img.uprogrammer.cn/static/images/Laravel%e9%85%8d%e7%bd%ae%e4%bf%a1%e6%81%af.png" alt="Laravel 配置信息"></p>
<h2 id="Laravel-文件夹结构"><a href="#Laravel-文件夹结构" class="headerlink" title="Laravel 文件夹结构"></a>Laravel 文件夹结构</h2><p><img src="http://img.uprogrammer.cn/static/images/Laravel%e6%96%87%e4%bb%b6%e5%a4%b9%e7%bb%93%e6%9e%84.png" alt="Laravel 结构"></p>
<h2 id="Laravel-请求生命周期"><a href="#Laravel-请求生命周期" class="headerlink" title="Laravel 请求生命周期"></a>Laravel 请求生命周期</h2><p><img src="http://img.uprogrammer.cn/static/images/Laravel%e8%af%b7%e6%b1%82%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f.png" alt="Laravel 请求生命周期"></p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下来，本人会继续对 Laravel 做比较系统的学习，会以思维导图的形式做梳理并于大家分享。这些文章都将首发在微信公众号：up2048 上。欢迎大家扫描下面的二维码，我们一起学习，分享，讨论，反思。</p>
<p>- EOF -</p>
<h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTE5MzYzOA==&amp;mid=2649861276&amp;idx=1&amp;sn=61e039b1eb87a330b84d1a70dbe72c0a&amp;chksm=8341d0d5b43659c32a5ec6849c9fbfa17303bb7fd9f623e9d2b1cd4f1e82b9b61c92d48a5013#rd" target="_blank" rel="noopener">十五张思维导图带你快速学习PHP言语基础</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十五张思维导图带你快速学习PHP语言基础]]></title>
      <url>http://linfuyan.com/mindmap-php-base/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/static/images/精进脑图之PHP基础.png" alt="精进脑图之PHP基础"></p>
<blockquote>
<p>在打算系统的学习 Laravel 之前，我抽空看了 PHP 语言基础，并且绘制了各个部分的思维导图，以方便自己从一些图片就可以查看相关知识的全貌。</p>
<p>这部分思维导图整理自菜鸟教程的 PHP 教程。</p>
<p>思维导图导出为图片时会导致其变模糊。需要高清的思维导图源文件，请关注微信公众号：<strong>up2048</strong>，并回复“<strong>精进脑图</strong>”来获取。</p>
</blockquote>
<p>下面我们就通过 15 张思维导图来快速学习 PHP 语言基础。</p>
<a id="more"></a>
<h2 id="0x00-PHP-简介"><a href="#0x00-PHP-简介" class="headerlink" title="0x00 PHP 简介"></a>0x00 PHP 简介</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP简介.png" alt="PHP简介"></p>
<h2 id="0x01-PHP-安装"><a href="#0x01-PHP-安装" class="headerlink" title="0x01 PHP 安装"></a>0x01 PHP 安装</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP安装.png" alt="PHP安装"></p>
<h2 id="0x02-PHP-语法"><a href="#0x02-PHP-语法" class="headerlink" title="0x02 PHP 语法"></a>0x02 PHP 语法</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP语法.png" alt="PHP语法"></p>
<h2 id="0x03-PHP-数据类型"><a href="#0x03-PHP-数据类型" class="headerlink" title="0x03 PHP 数据类型"></a>0x03 PHP 数据类型</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP数据类型.png" alt="PHP数据类型"></p>
<h2 id="0x04-PHP-变量"><a href="#0x04-PHP-变量" class="headerlink" title="0x04 PHP 变量"></a>0x04 PHP 变量</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP变量.png" alt="PHP变量"></p>
<h2 id="0x05-PHP-数组"><a href="#0x05-PHP-数组" class="headerlink" title="0x05 PHP 数组"></a>0x05 PHP 数组</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP数组.png" alt="PHP数组"></p>
<h2 id="0x06-PHP-常量"><a href="#0x06-PHP-常量" class="headerlink" title="0x06 PHP 常量"></a>0x06 PHP 常量</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP常量.png" alt="PHP常量"></p>
<h2 id="0x07-PHP-超级全局变量"><a href="#0x07-PHP-超级全局变量" class="headerlink" title="0x07 PHP 超级全局变量"></a>0x07 PHP 超级全局变量</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP超级全局变量.png" alt="PHP超级全局变量"></p>
<h2 id="0x08-PHP-魔术变量"><a href="#0x08-PHP-魔术变量" class="headerlink" title="0x08 PHP 魔术变量"></a>0x08 PHP 魔术变量</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP魔术变量.png" alt="PHP魔术变量"></p>
<h2 id="0x09-PHP-运算符"><a href="#0x09-PHP-运算符" class="headerlink" title="0x09 PHP 运算符"></a>0x09 PHP 运算符</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP运算符.png" alt="PHP运算符"></p>
<h2 id="0x0A-PHP-流程语句"><a href="#0x0A-PHP-流程语句" class="headerlink" title="0x0A PHP 流程语句"></a>0x0A PHP 流程语句</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP流程语句.png" alt="PHP流程语句"></p>
<h2 id="0x0B-PHP-函数"><a href="#0x0B-PHP-函数" class="headerlink" title="0x0B PHP 函数"></a>0x0B PHP 函数</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP函数.png" alt="PHP函数"></p>
<h2 id="0x0C-PHP-命名空间"><a href="#0x0C-PHP-命名空间" class="headerlink" title="0x0C PHP 命名空间"></a>0x0C PHP 命名空间</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP命名空间.png" alt="PHP命名空间"></p>
<h2 id="0x0D-PHP-面向对象"><a href="#0x0D-PHP-面向对象" class="headerlink" title="0x0D PHP 面向对象"></a>0x0D PHP 面向对象</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP面向对象.png" alt="PHP面向对象"></p>
<h2 id="0x0E-PHP-错误与异常"><a href="#0x0E-PHP-错误与异常" class="headerlink" title="0x0E PHP 错误与异常"></a>0x0E PHP 错误与异常</h2><p><img src="http://img.uprogrammer.cn/static/images/PHP错误与异常.png" alt="PHP错误与异常"></p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>接下来，本人会对 Laravel 做比较系统的学习，会以思维导图的形式做梳理并于大家分享。这些文章都将首发在微信公众号：up2048 上。欢迎大家扫描下面的二维码，我们一起学习，分享，讨论，反思。</p>
<h2 id="EOF"><a href="#EOF" class="headerlink" title="- EOF -"></a>- EOF -</h2>]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【小白必读】微信小程序 https 支持导致的问题及配置 https 支持的流程]]></title>
      <url>http://linfuyan.com/weapp-https/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近泡在好几个微信小程序QQ群里，发现大家提的好多问题是由于微信小程序的 https 支持引起的，这篇文章里面对于微信小程序的 https 相关问题做一些说明。</p>
</blockquote>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>哪些情况可能是由于 https 的配置导致的？</p>
<p>1. 小程序页面出现白屏</p>
<p>大部分的小程序页面需要通过服务器接口返回的数据进行填充之后才能展示，由于 https 的配置错误，导致数据无法获取到，表现在小程序的界面上就是这个页面没有数据，看起来白屏。有的小伙伴儿在开发的时候是能拿到数据，显示没有问题的，而提交审核以后却因为没有显示数据而不通过，就是这个原因。</p>
<p>2. 应该显示图片的部分没有内容显示</p>
<p>这个的原因和第一个其实是一样的，返回的图片的地址是 <code>http://</code> 开头，或者返回图片路径不对。所有无法加载出来。</p>
<p>3. 调用 <code>wx.downloadFile/wx.uploadFile</code> 失败</p>
<p>出现上面这些问题时，终端上的调试信息差不多是这样：</p>
<p><img src="http://img.uprogrammer.cn/static/images/wxapp-https-debug.png" alt="微信https问题调试"></p>
<a id="more"></a>
<h2 id="问题缘起"><a href="#问题缘起" class="headerlink" title="问题缘起"></a>问题缘起</h2><p><strong>正式上线的微信小程序仅支持 https 的请求，包括 <code>wx.request</code>, <code>wx.uploadFile</code>, <code>wx.downloadFile</code> 等 API，以及其他支持网络资源的组件，如 <code>&lt;image&gt;</code></strong>。</p>
<p>具体可以参看相关的 API 说明。</p>
<p>很多小伙伴儿疑惑，我的小程序接口不是 https 的呀，网上获取到的很多实例代码也都不是，为什么在微信 web 开发者工具里面都可以正常的跑起来呢？有更多的人可能在疑惑，为啥很多实例代码跑起来以后白屏或者图片不显示呢？</p>
<p>上面提到一个限定：<strong>正式上线的微信小程序</strong>仅支持 https 请求。正式环境为了安全，那开发环境也按照正式环境的标准来要求，就会有很多的不方便了。所以在开发环境下，微信小程序是可以支持 http 请求的，这在微信 web 开发者工具中可以配置。</p>
<p><img src="http://img.uprogrammer.cn/static/images/wxapp-https-switch.png" alt="微信https开关"></p>
<p>如上图，勾选最后的选项，开发环境下，不需要 https 请求，也能够获取到网络请求的数据了。所以从网络上下载了实例代码的小伙伴儿，如果出现白屏或者图片不显示，检查一下请求的 url，检查一下这块的配置，再跑起来看看是不是已经可以了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>确定了问题是因为没有 https 支持导致的，那接下来该怎么解决呢？</p>
<p><strong>显然解决方案是为来自服务端的请求加上 https 支持，为 <code>wx.uploadFile</code> 等 API 的请求域名加上 https 支持。</strong></p>
<p>为微信小程序配置 https 支持的步骤如下：</p>
<ol>
<li>具有部署服务端代码的空间及访问服务的域名</li>
<li>根据需要申请到域名对应的 https 证书</li>
<li>配置 web 服务器，使其支持 https</li>
<li>微信小程序后台配置对应的域名</li>
<li>微信小程序代码上的请求链接修改为 https</li>
</ol>
<h3 id="空间和域名"><a href="#空间和域名" class="headerlink" title="空间和域名"></a>空间和域名</h3><p>你的服务端代码最终是要部署到空间或者云服务器上的。最终上线的微信小程序服务器必须有域名，IP 地址是不支持的。所以你还必须有个域名。</p>
<p>空间/云服务器，域名哪里来，怎么申请，就不说了。如果你在公司，应该有专门的人来搞这个，或者已经都有了。如果你是个人，以前没接触过，可能需要花时间了解一下。</p>
<h3 id="https-证书申请"><a href="#https-证书申请" class="headerlink" title="https 证书申请"></a>https 证书申请</h3><p>有了域名，就可以针对域名申请 https 证书了。支持 https 的证书有许多这种，现在网上可以申请到免费的 https 证书。阿里云、七牛、腾讯云、let’s encrypt 等都有。具体这里也不展开。</p>
<h3 id="web-服务器配置"><a href="#web-服务器配置" class="headerlink" title="web 服务器配置"></a>web 服务器配置</h3><p>一般服务部署以后，是通过 web 服务器才访问到的。由于使用的技术五花八门，而你可能只接触到了开发环境，对最后的上线不太了解。这里只大略提一下。</p>
<p>大部分的开发人员，如果是 Java 开发后台，可能开发测试是在 tomcat 上跑的，本地测试经常访问 <code>http://localhost:8080</code> 这样；如果是 php，可能用的 phpstorm，运行起来以后，也是直接带个本地地址访问；又或者是 nodejs 的，命令行启动以后，内置的服务器就跑起来可以访问了；总而言之，最后的部署环境和开发时是不一样的。</p>
<p>针对不同的技术，有其自己特有的 https 配置方案。如果你是这种情况，根据需要查找资料吧。但一般企业应用有更通用的做法。</p>
<p>最后部署时，一般有 nginx 或者 apache，做反向代理及负载均衡等，然后才访问到真正的服务端业务代码。</p>
<p>举个例子：我用 Java 开发了后台服务程序，并且跑在 tomcat 上。然后正式对外时，我用 nginx 做反向代理。那么这个看起来就像下面图所示。</p>
<p><img src="http://img.uprogrammer.cn/static/images/server-deploy-arch.png" alt="服务端部署架构"></p>
<p>这时，通常就是对 nginx 做支持 https 的配置，以及配置反向代理。</p>
<h3 id="小程序后台配置"><a href="#小程序后台配置" class="headerlink" title="小程序后台配置"></a>小程序后台配置</h3><p><img src="http://img.uprogrammer.cn/static/images/https-required.png" alt="小程序后台配置 https"></p>
<p>当服务器的 https 支持配置完成以后，需要在小程序后台中配置上合法的服务器域名。必须针对不同的 API 使用，配置对应的域名。</p>
<h3 id="修改小程序代码，用-https-访问"><a href="#修改小程序代码，用-https-访问" class="headerlink" title="修改小程序代码，用 https 访问"></a>修改小程序代码，用 https 访问</h3><p>一切准备就绪，接下来就是修改小程序上的请求代码，用 https 访问。再将开发工具上的 https 验证的开发打开。这时候应该程序正常响应了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 https 配置导致的小程序问题，以及配置 https 支持需要的流程。每个部分都只粗略地提到，之所以没有具体说明，是因为每块都有挺多的内容可以讲。而针对小伙伴儿们不同的环境，又会有各种不同的方案。流程在这里了，每块具体内容大家自己查资料。后续我也可能针对具体内容写一些文章。欢迎到微信公众号“非典型程序员(up2048)”给我留言。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 微信 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Android 上开始使用 Kotlin]]></title>
      <url>http://linfuyan.com/android-kotlin-get-started/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://developer.android.com/kotlin/get-started.html" target="_blank" rel="noopener">https://developer.android.com/kotlin/get-started.html</a></p>
</blockquote>
<p>Android Studio 3.0 完整的支持 Kotlin，因此下面的这些操作都很方便。包括通过 Kotlin 文件创建新的项目，添加新的 Kotlin 文件到已有项目中，或者将 Java 语言代码转为 Kotlin。同时，你也可以针对 Kotlin 代码来使用所有 Android Studio已有的工具，如自动补全，lint 检查，重构，调试等。</p>
<p>这篇文章将介绍如何再 Android Studio 中开始使用 Kotlin。</p>
<a id="more"></a>
<h2 id="创建新项目来使用-Kotlin"><a href="#创建新项目来使用-Kotlin" class="headerlink" title="创建新项目来使用 Kotlin"></a>创建新项目来使用 Kotlin</h2><p>在新项目中使用 Kotlin，仅需要在新项目向导中一个额外的点击：</p>
<ol>
<li>在 Android Studio 中，点击<strong>文件(File) &gt; 新建(New) &gt; 新项目(New Project)</strong>。或者你刚刚打开 Android Studio，看到了 Android Studio 的欢迎窗口，那么点击<strong>开始一个新的 Android Studio 项目</strong>。</li>
<li>在第一个屏幕，选中<strong>包含 Kotlin 支持(Include Kotlin Support)</strong>。就只有这一个唯一的区别。</li>
<li>点击<strong>下一步(Next)</strong>并继续后面的向导直到结束。</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/kotlin-new-project_2x.png" alt="kotlin-new-project"></p>
<p>当你选择了一个 Activity 模板，它将以 Kotlin 代码提供。现在，至于一些<strong>手机和平板</strong>的模板提供了惯用的 Kotlin 代码。其他的则是从 Java 模板自动转化为 Kotlin。你仍然得到的是 Kotlin 代码，但是某些代码没有使用 Kotlin 最佳的语言特性。</p>
<p>与 Java 文件一样，Kotlin 文件被保存在 <code>src/main/java/</code> 目录下。</p>
<h2 id="在现有项目中添加-Kotlin"><a href="#在现有项目中添加-Kotlin" class="headerlink" title="在现有项目中添加 Kotlin"></a>在现有项目中添加 Kotlin</h2><p>如果你想要添加 Kotlin 代码到现有的项目中，简单点击<strong>文件(File) &gt; 新建(New)</strong>，并从中选择一个 Android 模板。如果你没有在菜单中看到模板列表，需要先打开<strong>项目(Project)</strong>窗口，并选择你的 App 模块。</p>
<p><img src="http://img.uprogrammer.cn/static/images/new-template-menu_2x.png" alt="new-template-menu"></p>
<p>在展示的向导中，为<strong>源代码(Source Language)</strong>选择 Kotlin。</p>
<p><img src="http://img.uprogrammer.cn/static/images/kotlin-new-activity_2x.png" alt="kotlin-new-activity"></p>
<p>继续后面的向导，直到结束。</p>
<p>此外，你可以点击<strong>文件(File) &gt; 新建(New) &gt; Kotlin文件/类(Kotlin File/Class)</strong>来创建基础文件。<strong>新建Kotlin文件/类</strong>窗口提供了不同文件类型的选择，但不用太在意你选择了那种文件。因为当你以后改变了声明方式， Kotlin 会自动切换文件类型。</p>
<p>默认情况下，新的 Kotlin 文件会被保存在 <code>src/main/java/</code> 中。你会发现 Kotlin 和 Java 文件在一个位置。如果你更喜欢将 Kotlin 文件与 Java 文件分开，你可以把 Kotlin 文件放到 <code>src/main/kotlin/</code> 目录下。这样做，你需要修改 sourceSets 的配置来包含该目录。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   sourceSets &#123;</span><br><span class="line">       main<span class="selector-class">.java</span><span class="selector-class">.srcDirs</span> += <span class="string">'src/main/kotlin'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换现有的-Java-代码为-Kotlin-代码"><a href="#转换现有的-Java-代码为-Kotlin-代码" class="headerlink" title="转换现有的 Java 代码为 Kotlin 代码"></a>转换现有的 Java 代码为 Kotlin 代码</h2><p>在 Android Studio 3.0 中，打开 Java 文件，并且选择<strong>代码(Code) &gt; 转换 Java 文件为 Kotlin 文件</strong>。</p>
<p>或者创建新的 Kotlin 文件(<strong>File &gt; New &gt; Kotlin File/Class</strong>)，然后粘贴 Java 代码到该文件里，当弹出提示时，点击<strong>是</strong>来转换代码到 Kotlin。你可以选中<strong>下次不再显示该对话框</strong>来取消同样操作时的提示。</p>
<p><img src="http://img.uprogrammer.cn/static/images/kotlin-convert_2x.png" alt="kotlin-convert"></p>
<h2 id="Kotlin-如何来使用-Android-API"><a href="#Kotlin-如何来使用-Android-API" class="headerlink" title="Kotlin 如何来使用 Android API"></a>Kotlin 如何来使用 Android API</h2><p>Kotlin 提供了与 Java 语言完整的互操作性，所以调用 Android API 看起来与 Java 代码几乎一样。此外，你还可以将这些方法调用与Kotlin的语法特征相结合。</p>
<p>下面是一些如何在 Kotlin 中调用 Android API 的例子，同时对比 Java 的相同代码。</p>
<p><strong>在 Kotlin 中声明 Activity</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 Java 中声明 Activity</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(<span class="type">R</span>.layout.activity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin 中的 On-click listener</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val fab = findViewById(R<span class="selector-class">.id</span><span class="selector-class">.fab</span>) as FloatingActionButton</span><br><span class="line">fab<span class="selector-class">.setOnClickListener</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java 中的 On-click listener</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</span><br><span class="line">fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin 中的 Item click listener</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private val mOnNavigationItemSelectedListener</span><br><span class="line">    = BottomNavigationView<span class="selector-class">.OnNavigationItemSelectedListener</span> &#123; item -&gt;</span><br><span class="line">  when (item.itemId) &#123;</span><br><span class="line">    R<span class="selector-class">.id</span><span class="selector-class">.navigation_home</span> -&gt; &#123;</span><br><span class="line">      mTextMessage.setText(R<span class="selector-class">.string</span><span class="selector-class">.title_home</span>)</span><br><span class="line">      return@OnNavigationItemSelectedListener true</span><br><span class="line">    &#125;</span><br><span class="line">    R<span class="selector-class">.id</span><span class="selector-class">.navigation_dashboard</span> -&gt; &#123;</span><br><span class="line">      mTextMessage.setText(R<span class="selector-class">.string</span><span class="selector-class">.title_dashboard</span>)</span><br><span class="line">      return@OnNavigationItemSelectedListener true</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java 中的 Item click listener</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener</span><br><span class="line">    = <span class="keyword">new</span> BottomNavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> onNavigationItemSelected(<span class="meta">@NonNull</span> MenuItem item) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">      <span class="keyword">case</span> R.id.<span class="string">navigation_home:</span></span><br><span class="line">        mTextMessage.setText(R.string.title_home);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> R.id.<span class="string">navigation_dashboard:</span></span><br><span class="line">        mTextMessage.setText(R.string.title_dashboard);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>如果你还没有入坑，那我告诉你，是时候学习 Kotlin 了。</p>
<p><a href="http://uprogrammer.cn/kotlin-in-chinese/index.html" target="_blank" rel="noopener">Kotlin 中文文档</a></p>
<p><a href="http://uprogrammer.cn/kotlin-for-android-developers-zh/index.html" target="_blank" rel="noopener">写给 Android 开发者的 Kotlin 教程</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android O </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Google IO 2017 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin 成为 Android 官方语言，看看官方怎么说？]]></title>
      <url>http://linfuyan.com/android-kotlin/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://developer.android.com/kotlin/index.html" target="_blank" rel="noopener">https://developer.android.com/kotlin/index.html</a></p>
</blockquote>
<p>伴随着开发者持续增长的兴趣，我们发现多年来 Android 开发中 Kotlin 被越来越多地采用。 Kotlin 具有很好的表现力，简洁，容易扩展，强大，并有优雅的可读写性。在可空性和不变性的处理上，有非常精彩的安全特性。这与我们想要让 Android 应用更加健壮和高效方面的投入相吻合。最重要的是，它与现有的 Android 语言及运行时可以相互操作。所以我们很高兴地让 Kotlin 成为 Android 上的官方语言。</p>
<a id="more"></a>
<p>如果你对使用 Kotlin 感兴趣，那么这将很容易开始。因为它可以与 Android 和 Android 平台上的 Java 和 C++ 搭配使用。所以你可以保持原有的代码，继续使用不同的 Android 库，并添加 Kotlin 代码到你的项目中。与其他多数语言不同， Kotlin 是可以双向使用的替代品。你可以从 Kotlin 调用 Java 语言，也可以从 Java 调用 Kotlin。</p>
<p>当然， IDE 的支持也是至关重要的，并且我们也已经拥有它。 Android Studio 是基于 JetBrains 开发的 IDE 产品 IntelliJ IDEA 来构建的。而正是这家公司发明了 Kotlin 语言。 JetBrains 的团队已经为能够让 Kotlin 在 IntelliJ IDEA 完美运行工作了很多年。所以我们将继承他们的辛勤工作。从 Android Studio 3.0 开始，对 Kotlin 的支持工具将直接集成在 Android Studio 中。</p>
<p>我们认为 Kotlin 非常适合 Android，不仅因为它为开发者提供了他们想要的，而且还因为它符合 Android 的精神。与 Android 一样， Kotlin 一直是 Apache 2 下开放源代码项目。它涉及整个社区，而不仅仅是一家公司。我们正在与 JetBrains 合作，把 Kotlin 转为一个非盈利的机构。</p>
<p>对于选择 Kotlin，正是我们对于“随着 Android 平台的不断发展和壮大，我们致力于开放开发者生态”的理念的重申。 Kotlin 语言的发展让我们感到兴奋。</p>
<hr>
<p>如果你还没有入坑，那我告诉你，是时候学习 Kotlin 了。</p>
<p><a href="http://uprogrammer.cn/kotlin-in-chinese/index.html" target="_blank" rel="noopener">Kotlin 中文文档</a></p>
<p><a href="http://uprogrammer.cn/kotlin-for-android-developers-zh/index.html" target="_blank" rel="noopener">写给 Android 开发者的 Kotlin 教程</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android O </tag>
            
            <tag> Kotlin </tag>
            
            <tag> Google IO 2017 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java Swing 代码打包成 Windows 上的 exe 文件]]></title>
      <url>http://linfuyan.com/java-swing-drag-jar-exe/</url>
      <content type="html"><![CDATA[<p>年前抽空给朋友做了个小东西。具体功能就不说了。对于他的最终需求，概括的说就是：需要一个满足功能的在 windows 上的 .exe 文件。桌面开发我不熟，后来基于 Java Swing 给实现了。在实现过程中，几个关键点记下来做备忘。</p>
<ol>
<li>拖拽文件到界面的输入框中，后续对文件进行处理。简化一下，拖拽文件到输入框，并获取文件路径。</li>
<li>项目的依赖是用 Gradle 来管理的，功能实现依赖第三方 jar，最终需要打包成一个可执行 jar。</li>
<li>将制作好的 jar 打包成 .exe 文件。</li>
</ol>
<a id="more"></a>
<h2 id="1-实现拖拽文件到指定控件，并获取文件路径"><a href="#1-实现拖拽文件到指定控件，并获取文件路径" class="headerlink" title="1. 实现拖拽文件到指定控件，并获取文件路径"></a>1. 实现拖拽文件到指定控件，并获取文件路径</h2><p>直接上核心代码，具体看注释。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.awt.datatransfer.DataFlavor;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.awt.dnd.DnDConstants;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.awt.dnd.DropTarget;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.awt.dnd.DropTargetAdapter;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.awt.dnd.DropTargetDropEvent;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拖拽文件到控件,并处理</span></span><br><span class="line"><span class="comment">     * @param component 要接受拖拽的控件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> drag(Component component) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> DropTarget(component, DnDConstants.ACTION_COPY_OR_MOVE, <span class="keyword">new</span> DropTargetAdapter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重写适配器的drop方法,实现自己需要的逻辑</span></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> drop(DropTargetDropEvent event) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果拖入的文件格式受支持</span></span><br><span class="line">                    <span class="keyword">if</span> (event.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) &#123;</span><br><span class="line">                        <span class="comment">// 接收拖拽来的数据</span></span><br><span class="line">                        event.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);</span><br><span class="line">                        <span class="comment">// 读取传递过来的数据</span></span><br><span class="line">                        java.util.List&lt;File&gt; list = (java.util.List&lt;File&gt;) (event.getTransferable().getTransferData(DataFlavor.javaFileListFlavor));</span><br><span class="line">                        <span class="comment">// 对传递过来的数据做处理</span></span><br><span class="line">                        <span class="comment">// do what you want to do</span></span><br><span class="line">                        event.dropComplete(<span class="literal">true</span>); <span class="comment">// 指示拖拽操作已完成</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        event.rejectDrop(); <span class="comment">// 否则拒绝拖拽来的数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-通过-Gradle-制作可执行的-jar-文件"><a href="#2-通过-Gradle-制作可执行的-jar-文件" class="headerlink" title="2. 通过 Gradle 制作可执行的 jar 文件"></a>2. 通过 Gradle 制作可执行的 jar 文件</h2><p>参考这里：<a href="http://stackoverflow.com/questions/21721119/creating-runnable-jar-with-gradle" target="_blank" rel="noopener">Creating runnable JAR with Gradle</a></p>
<p>里面提到了两种方案，一种是直接使用 application 插件，另一种是 shadowJar 插件。</p>
<p>我最终采用了 shadowJar 的方式实现，核心代码如下：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    <span class="attribute">repositories &#123;</span></span><br><span class="line"><span class="attribute">        maven &#123;</span></span><br><span class="line"><span class="attribute">            url "https</span>://plugins<span class="variable">.gradle</span><span class="variable">.org</span>/m2/"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath "com<span class="variable">.github</span><span class="variable">.jengelman</span><span class="variable">.gradle</span><span class="variable">.plugins</span>:shadow:1.2.4"</span><br><span class="line">        classpath 'gradle<span class="variable">.plugin</span><span class="variable">.edu</span><span class="variable">.sc</span><span class="variable">.seis</span><span class="variable">.gradle</span>:launch4j:2.3.0'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: 'java'</span><br><span class="line">apply plugin: 'com<span class="variable">.github</span><span class="variable">.johnrengelman</span><span class="variable">.shadow</span>'</span><br><span class="line"></span><br><span class="line">mainClassName = "your<span class="variable">.main</span><span class="variable">.ClassName</span>"</span><br><span class="line"></span><br><span class="line">shadowJar &#123;</span><br><span class="line">    baseName = 'your_jar_name'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包的命令行如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> shadowJar</span><br></pre></td></tr></table></figure>
<p>完成后，就可以在 build/libs 目录下找到 <code>*-all.jar</code>。</p>
<p>使用 <code>java -jar your-app-all.jar</code> 运行，看下你的程序已经跑起来了。</p>
<h2 id="3-将-jar-制作成-windows-下的-exe-文件"><a href="#3-将-jar-制作成-windows-下的-exe-文件" class="headerlink" title="3. 将 jar 制作成 windows 下的 exe 文件"></a>3. 将 jar 制作成 windows 下的 exe 文件</h2><p>网上找了很多这方面的工具，最终我发现 launch4j 真是个好用的东西。</p>
<p>我使用的是 launch4j 的 mac 版。这东西是跨平台的。</p>
<p>由于 java 的运行离不开 jre 环境，而除了开发人员，正常用户电脑上基本没有环境。所以我们打包的时候，需要把 jre 一起打包。</p>
<p>mac 上用 launch4j 来将 jar 打包成在 windows 上运行的 exe，还有一点需要注意，就是用于打包的 jre 必须是 windows 下的。</p>
<p>最简单的 launch4j 配置只需两步，就可以把 jar 打包成 exe了。</p>
<p><img src="http://img.uprogrammer.cn/static/images/jar2exe-1.png" alt="launch4j 基础配置"></p>
<p><img src="http://img.uprogrammer.cn/static/images/jar2exe-2.png" alt="launch4j jre 配置"></p>
<p><strong>jre</strong> 要放置在最终打包的 exe 的同级目录下。这边主要是因为打包后的 exe 是通过相对路径来寻找依赖的 jre。如果配置错误，将导致后面的 exe 文件无法运行。</p>
<p>到这里，最终打包的 exe 是可以运行了。不过 jre 包和 exe 文件是分开的。可以把这些东西，放在一个文件夹下再压缩，最后分发给用户。</p>
<p>还可以把  jre 一起打包到 exe 中。以后有时间我在处理。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 经验实践 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> swing </tag>
            
            <tag> shadowJar </tag>
            
            <tag> launch4j </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树莓派折腾记之第一天]]></title>
      <url>http://linfuyan.com/raspberrypi-day1/</url>
      <content type="html"><![CDATA[<p>周五晚上开箱晒图以后，直到周日才有时间开始折腾我的树莓派。</p>
<p>今天第一个小目标，就是点亮树莓派。</p>
<p>先说一下我自己拥有的设备。</p>
<ol>
<li>mac 电脑，没有 windows 系统。</li>
<li>没有键盘，有一个无线鼠标。</li>
<li>一台有 HDMI 接口的电视机。</li>
<li>网线一根</li>
</ol>
<p>另外就是我之前买回来的树莓派及配件了。</p>
<a id="more"></a>
<h2 id="Mac-上给树莓派安装-Raspbian"><a href="#Mac-上给树莓派安装-Raspbian" class="headerlink" title="Mac 上给树莓派安装 Raspbian"></a>Mac 上给树莓派安装 Raspbian</h2><p>树莓派支持的系统有很多，官方推荐的是 Raspbian。</p>
<h3 id="下载系统镜像"><a href="#下载系统镜像" class="headerlink" title="下载系统镜像"></a>下载系统镜像</h3><p>到<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">树莓派官网</a>下载 raspbian 的镜像文件。我的是 2017-03-02-raspbian-jessie.zip，1.57 G。解压出来成 2017-03-02-raspbian-jessie.img，有 4.39 G。</p>
<h3 id="格式化-SD-卡"><a href="#格式化-SD-卡" class="headerlink" title="格式化 SD 卡"></a>格式化 SD 卡</h3><p>使用 Mac 自带的磁盘工具，左侧选中对应的 SD 卡，点击右侧的“抹掉”标签，格式选择“MS-DOS(FAT)”，名称根据自己需要填写。</p>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-format-sdcard.png" alt="格式化 SD 卡"></p>
<h3 id="命令行查看挂载的卷"><a href="#命令行查看挂载的卷" class="headerlink" title="命令行查看挂载的卷"></a>命令行查看挂载的卷</h3><p>打开 Mac 终端，在命令行中输入 <code>df -h</code></p>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-df-h.png" alt="查看挂载的卷"></p>
<p>在这里可以看到挂载的 SD 卡，类似 <code>/dev/disk3s1</code>。</p>
<h3 id="卸载分区"><a href="#卸载分区" class="headerlink" title="卸载分区"></a>卸载分区</h3><p>在磁盘工具中，同样选中对应的 SD 卡，点击右侧标签上的卸载。</p>
<p>或者使用命令行工具：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil unmount <span class="regexp">/dev/</span>disk3s1</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-unmount.png" alt="卸载分区"></p>
<h3 id="确认-SD-卡设备的标识"><a href="#确认-SD-卡设备的标识" class="headerlink" title="确认 SD 卡设备的标识"></a>确认 SD 卡设备的标识</h3><p>在命令行中输入 <code>diskutil list</code></p>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-diskutil-list.png" alt="确认SD卡标识"></p>
<p>其中，<code>/dev/disk3</code> 就是我们要安装系统的设备。记住这个标识，非常的重要。</p>
<h3 id="将-Raspbian-镜像写入-SD-卡"><a href="#将-Raspbian-镜像写入-SD-卡" class="headerlink" title="将 Raspbian 镜像写入 SD 卡"></a>将 Raspbian 镜像写入 SD 卡</h3><p>Mac 下使用 dd 命令来将系统镜像写入设备。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd <span class="attribute">bs</span>=4m <span class="attribute">if</span>=2017-03-02-raspbian-jessie.img <span class="attribute">of</span>=/dev/disk3</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-write-img.png" alt="写入系统镜像"></p>
<p>if 后面的参数标识镜像文件路径<br>of 后面的参数则是写入设备的标识</p>
<h3 id="卸载设备"><a href="#卸载设备" class="headerlink" title="卸载设备"></a>卸载设备</h3><p>写完以后，在通过 <code>diskutil unmountDisk</code> 命令卸载 SD 卡。</p>
<p><img src="http://img.uprogrammer.cn/static/images/mac-raspberry-unmount2.png" alt="卸载设备"></p>
<p>这样，安装有 Raspbian 系统的 SD 卡就准备好了。</p>
<blockquote>
<p>以上图示和我实际情况略有出入。是因为我直接使用了其他网友的图片。具体见后面的参考。</p>
</blockquote>
<h2 id="点亮树莓派，进入系统"><a href="#点亮树莓派，进入系统" class="headerlink" title="点亮树莓派，进入系统"></a>点亮树莓派，进入系统</h2><p>接下来，把 SD 卡装入树莓派，接上电源，用 HDMI 线连接电视机。打开电源开关，不出意外，一会儿电视机屏幕上就看到树莓派系统的画面了。</p>
<p><img src="http://img.uprogrammer.cn/static/images/raspberrypi-boot.gif" alt="树莓派开机启动"></p>
<p>之前看过的很多资料都说点亮系统以后，需要对树莓派进行各种配置。这时候系统却大大出乎我的意料了。因为系统出现树莓派欢迎画面以后，还在继续玩下进行，直到最后直接进入到桌面。这个过程我没有做任何操作。</p>
<p>就这样，很顺利的进入了系统。后来发现新版的系统默认会用 pi/raspberry 的账户自动登录系统。这个真的很方便，对于树莓派小白来讲，门槛降低了很多。</p>
<p><img src="http://img.uprogrammer.cn/static/images/raspberrypi-logon.jpeg" alt="自动登录树莓派"></p>
<p>然而接下来，我一下子不知道还能干什么。</p>
<ol>
<li>毕竟没有键盘，只有鼠标，系统里面也没有软键盘，根本无法输入。</li>
<li>原来想着及时没有屏幕，也可以通过 ssh 来操作树莓派系统，做很多事情。而新版的树莓派系统是默认关闭 ssh 的。</li>
<li>想要 ssh 我也不知道树莓派系统的 ip。</li>
</ol>
<h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><p>我插上无线鼠标，插上网线，随意点击的过程中，发现右上角的网卡配置上，是可以显示 ip 地址的。这样， ip 就有了。一阵欣喜。</p>
<p>而后，在系统的“首选项”中“树莓派配置”，我发现可以配置 ssh， vnc 等服务的开关。我在这里把 ssh 和 vnc 都打开了。</p>
<p>于是，我在 Mac 的终端里，输入</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">pi</span>@<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">0</span>.<span class="keyword">5</span> // 这是我的树莓派 ip 地址，你的根据自己情况而定</span><br></pre></td></tr></table></figure>
<p>顺利地登录了。</p>
<p>此外，只用鼠标，我还配置了系统的语言，时区等，这些配置都有图形化的界面。</p>
<h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><p>Raspbian 是基于 debian 的，软件包管理工具是强大的 <code>apt</code>。为了能够快速的查找、安装各种软件，需要更新一下软件安装源。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure>
<p>从这个列表<a href="http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html" target="_blank" rel="noopener">Raspbian 中国软件源</a>中选择一两个源，按照 sources.list 的格式写入。然后执行下面的命令更新。注意：每次修改 <code>sources.list</code>，要使更新生效都必须执行此命令。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<h2 id="通过-VNC-控制树莓派桌面"><a href="#通过-VNC-控制树莓派桌面" class="headerlink" title="通过 VNC 控制树莓派桌面"></a>通过 VNC 控制树莓派桌面</h2><p>在网上看到很多篇关于远程控制树莓派桌面的文章，都是说需要安装 <code>tightvncserver</code>。其实是不需要的，新版的系统上已经内置了 vnc 服务 <code>RealVNC</code>，我们上面的设置中开启 vnc 就可以了。</p>
<p>而 <a href="https://www.realvnc.com/download/viewer/" target="_blank" rel="noopener">RealVNC</a> 在很多平台下都有客户端，包括 Mac，iOS，Android。我在 Mac 和 iOS 里都下载了 VNC Viewer 客户端，简单配置以后，就可以对树莓派进行远程桌面控制了。</p>
<p><img src="http://img.uprogrammer.cn/static/images/nvc-on-mac.jpeg" alt="mac vnc 客户端"></p>
<div align="center">mac 上的 VNC Viewer</div>

<p><img src="http://img.uprogrammer.cn/static/images/vnc-on-ios.png" alt="ios vnc 客户端"></p>
<div align="center">iOS 上的 VNC Viewer</div>

<h2 id="安装-kodi，打造多媒体控制中心"><a href="#安装-kodi，打造多媒体控制中心" class="headerlink" title="安装 kodi，打造多媒体控制中心"></a>安装 kodi，打造多媒体控制中心</h2><p>网上大多数的教程都是说可以通过安装 <code>xbmc</code> 来将树莓派打造成多媒体控制中心。简单说就类似一个电视盒子。</p>
<p>其实 <code>xbmc</code> 已经是过去时了。现在叫 <code>kodi</code>, 我是通过命令行安装 <code>xbmc</code> 是才发现的，系统提醒我 <code>xbmc</code> 的包已经过时了。</p>
<p>等我缓过神来，发现树莓派系统的影音菜单里面包含有 <code>Kodi Media Center</code>。所以我不清楚是系统预装的，还是我通过命令行安装的。如果是命令行安装，大家执行如下命令就可以了。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install kodi</span><br></pre></td></tr></table></figure>
<p>安装完成以后，通过菜单可以打开 kodi。如果你在 VNC Viewer 上远程操作，是看不到 kodi 的界面的。<strong>只能在 HDMI 设备上看到</strong>。</p>
<h3 id="kodi-中文化及安装中文节目插件"><a href="#kodi-中文化及安装中文节目插件" class="headerlink" title="kodi 中文化及安装中文节目插件"></a>kodi 中文化及安装中文节目插件</h3><p>打开 kodi，默认是英文界面。如果想看自己需要的界面，则需要安装对应的插件。下面是插件项目地址：</p>
<p><a href="https://github.com/taxigps/xbmc-addons-chinese" target="_blank" rel="noopener">Addon scripts, plugins, and skins for XBMC Media Center. Special for chinese laguage.</a></p>
<p>具体安装步骤：</p>
<ol>
<li>下载<a href="https://github.com/taxigps/xbmc-addons-chinese/raw/master/repo/repository.xbmc-addons-chinese/repository.xbmc-addons-chinese-1.2.1.zip" target="_blank" rel="noopener">插件仓库</a>。</li>
<li>打开 kodi，导航到 系统(System) | 设置(Setting) | 插件(Add-ons)</li>
<li>选择 “从 zip 文件安装”</li>
<li>找到下载的 zip 所在路径，选择确认。</li>
</ol>
<p>以上插件仓库就添加完成了。具体的插件，在需要的时候选择安装就可以了。如点开视频-&gt;插件-&gt;获取更多-&gt;PPTV 等。</p>
<p>kodi 中文化步骤：</p>
<ol>
<li>导航到 系统(System) | 设置(Setting) | 外观(Appearance) | 皮肤(Skin)</li>
<li>修改皮肤的字体设置为 “基于 Arial(Arial based)”</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/launch-kodi.jpeg" alt="kodi启动"></p>
<h3 id="通过安装-kodi-的客户端，在手机上控制-kodi"><a href="#通过安装-kodi-的客户端，在手机上控制-kodi" class="headerlink" title="通过安装 kodi 的客户端，在手机上控制 kodi"></a>通过安装 kodi 的客户端，在手机上控制 kodi</h3><p>可以在手机上下载 kodi 客户端来实现屏幕的控制。比如 iphone 在 AppStore 上搜索 kodi 就可以了。</p>
<p>要打开 kodi 的客户端控制，需要在 kodi 上进行配置。</p>
<p>1. 配置 Web 服务器</p>
<p><img src="http://img.uprogrammer.cn/static/images/kodi-setting1.jpg" alt="配置 Web 服务器"></p>
<p>2. 开启 Zeroconf 协议</p>
<p>同样在 kodi 客户端上进行连接服务器的配置。 </p>
<p><img src="http://img.uprogrammer.cn/static/images/kodi-on-iphone.jpeg" alt="kodi客户端iphone"> <img src="http://img.uprogrammer.cn/static/images/kodi-operator-on-iphone" alt="kodi iphone遥控器"></p>
<p>下面是用 kodi 打开搜狐视频播放影片的截屏。</p>
<p><img src="http://img.uprogrammer.cn/static/images/kodi-movie.jpeg" alt="kodi播放影片"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总的来讲，今天的收获还是很大的。</p>
<ol>
<li>点亮系统比我想象的要简单。</li>
<li>也搞定了 ssh 登录，以后不用屏幕、外设来控制树莓派也很方便。</li>
<li>kodi 则让我觉得惊艳，尤其是通过手机来控制 kodi 以后，觉得比较酷。另外则是惊叹小小一块板子，看起视频来效果还是不错的。</li>
</ol>
<p>最大的感慨是，网络上的很多教程都过时了。比起那些教程，新版的 Raspbian 是在容易上手太多，很多东西也都预装好了，更加傻瓜化了。</p>
<p><strong>参考</strong></p>
<p><a href="http://www.5yun.org/9148.html" target="_blank" rel="noopener">Kodi播放器出现乱码的解决方法，超简单!</a></p>
<p><a href="http://www.jianshu.com/p/5dc83db2b78e" target="_blank" rel="noopener">mac 下安装树莓派系统</a></p>
]]></content>
      
        
        <tags>
            
            <tag> raspberry pi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[macOS Sierra 上通过 docker 安装 seafile 搭建家庭云盘]]></title>
      <url>http://linfuyan.com/macOS-Sierra-docker-seafile/</url>
      <content type="html"><![CDATA[<p>先上效果图。下图是 mac 客户端与 web 服务器的配合使用录屏。</p>
<p><img src="http://img.uprogrammer.cn/seafile.gif" alt="macOS-sierra-docker-seafile-demo"></p>
<h2 id="〇、前言"><a href="#〇、前言" class="headerlink" title="〇、前言"></a>〇、前言</h2><ol>
<li>安装 docker 比较简单。直接从<a href="https://www.docker.com/products/docker#/mac" target="_blank" rel="noopener">官网</a>下载安装文件，双击安装就可以了。和普通的 macOS app 一样。</li>
<li>对于 docker 操作要有基础的了解。可以参考 <a href="http://uprogrammer.cn/docker_practice/index.html" target="_blank" rel="noopener">docker 从入门到实践</a>。正常按照文中的步骤就可以顺利完成。</li>
<li>什么是 seafile？<a href="https://www.seafile.com/home/" target="_blank" rel="noopener">官网</a>为什么选了 seafile？<a href="https://www.zhihu.com/search?type=content&amp;q=seafile" target="_blank" rel="noopener">知乎</a>这里两个链接可以点击直接查看。更多的信息，大家自行了解。</li>
</ol>
<a id="more"></a>
<p>安装完成 docker，你就可以在终端中输入 <code>docker version</code>, 出现下面的反馈，我们就可以开始后面的事情了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">version</span></span><br><span class="line"><span class="attr">Client:</span></span><br><span class="line"><span class="attr"> Version:</span>      <span class="number">1.13</span><span class="number">.1</span></span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.26</span></span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.7.5</span></span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">092</span><span class="string">cba3</span></span><br><span class="line"><span class="attr"> Built:</span>        <span class="string">Wed</span> <span class="string">Feb</span>  <span class="number">8</span> <span class="number">08</span><span class="string">:47:51</span> <span class="number">2017</span></span><br><span class="line"> <span class="string">OS/Arch:</span>      <span class="string">darwin/amd64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Server:</span></span><br><span class="line"><span class="attr"> Version:</span>      <span class="number">1.13</span><span class="number">.1</span></span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.26</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.12</span><span class="string">)</span></span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.7.5</span></span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">092</span><span class="string">cba3</span></span><br><span class="line"><span class="attr"> Built:</span>        <span class="string">Wed</span> <span class="string">Feb</span>  <span class="number">8</span> <span class="number">08</span><span class="string">:47:51</span> <span class="number">2017</span></span><br><span class="line"> <span class="string">OS/Arch:</span>      <span class="string">linux/amd64</span></span><br><span class="line"><span class="attr"> Experimental:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>seafile 服务器端目前有 Linux，Raspberry PI，Windows 版本，这也是在 macOS 上需要 docker 的原因。</p>
<h2 id="一、下载-docker-Ubuntu-16-04-镜像"><a href="#一、下载-docker-Ubuntu-16-04-镜像" class="headerlink" title="一、下载 docker Ubuntu 16.04 镜像"></a>一、下载 docker Ubuntu 16.04 镜像</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/<span class="string">ubuntu:</span><span class="number">16.04</span></span><br></pre></td></tr></table></figure>
<p>由于官方的 docker 镜像仓库在国内链接很慢，这里可以选择 daocloud.io 的镜像仓库。上面的命令用来从镜像仓库中拉取tag为16.04的 ubuntu 版本。</p>
<h2 id="二、基于-Ubuntu-16-04-镜像更新源，安装必要工具"><a href="#二、基于-Ubuntu-16-04-镜像更新源，安装必要工具" class="headerlink" title="二、基于 Ubuntu 16.04 镜像更新源，安装必要工具"></a>二、基于 Ubuntu 16.04 镜像更新源，安装必要工具</h2><p>运行基于 daocloud.io/ubuntu:16.04 镜像的容器，并打开其终端。在容器内部，就和操作普通的 ubuntu 没有大的差别了。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t daocloud.io/ubuntu:16.04 /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>更新 ubuntu 的源，并安装必要的软件。基础的 ubuntu 镜像，我们需要的软件工具都没有，所以我们需要先安装。由于官方的源，同样因为国内的关系，速度很慢，我们需要添加国内的软件源。参考：<a href="http://www.cnblogs.com/bovenson/p/5752213.html" target="_blank" rel="noopener">Ubuntu 16.04 几个国内更新源</a></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span> // 更新软件源</span><br><span class="line">apt-<span class="built_in">get</span> install <span class="keyword">vim</span> // 安装 <span class="keyword">vim</span></span><br><span class="line"><span class="keyword">vi</span> /etc/apt/sources.<span class="keyword">list</span> // 编辑软件源配置文件，保存，退出</span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span> // 每次修改 sources.<span class="keyword">list</span> 都要执行该命令，使更新源的修改生效</span><br></pre></td></tr></table></figure>
<p>更新到国内源以后，下载速度就快很多了。继续安装一些工具如 <code>wget</code>，<code>tree</code>，后面会用到。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install wget tree</span><br></pre></td></tr></table></figure>
<h2 id="三、在-ubuntu-上安装-seafile"><a href="#三、在-ubuntu-上安装-seafile" class="headerlink" title="三、在 ubuntu 上安装 seafile"></a>三、在 ubuntu 上安装 seafile</h2><p>官方有很详尽的<a href="https://manual-cn.seafile.com/deploy/using_mysql.html" target="_blank" rel="noopener">文档</a>，照着做下来就好了。这边我记录下自己的步骤。</p>
<p>通过 <code>wget</code> 从官网下载服务器端安装包。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c <span class="string">http:</span><span class="comment">//seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.0.8_x86-64.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>下载完成后，按照如下建立目录：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> haiwen</span><br><span class="line">mv seafile-server_* haiwen</span><br><span class="line"><span class="built_in">cd</span> haiwen</span><br></pre></td></tr></table></figure>
<p>将 seafile-server_* 移动到 haiwen 目录下后</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf seafile-server_*</span><br><span class="line"><span class="built_in">mkdir</span> installed</span><br><span class="line">mv seafile-server_* installed</span><br></pre></td></tr></table></figure>
<p>官方说明：这样设计目录的好处在于</p>
<ul>
<li>和 seafile 相关的配置文件都可以放在 haiwen 目录下，便于集中管理。</li>
<li>后续升级时，你只需要解压最新的安装包到 haiwen 目录下。</li>
</ul>
<h3 id="安装-seafile-社区版依赖的软件："><a href="#安装-seafile-社区版依赖的软件：" class="headerlink" title="安装 seafile 社区版依赖的软件："></a>安装 seafile 社区版依赖的软件：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> install mariadb-server // mariadb 是 mysql 的分支</span><br><span class="line">apt-<span class="built_in">get</span> install python2.<span class="number">7</span> <span class="keyword">python</span>-setuptools <span class="keyword">python</span>-imaging <span class="keyword">python</span>-ldap <span class="keyword">python</span>-mysqldb <span class="keyword">python</span>-memcache <span class="keyword">python</span>-urllib3</span><br></pre></td></tr></table></figure>
<p>安装完成以后，需要修改mysql用户的密码，并启动 mysql 服务：</p>
<p>参考地址：<a href="http://blog.csdn.net/stubbornness1219/article/details/53445904" target="_blank" rel="noopener">Ubuntu 16.04 下重置 MySQL 5.7 密码</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service mysql start // 启动 mysql 服务</span><br><span class="line">mysql // 用空密码进入 mysql 管理命令行</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql // 切换到 mysql 库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update mysql.user <span class="built_in">set</span> authentication_string=password(<span class="string">'123qwe'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span> and Host =<span class="string">'localhost'</span>; // 修改为自己的密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> plugin=<span class="string">"mysql_native_password"</span>; </span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit;</span></span><br></pre></td></tr></table></figure>
<p>再重启，用新的密码登录，验证修改是否生效。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service mysql <span class="literal">start</span></span><br><span class="line">mysql -uroot -pnewpwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开始后面的步骤时，mysql 服务必须开启，否则会提示 mysql 相关的错误。</p>
</blockquote>
<p>进入 seafile-server-* 目录，并运行安装脚本，根据提示回答问题。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> seafile-server-*</span><br><span class="line"><span class="string">./setup-seafile-mysql.sh</span></span><br></pre></td></tr></table></figure>
<p>基本上使用默认就可以了。 </p>
<blockquote>
<ul>
<li><code>seafile server ip or domain</code> 会影响到后面的下载与上传，不过系统配置中可以修改。这里可以随意填写， 如：<code>127.0.0.1</code></li>
<li><code>seafile data dir</code> 是文件存储的位置，这个要记清楚。后面我们要配置 docker 容器的数据目录。</li>
</ul>
</blockquote>
<p>接下来，你会被要求选择一种创建 Seafile 数据库的方式:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------</span><br><span class="line">Please choose a way to initialize seafile databases:</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">[1] Create new ccnet/seafile/seahub databases</span><br><span class="line">[2] Use existing ccnet/seafile/seahub databases</span><br></pre></td></tr></table></figure>
<p>如果选择1, 你需要提供根密码. 脚本程序会创建数据库和用户。<br>如果选择2, ccnet/seafile/seahub 数据库应该已经被你（或者其他人）提前创建。</p>
<p><strong>我们选1</strong>，然后一路回车下来。</p>
<p>以上，我们已经完成了 seafile 社区版在 ubuntu 上的安装。</p>
<h3 id="关于-seafile-专业版"><a href="#关于-seafile-专业版" class="headerlink" title="关于 seafile 专业版"></a>关于 seafile 专业版</h3><p>seafile 社区版是没有用户使用限制的，专业版有。专业版的功能更加强大。如社区版无法预览 office，pdf 文件，仅提供下载到本地的功能，专业版可以在线预览。</p>
<p>专业版的安装与社区版类似。由于专业版的功能更强大，所以有更多的依赖，这就要在安装时安装更多其他的软件。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install openjdk-<span class="number">8</span>-jre poppler-utils libpython2.<span class="number">7</span> <span class="keyword">python</span>-pip \</span><br><span class="line">mysql-server <span class="keyword">python</span>-setuptools <span class="keyword">python</span>-imaging <span class="keyword">python</span>-mysqldb <span class="keyword">python</span>-memcache <span class="keyword">python</span>-ldap \</span><br><span class="line"><span class="keyword">python</span>-urllib3</span><br><span class="line"></span><br><span class="line">pip install boto requests</span><br><span class="line"><span class="keyword">ln</span> -<span class="keyword">sf</span> /usr/lib/jvm/java-<span class="number">8</span>-openjdk-amd64/jre/bin/java /usr/bin/</span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> install libreoffice libreoffice-script-provider-<span class="keyword">python</span> // Office 预览</span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy // 字体支持</span><br></pre></td></tr></table></figure>
<p>专业版3人以下使用是不需要授权的。更多的人需要购买授权。家庭使用的话，免费的专业版也完全够用啦。哪里可以下载到专业版请看后面的问题。</p>
<h2 id="四、从-docker-容器中退出，制作-seafile-镜像"><a href="#四、从-docker-容器中退出，制作-seafile-镜像" class="headerlink" title="四、从 docker 容器中退出，制作 seafile 镜像"></a>四、从 docker 容器中退出，制作 seafile 镜像</h2><p>在上面的操作中，我们看到终端的左侧有类似下面的前置符：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@d63b87d071a4</span><span class="symbol">:/haiwen/</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>d63b87d071a4</code> 是这次打开容器的 ID，我们要基于此来提交我们刚才做的修改。否则我们再次启动 ubuntu:16.04 这个镜像时，所有的修改都丢失了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">'install seafile'</span> -<span class="selector-tag">a</span> <span class="string">'user'</span> d63b87d071a4 seafile:v1</span><br></pre></td></tr></table></figure>
<p>这样，就可以创建一个本地的 seafile 仓库，标签为 v1 的镜像。<code>-m</code> 为这次提交添加注释， <code>-a</code> 说明添加的用户， <code>d63b87d071a4</code> 修改的容器ID，<code>seafile:v1</code> (仓库:标签)标识新建的镜像。<code>docker commit</code> 与 <code>git commit</code> 类似。</p>
<p>通过 <code>docker images</code> 查看本地镜像，类似如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">seafile              v1                  <span class="number">9621e0684187</span>        <span class="number">2</span> days ago          <span class="number">776</span> MB</span><br><span class="line">youshi/ubuntu        v2                  <span class="number">08913</span>c24e827        <span class="number">3</span> days ago          <span class="number">222</span> MB</span><br><span class="line">daocloud.io/ubuntu   <span class="number">16.04</span>               f49eec89601e        <span class="number">5</span> weeks ago         <span class="number">129</span> MB</span><br><span class="line">daocloud.io/ubuntu   <span class="number">14.04</span>               b969ab9f929b        <span class="number">5</span> weeks ago         <span class="number">188</span> MB</span><br></pre></td></tr></table></figure>
<h2 id="五、启动-docker-中的-seafile-服务"><a href="#五、启动-docker-中的-seafile-服务" class="headerlink" title="五、启动 docker 中的 seafile 服务"></a>五、启动 docker 中的 seafile 服务</h2><p>配置数据卷、端口映射，启动 seafile 容器：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -v [<span class="number">1</span>]<span class="symbol">:/haiwen/seafile-data</span> -v [<span class="number">2</span>]<span class="symbol">:/var/lib/mysql</span> -p <span class="number">10001</span><span class="symbol">:</span><span class="number">10001</span> -p <span class="number">12001</span><span class="symbol">:</span><span class="number">12001</span> -p <span class="number">8000</span><span class="symbol">:</span><span class="number">8000</span> -p <span class="number">8082</span><span class="symbol">:</span><span class="number">8082</span> <span class="symbol">seafile:</span>v1 /bin/bash</span><br></pre></td></tr></table></figure>
<ol>
<li><code>-v</code> 参数映射 mac 系统中的路径到 docker 容器中的路径，作为数据卷。这样容器中的数据就保存在物理磁盘上了。[1] mac 上需要映射到 seafile 同步文件存储的路径。[2] 需要映射到 mysql 存储的路径。</li>
<li><code>-p</code> 映射容器的端口到 mac 的端口，用于网络通信。 seafile 服务需要 10001，12001，8000，8082 共4个端口。8000 是浏览器访问网页服务的端口，8082是文件同步服务的端口。</li>
</ol>
<p>启动 mysql 服务：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql <span class="literal">start</span></span><br></pre></td></tr></table></figure>
<p>这时终端中提示报错也没有关系，是因为没有输入 mysql 的用户/密码导致的。</p>
<p>进入到 seafile-server-* 目录下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./seafile<span class="selector-class">.sh</span> start <span class="comment">// 启动 Seafile 服务</span></span><br><span class="line">./seahub<span class="selector-class">.sh</span> start <span class="comment">// 启动 Seahub 网站</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一次启动 seahub 时，需要填写管理员账号，密码。</p>
</blockquote>
<p>以上，你在浏览器中输入 <code>127.0.0.1:8000</code>， 就可以看到 seafile 网站了。通过之前填写的管理员账户登录，就可以开始体验私有云的功能啦。</p>
<h2 id="六、问题"><a href="#六、问题" class="headerlink" title="六、问题"></a>六、问题</h2><h3 id="1-客户端无法下载-上传？"><a href="#1-客户端无法下载-上传？" class="headerlink" title="1. 客户端无法下载/上传？"></a>1. 客户端无法下载/上传？</h3><p>Seafile 可以支持桌面客户端、网页版、Android、iOS 客户端。客户端上设置你的服务器地址，用网站上配置的账号，就可以使用了。如果遇到无法上传、下载文件的问题。用管理员账号，进入系统管理后台-&gt;设置中，修改 <code>SERVICE_URL</code> 和 <code>FILE_SERVER_ROOT</code>。前者用作网站访问链接，会影响到分享的文件URL；后者则影响文件同步。两者需要都能够被访问到。因此，地址是内网的，你出了局域网就访问不到了。</p>
<h3 id="2-专业版如何获取？"><a href="#2-专业版如何获取？" class="headerlink" title="2. 专业版如何获取？"></a>2. 专业版如何获取？</h3><p>专业版的获取方法，请扫下面的二维码关注公众号，并回复 <code>seafilepro</code>。</p>
<p><div align="center"><br>    <img src="http://img.uprogrammer.cn/static/images/qrcode_for_gh_3ad92a8fc23c_860.jpg" width="80%"><br>    <span>关注公众号，回复 seafilepro</span></div></p>
<div>





















</div>]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> seafile </tag>
            
            <tag> 私有云 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu搭建ngrok服务器，尽享内网穿透技术带来的福利]]></title>
      <url>http://linfuyan.com/ubuntu-ngrok/</url>
      <content type="html"><![CDATA[<p>如果你做微信开发，一次又一次的发布、发现错误、调试、发布、发现错误、调试…的循环一定让你个人或是团队感到厌倦；<br>如果你接外包项目，在开发过程中，客户想要看一看开发中的进展，你一定为还没有可预览环境或者搭建环境产生的消耗而苦恼。<br>…<br>这一切的原因仅仅是因为你深处复杂的内网环境，被一个局域网阻断了与外部的直接联系。你一定希望有一样东西，能够冲破这层阻隔，为你的工作提高效率。<br>这篇文章我们介绍 ngrok，一个开源软件，可以用于提供内网穿透。</p>
<p>以下我记录下ngrok服务的搭建过程。</p>
<a id="more"></a>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><ol>
<li>需要一个有公网IP的VPS</li>
<li>需要一个能够自由解析的域名</li>
</ol>
<h2 id="二、解析域名"><a href="#二、解析域名" class="headerlink" title="二、解析域名"></a>二、解析域名</h2><p>使用自己的域名，把域名解析到 VPS 的地址，解析方式如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngrok.uprogrammer.cn ----------&gt; A记录到你的 VPS IP</span><br><span class="line">*.ngrok.uprogrammer.cn ----------&gt; CNAME到ngrok.uprogrammer.cn</span><br></pre></td></tr></table></figure>
<h3 id="三、VPS-服务端安装-go-环境"><a href="#三、VPS-服务端安装-go-环境" class="headerlink" title="三、VPS 服务端安装 go 环境"></a>三、VPS 服务端安装 go 环境</h3><p>因为 ngrok 是由 go 语言开发的，所以需要安装 go 环境。</p>
<p>1. 从 <a href="https://golang.org/dl/" target="_blank" rel="noopener">go 官网</a>下载最新的 go 版本，并解压到 <code>/usr/local</code> 目录下。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https:<span class="comment">//storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz</span></span><br><span class="line">tar -C /usr/local -zxvf go1.<span class="number">7.4</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>2. 设置相关环境变量</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 可以根据自己需要调整路径  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">'export GOROOT=/usr/local/go'</span> &gt;&gt; /etc/<span class="keyword">profile</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'export PATH=$PATH:$GOROOT/bin'</span> &gt;&gt; /etc/<span class="keyword">profile</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'export GOPATH=$HOME/go'</span> &gt;&gt; /etc/<span class="keyword">profile</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'export GOROOT_BOOTSTRAP=/usr/local/go'</span> &gt;&gt; /etc/<span class="keyword">profile</span></span><br><span class="line"><span class="keyword">source</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>3. 检查是否安装成功</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="keyword">version</span></span><br></pre></td></tr></table></figure>
<h3 id="四、安装-Git-环境"><a href="#四、安装-Git-环境" class="headerlink" title="四、安装 Git 环境"></a>四、安装 Git 环境</h3><p>由于我们通过 github 上的源码来安装 ngrok，所以需要先安装下 git。如果已经有 git环境，则直接跳过。</p>
<p>ubuntu 上可以直接通过 <code>apt-get install git</code> 来安装 git。完成以后，做相应的 git 配置，此处略过。</p>
<h3 id="五、Ubuntu-安装-ngrok"><a href="#五、Ubuntu-安装-ngrok" class="headerlink" title="五、Ubuntu 安装 ngrok"></a>五、Ubuntu 安装 ngrok</h3><p>1. 下载 ngrok，并修改参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/inconshreveable/ngrok.git</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/ngrok/</span><br><span class="line"><span class="built_in">export</span> NGROK_DOMAIN=<span class="string">"ngrok.uprogrammer.cn"</span></span><br><span class="line"><span class="built_in">cd</span> ngrok</span><br></pre></td></tr></table></figure>
<p>2. 生成证书(必须)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rootCA<span class="selector-class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -x509 -new -nodes -key rootCA<span class="selector-class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -days <span class="number">5000</span> -out rootCA.pem</span><br><span class="line">openssl genrsa -out server<span class="selector-class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -key server<span class="selector-class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out server.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server<span class="selector-class">.csr</span> -CA rootCA<span class="selector-class">.pem</span> -CAkey rootCA<span class="selector-class">.key</span> -CAcreateserial -out server<span class="selector-class">.crt</span> -days <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>3. 将源代码目录下生成的证书文件复制到指定的位置</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp rootCA<span class="selector-class">.pem</span> assets/client/tls/ngrokroot.crt</span><br><span class="line">cp server<span class="selector-class">.crt</span> assets/server/tls/snakeoil.crt</span><br><span class="line">cp server<span class="selector-class">.key</span> assets/server/tls/snakeoil.key</span><br></pre></td></tr></table></figure>
<p>4. 如果是在国内的服务器，需要执行下面的修改，否则会由于网络原因产生库的依赖问题。香港或者国外的服务器就不需要了。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/ngrok/src/ngrok/<span class="built_in">log</span>/logger.<span class="built_in">go</span></span><br><span class="line"><span class="built_in">log</span> <span class="string">"github.com/keepeye/log4go"</span></span><br></pre></td></tr></table></figure>
<p>5. 编译服务器，这里也同时编译了一个 linux 下的客户端。64位系统使用 amd64，如果是32位，需要修改成 amd386。<br>编译的时候，这里可能会遇到一个坑，后面会讲到。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src</span><br><span class="line"><span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=amd64 ./make.bash</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=amd64 make release-server release-client</span><br></pre></td></tr></table></figure>
<p>编译 Mac 64 位客户端</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src</span><br><span class="line"><span class="attribute">GOOS</span>=darwin <span class="attribute">GOARCH</span>=amd64 ./make.bash</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=darwin <span class="attribute">GOARCH</span>=amd64 make release-client</span><br></pre></td></tr></table></figure>
<p>编译 Windows 64位客户端</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src</span><br><span class="line"><span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 ./make.bash</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 make release-client</span><br></pre></td></tr></table></figure>
<h2 id="六、服务端运行与使用"><a href="#六、服务端运行与使用" class="headerlink" title="六、服务端运行与使用"></a>六、服务端运行与使用</h2><p>1. 进入服务端目录，服务端程序文件名为 ngrokd，并执行相应命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ngrok/bin</span><br><span class="line">./ngrokd -domain=<span class="string">"<span class="variable">$NGROK_DOMAIN</span>"</span> -httpAddr=<span class="string">":80"</span></span><br></pre></td></tr></table></figure>
<p>2. 返回类似如下的结果，则说明服务端运行成功</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[08:09:41 UTC 2016/12/19]</span> <span class="selector-attr">[INFO]</span> (ngrok/log.(*PrefixLogger).<span class="attribute">Info</span>:<span class="number">83</span>) <span class="selector-attr">[registry]</span> <span class="selector-attr">[tun]</span> <span class="selector-tag">No</span> <span class="selector-tag">affinity</span> <span class="selector-tag">cache</span> <span class="selector-tag">specified</span></span><br><span class="line"><span class="selector-attr">[08:09:41 UTC 2016/12/19]</span> <span class="selector-attr">[INFO]</span> (ngrok/log.<span class="attribute">Info</span>:<span class="number">112</span>) <span class="selector-tag">Listening</span> <span class="selector-tag">for</span> <span class="selector-tag">public</span> <span class="selector-tag">http</span> <span class="selector-tag">connections</span> <span class="selector-tag">on</span> <span class="selector-attr">[::]</span><span class="selector-pseudo">:80</span></span><br><span class="line"><span class="selector-attr">[08:09:41 UTC 2016/12/19]</span> <span class="selector-attr">[INFO]</span> (ngrok/log.<span class="attribute">Info</span>:<span class="number">112</span>) <span class="selector-tag">Listening</span> <span class="selector-tag">for</span> <span class="selector-tag">public</span> <span class="selector-tag">https</span> <span class="selector-tag">connections</span> <span class="selector-tag">on</span> <span class="selector-attr">[::]</span><span class="selector-pseudo">:443</span></span><br><span class="line"><span class="selector-attr">[08:09:41 UTC 2016/12/19]</span> <span class="selector-attr">[INFO]</span> (ngrok/log.<span class="attribute">Info</span>:<span class="number">112</span>) <span class="selector-tag">Listening</span> <span class="selector-tag">for</span> <span class="selector-tag">control</span> <span class="selector-tag">and</span> <span class="selector-tag">proxy</span> <span class="selector-tag">connections</span> <span class="selector-tag">on</span> <span class="selector-attr">[::]</span><span class="selector-pseudo">:4443</span></span><br><span class="line"><span class="selector-attr">[08:09:41 UTC 2016/12/19]</span> <span class="selector-attr">[INFO]</span> (ngrok/log.(*PrefixLogger).<span class="attribute">Info</span>:<span class="number">83</span>) <span class="selector-attr">[metrics]</span> <span class="selector-tag">Reporting</span> <span class="selector-tag">every</span> <span class="selector-tag">30</span> <span class="selector-tag">seconds</span></span><br></pre></td></tr></table></figure>
<h2 id="七、客户端的运行与使用"><a href="#七、客户端的运行与使用" class="headerlink" title="七、客户端的运行与使用"></a>七、客户端的运行与使用</h2><p>1. 把刚刚从 VPS 服务器上生成的客户端服务器下载到本机，可以通过 <code>scp</code> 命令</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp username<span class="variable">@servername</span><span class="symbol">:/path/filename</span> /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure>
<p>mac 客户端的位置：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/ngrok/</span>bin<span class="regexp">/darwin_amd64/</span>ngrok</span><br></pre></td></tr></table></figure>
<p>windows 客户端的位置：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/ngrok/</span>bin<span class="regexp">/windows_amd64/</span>ngrok.exe</span><br></pre></td></tr></table></figure>
<p>linux 客户端的位置：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/ngrok/</span>bin<span class="regexp">/ngrok</span></span><br></pre></td></tr></table></figure>
<p>2. 客户端程序下载到本地以后，在本地同一目录下新建名为 <code>ngrok.cfg</code> 的文件，文件内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server_addr:</span> <span class="string">"ngrok.uprogrammer.cn:4443"</span></span><br><span class="line"><span class="string">trust_host_root_certs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>3. 运行客户端</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./ngrok <span class="attribute">-config</span>=./ngrok.cfg <span class="attribute">-subdomain</span>=test 8080</span><br><span class="line"><span class="comment"># -subdomain参数指的是域名，例如这里是test.ngrok.uprogrammer.cn</span></span><br><span class="line"><span class="comment"># 后面的80是指本机端口，这里是指把本机的8080端口开放穿透</span></span><br><span class="line"><span class="comment"># windows运行客户端，请把./改成win风格的目录方式</span></span><br></pre></td></tr></table></figure>
<p>4. 返回类似如下的结果，则说明客户端运行成功</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tunnel Status                 online                                                                                                        </span><br><span class="line">Version                       <span class="number">1.7</span>/<span class="number">1.7</span>                                                                                                       </span><br><span class="line">Forwarding                    http://<span class="keyword">test</span>.ngrok.uprogrammer.cn -&gt; <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8080</span>                                                            </span><br><span class="line">Forwarding                    https://<span class="keyword">test</span>.ngrok.uprogrammer.cn -&gt; <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8080</span>                                                           </span><br><span class="line">Web Interface                 <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">4040</span>                                                                                                </span><br><span class="line"># Conn                        <span class="number">0</span>                                                                                                             </span><br><span class="line">Avg Conn Time                 <span class="number">0.</span>00ms</span><br></pre></td></tr></table></figure>
<p>接下来，你就可以运行本地 8080 端口的程序，看一看是不是通过 <code>test.uprogrammer.cn</code> 就可以访问啦，也可以发给局域网之外的人来访问^ ^</p>
<h2 id="八、可能遇到的坑"><a href="#八、可能遇到的坑" class="headerlink" title="八、可能遇到的坑"></a>八、可能遇到的坑</h2><p>1. 出现以下错误提示：<code>$GOROOT_BOOTSTRAP must not be set to $GOROOT</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##### Building Go bootstrap tool.</span></span><br><span class="line">cmd/dist</span><br><span class="line">ERROR: <span class="variable">$GOROOT_BOOTSTRAP</span> must <span class="keyword">not</span> be <span class="builtin-name">set</span> <span class="keyword">to</span> <span class="variable">$GOROOT</span></span><br><span class="line"><span class="builtin-name">Set</span> <span class="variable">$GOROOT_BOOTSTRAP</span> <span class="keyword">to</span> a working Go tree &gt;= Go 1.4.</span><br></pre></td></tr></table></figure>
<p>配置的 <code>$GOROOT_BOOTSTRAP</code> 和 <code>$GOROOT</code> 一致导致。可以复制一份 go 的源码到另外的路径，如 <code>/usr/local/go-copy</code>，同时 <code>export GOROOT_BOOTSTRAP=/usr/local/go-copy</code></p>
<p>2. 客户端可以连上，但域名不完全，显示如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tunnel Status                 online</span><br><span class="line">Version                       <span class="number">1.7</span>/<span class="number">1.7</span></span><br><span class="line">Forwarding                    http://<span class="keyword">test</span>. -&gt; <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8080</span></span><br><span class="line">Forwarding                    https://<span class="keyword">test</span>. -&gt; <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8080</span></span><br><span class="line">Web Interface                 <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">4040</span></span><br><span class="line"># Conn                        <span class="number">0</span></span><br><span class="line">Avg Conn Time                 <span class="number">0.</span>00ms</span><br></pre></td></tr></table></figure>
<p>这种错误是由于服务端运行时环境变量没有正确配置导致的，可以显示设置域名：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrokd <span class="attribute">-domain</span>=<span class="string">"ngrok.uprogrammer.cn"</span> <span class="attribute">-httpAddr</span>=<span class="string">":80"</span></span><br></pre></td></tr></table></figure>
<p>3. 如果你对 VPS 服务器已经有其他程序占用 80 端口，而还需要 ngrok 通过80端口做内网穿透的话，可以通过 nginx 来做反向代理。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> ngrok </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ngrok </tag>
            
            <tag> 微信开发 </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为 lunr.js 添加中文支持]]></title>
      <url>http://linfuyan.com/add-chinese-support-to-lunrjs/</url>
      <content type="html"><![CDATA[<p>如果你能找到这里，那么你应该是知道 lunr.js 的。 Ok， 那 lunr.js 是什么？<a href="http://lunrjs.com/" target="_blank" rel="noopener">官方网站</a>上说: “Simple full-text search in your browser”。翻译过来就是：浏览器上的简单的纯文本搜索工具。是的，它可以直接在浏览器上运行，不依赖服务端来完成对网页上纯文本的搜索功能，可以极大的提升通过网络服务器请求获取搜索结果时不流畅的搜索体验。用在博客等应用中，真是再好不过。然而，和大部分老外制作的工具一样，对于中文，老外的工具还是水土不服。对于中文网页搜索最大的问题就是，lunr.js 不支持中文搜索，由此还影响到一系列基于 lunr.js 制作的本地搜索工具，如 gitbook 内置的 gitbook-search-plugin 等，所以如果你在使用 gitbook 的搜索功能，发现输入中文出现错误结果不要大惊小怪。</p>
<p>不多说，以下基于当前 lunr.js 版本（commit id:6a978d1ebf1a0c08e1a76cd4f7f74ad5490e5937），添加了中文支持。</p>
<p>仓库地址：<a href="https://github.com/linfuyan/lunr.js" target="_blank" rel="noopener">https://github.com/linfuyan/lunr.js</a></p>
<p>有<a href="https://github.com/linfuyan/lunr.js/tree/un-participle" target="_blank" rel="noopener">未分词的中文支持版本</a>和<a href="https://github.com/linfuyan/lunr.js/tree/un-participle" target="_blank" rel="noopener">分词的中文支持版本</a>，位于仓库中不同的分支。</p>
<a id="more"></a>
<h2 id="未分词的中文支持版本"><a href="#未分词的中文支持版本" class="headerlink" title="未分词的中文支持版本"></a>未分词的中文支持版本</h2><p>中文支持的基本原理是，保证 lunr.js 在分析过程中中文字符不会被转义。因此在 trimmer 函数中对中文字符做过滤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lunr.trimmer = <span class="function"><span class="keyword">function</span> (<span class="params">token</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//by ming300 check token is chinese then not replace   </span></span><br><span class="line">  <span class="keyword">if</span>(isChineseChar(token))&#123;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token</span><br><span class="line">    .replace(<span class="regexp">/^\W+/</span>, <span class="string">''</span>)</span><br><span class="line">    .replace(<span class="regexp">/\W+$/</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> **check it contains Chinese (including Japanese and Korean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChineseChar</span>(<span class="params">str</span>)</span>&#123;     </span><br><span class="line">   <span class="keyword">var</span> reg = <span class="regexp">/[\u4E00-\u9FA5\uF900-\uFA2D]/</span>;  </span><br><span class="line">   <span class="keyword">return</span> reg.test(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在分词部分 tokenizer 函数做些调整，添加如下关键代码：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var str = obj.toString().replace(/^<span class="symbol">\s</span>+/, '')</span><br><span class="line"></span><br><span class="line">  for (var i = str.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (/<span class="symbol">\S</span>/.test(str.charAt(i))) &#123;</span><br><span class="line">      str = str.substring(0, i + 1)</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var rs = str</span><br><span class="line">    .split(/[<span class="symbol">\ </span>|<span class="symbol">\~</span>|<span class="symbol">\`</span>|<span class="symbol">\!</span>|<span class="symbol">\@</span>|<span class="symbol">\#</span>|<span class="symbol">\$</span>|<span class="symbol">\%</span>|<span class="symbol">\^</span>|<span class="symbol">\&amp;</span>|<span class="symbol">\*</span>|<span class="symbol">\u</span>FE30-<span class="symbol">\u</span>FFA0|<span class="symbol">\(</span>|<span class="symbol">\)</span>|<span class="symbol">\-</span>|<span class="symbol">\_</span>|<span class="symbol">\+</span>|<span class="symbol">\=</span>|<span class="symbol">\|</span>|<span class="symbol">\\</span>|<span class="symbol">\[</span>|<span class="symbol">\]</span>|<span class="symbol">\&#123;</span>|<span class="symbol">\&#125;</span>|<span class="symbol">\;</span>|<span class="symbol">\:</span>|<span class="symbol">\"</span>|<span class="symbol">\'</span>|<span class="symbol">\,</span>|<span class="symbol">\&lt;</span>|<span class="symbol">\.</span>|<span class="symbol">\&gt;</span>|<span class="symbol">\/</span>|<span class="symbol">\?</span>]+/)</span><br><span class="line">    .map(function (token) &#123;</span><br><span class="line">      var t = token.replace(/[<span class="symbol">\ </span>|<span class="symbol">\~</span>|<span class="symbol">\`</span>|<span class="symbol">\!</span>|<span class="symbol">\@</span>|<span class="symbol">\#</span>|<span class="symbol">\$</span>|<span class="symbol">\%</span>|<span class="symbol">\^</span>|<span class="symbol">\&amp;</span>|<span class="symbol">\*</span>|<span class="symbol">\u</span>FE30-<span class="symbol">\u</span>FFA0|<span class="symbol">\(</span>|<span class="symbol">\)</span>|<span class="symbol">\-</span>|<span class="symbol">\_</span>|<span class="symbol">\+</span>|<span class="symbol">\=</span>|<span class="symbol">\|</span>|<span class="symbol">\\</span>|<span class="symbol">\[</span>|<span class="symbol">\]</span>|<span class="symbol">\&#123;</span>|<span class="symbol">\&#125;</span>|<span class="symbol">\;</span>|<span class="symbol">\:</span>|<span class="symbol">\"</span>|<span class="symbol">\'</span>|<span class="symbol">\,</span>|<span class="symbol">\&lt;</span>|<span class="symbol">\.</span>|<span class="symbol">\&gt;</span>|<span class="symbol">\/</span>|<span class="symbol">\?</span>]/g, '').toLowerCase()</span><br><span class="line">      return t;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这里仅仅是基于英文中简单的通过空格进行分词的原则。因此会存在比较大的局限性。例如：”中文Chinese and English”，则直接被识别为”中文Chinese”、”and”、”English”，而无法将”中文”和”Chinese”再区分开。</p>
<p>相较于第二种方案的有点则是没有任何其他依赖，很轻量，适用于网页。而对基于网页标签进行的搜索则比较好，因为，标签本身就是简短，分散的。可以认为是分词好的。</p>
<h2 id="基于分词的中文支持版本"><a href="#基于分词的中文支持版本" class="headerlink" title="基于分词的中文支持版本"></a>基于分词的中文支持版本</h2><p>这个版本基于node-segment中文分词库，在未分词版本的基础上引入分词。功能自然更强大，不过由于分词库的依赖，导致整个包太大。由于需要读取文件形式的分词库，无法在浏览器上使用，但可以在 nodejs 服务端用。虽然做些修改，可以将分词库作为 js 文件 require 进来，但还是存在包太大的问题。</p>
<p>关键代码的修改也是在 lunr.js 中的 trimmer 和 tokenizer 方法中。不过需要注意的是，在 package.json 中添加对 node-segment 的依赖。</p>
<p>感谢以下两个仓库作者。</p>
<p><a href="https://github.com/ming300/lunr.js/" target="_blank" rel="noopener">https://github.com/ming300/lunr.js/</a></p>
<p><a href="https://github.com/nandy007/lunr.js" target="_blank" rel="noopener">https://github.com/nandy007/lunr.js</a></p>
<p>以及以下文章：</p>
<p><a href="http://blog.songjz.cn/jie-jue-lunr-jsde/" target="_blank" rel="noopener">我的建站路4：解决 lunr.js 的中文支持问题</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> lunr </tag>
            
            <tag> 分词 </tag>
            
            <tag> node-segment </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决pip install时unsupported locale setting错误]]></title>
      <url>http://linfuyan.com/locale_error_unsupported_locale_setting/</url>
      <content type="html"><![CDATA[<p>今天在安装 Shadowsocks 时，使用 <code>pip install</code> 命令出现了下面这个错误：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install shadowsocks</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/bin/pip"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sys.<span class="keyword">exit</span>(main())</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/dist-packages/pip/__init__.py"</span>, line <span class="number">215</span>, <span class="keyword">in</span> main</span><br><span class="line">    locale.setlocale(locale.LC_ALL, <span class="string">''</span>)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/locale.py"</span>, line <span class="number">581</span>, <span class="keyword">in</span> setlocale</span><br><span class="line">    return _setlocale(category, locale)</span><br><span class="line">locale.Error: unsupported locale setting</span><br></pre></td></tr></table></figure>
<p>其实是语言配置错误导致的：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># locale -a</span></span><br><span class="line">locale: Cannot <span class="builtin-name">set</span> LC_CTYPE <span class="keyword">to</span><span class="built_in"> default </span>locale: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">en_AG</span><br><span class="line">en_AG.utf8</span><br><span class="line">en_AU.utf8</span><br><span class="line">en_BW.utf8</span><br><span class="line">en_CA.utf8</span><br><span class="line">en_DK.utf8</span><br><span class="line">en_GB.utf8</span><br><span class="line">en_HK.utf8</span><br><span class="line">en_IE.utf8</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> LC_ALL=C</span></span><br></pre></td></tr></table></figure>
<p>Done!</p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pip </tag>
            
            <tag> locale </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网]]></title>
      <url>http://linfuyan.com/shadowsocks-with-digitalocean/</url>
      <content type="html"><![CDATA[<p>如果下面这些情形你经常遇到：</p>
<blockquote>
<ol>
<li>经常会折腾各种各样的 Web 应用(Java、nodejs、python等各种语言环境)，但是国内的云服务无法提供对应的环境。</li>
<li>你只是临时的折腾这些应用，并不会长期的运营这些服务。国内的云服务费用昂贵，并需要持续较长时间购买。</li>
<li>虽然可能是临时或者短时间折腾这些服务，你也希望可以有稳定的 IP 或者域名来访问服务。而国内的云服务域名需要备案，而你却懒得折腾这些。</li>
<li>你经常有科学上网的需求，却苦于免费的 VPN 不稳定，稳定的却死贵。</li>
</ol>
</blockquote>
<p>那么，可能 DigitalOcean 是你需要的。请往下继续看。否则，你已经可以关闭这个页面了。</p>
<p>先说说 DigitalOcean：</p>
<blockquote>
<ol>
<li>可以把 DigitalOcean 看做是 VPS，你对上面的环境有完全的支配权，想折腾什么类型的 Web 应用都可以。</li>
<li>DigitalOcean 通过创建 droplet 来快速搭建基础环境，可视化的管理配置，轻而易举的可以与你的域名绑定。从而快速稳定的访问你的服务。</li>
<li>DigitalOcean 最低的收费是每月5美刀，并且按照使用时长(每小时结算)收费。创建的 droplet 如果关闭，则不再继续收费。非常适合需要临时折腾的你。而且，通过这个<strong><a href="https://m.do.co/c/c6ceb25187c4" target="_blank" rel="noopener">邀请链接</a></strong>进行注册，将自动赠送10美刀。</li>
<li>DigitalOcean 的旧金山节点，国内链接速度快，很适合通过搭建 Shadowsocks 来提供稳定靠谱的科学上网服务。</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="在-DigitalOcean-上配置-droplet"><a href="#在-DigitalOcean-上配置-droplet" class="headerlink" title="在 DigitalOcean 上配置 droplet"></a>在 DigitalOcean 上配置 droplet</h2><p>注册 DigitalOcean 账户就不说了。需要提醒的是，使用 DigitalOcean 需要绑定银行卡。</p>
<p>新建 droplet 的步骤： </p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_1.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<p>1. 选择系统镜像，这里选了 ubuntu 16.04</p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_2.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<p>2. 选择配置，这里选$5/月</p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_3.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<p>3. 选择机房位置，旧金山的访问速度比较快</p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_4.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<p>4. 添加 SSH key，用于后面远程登录的验证。具体操作可以看<a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets" target="_blank" rel="noopener">官方文档</a>或者<a href="http://linfuyan.com/generating-ssh-keys/">生成SSH密钥</a>。</p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_5.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<p>5. 这样，不到1分钟时间，就创建好了一个 droplet，带有固定IP，还可以绑定域名。</p>
<p><img src="http://img.uprogrammer.cn/static/images/ss_do_6.png" alt="在DigitalOcean上搭建Shadowsocks来实现稳定靠谱的科学上网"></p>
<h2 id="安装并配置-Shadowsocks-服务"><a href="#安装并配置-Shadowsocks-服务" class="headerlink" title="安装并配置 Shadowsocks 服务"></a>安装并配置 Shadowsocks 服务</h2><p>在第一步中配置完 ssh key，就可以远程登录到 DigitalOcean 的 droplet 上，直接用 root 用户即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> root<span class="variable">@your_droplet_ip</span></span><br></pre></td></tr></table></figure>
<p>刚才我们的 droplet 环境是 ubuntu 16.04，通过如下命令安装 shadowsocks：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> python-pip</span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我遇到了 <code>locale.Error: unsupported locale setting</code> 的问题，解决方案看这里：<a href="https://linfuyan.com/locale_error_unsupported_locale_setting/index.html">解决 pip install 时 locale.Error: unsupported locale setting 错误</a></p>
</blockquote>
<p>安装好以后，就可以通过以下指令启动服务：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssserver -p <span class="number">8836</span> -k `password` -m rc4-md5</span><br><span class="line"></span><br><span class="line"># 或者可以通过以下指令在后台启动shadowsocks的服务：</span><br><span class="line">ssserver -p <span class="number">8843</span> -k `password` -m rc4-md5 -d start</span><br><span class="line">ssserver -p <span class="number">8843</span> -k `password` -m rc4-md5 -d stop</span><br></pre></td></tr></table></figure>
<p>上面的指令方式不太方便，推荐通过文件配置的方式。新建一个 <code>/etc/shadowsocks.json</code> 文件，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"your_droplet_ip"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: <span class="number">8388</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"your_password"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来使用下面的指令启动服务：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">#或者在后台运行</span><br><span class="line">ssserver -c /etc/shadowsocks<span class="selector-class">.json</span> -d start</span><br><span class="line">ssserver -c /etc/shadowsocks<span class="selector-class">.json</span> -d stop</span><br></pre></td></tr></table></figure>
<p>以上操作以后，就可以通过各种 Shadowsocks 客户端科学上网啦。稳定又靠谱！</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Shadowsocks </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> DigitalOcean </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[形象的讲解 angular 中的 $q 与 promise]]></title>
      <url>http://linfuyan.com/$q_and_promise_in_angular/</url>
      <content type="html"><![CDATA[<p>promise 不是 angular 首创的，作为一种编程模式，它出现在…1976年，比 javascript 还要古老得多。promise 全称是 Futures and promises。具体的可以参见 <a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Futures_and_promises</a>。</p>
<p>而在 javascript 世界中，一个广泛流行的库叫做 Q 地址是 <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a>，而 angular 中的 $q 就是从它引入的。 promise 解决的是异步编程的问题，对于生活在同步编程世界中的程序员来说，它可能比较难于理解，这也构成了 angular 入门门槛之一，本文将用生活中的一个例子对此做一个形象的讲解。</p>
<a id="more"></a>
<p>假设有一个家具厂，而它有一个 VIP 客户张先生。</p>
<p>有一天张先生需要一个豪华衣柜，于是，他打电话给家具厂说我需要一个衣柜，回头做好了给我送来，这个操作就叫 $q.defer，也就是延期，因为这个衣柜不是现在要的，所以张先生这是在发起一个可延期的请求。</p>
<p>同时，家具厂给他留下了一个回执号，并对他说：我们做好了会给您送过去，放心吧。这叫做 promise，也就是承诺。</p>
<p>这样，这个 defer 算是正式创建了，于是他把这件事记录在自己的日记上，并且同时记录了回执号，这叫做 deferred，也就是已延期事件。</p>
<p>现在，张先生就不用再去想着这件事了，该做什么做什么，这就是“异步”的含义。</p>
<p>假设家具厂在一周后做完了这个衣柜，并如约送到了张先生家（包邮哦，亲），这就叫做 deferred.resolve (衣柜)，也就是“已解决”。而这时候张先生只要签收一下这个（衣柜）参数就行了，当然，这个“邮包”中也不一定只有衣柜，还可以包含别的东西，比如厂家宣传资料、产品名录等。整个过程中轻松愉快，谁也没等谁，没有浪费任何时间。</p>
<p>假设家具厂在评估后发现这个规格的衣柜我们做不了，那么它就需要 deferred.reject (理由)，也就是“拒绝”。拒绝没有时间限制，可以发生在给出承诺之后的任何时候，甚至可能发生在快做完的时候。而且拒绝时候的参数也不仅仅限于理由，还可以包含一个道歉信，违约金之类的，总之，你想给他什么就给他什么，如果你觉得不会惹恼客户，那么不给也没关系。</p>
<p>假设家具厂发现，自己正好有一个符合张先生要求的存货，它就可以用 $q.when (现有衣柜)来把这个承诺给张先生，这件事就立即被解决了，皆大欢喜，张先生可不在乎你是从头做的还是现有的成品，只会惊叹于你们的效率之高。</p>
<p>假设这个家具厂对客户格外的细心，它还可能通过 deferred.notify (进展情况)给张先生发送进展情况的“通知”。</p>
<p>这样，整个异步流程就圆满完成，无论成功或者失败，张先生都没有往里面投入任何额外的时间成本。</p>
<p>好，我们再扩展一下这个故事：</p>
<p>张先生这次需要做一个桌子，三把椅子，一张席梦思，但是他不希望今天收到个桌子，明天收到个椅子，后天又得签收一次席梦思，而是希望家具厂做好了之后一次性送过来，但是他下单的时候又是分别下单的，那么他就可以重新跟家具厂要一个包含上述三个承诺的新承诺，这就是 $q.all (桌子承诺，椅子承诺，席梦思承诺)，这样，他就不用再关注以前的三个承诺了，直接等待这个新的承诺完成，到时候只要一次性签收了前面的这些承诺就行了。</p>
<blockquote>
<p>原文：<a href="http://www.ngnice.com/posts/126ee9cf6ddb68" target="_blank" rel="noopener">形象的讲解angular中的$q与promise</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular </tag>
            
            <tag> $q </tag>
            
            <tag> promise </tag>
            
            <tag> defer </tag>
            
            <tag> 异步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React + React Router + Redux + Webpack 开发 SPA]]></title>
      <url>http://linfuyan.com/React+ReactRouter+Redux+Webpack%E6%89%93%E9%80%A0SPA/</url>
      <content type="html"><![CDATA[<p>前段时间要做一个 Web app，于是对 ReactJS 作了些学习。没想到水比较深，由此探索了一套用于开发 SPA 的相关技术： React + React Router + Redex + Webpack。</p>
<p>这里先占个坑，后续再细写。相关的学习资料如下：</p>
<p><a href="http://uprogrammer.cn/react-tutorial-cn/index.html" target="_blank" rel="noopener">ReactJS 入门教程中文版</a></p>
<p><a href="http://uprogrammer.cn/react-router-cn/index.html" target="_blank" rel="noopener">React Router 中文文档</a></p>
<p><a href="http://uprogrammer.cn/redux-in-chinese/index.html" target="_blank" rel="noopener">Redux 中文文档</a></p>
<p><a href="http://uprogrammer.cn/webpack-handbook/index.html" target="_blank" rel="noopener">Webpack 中文手册</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReactJS </tag>
            
            <tag> React Router </tag>
            
            <tag> Redux </tag>
            
            <tag> Flux </tag>
            
            <tag> Webpack </tag>
            
            <tag> SPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实例：使用 cheerio 抓取网页数据，并通过 ejs 模板输出静态页面]]></title>
      <url>http://linfuyan.com/grab-web-page-by-cheerio-and-render-via-ejs/</url>
      <content type="html"><![CDATA[<p>这篇文章中，我将使用 cheerio 从 <a href="http://ss.uprogrammer.cn" target="_blank" rel="noopener">http://ss.uprogrammer.cn</a> 上抓取到免费的 shadowsocks 账号，然后通过 ejs 模板，输出成新的网页。</p>
<p><strong>cheerio</strong> 是 nodejs 的抓取页面模块，为服务器特别定制的，快速、灵活、实施的 jquery 核心实现，适合各种 Web 爬虫程序。详见: <a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a></p>
<p><strong>ejs</strong> 是一个 JavaScript 模板库，用来从 JSON 数据中生成 HTML 字符串。详见： <a href="https://github.com/tj/ejs" target="_blank" rel="noopener">https://github.com/tj/ejs</a></p>
<a id="more"></a>
<p>下面的截图中显示，<a href="http://ss.upgrogrammer.cn" target="_blank" rel="noopener">http://ss.upgrogrammer.cn</a> 上有一个免费 shadowsocks 账号的展示区域。</p>
<p><img src="http://img.uprogrammer.cn/static/images/free-shadowsocks.png" alt="http://ss.uprogrammer.cn 科学上网，免费shadowsocks账号"></p>
<p>并且通过 chrome 的审查元素，可以看到相关的源码。</p>
<p><img src="http://img.uprogrammer.cn/static/images/free-shadowsocks-2.png" alt="http://ss.uprogrammer.cn 科学上网，免费shadowsocks账号"></p>
<p>那么，接下来，我们就要抓取这部分内容中的免费 shadowsocks 账号信息。</p>
<h2 id="新建-nodejs-项目，并安装相关依赖"><a href="#新建-nodejs-项目，并安装相关依赖" class="headerlink" title="新建 nodejs 项目，并安装相关依赖"></a>新建 nodejs 项目，并安装相关依赖</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> init</span><br><span class="line">...</span><br><span class="line"><span class="built_in">npm</span> install cheerio ejs --save</span><br></pre></td></tr></table></figure>
<p>以下图片显示了通过 <code>npm init</code> 命令创建 nodejs 项目的过程：</p>
<p><img src="http://img.uprogrammer.cn/static/images/npm_init_project.gif" alt="http://ss.uprogrammer.cn 科学上网，免费shadowsocks账号"></p>
<h2 id="获取-http-ss-upgrammer-cn-完整网页内容"><a href="#获取-http-ss-upgrammer-cn-完整网页内容" class="headerlink" title="获取 http://ss.upgrammer.cn 完整网页内容"></a>获取 <a href="http://ss.upgrammer.cn" target="_blank" rel="noopener">http://ss.upgrammer.cn</a> 完整网页内容</h2><p>在使用 cheerio 来抓取我们所需的内容之前，我们要通过 http 模块，将完整页面先获取到。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">	http.get(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> data = <span class="string">""</span>;</span><br><span class="line">		res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">			data += chunk;</span><br><span class="line">		&#125;);</span><br><span class="line">		res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			callback(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;).on(<span class="string">"err"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e);</span><br><span class="line">		callback(<span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码片段通过 GET 方法获取对应 url 的数据，并通过 callback 传回。</p>
<h2 id="从获取到的完整页面中抓取免费账号信息"><a href="#从获取到的完整页面中抓取免费账号信息" class="headerlink" title="从获取到的完整页面中抓取免费账号信息"></a>从获取到的完整页面中抓取免费账号信息</h2><p>通过在浏览器中查看源代码(具体内容其实也就是我们通过上面的 <code>download</code> 函数返回的结构)，我们发现，这个页面结构是非常简单的。</p>
<ol>
<li>所有的免费账号信息都在 id 为 <code>account_container</code> 的 <code>&lt;div&gt;</code> 标签中。</li>
<li>所有的单条账号信息，都在 <code>&lt;div class=&quot;col-md-4 text-center&quot;&gt;...&lt;/div&gt;</code> 中。</li>
<li>单条账号中的信息，是连续的6个<code>&lt;h4&gt;</code>标签，按照服务器地址、端口号、密码、加密方式、状态、说明的方式存在。 </li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">download(<span class="string">"http://ss.uprogrammer.cn/"</span>, function(<span class="name">data</span>) &#123;</span><br><span class="line">	if (!data) &#123;</span><br><span class="line">		console.log('no data found')<span class="comment">;</span></span><br><span class="line">		return<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    var accounts = []<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">	$ = cheerio.load(<span class="name">data</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // 通过 cheerio 的选择器获取免费账号信息单元</span><br><span class="line">	var ss = $('#account_container &gt; .col-md-4')<span class="comment">;</span></span><br><span class="line">	</span><br><span class="line">	for (<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; ss.length; i++) &#123;</span></span><br><span class="line">		var s = &#123;&#125;<span class="comment">;</span></span><br><span class="line">		</span><br><span class="line">		// 解析服务器</span><br><span class="line">		var server = $(<span class="name">ss</span>[i]).children().first()<span class="comment">;</span></span><br><span class="line">		s['server'] = server.text().substr(<span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['server'])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 解析端口</span><br><span class="line">		var port = $(<span class="name">server</span>).next()<span class="comment">;</span></span><br><span class="line">		s['port'] = port.text().substr(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['port'])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 解析密码</span><br><span class="line">		var password = $(<span class="name">port</span>).next()<span class="comment">;</span></span><br><span class="line">		s['password'] = password.text().substr(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['password'])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 解析加密方式</span><br><span class="line">		var encrypt = $(<span class="name">password</span>).next()<span class="comment">;</span></span><br><span class="line">		s['encrypt'] = encrypt.text().substr(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['encrypt'])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 解析状态</span><br><span class="line">		var status = $(<span class="name">encrypt</span>).next()<span class="comment">;</span></span><br><span class="line">		s['status'] = status.text().substr(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['status'])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        // 解析说明</span><br><span class="line">		var tip = $(<span class="name">status</span>).next()<span class="comment">;</span></span><br><span class="line">		s['tip'] = tip.text()<span class="comment">;</span></span><br><span class="line">		console.log(<span class="name">s</span>['tip'])<span class="comment">;</span></span><br><span class="line">		</span><br><span class="line">		account.push(<span class="name">s</span>)<span class="comment">;</span></span><br><span class="line">		console.log(<span class="string">"==="</span>)<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>主要的代码片段如上，最终 <code>account</code> 变量中将保存所有的账号信息。</p>
<h2 id="将数据通过-ejs-模板渲染成新的页面"><a href="#将数据通过-ejs-模板渲染成新的页面" class="headerlink" title="将数据通过 ejs 模板渲染成新的页面"></a>将数据通过 ejs 模板渲染成新的页面</h2><p>我们需要定义一个模板文件 <code>template.ejs</code>，如下：</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实例：使用 cheerio 抓取网页数据，并通过 ejs 模板输出静态页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="vbscript">&lt;% servers.forEach(<span class="keyword">function</span>(<span class="built_in">server</span>)&#123; %&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span>服务器地址:</span><span class="vbscript">&lt;%= <span class="built_in">server</span>.<span class="built_in">server</span> %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span>端口:</span><span class="vbscript">&lt;%= <span class="built_in">server</span>.port %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span>密码:</span><span class="vbscript">&lt;%= <span class="built_in">server</span>.password %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span>加密方式:</span><span class="vbscript">&lt;%= <span class="built_in">server</span>.encrypt %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span>状态:</span><span class="vbscript">&lt;%= <span class="built_in">server</span>.status %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><span class="vbscript">&lt;%= <span class="built_in">server</span>.tip %&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="vbscript">&lt;% &#125;) %&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的模板文件，只是说明传递数据与模板解析的功能。其中将接收名为 <code>servers</code> 的参数。</p>
<p>下面我们定义一个 <code>render</code> 函数，读取 <code>template.ejs</code> 模板文件，并根据传入的 <code>servers</code> 参数进行渲染，输出到 <code>index.html</code> 中。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(accounts)</span> </span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./template.ejs'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e, v)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret = v.toString();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">var</span> options = &#123;servers: accounts&#125;</span><br><span class="line">      <span class="keyword">var</span> template = ejs.render(ret, options);</span><br><span class="line">      fs.writeFile(<span class="string">'./index.html'</span>, template, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;         </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK。完成上面的过程，整个程序结构如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/demo-cheerio-ejs-structure.png" alt="http://ss.uprogrammer.cn 科学上网，免费shadowsocks账号"></p>
<p>最后，在项目根目录中执行 <code>node index.js</code>， 正常在终端中可以看到日志输出，并生成 <code>index.html</code> 文件。通过浏览器打开 <code>index.html</code> 就可以验收成果啦。</p>
<p>完整的源码见：<a href="https://github.com/linfuyan/demo-cheerio-ejs" target="_blank" rel="noopener">https://github.com/linfuyan/demo-cheerio-ejs</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> cheerio </tag>
            
            <tag> 网页抓取 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> ejs </tag>
            
            <tag> 模板 </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何通过 JS 来修改浏览器地址]]></title>
      <url>http://linfuyan.com/manipulating-url-using-javascript-without-freshing-the-page/</url>
      <content type="html"><![CDATA[<p>今天看到 jsdig.com 上的效果，发现随着输入的变化，浏览器地址栏中的地址会发生变化，很好奇。效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/jaywcjlove/FED/gh-pages/img/fed.gif" alt="jsdig"></p>
<p>所以找了些资料。</p>
<p>现在的浏览器，可以在不刷新页面的情况下修改浏览器 URL。在浏览过程中，可以将浏览历史储存起来，当点击浏览器后退按钮的时候，还可以从浏览历史上获得回退的信息。主要的工作原理呢，是通过 History 对象的 pushState() 实现的。</p>
<p>直接上测试的代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">"counter"</span>&gt;</span>点击按钮查看变化<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击"</span> <span class="attr">onclick</span>=<span class="string">"update()"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  	<span class="keyword">var</span> counter = <span class="built_in">document</span>.getElementById(<span class="string">"counter"</span>);</span></span><br><span class="line"><span class="actionscript">   	<span class="keyword">var</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  	<span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">  		<span class="keyword">var</span> stateObject = &#123;id: i&#125;;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> title = <span class="string">"Wow Title "</span>+i;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> newUrl = <span class="string">"?count="</span>+i;</span></span><br><span class="line"><span class="undefined">		history.pushState(stateObject, title, newUrl);</span></span><br><span class="line"><span class="javascript">		counter.innerHTML = <span class="built_in">window</span>.location.href;</span></span><br><span class="line"><span class="undefined">		i++;</span></span><br><span class="line"><span class="undefined">  	&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">	  readState(event.state);</span></span><br><span class="line"><span class="undefined">	&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">	<span class="function"><span class="keyword">function</span> <span class="title">readState</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="undefined">	  counter.innerHTML = data.id;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接把上面的代码保存成静态网页，然后放到 web 服务器下访问就可以了。具体画面如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/via_js_update_window_location_href.gif" alt="如何通过 JS 来修改浏览器地址"></p>
<p>参考：</p>
<p><a href="https://hasin.me/2013/10/16/manipulating-url-using-javascript-without-freshing-the-page/" target="_blank" rel="noopener">Manipulating browser URL using Javascript without refreshing the page</a></p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器地址 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何使用 npm 打包发布 nodejs 程序包]]></title>
      <url>http://linfuyan.com/publish_your_module_to_npm/</url>
      <content type="html"><![CDATA[<p>昨天写了个 gitbook 的 cnzz 统计插件，<a href="https://github.com/linfuyan/gitbook-plugin-cnzz" target="_blank" rel="noopener">源码见这里</a>，想要发布出来，再通过 <code>npm install</code> 的形式安装。</p>
<p>具体的步骤如下：</p>
<p>1. 在 npm 官网 <a href="https://www.npmjs.org" target="_blank" rel="noopener">https://www.npmjs.org</a> 申请一个账号，并且进行必要的验证。</p>
<blockquote>
<p>刚开始用的是网易邮箱注册，但似乎收不到官方的验证邮件，后来改用了 Gmail，可以注册了。</p>
</blockquote>
<p>2. 增加刚申请完成的用户名到 npm 环境中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm --registry <span class="string">http:</span><span class="comment">//registry.npmjs.org adduser</span></span><br><span class="line"><span class="string">Username:</span> your name</span><br><span class="line"><span class="string">Password:</span> your password</span><br><span class="line"><span class="string">Email:</span> (<span class="keyword">this</span> IS <span class="keyword">public</span>) yourmail<span class="meta">@host</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意所使用的 registry。由于国内的网络环境，之前将默认的 registry 设置成了淘宝的 npm 源。这里需要调整回来。</p>
</blockquote>
<p>3. 进入到你的 npm 项目中，通过 <code>npm publish</code> 发布。</p>
<p>4. 再新建一个项目 nodejs 项目，通过 <code>npm install</code> 验证是否能够安装。</p>
<p>我在发布过程中，遇到了如下问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! no_perms Private mode enable, only admin can publish <span class="keyword">this</span> <span class="keyword">module</span>: gitbook-plugin-cnzz</span><br></pre></td></tr></table></figure>
<p>原因就是我默认使用的淘宝的 npm 源，添加了用户，但权限不对，在发布时同样添加 registry 就可以了。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> 打包 </tag>
            
            <tag> 发布 </tag>
            
            <tag> gitbook </tag>
            
            <tag> cnzz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 IntelliJ IDEA 上创建基于 Gradle 的 SpringMVC 实例]]></title>
      <url>http://linfuyan.com/create_springmvc_project_base_on_gradle_use_intellij_idea/</url>
      <content type="html"><![CDATA[<p>注意：需要 IntelliJ IDEA 的 Ultimate 版本，用 Community 版本是不行的，因为需要支持 Web 项目。 Ultimate 版本是收费的，网上有破解。</p>
<p><img src="http://img.uprogrammer.cn/static/images/intellij_idea.png" alt="IntelliJ IDEA 版本"></p>
<p>我把具体的过程录制成了视频：</p>
<iframe frameborder="0" width="100%" height="400" src="http://v.qq.com/iframe/player.html?vid=r0188ue1mgk&tiny=0&auto=0" allowfullscreen></iframe>

<p>如果想要看高清的视频，可以扫描页面上的公众号二维码，关注并回复”firstspringmvc”来获取原始视频链接。</p>
<p>参考：</p>
<p><a href="http://note.youdao.com/share/web/file.html?id=f6818219990d6a031ef8b237e12c3ff4&amp;type=note" target="_blank" rel="noopener">intellij + gradle + tomcat + 热加载 + 测试 搭建java web开发环境</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> JavaWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OSX 10.11 通过 HomeBrew 安装 MySQL]]></title>
      <url>http://linfuyan.com/install_mysql_via_brew_on_osx_eicapitan/</url>
      <content type="html"><![CDATA[<p>在 Mac OSX 升级到 EICapitan 之后，原来安装的 MySQL 就多多少少出现了问题。于是决定重装：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ brew <span class="keyword">install</span> mysql</span><br><span class="line">==&gt; Installing dependencies <span class="keyword">for</span> mysql: openssl</span><br><span class="line">==&gt; Installing mysql dependency: openssl</span><br><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/openssl<span class="number">-1.0</span><span class="number">.2</span>e_1.el_capitan</span><br><span class="line">######################################################################## <span class="number">100.0</span>%</span><br><span class="line">==&gt; Pouring openssl<span class="number">-1.0</span><span class="number">.2</span>e_1.el_capitan.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">A CA <span class="keyword">file</span> has been bootstrapped <span class="keyword">using</span> certificates <span class="keyword">from</span> the <span class="keyword">system</span></span><br><span class="line">keychain. <span class="keyword">To</span> <span class="keyword">add</span> additional certificates, place .pem files <span class="keyword">in</span></span><br><span class="line">  /usr/<span class="keyword">local</span>/etc/openssl/certs</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> run</span><br><span class="line">  /usr/<span class="keyword">local</span>/opt/openssl/<span class="keyword">bin</span>/c_rehash</span><br><span class="line"></span><br><span class="line">This formula <span class="keyword">is</span> keg-<span class="keyword">only</span>, which means it was <span class="keyword">not</span> symlinked <span class="keyword">into</span> /usr/local.</span><br><span class="line"></span><br><span class="line">Apple has deprecated <span class="keyword">use</span> <span class="keyword">of</span> OpenSSL <span class="keyword">in</span> favor <span class="keyword">of</span> its own TLS <span class="keyword">and</span> crypto libraries</span><br><span class="line"></span><br><span class="line">Generally there <span class="keyword">are</span> <span class="keyword">no</span> consequences <span class="keyword">of</span> this <span class="keyword">for</span> you. <span class="keyword">If</span> you <span class="keyword">build</span> your</span><br><span class="line">own software <span class="keyword">and</span> it requires this formula, you<span class="string">'ll need to add to your</span></span><br><span class="line"><span class="string">build variables:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    LDFLAGS:  -L/usr/local/opt/openssl/lib</span></span><br><span class="line"><span class="string">    CPPFLAGS: -I/usr/local/opt/openssl/include</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; Summary</span></span><br><span class="line"><span class="string">🍺  /usr/local/Cellar/openssl/1.0.2e_1: 465 files, 11.9M</span></span><br><span class="line"><span class="string">==&gt; Installing mysql</span></span><br><span class="line"><span class="string">==&gt; Downloading https://homebrew.bintray.com/bottles/mysql-5.7.10.el_capitan.bot</span></span><br><span class="line"><span class="string">######################################################################## 100.0%</span></span><br><span class="line"><span class="string">==&gt; Pouring mysql-5.7.10.el_capitan.bottle.2.tar.gz</span></span><br><span class="line"><span class="string">==&gt; /usr/local/Cellar/mysql/5.7.10/bin/mysqld --initialize-insecure --user=lfy -</span></span><br><span class="line"><span class="string">==&gt; Caveats</span></span><br><span class="line"><span class="string">We'</span>ve installed your MySQL <span class="keyword">database</span> <span class="keyword">without</span> a root password. <span class="keyword">To</span> secure it run:</span><br><span class="line">    mysql_secure_installation</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> <span class="keyword">connect</span> run:</span><br><span class="line">    mysql -uroot</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> have launchd <span class="keyword">start</span> mysql <span class="keyword">at</span> login:</span><br><span class="line">  <span class="keyword">ln</span> -sfv /usr/<span class="keyword">local</span>/opt/mysql<span class="comment">/*.plist ~/Library/LaunchAgents</span></span><br><span class="line"><span class="comment">Then to load mysql now:</span></span><br><span class="line"><span class="comment">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span></span><br><span class="line"><span class="comment">Or, if you don't want/need launchctl, you can just run:</span></span><br><span class="line"><span class="comment">  mysql.server start</span></span><br><span class="line"><span class="comment">==&gt; Summary</span></span><br><span class="line"><span class="comment">🍺  /usr/local/Cellar/mysql/5.7.10: 12,677 files, 433.2M</span></span><br></pre></td></tr></table></figure>
<p>直接使用 <code>mysql -uroot</code>，出现如下错误提示：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock'</span><br></pre></td></tr></table></figure>
<p>原因是 mysql 服务没有启动，故尝试 <code>mysql.server start</code>，结果如下，依然出错。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysql.server start</span><br><span class="line">Starting MySQL</span><br><span class="line">. ERROR! The<span class="built_in"> server </span>quit without updating PID file (/usr/local/var/mysql/bogon.pid).</span><br></pre></td></tr></table></figure>
<p>最终的处理方式是：</p>
<ol>
<li>通过 <code>mysqld</code> 直接启动 mysql。</li>
<li>由于 HomeBrew 安装的 mysql 默认root账户没有设置密码，故按照提示输入 <code>mysql_secure_installation</code> 来设置密码。</li>
<li>设置完成以后，就可以正常操作 mysql 了。</li>
</ol>
<p>HomeBrew 安装的 mysql 的数据存储位置为 <code>/usr/local/var/mysql</code>。 可以通过 <code>find / -name databasename</code> 的方式根据数据库名称找到具体位置。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> LAMP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> HomeBrew </tag>
            
            <tag> MySQL </tag>
            
            <tag> OSX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OS X 上安装 MongoDB]]></title>
      <url>http://linfuyan.com/install-mongodb-on-mac-os-x/</url>
      <content type="html"><![CDATA[<p>参考：<a href="https://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">Install MongoDB on OS X</a></p>
<p><strong>Mac OS X 的系统版本：EI Capitan (10.11.1)</strong></p>
<p>这里采用 HomeBrew 来安装 MongoDB。</p>
<a id="more"></a> 
<p>1. 升级 HomeBrew 到最新</p>
<blockquote>
<p>brew update</p>
</blockquote>
<p>2. 完成以后，通过以下命令安装</p>
<blockquote>
<p>brew install mongodb</p>
</blockquote>
<p>正常情况下按照上面步骤就可以完成安装，但是我这里遇到了一些问题。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Error: The `brew link` step did <span class="keyword">not</span> complete successfully</span><br><span class="line">The formula built, <span class="keyword">but</span> <span class="keyword">is</span> <span class="keyword">not</span> symlinked <span class="keyword">into</span> /usr/<span class="keyword">local</span></span><br><span class="line">Could <span class="keyword">not</span> symlink .</span><br><span class="line">/usr/<span class="keyword">local</span>/opt <span class="keyword">is</span> <span class="keyword">not</span> writable.</span><br><span class="line"></span><br><span class="line">You can <span class="keyword">try</span> again using:</span><br><span class="line">  brew link scons</span><br></pre></td></tr></table></figure>
<p>问题的原因就是 <code>/usr/local/opt</code> 目录不可写，正常情况下，在目前的 Mac OS X EI Capitan 上 <code>/usr/local</code> 是可写的，但其他的应用是可以修改其读写权限的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Error: The /usr/local directory is not writable.</span><br><span class="line">Even if this directory was writable when you installed Homebrew, other</span><br><span class="line">software may <span class="keyword">change</span> permissions <span class="keyword">on</span> this directory. <span class="keyword">Some</span> <span class="keyword">versions</span> <span class="keyword">of</span> the</span><br><span class="line"><span class="string">"InstantOn"</span> component <span class="keyword">of</span> Airfoil <span class="keyword">are</span> known <span class="keyword">to</span> <span class="keyword">do</span> this.</span><br><span class="line"></span><br><span class="line">You should probably <span class="keyword">change</span> the ownership <span class="keyword">and</span> permissions <span class="keyword">of</span> /usr/<span class="keyword">local</span></span><br><span class="line">back <span class="keyword">to</span> your <span class="keyword">user</span> account.</span><br><span class="line">  sudo chown -R $(whoami):<span class="keyword">admin</span> /usr/<span class="keyword">local</span></span><br></pre></td></tr></table></figure>
<p>按照提示修改一下问题，重新 <code>brew install mongodb</code> 即可。如提示需要 <code>brew link</code>， 则按照提示操作。</p>
<p>3. 安装完成最终会出现如下提示来以不同方式开启 MongoDB。根据你的需要操作即可。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lfys-MacBook-Pro: lfy$ brew install mongodb</span><br><span class="line">==&gt; Downloading https:<span class="comment">//homebrew.bintray.com/bottles/mongodb-3.2.0.el_capitan.bottle.tar.gz</span></span><br><span class="line">Already downloaded: /Library/Caches/Homebrew/mongodb-<span class="number">3.2</span>.<span class="number">0</span><span class="selector-class">.el_capitan</span><span class="selector-class">.bottle</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">==&gt; Pouring mongodb-<span class="number">3.2</span>.<span class="number">0</span><span class="selector-class">.el_capitan</span><span class="selector-class">.bottle</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">==&gt; Caveats</span><br><span class="line">To have launchd start mongodb at login:</span><br><span class="line">  ln -sfv /usr/local/opt/mongodb<span class="comment">/*.plist ~/Library/LaunchAgents</span></span><br><span class="line"><span class="comment">Then to load mongodb now:</span></span><br><span class="line"><span class="comment">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plist</span></span><br><span class="line"><span class="comment">Or, if you don't want/need launchctl, you can just run:</span></span><br><span class="line"><span class="comment">  mongod --config /usr/local/etc/mongod.conf</span></span><br><span class="line"><span class="comment">==&gt; Summary</span></span><br><span class="line"><span class="comment">🍺  /usr/local/Cellar/mongodb/3.2.0: 17 files, 208M</span></span><br></pre></td></tr></table></figure>
<p>这里我执行了下面的命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config <span class="regexp">/usr/</span>local<span class="regexp">/etc/m</span>ongod.conf</span><br></pre></td></tr></table></figure>
<p>4. 在新的终端窗口中输入 <code>mongo</code> 就可以进行 MongoDB 的操作了。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> Mac </tag>
            
            <tag> HomeBrew </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[技术高手如何炼成？]]></title>
      <url>http://linfuyan.com/how-to-be-a-niubility-engineer/</url>
      <content type="html"><![CDATA[<blockquote>
<p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：郑昀<br>链接：<a href="http://zhuanlan.zhihu.com/zhengyun/20270317" target="_blank" rel="noopener">http://zhuanlan.zhihu.com/zhengyun/20270317</a><br>来源：知乎</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/bingshanyijiao.jpg" alt="技术高手如何炼成？"></p>
<p>面试的时候，我会问面试者，你日常如何构建自己的知识体系，如何让自己更高更快更强？多数工程师并没有深入地思考过这个问题，基本上是零敲碎打，随机性大。本着不能让你白来一趟的精神，好为人师的我会娓娓道来：</p>
<h2 id="第一阶段-认真构建完整的知识体系"><a href="#第一阶段-认真构建完整的知识体系" class="headerlink" title="第一阶段 认真构建完整的知识体系"></a>第一阶段 认真构建完整的知识体系</h2><p>十几年前我投身软件行业的时候，光是讲解数据库原理、操作系统、TCP/IP、组网、算法等等基础知识的英文原版书摞起来就等身，认认真真看完，各种上手实践，入行后，读遍 C++ 各种经典著作，读遍各种协议原文，认认真真打基础。很多工程师都说自己平常就是在某些 IT 门户上看看推荐的博文或新闻，我说这属于典型的零敲碎打，不够刺激。</p>
<p>聊到这时，我会举一个例子，<strong>为什么要阅读长篇小说，因为中短篇小说就像用针扎你，而长篇小说就像把你装进一个沙袋里吊起来，从四面八方用狼牙棒打你，酣畅淋漓。</strong>构建可用的知识体系，就得读书，书是有体系结构的，你关心不关心，现阶段你用到用不到，它都讲到了，从头到尾看几遍，针扎得透透的。</p>
<p>何谓知识体系？</p>
<p>几年前，前支付宝架构师姚建东曾经在我们公司做过技术人员如何规划自己的分享讲座，他是这么论述的：</p>
<p>技术与技巧包括：</p>
<ul>
<li>计算机基础理论<ul>
<li>计算机模型：内存/IO/时钟/CPU……</li>
</ul>
</li>
<li>算法</li>
<li>专项技术领域：<ul>
<li>数据挖掘</li>
<li>数据管理</li>
<li>智能推荐</li>
<li>搜索</li>
<li>……</li>
</ul>
</li>
<li>语言与工具<ul>
<li>语言与相关体系</li>
<li>开发工具，分析工具，代码管理工具</li>
<li>HTML/CSS/JS/Ajax</li>
<li>常用框架与第三方类库</li>
</ul>
</li>
<li>调试与测试<ul>
<li>调试方法和哲学</li>
<li>定位问题</li>
<li>BUG管理工具</li>
<li>单元测试</li>
<li>集成测试</li>
<li>性能测试</li>
<li>安全测试</li>
<li>兼容性测试与方法</li>
<li>JS/Ajax测试与方法</li>
<li>服务层测试</li>
<li>Web层测试</li>
</ul>
</li>
<li>网络与系统<ul>
<li>TCP/IP协议与模型，HTTP/SMTP等协议</li>
<li>Linux系统，网络分析工具，系统分析工具</li>
<li>容量，流量与负载均衡</li>
<li>应用部署、规范、规划</li>
<li>安全</li>
<li>监控与故障分析</li>
<li>磁盘与存储</li>
<li>Shell</li>
<li>DNS与域名</li>
<li>缓存，反向代理</li>
<li>图片服务器（海量小文件）</li>
</ul>
</li>
<li>需求挖掘与分析<ul>
<li>需求文档格式</li>
<li>需求访谈</li>
<li>需求分析方法，需求分析工具</li>
<li>领域知识与经验</li>
</ul>
</li>
<li>系统分析与设计<ul>
<li>UML语言与模型</li>
<li>分析模式</li>
<li>设计模式，领域驱动</li>
<li>系统分析文档格式</li>
<li>系统设计文档格式</li>
<li>功能性需求与非功能性需求</li>
</ul>
</li>
<li>数据与系统<ul>
<li>数据库</li>
<li>可伸缩策略，扩展策略，备份，容灾，性能，安全，高可用……</li>
<li>数据设计与范式，SQL/NoSQL，Cache，分布式文件</li>
</ul>
</li>
<li>架构设计<ul>
<li>架构模式，典型互联网公司架构演进历史</li>
<li>架构原则，常用策略</li>
<li>架构设计方法</li>
<li>非功能性理解<ul>
<li>扩展性</li>
<li>伸缩性</li>
<li>稳定性</li>
<li>一致性</li>
<li>性能</li>
<li>吞吐量</li>
</ul>
</li>
<li>容量预测与规划</li>
<li>架构体系与相关技术</li>
</ul>
</li>
<li>过程与管理<ul>
<li>分析过程</li>
<li>研发过程</li>
<li>评审过程</li>
<li>测试过程</li>
<li>发布过程</li>
<li>回滚过程</li>
<li>文档管理</li>
<li>知识管理</li>
<li>项目管理</li>
</ul>
</li>
</ul>
<p>以上其实就是一份从业基础知识清单，你可以按图索骥，阅读相关书籍。</p>
<h2 id="第二阶段-顺着一个Topic钻进去，锻炼自己的预研能力"><a href="#第二阶段-顺着一个Topic钻进去，锻炼自己的预研能力" class="headerlink" title="第二阶段 顺着一个Topic钻进去，锻炼自己的预研能力"></a>第二阶段 顺着一个Topic钻进去，锻炼自己的预研能力</h2><p>无论公司业务还是自己喜欢做的事，都可以抽象出通用性课题，然后以做论文的方式杀进去。<strong>这个事情得反复操练，有意识操练。</strong></p>
<p>做事方式为：</p>
<ol>
<li>抽象出 Topic——如分布式锁，分布式并行计算引擎，防CSRF的FormToken自动生成框架，定时任务管理与调度平台，分布式跟踪，等等</li>
<li>向功课好的学生学习——有针对性地深入了解业界其他公司是如何分析问题和解决问题的，汇总各种方案，站在巨人的肩膀上</li>
<li>分析特定应用场景，技术选型</li>
<li>兼顾高可用性和可伸缩，做设计评审</li>
<li>做测试自证靠谱，梳理知识点，开技术分享会</li>
<li>上线商用，总结经验教训，开经验分享会</li>
</ol>
<p>其中一个重点是汇总和分享。05年时，应电信级统一消息业务需要，我去研究了 SIP 协议，做了各种试验，分析报文，写了一系列的幻灯片，做了公开分享，一时间还颇受欢迎：</p>
<ol>
<li>SIP_to_Freshman_by_zhengyun.ppt</li>
<li>SIP之穿越NAT_by_zhengyun.ppt</li>
<li>SIP体系架构讲义及消息交互演示_by_zhengyun.ppt</li>
<li>SIP多方会话消息之实例讲解_by_zhengyun.ppt</li>
<li>SIP安全框架之认证[NTLM和Kerberos]_by_zhengyun.ppt</li>
<li>SIP消息之逐项讲解_by_zhengyun.ppt</li>
</ol>
<p>为什么要写出来、讲出来呢？因为有一个学习金字塔理论，如下图所示：</p>
<p><img src="http://img.uprogrammer.cn/static/images/xuexijinzita.png" alt="学习金字塔"></p>
<p>我们读过的事情能够记住学习内容的10%，<br>我们听过的事情能够记住20%，<br>我们看过的事情能够记住30%，<br>我们听过和看过的事情能够记住50%——如看影像/看展览/看演示/现场观摩，<br>我们说过的事情能够记住70%——如参与讨论/发言，<br><strong>我们说过和做过的事情能够记住90%——如做报告，给别人讲，亲身体验，动手做。</strong></p>
<p>这也就是我在《<a href="http://www.cnblogs.com/zhengyun_ustc/p/rightThings.html" target="_blank" rel="noopener">窝窝研发过去几年做对了哪些事</a>》中阐述的管理方法：我们从入职之后就有意识地训练大家，让大家能够公开陈述、清晰表达。所以，试用期内，新人必须做一次技术分享和一次技术评审，面对各方的 challenge；预研的中间和结尾都要有分享会；平时也要定期组织技术讲座。</p>
<h2 id="第三阶段-疯狂回答技术问题"><a href="#第三阶段-疯狂回答技术问题" class="headerlink" title="第三阶段 疯狂回答技术问题"></a>第三阶段 疯狂回答技术问题</h2><p>知识体系慢慢构建，与业务相关的抽象 Topic 也在探索中。但这还不够。因为你亲身接触到的世界太小，可能不足以构成挑战，你可能意识不到自己缺多少知识和技能，不利于你分析问题、提出问题和解决问题的能力培养。</p>
<p>所以，要主动出击：疯狂回答问题。</p>
<p>我曾经在入行的头几年里几乎把我关注的垂直领域（包括语言领域和业务领域）里的所有问题都回答了一遍。我对外宣扬知无不言言无不尽，放出邮件地址和 MSN（那时候 MSN 很高大上），很多网友都会发邮件或者加我好友，问各种开发疑难问题，平均每天都有几个，然后我把解决问题的过程写成微软 KB（KnowledgeBase） 文体发表在我的博客上。</p>
<p>你想想看，工作中的问题你平均每隔几天才能遇到一个，而这么做，每天你都会遇到几个乃至于十几个，第一让你脑力激荡，第二接触到更多新知。05年到06年期间，我因工作需要学习了 JavaME（或古老的称呼 J2ME），早年间 Symbian 手机上的客户端开发。那段时间我天天扫中文论坛的帖子，力求回答所有问题，尤其是那些 BUG 或故障。对于那些暂时没有人解决的，如流媒体实时播放，如仿 OperaMini 二级菜单界面，都上下求索，最后放出思路以及源码。</p>
<p>同时，我经常整理常见问题，梳理成册并发布。譬如我整理过的 J2ME 疑难问题：</p>
<ol>
<li>[J2ME Q&amp;A]真机报告MontyThread -n的错误之解释</li>
<li>[J2MEQ&amp;A]WTK初始化WMAClient报错XXX has no IP address的解释</li>
<li>[J2ME Q&amp;A]untrusted domain is not configured问题回应</li>
<li>[J2ME]“Cannot open socket for LIME events”错误解决</li>
</ol>
<p>几个月后，我成为 J2ME 中文论坛超级版主。通过这个历程，我想告诉大家，回答网友问题，技巧得当的话，比如别老是重复回答新手问题，试着攻克那些疑难问题，或者离奇故障，绝对不会浪费你的时间。为什么？</p>
<p>因为你要信奉：</p>
<blockquote>
<p><strong>你学过的每一样东西，你遭受的每一次苦难，都会在你一生中的某个时候派上用场。</strong><br>——佩内洛普·菲兹杰拉德 《离岸》</p>
<p>Everything that you’ve learnt and all the hardships you’ve suffered will all come in handy at some point in your life.</p>
</blockquote>
<h2 id="第四阶段-RCA-总结"><a href="#第四阶段-RCA-总结" class="headerlink" title="第四阶段 RCA/总结"></a>第四阶段 RCA/总结</h2><p>现在是你把经验教训变为财富的时刻了。</p>
<p>什么是好的技术 Leader？</p>
<p>随便一个业务需求或业务场景讲出来，你立刻把它抽象为几个模块/系统/Topic，然后侃侃而谈，业界都是怎么解决的，我们以前又是怎么分析怎么解决的，现在咱们这种情况下应该如何设计，可能会遇到什么问题，我们应该做哪些预防设计，blabla。</p>
<p>怎么做到这一点？</p>
<p>第一，写 RCA 报告。我以前说过，『窝窝从 2011 年开始，一直坚持每错必查、错了又错就整改、每错必写，用身体力行告诉每一个新员工直面错误、公开技术细节、分享给所有人，长此以往，每一次事故和线上漏测都会变为我们的财富。这就是我们的 RCA（Root Cause Analysis）制度，截止到目前已经收集整理了近两百个详尽的 RCA 报告。』</p>
<p>RCA 报告格式为：</p>
<ol>
<li>背景知识（Optional）</li>
<li>问题现象</li>
<li>影响范围</li>
<li>问题原因</li>
<li>问题分析过程（Optional）</li>
<li>解决办法</li>
<li>后续处理措施：如线上脏数据如何修复，如对用户造成的影响如何弥补等（Optional）</li>
<li>经验教训</li>
<li>RCA类型：如代码问题、实施问题、配置问题、设计问题、测试问题</li>
</ol>
<p>这样，作为一名合格的老兵，你见过了足够多的血，并且把它们变成了你的人生财富。</p>
<p>第二，写总结。话说，要经常拉清单。侃侃而谈得有资料，这些都得是你自己写才能印象深刻，关键时刻想得起来。</p>
<p>好了，这就是我告诉面试者的高手炼成四个阶段。</p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 知识体系 </tag>
            
            <tag> 学习金字塔 </tag>
            
            <tag> 技术高手 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android (Java) 编码惯例及最佳实践]]></title>
      <url>http://linfuyan.com/android-or-java-style-guide-and-best-practice/</url>
      <content type="html"><![CDATA[<h1 id="1-声明-Declaration"><a href="#1-声明-Declaration" class="headerlink" title="1. 声明(Declaration)"></a>1. 声明(Declaration)</h1><h2 id="1-1-每行声明变量的数量-Number-Per-Line"><a href="#1-1-每行声明变量的数量-Number-Per-Line" class="headerlink" title="1.1 每行声明变量的数量(Number Per Line)"></a>1.1 每行声明变量的数量(Number Per Line)</h2><p>推荐一行一个声明，因为这样以利于写注释。亦即，</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> level; <span class="comment">// indentation level      </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// size of table</span></span><br></pre></td></tr></table></figure>
<p>要优于，</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> level, <span class="built_in">size</span>;</span><br></pre></td></tr></table></figure>
<p>不要将不同类型变量的声明放在同一行，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo, fooarry[]; <span class="comment">// WRONG!</span></span><br></pre></td></tr></table></figure>
<p>注意：上面的例子中，在类型和标识之间放了一个空格，另一种被允许的替代方法是多行变量注释的对齐：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> level;                <span class="comment">// indentation level</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">size</span>;                 <span class="comment">// size of table  </span></span><br><span class="line"><span class="keyword">Object</span> currentEntry;      <span class="comment">// currently selected table entry</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-初始化-Initialization"><a href="#1-2-初始化-Initialization" class="headerlink" title="1.2 初始化(Initialization)"></a>1.2 初始化(Initialization)</h2><p>尽量在声明局部变量的同时进行初始化。唯一 不这么做理由是变量的初始值依赖于某些先前发生的计算。</p>
<h2 id="1-3-布局-Placement"><a href="#1-3-布局-Placement" class="headerlink" title="1.3 布局(Placement)"></a>1.3 布局(Placement)</h2><p>建议只在代码块的开始处声明变量(一个块可以指任何被包含在大括号“{”和“}”中间的代码，也可以是逻辑上分块的代码)。通常不要在首次用于该变量时才声明之，这会把注意力不集中的程序员搞糊涂，同时会妨碍代码在该作用域内的可移植性。    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int1 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">int</span> int2 = <span class="number">0</span>;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该规则的一个例外是for循环的索引变量</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; maxLoops; <span class="built_in">i</span>++) &#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>避免声明的局部变量覆盖上一级声明的变量。例如，不要在内部代码块中声明相同的变量名：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">…</span><br><span class="line">myMethod() &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;    <span class="comment">// AVOID!</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-类和接口的声明-Class-and-Interface-Declarations"><a href="#1-4-类和接口的声明-Class-and-Interface-Declarations" class="headerlink" title="1.4 类和接口的声明(Class and Interface Declarations)"></a>1.4 类和接口的声明(Class and Interface Declarations)</h2><p>当编写类和接口时，应该遵守以下格式规则：</p>
<ol>
<li>在方法名与其参数列表之前的左括号“(”间不要有空格。</li>
<li>左大括号“{”位于声明语句同行的末尾。</li>
<li>右大括号“}”另起一行，与相应的声明语句对齐，除非是一个空语句，“}”应紧跟在“{”之后。   </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    int ivar1;</span><br><span class="line">    int ivar2;</span><br><span class="line"></span><br><span class="line">    <span class="type">Sample</span>(int i, int j) &#123;</span><br><span class="line">        ivar1 = i;</span><br><span class="line">        ivar2 = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int emptyMethod() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-注释-Comments"><a href="#2-注释-Comments" class="headerlink" title="2. 注释(Comments)"></a>2. 注释(Comments)</h1><p>Java 程序有两类注释：实现注释( implementation comments )和文档注释( document comments )。实现注释是那些在 C++ 中见过的，使用 <code>/*…*/</code> 和 <code>//</code> 界定的注释。文档注释(被称为“doc comments”)是 Java 独有的，并由 <code>/**…*/</code> 界定。文档注释可以通过 javadoc 工具转换成 HTML 文件。</p>
<p>实现注释用以注释代码或或者实现细节。文档注释从实现自由( implemtentation-free )的角度描述代码的规范。它可以被那些手头没有源码的开发人员读懂。</p>
<p>注释应被用来给出代码的总括，并提供代码自身没有提供的附加信息。注释应该仅包含与阅读和理解程序有关的信息。例如，相应的包如何被建立或位于哪个目录下之类的信息不应包括在注释中。</p>
<p>在注释里，对设计决策中重要的或者不是显而易见的地方进行说明是可以的，但应避免提供代码中已清晰表达出来的重复信息，多余的注释很容易过时。通常应避免那些代码更新就可能过时的注释。</p>
<p>注意：频繁的注释有时反映出代码的低质量。当你觉得被迫要加注释的时候，考虑一下重写代码使其更清晰。</p>
<p>注释不应写在用星号或字符画出来的大框里。注释不应包括诸如制表符和回退符之类的特殊字符。</p>
<h2 id="2-1-实现注释的格式-Implementation-Comment-Formats"><a href="#2-1-实现注释的格式-Implementation-Comment-Formats" class="headerlink" title="2.1 实现注释的格式(Implementation Comment Formats)"></a>2.1 实现注释的格式(Implementation Comment Formats)</h2><p>程序可以有4种实现注释的风格：块(Block)，单行(single-line)，尾端(trailing)和行末(end-of-line)。</p>
<h3 id="2-1-1-块注释"><a href="#2-1-1-块注释" class="headerlink" title="2.1.1 块注释"></a>2.1.1 块注释</h3><p>块注释通常用于提供对文件，方法，数据结构和算法的描述。块注释被置于每个文件的开始处以及每个方法之前。它们也可以被用于其他地方，比如方法的内部。在功能和方法内部的块注释应该和它们所描述的代码具有一样的缩进格式。</p>
<p>块注释之首应该有一个空行，用于把块注释和代码分割开来，比如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here is a block comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-单行注释-Single-Line-Comments"><a href="#2-1-2-单行注释-Single-Line-Comments" class="headerlink" title="2.1.2 单行注释(Single-Line Comments)"></a>2.1.2 单行注释(Single-Line Comments)</h3><p>短注释可以显示一行内，并与其后的代码具有一样的缩进层级。如果一个注释不能在一行内写完，就该块注释(参见“块注释”)。单行注释之前应该有一个空行。以下是一个Java代码中单行注释的例子：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> &#123;</span><br><span class="line">    <span class="comment">/* Handle the condition. */</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-尾端注释-Trailing-Comments"><a href="#2-1-3-尾端注释-Trailing-Comments" class="headerlink" title="2.1.3 尾端注释(Trailing Comments)"></a>2.1.3 尾端注释(Trailing Comments)</h3><p>极短的注释可以与它们所要描述的代码位于同一行，但是应该有足够的空白（至少一个空格）来分开代码和注释。若有多个短注释出现于大段代码中，它们应该具有相同的缩进。</p>
<p>以下是一个Java代码中尾端注释的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a ==<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;            <span class="comment">/* special case */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isPrime(a);      <span class="comment">/* works only for odd a */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-行末注释-End-Of-Line-Comments"><a href="#2-1-4-行末注释-End-Of-Line-Comments" class="headerlink" title="2.1.4 行末注释(End-Of-Line Comments)"></a>2.1.4 行末注释(End-Of-Line Comments)</h3><p>注释界定符//，可以注释掉整行或者一行中的一部分。它一般不用于连续多行的注释文本；然而，它可以用来注释掉多行的代码段。以下是所有三种风格的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Do a double-filp.</span></span><br><span class="line">    ……</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Expalin why here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (bar &gt; 1) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // Do a triple-flip.</span></span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else &#123;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-文档注释-Documentation-Comments"><a href="#2-2-文档注释-Documentation-Comments" class="headerlink" title="2.2 文档注释(Documentation Comments)"></a>2.2 文档注释(Documentation Comments)</h2><p>注意：此处描述的注释格式之范例，参见“ Java 源文件范例”<br>若想了解更多，参见“How to Write Doc Comments for Javadoc”，其中包含了有关文档注释标记的信息(@return，@param，@see)：</p>
<p><a href="http://java.sun.com/javadoc/writingdoccomments/index.html" target="_blank" rel="noopener">http://java.sun.com/javadoc/writingdoccomments/index.html</a></p>
<p>若想了解有关文档注释和 javadoc 的详细资料，参见 javadoc 的主页：</p>
<p><a href="http://java.sun.com/javadoc/index.html" target="_blank" rel="noopener">http://java.sun.com/javadoc/index.html</a></p>
<p>文档注释描述Java的类、接口、构造器、方法，以及字段(field)。每个文档注释都会被置于注释界定符 <code>/**…*/</code> 之中，一个注释对应一个类、接口或成员。该注释应位于声明之前：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Example class provides …</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> FirstName Lastname (account<span class="doctag">@sohu</span>-inc.com)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123; …</span><br></pre></td></tr></table></figure>
<p>注意：顶层(top-level)的类和接口是不缩进的，而其成员是缩进的。描述类和接口的文档注释的第一行会被置于注释的第一行(/ **)不需要缩进；随后的文档注释每行都缩进1格(使星号纵向对齐)。成员，包括构造函数在内，其文档注释的第一行缩进4格，随后每行都缩进5格。</p>
<p>若你想给出有关类、接口、变量或方法的信息，而这些信息又不适合写在文档中，则可使用实现块注释(见2.1.1)或紧跟在声明后面的单行注释(见2.1.2)。例如，有关一个类实现的细节应放入紧跟在类声明后面的实现块注释中，而不是放在文档注释中。</p>
<p>文档注释不能放在一个方法或构造器的定义块中，因为 Java 会将位于文档注释之后的第一个声明与其相关联。</p>
<h1 id="3-编程实践"><a href="#3-编程实践" class="headerlink" title="3. 编程实践"></a>3. 编程实践</h1><h2 id="3-1-提供对实例以及类变量的访问控制-Providing-Access-to-Instance-and-Class-Variables"><a href="#3-1-提供对实例以及类变量的访问控制-Providing-Access-to-Instance-and-Class-Variables" class="headerlink" title="3.1 提供对实例以及类变量的访问控制(Providing Access to Instance and Class Variables)"></a>3.1 提供对实例以及类变量的访问控制(Providing Access to Instance and Class Variables)</h2><p>若没有足够的理由，不要把实例或类类变量声明为 public。通常，实例变量无需显式的设置(set)和获取(gotten)，通常这作为方法调用的边缘效应(side effect)而产生。</p>
<p>一个具有public实例变量的恰当例子，是类仅作为数据结构，没有行为。亦即，若你要使用一个结构(struct)而非一个类(如果Java支持结构的话)，那么把类的实例变量声明为public是合适的。</p>
<p>Android 变量访问控制：Android 的开发通常允许公共的实例变量。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Common</span> practice <span class="keyword">in</span> Android development.</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClass &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> pulicField;  // <span class="keyword">public</span> field for <span class="keyword">direct</span> <span class="keyword">access</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-引用类变量和类方法-Referring-to-Class-Variables-and-Methods"><a href="#3-2-引用类变量和类方法-Referring-to-Class-Variables-and-Methods" class="headerlink" title="3.2 引用类变量和类方法(Referring to Class Variables and Methods)"></a>3.2 引用类变量和类方法(Referring to Class Variables and Methods)</h2><p>避免用一个对象访问一个类的静态变量和方法。应该用类名替代。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">classMethod</span>();         <span class="comment">// OK</span></span><br><span class="line"><span class="selector-tag">AClass</span><span class="selector-class">.classMethod</span>();   <span class="comment">// OK</span></span><br><span class="line"><span class="selector-tag">anObject</span><span class="selector-class">.classMethod</span>();  <span class="comment">// AVOID!</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-常量-Constants"><a href="#3-3-常量-Constants" class="headerlink" title="3.3 常量(Constants)"></a>3.3 常量(Constants)</h2><p>位于for循环中作为计数器值的数字常量，除了-1，0和1之外，不应被直接写入代码。</p>
<h2 id="3-4-变量赋值-Variable-Assignments"><a href="#3-4-变量赋值-Variable-Assignments" class="headerlink" title="3.4 变量赋值(Variable Assignments)"></a>3.4 变量赋值(Variable Assignments)</h2><p>避免在一个语句中给多个变量赋相同的值。它很难读懂。例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooBar.fChar = <span class="keyword">barFoo.lchar </span>= ‘c’<span class="comment">;  // AVOID!</span></span><br></pre></td></tr></table></figure>
<p>不要将赋值运算符用在容易与相等关系运算符混淆的地方。例如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(c++ = d++)</span> &#123;    <span class="comment">// AVOID! (Java disallows)</span></span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该写成</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">if</span> <span class="comment">((c</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">=</span> <span class="comment">d</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)</span> <span class="comment">!</span> <span class="comment">=</span> <span class="comment">0)</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">…</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不要使用内嵌(embedded)赋值运算符试图提高运行时效率，这是编译器的工作。例如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="comment">(a = b +c)</span> + r; <span class="comment">// AOVID!</span></span><br></pre></td></tr></table></figure>
<p>应该写成</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = b + c;</span><br><span class="line"><span class="attribute">d</span> = a + r;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-其它惯例-Miscellaneous-Practices"><a href="#3-5-其它惯例-Miscellaneous-Practices" class="headerlink" title="3.5 其它惯例(Miscellaneous Practices)"></a>3.5 其它惯例(Miscellaneous Practices)</h2><h3 id="3-5-1-圆括号与运算符优先级-Parentheses-and-Operator-Precedence"><a href="#3-5-1-圆括号与运算符优先级-Parentheses-and-Operator-Precedence" class="headerlink" title="3.5.1 圆括号与运算符优先级(Parentheses and Operator Precedence)"></a>3.5.1 圆括号与运算符优先级(Parentheses and Operator Precedence)</h3><p>一般而言，在含有多种运算符的表达式中使用括号来避免运算符优先级问题，是个好方法。即便运算符的优先级对你而言可能很清楚，但对其他人未必如此。你不能假设别的程序员和你一样清楚运算符的优先级。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="selector-tag">a</span> == <span class="selector-tag">b</span> &amp;&amp; c ==d)     <span class="comment">// AVOID!</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="selector-tag">a</span> == b) &amp;&amp; (c == d))  <span class="comment">// RIGHT</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-返回值-Returning-Values"><a href="#3-5-2-返回值-Returning-Values" class="headerlink" title="3.5.2 返回值(Returning Values)"></a>3.5.2 返回值(Returning Values)</h3><p>设法让你的程序结构符合目的。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (booleanException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该代之以如下方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> booleanException;</span><br></pre></td></tr></table></figure>
<p>类似地：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br></pre></td></tr></table></figure>
<p>应该写为：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (condition ? x : <span class="type">y</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-条件运算符“-”前的表达式-Expressions-before-“-”-in-the-Conditional-Operator"><a href="#3-5-3-条件运算符“-”前的表达式-Expressions-before-“-”-in-the-Conditional-Operator" class="headerlink" title="3.5.3 条件运算符“?”前的表达式 (Expressions before “?” in the Conditional Operator)"></a>3.5.3 条件运算符“?”前的表达式 <code>(Expressions before “?” in the Conditional Operator)</code></h3><p>如果一个包含二元运算符表达式出现在三元运算符“<code>? :</code>”之前，那么应该给表达式添上一对圆括号。例如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">x</span> &gt;= <span class="number">0</span>) ? <span class="keyword">x</span> : -<span class="keyword">x</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-特殊注释-Special-Comments"><a href="#3-5-4-特殊注释-Special-Comments" class="headerlink" title="3.5.4 特殊注释(Special Comments)"></a>3.5.4 特殊注释(Special Comments)</h3><p>使用 TODO 来注释一个临时的或者未完成的解决方案。TODO 必须包含详细的信息，例如，需要做什么，打算怎么做，为什么以后才做，等。要发布到生产环境的代码尽量减少 TODO。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO: Change this <span class="built_in">to</span> use <span class="keyword">a</span> flag instead <span class="keyword">of</span> <span class="keyword">a</span> <span class="built_in">constant</span>.</span><br></pre></td></tr></table></figure>
<p>如果有可能，尽量包含具体的开发者帐号，以及具体的修正日期。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO(tom, Fix <span class="keyword">by</span> Nov <span class="number">2005</span>): Change this <span class="built_in">to</span> use <span class="keyword">a</span> flag.</span><br></pre></td></tr></table></figure>
<h2 id="3-6-所有对象的共有方法-Methods-Common-to-All-Objects"><a href="#3-6-所有对象的共有方法-Methods-Common-to-All-Objects" class="headerlink" title="3.6 所有对象的共有方法(Methods Common to All Objects)"></a>3.6 所有对象的共有方法(Methods Common to All Objects)</h2><h3 id="3-6-1-覆盖equals时请遵守通用约定"><a href="#3-6-1-覆盖equals时请遵守通用约定" class="headerlink" title="3.6.1 覆盖equals时请遵守通用约定"></a>3.6.1 覆盖equals时请遵守通用约定</h3><p>Item 8: Obey the general contract when overriding equals.</p>
<p>重写 equals 方法看起来很简单，实际上非常容易犯错误。在多数情况下我们不推荐重写equals方法。如果确实有必要，这里再强调一下 Object.equals 的约定：</p>
<ul>
<li>自反：对于任意 non-null 的引用值x，x.equals(x) 必须返回true。</li>
<li>对称：对于任意的 non-null 的值x和y，x.equals(y) 和 y.equals(x) 必须返回相同的值。</li>
<li>传递：对于任意 non-null 的值，x，y，z，如果 x.equals(y) 返回true以及 y.equals(z) 返回true，那么 x.equals(z) 也必须返回 true。</li>
<li>一致：如果 equals 实现中的辅助信息没有改变，对于任意的x和y，对  x.equals(y) 必须返回相同的值。</li>
</ul>
<p>对于所有的 non-null 的 x，x.equals(null) 必须返回false。</p>
<h3 id="3-6-2-覆盖equals时总要覆盖hashCode"><a href="#3-6-2-覆盖equals时总要覆盖hashCode" class="headerlink" title="3.6.2 覆盖equals时总要覆盖hashCode"></a>3.6.2 覆盖equals时总要覆盖hashCode</h3><p>Item 9: Always override hashCode when you override equals.</p>
<p>对于每一个 equals 方法被重写的类，你必须重写 hashCode 方法。请仔细阅读 javadoc 中关于 Object.equals 的描述。相等的对象必须有相等的 hash 值。</p>
<p>这里是一个错误的例子：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> class PhoneNumber &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> areaCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> prefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> lineNumber;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PhoneNumber pn = (PhoneNumber)o;</span><br><span class="line">        <span class="keyword">return</span> pn.lineNumber == lineNumber</span><br><span class="line">                         &amp;&amp; pn.prefix  == prefix</span><br><span class="line">                         &amp;&amp; pn.areaCode  == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Broken - no hashCode method!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;PhoneNumber, <span class="keyword">String</span>&gt; m = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;PhoneNumber, <span class="keyword">String</span>&gt;();</span><br><span class="line">m.put(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>), <span class="string">"Jenny"</span>);</span><br><span class="line"><span class="comment">// null is returned instead of "Jenny"</span></span><br><span class="line">m.<span class="built_in">get</span>(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>));</span><br></pre></td></tr></table></figure>
<h2 id="3-7-泛型-Generics"><a href="#3-7-泛型-Generics" class="headerlink" title="3.7 泛型(Generics)"></a>3.7 泛型(Generics)</h2><h3 id="3-7-1-请不要在新代码中使用原生态类型"><a href="#3-7-1-请不要在新代码中使用原生态类型" class="headerlink" title="3.7.1 请不要在新代码中使用原生态类型"></a>3.7.1 请不要在新代码中使用原生态类型</h3><p>Item 23: Don’t use raw types in new code.</p>
<p>从1.5版本开始，java提供了泛型机制来保证类型的安全。除非为了向后兼容，不允许使用原生态类型，像List（而不是 <code>List&lt;String&gt;</code>)。</p>
<p>下面这段代码就很容易出问题：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now a raw collection type - don't do this!</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * My stamp collection. Contains only Stamp instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private final <span class="type">Collection</span> stamps = ... ;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// Erroneous insertion of coin into stamp collection</span></span><br><span class="line">stamps.add(<span class="function"><span class="keyword">new</span> <span class="title">Coin</span>( ... ));</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"><span class="comment">// Now a raw iterator type - don't do this!</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> (<span class="type">Iterator</span> i = stamps.iterator(); <span class="title">i</span>.<span class="title">hasNext</span>(); ) &#123;</span></span><br><span class="line"><span class="function">    <span class="title">Stamp</span> <span class="title">s</span> = (<span class="type">Stamp</span>) <span class="title">i</span>.<span class="title">next</span>(); <span class="comment">// Throws ClassCastException</span></span></span><br><span class="line"><span class="function">    ... <span class="comment">// Do something with the stamp</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用泛型能够很好地解决这个问题：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameterized collection type - typesafe</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Stamp&gt; stamps = ... ;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// for-each loop over a parameterized collection - typesafe</span></span><br><span class="line"><span class="keyword">for</span> (Stamp <span class="string">s :</span> stamps) &#123; <span class="comment">// No cast</span></span><br><span class="line">    ... <span class="comment">// Do something with the stamp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-2-消除非受检警告"><a href="#3-7-2-消除非受检警告" class="headerlink" title="3.7.2 消除非受检警告"></a>3.7.2 消除非受检警告</h3><p>Item 24: Elimate unchecked warnings.</p>
<p>在使用泛型编程的时候，我们经常会看到编译警告：非受检的类型转换警告，非受检的函数调用警告等等。很多非受检的警告是非常容易消除的，例如：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;Lark&gt; exaltation <span class="comment">= new HashSet()</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会抛出警告：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Venery.<span class="string">java:</span><span class="number">4</span>: <span class="string">warning:</span> [unchecked] unchecked conversion</span><br><span class="line"><span class="string">found  :</span> HashSet, <span class="string">required:</span> Set&lt;Lark&gt;</span><br><span class="line">    Set&lt;Lark&gt; exaltation = <span class="keyword">new</span> HashSet();</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>
<p>我们很容易消除这个警告：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>&lt;Lark&gt; exaltation <span class="comment">= new HashSet&lt;Lark&gt;()</span>;</span><br></pre></td></tr></table></figure>
<p>关于消除非受检的警告，有如下基本规则：</p>
<ul>
<li>尽可能地消除每个非受检的警告。</li>
<li>如果无法消除，必须能够证明这个警告不会引起类型安全问题，同时通过 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 来消除警告。</li>
<li>SuppressWarning必须作用在尽可能小的范围。</li>
<li>每一次使用 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 时，必须注释说明为什么这样做是安全的。</li>
</ul>
<h2 id="3-8-枚举和注解-Enums-and-Annotations"><a href="#3-8-枚举和注解-Enums-and-Annotations" class="headerlink" title="3.8 枚举和注解(Enums and Annotations)"></a>3.8 枚举和注解(Enums and Annotations)</h2><h3 id="3-8-1-用-enum-代替-int-常量"><a href="#3-8-1-用-enum-代替-int-常量" class="headerlink" title="3.8.1 用 enum 代替 int 常量"></a>3.8.1 用 enum 代替 int 常量</h3><p>Item 30: Use enums instead of int constants.</p>
<p>下面的代码利用了一种叫 int enum pattern 的技术，它有很多问题。它不能保证类型安全；它不能很好地转换为可读的字符串；如果数值变了的话，使用它的代码必须重新编译（严重！）。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The int enum pattern - severely deficient!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_NAVEL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_TEMPLE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_BLOOD = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>我们应该用enum来实现上面的代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Orange</span> &#123; <span class="title">NAVEL</span>, <span class="title">TEMPLE</span>, <span class="title">BLOOD</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：出于效率考虑，Android 的开发允许使用 int 常量，但是使用时要非常小心。</p>
<h3 id="8-8-2-用实例域代替序数"><a href="#8-8-2-用实例域代替序数" class="headerlink" title="8.8.2 用实例域代替序数"></a>8.8.2 用实例域代替序数</h3><p>Item 31: Use instance fields instead of ordinals.</p>
<p>所有的枚举类型都有一个ordinal方法，它能够返回每个枚举常量在类型中的位置。有时候，你可能会想从这个方法中直接得到一个整数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abuse of ordinal to derive an associated value - DON'T DO THIS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO, SEXTET, DUET, TRIO, QUARTET, QUINTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要从枚举的序数中得到一个整数值，如果需要，请创建一个整数字段：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Ensemble</span> &#123;</span></span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final int numberOfMusicians;</span><br><span class="line">    Ensemble(int size) &#123; this.numberOfMusicians = size; &#125;</span><br><span class="line">    public int numberOfMusicians() &#123; <span class="keyword">return</span> numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-3-坚持使用Override注解"><a href="#3-8-3-坚持使用Override注解" class="headerlink" title="3.8.3 坚持使用Override注解"></a>3.8.3 坚持使用Override注解</h3><p>Item 36: Consistently use the Override annotation.</p>
<p>你能发现下面代码的错误吗？</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Bigram &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">char</span> <span class="built_in">second</span>;</span><br><span class="line">    <span class="keyword">public</span> Bigram(<span class="built_in">char</span> first, <span class="built_in">char</span> <span class="built_in">second</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">second</span> = <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(Bigram b) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.first == first &amp;&amp; b.<span class="built_in">second</span> == <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们加入了 <code>@Override</code> 的标注，编译器就能告诉我们错误了。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Override</span> <span class="keyword">public</span> boolean <span class="keyword">equals</span>(Bigram b) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return b.first == first &amp;&amp; b.second == second;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line">        </span><br><span class="line">Bigram.java:<span class="number">10</span>: <span class="function"><span class="keyword">method</span> <span class="title">does</span> <span class="title">not</span> <span class="title">override</span> <span class="title">or</span> <span class="title">implement</span> <span class="title">a</span> <span class="title">method</span></span></span><br><span class="line"><span class="function">        <span class="title">from</span> <span class="title">a</span> <span class="title">supertype</span></span></span><br><span class="line"><span class="function">@<span class="title">Override</span> <span class="title">public</span> <span class="title">boolean</span> <span class="title">equals</span><span class="params">(Bigram b)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">^</span></span></span><br></pre></td></tr></table></figure>
<h2 id="3-9-方法-Methods"><a href="#3-9-方法-Methods" class="headerlink" title="3.9 方法 (Methods)"></a>3.9 方法 (Methods)</h2><h3 id="3-9-1-检查参数的有效性"><a href="#3-9-1-检查参数的有效性" class="headerlink" title="3.9.1 检查参数的有效性"></a>3.9.1 检查参数的有效性</h3><p>Item 38: Check parameters for validaity.</p>
<p>大多数的方法对于传入参数的值有限制，例如，通常来说索引值必须是非负的，对象应用必须是非空的。一条总的规则是，在错误发生之前必须尽早地发现它、处理它。</p>
<p>如果我们能在方法执行主要逻辑之前检查到错误的参数，我们就能够及时退出，同时抛出一个合适的一场。如果错误的参数进入函数的主要执行逻辑，方法就可能抛出一个奇怪的异常。在更坏的情况下，方法可能成功返回，但是中间出现一些不可预知的结果。</p>
<p>对于公共方法，用 <code>@throws</code> 来注释异常。比如，这些异常可能是 <code>IllegalArgumentException</code> 或者是 <code>NullPointerException</code>。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the modulus, which must be positive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this mod m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArithmeticException if m is less than or equal to 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.signum() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Modulus &lt;= 0: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Do the computation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-异常-Exceptions"><a href="#3-10-异常-Exceptions" class="headerlink" title="3.10 异常(Exceptions)"></a>3.10 异常(Exceptions)</h2><h3 id="3-10-1-只针对异常的情况才使用异常"><a href="#3-10-1-只针对异常的情况才使用异常" class="headerlink" title="3.10.1 只针对异常的情况才使用异常"></a>3.10.1 只针对异常的情况才使用异常</h3><p>Item 57: Use exceptions only for exceptional conditions.</p>
<p>异常，只应该被应用于异常的情况；不能被用于正常的控制流程。这一点在很多时候会被误用，下面是一个极端的例子：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Horrible</span> abuse <span class="keyword">of</span> exceptions. <span class="type">Don</span>'t ever <span class="keyword">do</span> this!</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">range</span>[i++].climb();</span><br><span class="line">    &#125; catch(<span class="type">ArrayIndexOutOfBoundsException</span> e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-2-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#3-10-2-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="3.10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>3.10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><p>Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors.</p>
<p>受检异常在调用者能够合适处理并恢复程序执行的情况下使用。运行时异常用来表明程序自身的错误，大多数的运行时异常都是因为调用者违反了函数的预设条件。</p>
<p>应用程序所有非受检的异常应该派生自 RuntimeException ，作为惯例，Error 通常只被 JVM 使用。</p>
<h3 id="3-10-3-抛出与抽象相对应的异常"><a href="#3-10-3-抛出与抽象相对应的异常" class="headerlink" title="3.10.3 抛出与抽象相对应的异常"></a>3.10.3 抛出与抽象相对应的异常</h3><p>Item 61: Throw exceptions appropriate to the abstraction.</p>
<p>抛出与当前方法明显无关的异常会让人十分迷惑，而且会暴露出实现的细节。这种情况通常是因为高一级的方法直接抛出底层调用的异常引起的。我们采用异常转换的方法来避免这一种情况。也就是说，高一级的方法应该捕获底层调用的异常，抛出一个更高抽象的异常。例如，下面是一段 AbstractSequentialList 实现代码，它需要实现 <code>List&lt;E&gt;#get</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> i.<span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NoSuchElementException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，不要滥用了异常转换。</p>
<h3 id="3-10-4-每个方法抛出的异常都要有文档"><a href="#3-10-4-每个方法抛出的异常都要有文档" class="headerlink" title="3.10.4 每个方法抛出的异常都要有文档"></a>3.10.4 每个方法抛出的异常都要有文档</h3><p>Item 62: Document all exceptions thrown by each method.</p>
<p>关于异常的文档有以下要求：</p>
<p>必须单独地声明每个受检异常，同时准确地用 <code>@throws</code> 来说明异常条件。</p>
<p>用 Javadoc 的 <code>@throws</code> 来表明非受检的异常；但是不要用throws关键字在方法的声明中包括非受检的异常。</p>
<p>如果一个异常会被同一个类的很多方法抛出，在类的注释中表明这个异常是可以接受的。但是通常不推荐这么做。</p>
<h3 id="3-10-5-不要忽略异常"><a href="#3-10-5-不要忽略异常" class="headerlink" title="3.10.5 不要忽略异常"></a>3.10.5 不要忽略异常</h3><p>Item 65: Don’t ignore exceptions.</p>
<p>我们不允许像下面的代码一样忽略异常：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span>(<span class="params">String <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(<span class="keyword">value</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至少，在 catch 语句里，应该有注释说明为什么忽略异常是合适的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** If value is not a valid number, original port number is used. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span>(<span class="params">String <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(<span class="keyword">value</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// Method is documented to just ignore invalid user input.</span></span><br><span class="line">        <span class="comment">// serverPort will just be unchanged.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-6-不要一次捕获所有异常"><a href="#3-10-6-不要一次捕获所有异常" class="headerlink" title="3.10.6 不要一次捕获所有异常"></a>3.10.6 不要一次捕获所有异常</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">try</span> &#123;</span><br><span class="line">    <span class="selector-tag">someComplicatedIOFunction</span>();        <span class="comment">// may throw IOException </span></span><br><span class="line">    <span class="selector-tag">someComplicatedParsingFunction</span>();   <span class="comment">// may throw ParsingException </span></span><br><span class="line">    <span class="selector-tag">someComplicatedSecurityFunction</span>();  <span class="comment">// may throw SecurityException </span></span><br><span class="line">    <span class="comment">// phew, made it all the way </span></span><br><span class="line">    &#125; <span class="selector-tag">catch</span> (Exception e) &#123;                 <span class="comment">// I'll just catch all exceptions </span></span><br><span class="line">    <span class="selector-tag">handleError</span>();                      <span class="comment">// with one generic handler!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绝大多数情况下，捕获 Exception 或者是 Throwable 都是不对的。这个非常危险，你可能会捕获一些没有想到的异常，或者是稍后加入的异常。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://source.android.com/source/code-style.html" target="_blank" rel="noopener">Code Style Guidelines for Contributors</a></p>
<p><a href="http://linfuyan.com/google-java-style-guide/">Google Java 编程风格指南</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 代码 </tag>
            
            <tag> 规范 </tag>
            
            <tag> 实践 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google Java 编程风格指南]]></title>
      <url>http://linfuyan.com/google-java-style-guide/</url>
      <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p>
<p>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</p>
<p>其他的术语说明会偶尔在后面的文档出现。</p>
<h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<h1 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2. 源文件基础"></a>2. 源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 .java。</p>
<h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p>
<h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \“, \‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p>
<h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。<br>例如：</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String unitAbbrev = “μs”;</td>
<td>赞，即使没有注释也非常清晰</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // “μs”</td>
<td>允许，但没有理由要这样做</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td>
<td>允许，但这样做显得笨拙还容易出错</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”;</td>
<td>很糟，读者根本看不出这是什么</td>
</tr>
<tr>
<td>return ‘\ufeff’ + content; // byte order mark</td>
<td>好，对于非打印字符，使用转义，并在必要时写上注释</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Tip: 永远不要由于害怕某些程序可能无法正确处理非 ASCII 字符而让你的代码可读性变差。当程序无法正确处理非 ASCII 字符时，它自然无法正确运行， 你就会去 fix 这些问题的了。(言下之意就是大胆去用非 ASCII 字符，如果真的有需要的话)</p>
</blockquote>
<h1 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3. 源文件结构"></a>3. 源文件结构</h1><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：import java.util.*;</p>
<h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import 语句不换行，列限制(4.4节)并不适用于 import 语句。(每个 import 语句独立成行)</p>
<h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import 语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<ol>
<li>所有的静态导入独立成组</li>
<li><code>com.google</code> imports (仅当这个源文件是在 <code>com.google</code> 包下)</li>
<li>第三方的包。每个顶级包为一组，字典序。例如： android, com, junit, org, sun</li>
<li><code>java</code> imports</li>
<li><code>javax</code> imports</li>
</ol>
<p>组内不空行，按字典序排列。</p>
<blockquote>
<p>飞博团队要求：</p>
</blockquote>
<p>导入包的顺序为：静态导入，java基础包，javax基础包，android包，第三方包（每个顶级包为一组，字典序。例如：com, junit, org, sun, feibo包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">javax</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">android</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.feibo</span><span class="selector-class">.a</span><span class="selector-class">.B</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含 .java 后缀)。</p>
<h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 </p>
<p>最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="4-格式"><a href="#4-格式" class="headerlink" title="4. 格式"></a>4. 格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="noopener">Egyptian brackets</a>):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>实例：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                something();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">                recover();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.8.1节给出了enum类的一些例外。</p>
<h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(<code>if/else 或 try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-块缩进：4个空格"><a href="#4-2-块缩进：4个空格" class="headerlink" title="4.2 块缩进：4个空格"></a>4.2 块缩进：4个空格</h2><p>每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如， Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。</li>
<li>package 和 import 语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到 shell 中的命令行。</li>
</ol>
<h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
<h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li><p>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如C++和JavaScript)。 </p>
<ul>
<li>这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的 <code>&amp;（&lt;T extends Foo &amp; Bar&gt;)</code> ，catch块中的管道符号 <code>(catch (FooException | BarException e)</code> </li>
</ul>
</li>
<li><p>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。</p>
<ul>
<li>这条规则也适用于foreach语句中的分号。</li>
</ul>
</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>当一个表达式无法容纳在一行内时，可以依据如下一般规则断开之：</p>
<ul>
<li>在一个逗号后面断开。</li>
<li>在一个操作符前面断开。</li>
<li>宁可选择较高级别的(higher-level)的断开，而非较低级别(lower-level)的断开。</li>
<li>新的一行应该与上一行同一级别表达式的开头处对齐。</li>
<li>如果以上规则导致你的代码混乱或者使你的代码都堆挤在右边，那就代之以缩进8个空格。</li>
</ul>
<p>以下是断开方法的一些例子：</p>
<pre><code>someMethod(longExpression1, longExpression2, longExpression3,
        longExpression4, longExpression5); // 8个空格
var = someMethod1(Expression1,
                  someMethod2(longExpression2,
                              longExpression3));
</code></pre><p>以下是两个断开算术表达式的例子。前者更好，因为断开处位于括号表达式的外边，这是个较高级别的断开。</p>
<pre><code>longName1 = longName2 * (longName3 + longName4 - longName5)
            + 4 * longname6; // PREFER
longName1 = longName2 * (longName3 + longName4
        - longName5) + 4 * longName6; //AVOID
</code></pre><p>以下是两个缩进方法声明的例子。前者是常规情形，后者若使用常规的缩进方式将会使第二行和第三行移得很靠右，所以代这以缩进8个空格。</p>
<pre><code>// CONVENTION INDENTATION
someMethod(int anArg, Object anotherArg,
           String yetAnotherArg,
           Object andStillAnother) {
    ……
}

// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS
private static synchronized horkingLongMethodName(int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother) {
    ……
}
</code></pre><p>if语句的换行通常使用8个空格的规则，因为常规缩进(4个空格)会使语句看起来比较费劲。比如：</p>
<pre><code>//DON’T USE THIS INDENTATION
if ((condition1 &amp;&amp; condition2)
    || (condition3 &amp;&amp; condition4)
    || !(condition5 &amp;&amp; condition6)) { //BAD WRAPS
    doSomethingAboutIt(); // MAKE THIS LING EASY TO MISS
}
// USE THIS INDENTATION INSTEAD
if ((condition1 &amp;&amp; condition2)
        || (condition3 &amp;&amp; condition4)
        || !(condition5 &amp;&amp; condition6)) {
    doSomethingAboutIt();
}

// OR USE THIS
if ((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)
        || !(condition5 &amp;&amp; condition6)) {
   doSomthingAoutIt();
}
</code></pre><p>这里有三种可行的方法用于处理三元运算表达式：</p>
<pre><code>alpha = (aLongBooleanExpression) ? beta : gamma;

alpha = (aLongBooleanExpression) ? beta
                                 : gamma;

alpha = (aLongBooleanExpression)
        ? beta
        : gamma;
</code></pre><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ol>
<p>空行将逻辑相关的代码段分隔开，以提高可读性。</p>
<p>下列情况应总是使用两个空行：</p>
<ul>
<li>一个源文件的两个片段(section)之间。</li>
<li>类声明和接口声明之间。</li>
</ul>
<p>下列情况应该总是使用一个空行：</p>
<ul>
<li>两个方法之间。方法与方法之间 以空行分隔。</li>
<li>方法内的局部变量和方法的第一条语句之间。</li>
<li>块注释(参见“5.1.1”)或单行注释(参见5.1.2)之前。</li>
<li>一个方法内的两个逻辑段之间，用以提高可读性。</li>
</ul>
<h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code> (不使用空格)。</li>
<li><code>String[][] x = foo;</code> (大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的<code>&amp;(&lt;T extends Foo &amp; Bar&gt;)</code>。</li>
<li>catch块中的管道符号<code>(catch (FooException | BarException e)</code>。</li>
<li>foreach语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则双斜杠(<code>//</code>)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：<code>List&lt;String&gt; list</code>。</li>
<li>数组初始化中，大括号内的空格是可选的，<ul>
<li><code>new int[] {5, 6}</code> 和 <code>new int[] { 5, 6 }</code> 都是可以的。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了 reviewer 的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-6-4-空格-Blank-Spaces"><a href="#4-6-4-空格-Blank-Spaces" class="headerlink" title="4.6.4 空格(Blank Spaces)"></a>4.6.4 空格(Blank Spaces)</h3><p>下列情况应该使用空格：</p>
<p>1. 一个紧跟着括号的关键应该被空格分开，例如：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：空格不应该置于方法名与其左括号之间，这将有助于区分关键字和方法调用。</p>
</blockquote>
<p>2. 空白应该位于参数列表中逗号的后面。</p>
<p>3. 所有的二元运算符，除了“.”，应该使用空格将之与操作数分开。一元操作符和操作数之间不应该加空格，比如：负号(“-”)，自增(“++”)和自减(“–”)。例如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">a</span> <span class="literal">+</span><span class="comment">=</span> <span class="comment">c</span> <span class="literal">+</span> <span class="comment">d;</span></span><br><span class="line"><span class="comment">a</span> <span class="comment">=</span> <span class="comment">(a</span> <span class="literal">+</span> <span class="comment">b)</span> <span class="comment">/</span> <span class="comment">(c</span> <span class="comment">*</span> <span class="comment">d);</span></span><br><span class="line"><span class="comment"></span>        </span><br><span class="line"><span class="comment">while</span> <span class="comment">(d</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">=</span> <span class="comment">s</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span>    <span class="comment">n</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printSize(“size</span> <span class="comment">is</span> <span class="comment">”</span> <span class="literal">+</span> <span class="comment">foo</span> <span class="literal">+</span> <span class="comment">“\n”);</span></span><br></pre></td></tr></table></figure>
<p>4. for语句中的表达式应该被空格分开，例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (expr1<span class="comment">; expr2; expr3)</span></span><br></pre></td></tr></table></figure>
<p>5. 强制转型后应该跟一个空格，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myMethod((<span class="name">byte</span>) aNum, (<span class="name">Object</span>) x)<span class="comment">;</span></span><br><span class="line">myMethod((<span class="name">int</span>) (<span class="name">cp</span> + <span class="number">5</span>), ((<span class="name">int</span>) (<span class="name">i</span> + <span class="number">3</span>)) + <span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h2 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h2><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> &#123; <span class="title">CLUBS</span>, <span class="title">HEARTS</span>, <span class="title">SPADES</span>, <span class="title">DIAMONDS</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如 <code>int a, b;</code>。</p>
<h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[]</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[]</code> args， 而非 <code>String args[]</code>。</p>
<h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p>术语说明：switch 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签( case FOO: 或 default: )，后面跟着一条或多条语句。</p>
<h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为4个空格。</p>
<p>每个switch标签后新起一行，再缩进4个空格，写下一条或多条语句。</p>
<h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个 switch 块内，每个语句组要么通过 <code>break, continue, return</code> 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是 OK 的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">input</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        prepareOneOrTwo()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        handleOneTwoOrThree()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">break</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        handleLargeNumber(<span class="keyword">input</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。</p>
<h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@Nullable</span></span><br><span class="line">public String getNameIfPresent() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Partial</span> <span class="variable">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。以下示例注释都是OK的。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This <span class="keyword">is</span>          // <span class="keyword">And</span> so           /* <span class="keyword">Or</span> you can</span><br><span class="line"> * okay.            // <span class="keyword">is</span> this.          * even <span class="keyword">do</span> this. */</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 <code>/* ... */</code>。</p>
</blockquote>
<h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-8-简单语句-Simple-Statement"><a href="#4-8-8-简单语句-Simple-Statement" class="headerlink" title="4.8.8 简单语句(Simple Statement)"></a>4.8.8 简单语句(Simple Statement)</h3><p>每行至多包含一条语句，例如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span> <span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>    <span class="comment">//</span> <span class="comment">AVOID!</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-9-复合语句-Compound-Statements"><a href="#4-8-9-复合语句-Compound-Statements" class="headerlink" title="4.8.9 复合语句(Compound Statements)"></a>4.8.9 复合语句(Compound Statements)</h3><p>复合语句是包含在大括号中的语句序列，形如“{ statements }”。例如下面各段。</p>
<ul>
<li>被括其中的语句应该较之复合语句缩进一个层次。</li>
<li>左大括号“{”应位于复合语句起始行的行尾；右大括号“}”应另起一行并与复合语句首行对齐。</li>
<li>大括号可以被用于所有语句，包括单个语句，只要这些语句是诸如if–else或for控制结构的一部分。这样便于添加语句而无需担心由于忘了加括号而引入bug.</li>
</ul>
<h3 id="4-8-10-返回语句-return-Statements-s"><a href="#4-8-10-返回语句-return-Statements-s" class="headerlink" title="4.8.10 返回语句(return Statements)s"></a>4.8.10 返回语句(return Statements)s</h3><p>一个带返回值的return语句不使用小括号“()”，除非它们以某种方式使返回值更显见。例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span>;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> myDisk.<span class="built_in">size</span>();  </span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> (<span class="built_in">size</span> ? <span class="built_in">size</span> ; defaultSize);</span><br></pre></td></tr></table></figure>
<h3 id="4-8-11-if-if-else-if-else-if-else-语句-if-if-else-if-else-if-else-Statements"><a href="#4-8-11-if-if-else-if-else-if-else-语句-if-if-else-if-else-if-else-Statements" class="headerlink" title="4.8.11 if, if-else, if else-if else 语句(if, if-else, if else-if else Statements)"></a>4.8.11 <code>if, if-else, if else-if else</code> 语句(<code>if, if-else, if else-if else Statements</code>)</h3><p>if-else 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：if 语句问题用 “{” 和 “}” 括起来，避免使用如下容易引起错误的格式：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">condition</span>)  <span class="comment">// AVOI! THIS OMITS THE BRACES &#123;&#125;!</span></span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-12-for语句-for-Statements"><a href="#4-8-12-for语句-for-Statements" class="headerlink" title="4.8.12 for语句(for Statements)"></a>4.8.12 for语句(for Statements)</h3><p>一个for语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; <span class="keyword">update</span>) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空的for语句(所有工作都在初始化，条件判断，更新子句中完成)应该具有如下格式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">initialization</span>; condition; update);</span><br></pre></td></tr></table></figure>
<p>当在 for 语句的初始化或更新子句中使用逗号时，避免因使用三个以上变量，而导致复杂度提高。若需要，可以在 for 循环之前(为初始化子句)或 for 循环末尾(为更新子句)使用单独的语句。</p>
<h3 id="4-8-13-while语句-while-Statements"><a href="#4-8-13-while语句-while-Statements" class="headerlink" title="4.8.13 while语句(while Statements)"></a>4.8.13 while语句(while Statements)</h3><p>一个 while 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空的 while 语句应该具有如下格式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(condition)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-14-do-while语句-do-while-Statements"><a href="#4-8-14-do-while语句-do-while-Statements" class="headerlink" title="4.8.14 do-while语句(do-while Statements)"></a>4.8.14 do-while语句(do-while Statements)</h3><p>一个 do-while 语句应该具有如下格式：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">statements</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<h3 id="4-8-15-switch语句-switch-Statements"><a href="#4-8-15-switch语句-switch-Statements" class="headerlink" title="4.8.15 switch语句(switch Statements)"></a>4.8.15 switch语句(switch Statements)</h3><p>一个 switch 语句应该具有如下格式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">ABC:</span></span><br><span class="line">    statements;</span><br><span class="line">    <span class="comment">/* falls through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">DEF:</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">case</span> <span class="string">XYZ:</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">default:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">false :</span> condition;  <span class="comment">// Or throw error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个 case 顺着往下执行时(因为没有 break 语句)，通常应在 break 语句的位置添加注释。上面的示例代码中就包含注释 <code>/* falls through */</code> 。</p>
<p>每个 switch 语句，必须有对应的 default 语句。如果执行不到，可以加上  assert语句。</p>
<p>case 语句后面需要使用 “{“ , “}” 包含语句块。</p>
<h3 id="4-8-16-try-catch语句-try-catch-Statements"><a href="#4-8-16-try-catch语句-try-catch-Statements" class="headerlink" title="4.8.16 try-catch语句(try-catch Statements)"></a>4.8.16 try-catch语句(try-catch Statements)</h3><p>一个 try-catch 语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass e) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 try-catch 语句后面也可能跟着一个 finally 语句，不论 try 代码块是否顺利执行完，它都会被执行。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass e) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-命名规范-Naming"><a href="#5-命名规范-Naming" class="headerlink" title="5. 命名规范(Naming)"></a>5. 命名规范(Naming)</h1><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用 ASCII 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 \w+。</p>
<h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>一个唯一包名的前缀总是全部小写的 ASCⅡ 字母并且是一个顶级域名，通常是 com，gov，edu，mil，net，org，或1981年ISO 3166标准所指定的标识的国家的英文双字符代码。包名的后续部分根据不同机构各自内部的命名规范而不尽相同。这类命名规范可能以特定目录名的组成来区分部门(department)，项目(project)，机器(machine)，或注册名(login names)。</p>
<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.eng</span></span><br><span class="line">com<span class="selector-class">.feibo</span><span class="selector-class">.joke</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名是一个名词，采用大小写混合方式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。使用完整单词，避免缩写词(除非该缩写词被广泛的使用，如 URL，HTML)。例如：</p>
<p>类名都以 UpperCamelCase 风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以 Test 结束。例如， HashTest 或 HashIntegrationTest。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raster</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageSprite</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以 lowerCamelCase 风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是： <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code> ，例如 <code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为 <code>CONSTANT_CASE</code> ，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;<span class="built_in">String</span>&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span>[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以 lowerCamelCase 风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以 lowerCamelCase 风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><p>驼峰式命名法分大驼峰式命名法( UpperCamelCase )和小驼峰式命名法( lowerCamelCase )。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。 Google 指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯 ASCII 码，并且移除任何单引号。例如： “Müller’s algorithm” 将变成 “Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>实例：</p>
<table>
<thead>
<tr>
<th>Prose form</th>
<th>Correct</th>
<th>Incorrect</th>
</tr>
</thead>
<tbody>
<tr>
<td>“XML HTTP request”</td>
<td>XmlHttpRequest</td>
<td>XMLHTTPRequest</td>
</tr>
<tr>
<td>“new customer ID”</td>
<td>newCustomerId</td>
<td>newCustomerID</td>
</tr>
<tr>
<td>“inner stopwatch”</td>
<td>innerStopwatch</td>
<td>innerStopWatch</td>
</tr>
<tr>
<td>“supports IPv6 on iOS?”</td>
<td>supportsIpv6OnIos</td>
<td>supportsIPv6OnIOS</td>
</tr>
<tr>
<td>“YouTube importer”</td>
<td>YouTubeImporter</td>
<td>YoutubeImporter*</td>
</tr>
</tbody>
</table>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>注意：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名 checkNonempty 和 checkNonEmpty 也都是正确的。</p>
</blockquote>
<h1 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6. 编程实践"></a>6. 编程实践</h1><h2 id="6-1-Override：-能用则用"><a href="#6-1-Override：-能用则用" class="headerlink" title="6.1 @Override： 能用则用"></a>6.1 @Override： 能用则用</h2><p>只要是合法的，就把@Override注解给用上。</p>
<h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。)</p>
<p>如果它确实是不需要在 catch 块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">handleNumericResponse</span><span class="params">(i)</span></span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">    <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">handleTextResponse</span><span class="params">(response)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    emptyStack.pop();</span><br><span class="line">    fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = <span class="string">...</span>;</span><br><span class="line">Foo.aStaticMethod<span class="params">()</span>; <span class="string">//</span> good</span><br><span class="line">aFoo.aStaticMethod<span class="params">()</span>; <span class="string">//</span> bad</span><br><span class="line">somethingThatYieldsAFoo<span class="params">()</span><span class="string">.aStaticMethod</span><span class="params">()</span>; <span class="string">//</span> very bad</span><br></pre></td></tr></table></figure>
<h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重载 Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7. Javadoc"></a>7. Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc 块的基本格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** An especially short bit of Javadoc. *</span>/</span></span></span><br></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="7-1-3-Javadoc-标记"><a href="#7-1-3-Javadoc-标记" class="headerlink" title="7.1.3 Javadoc 标记"></a>7.1.3 Javadoc 标记</h3><p>标准的 Javadoc 标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 <code>A {@code Foo} is a...</code> 或 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record...</code> 。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的 Javadoc 写成 <code>/** @return the customer ID */</code> ，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="7-3-哪里需要使用-Javadoc"><a href="#7-3-哪里需要使用-Javadoc" class="headerlink" title="7.3 哪里需要使用 Javadoc"></a>7.3 哪里需要使用 Javadoc</h2><p>至少在每个 public 类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p>
<h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如 getFoo，Javadoc 是可选的(即，是可以不写的)。这种情况下除了写 “Returns the foo” ，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p>
</blockquote>
<h3 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h3><p>如果一个方法重载了超类中的方法，那么 Javadoc 并非必需的。</p>
<h3 id="7-3-3-可选的-Javadoc"><a href="#7-3-3-可选的-Javadoc" class="headerlink" title="7.3.3 可选的 Javadoc"></a>7.3.3 可选的 Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。</p>
<h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><p><a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Google Java StyleGuide 中文翻译</a></p>
<p><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java StyleGuide 官方英文</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 指南 </tag>
            
            <tag> 规范 </tag>
            
            <tag> Google </tag>
            
            <tag> 编码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C 编码风格指南]]></title>
      <url>http://linfuyan.com/objective-c-coding-style-guide/</url>
      <content type="html"><![CDATA[<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>源文件编码格式为 UTF-8</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>使用英语，变量的命名等已英语单词命名，不要使用汉语拼音。</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>使用 <code>#pragma mark</code> 来为方法分组。</p>
<h2 id="间距与空白"><a href="#间距与空白" class="headerlink" title="间距与空白"></a>间距与空白</h2><ul>
<li>一个缩进使用 4 个空格，不要使用制表符。可以在 Xcode 中配置自动将 Tab 转化为空格。在 Xcode &gt; Preferences &gt; Text Editing 将 Tab 和自动缩进都设置为 4 个空格。</li>
<li>行尾不允许留有空格。</li>
<li>关键字及符号之间需要留有 1 个空格。</li>
<li>方法或者代码块之间留有一行空白。</li>
</ul>
<h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><ul>
<li>方法和大括号及其他大括号( if / else / switch / while 等等)始终和声明在同一行开始，在新的一行结束。</li>
</ul>
<p>以下是正确的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是不正确的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为 Xcode 的对齐方式令它难以辨认。</li>
</ul>
<p>应该：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[UIView animateWithDuration:<span class="number">1.0</span></span><br><span class="line"><span class="symbol">                 animations:</span>^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line"><span class="symbol">                 completion:</span>^(BOOL finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul>
<li>长的，描述性的方法和变量命名是好的。</li>
</ul>
<p>应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *setBut<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。</p>
</blockquote>
<ul>
<li>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@synthesize语句，除非你有一个好的理由。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id varnm<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>当使用属性时，实例变量应该使用 <code>self.</code> 来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有 <code>self.</code> 。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免 <code>getters/setters</code> 潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合 Apple 的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像 initWithWidth:height 以下这个例子：</p>
<p>应该：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setExampleText:<span class="params">(NSString *)</span>text image:<span class="params">(UIImage *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(SEL)</span>aSelector to:<span class="params">(id)</span>anObject forAllCells:<span class="params">(BOOL)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>viewWithTag:<span class="params">(NSInteger)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(CGFloat)</span>width height:<span class="params">(CGFloat)</span>height;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">setT</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">text</span> <span class="selector-tag">i</span><span class="selector-pseudo">:(UIImage</span> *)<span class="selector-tag">image</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">sendAction</span><span class="selector-pseudo">:(SEL)aSelector</span> <span class="selector-pseudo">:(id)anObject</span> <span class="selector-pseudo">:(BOOL)flag</span>;</span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">taggedView</span><span class="selector-pseudo">:(NSInteger)tag</span>;</span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithWidth</span><span class="selector-pseudo">:(CGFloat)width</span> <span class="selector-tag">andHeight</span><span class="selector-pseudo">:(CGFloat)height</span>;</span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWith</span><span class="selector-pseudo">:(int)width</span> <span class="selector-tag">and</span><span class="selector-pseudo">:(int)height</span>;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p>私有变量应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性( _variable ，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法( init , initWithCoder: , 等…)， dealloc 方法和自定义的 setters 和 getters 。想了解关于如何在初始化方法和 dealloc 直接使用 Accessor 方法的更多信息，查看这里。</p>
<p>应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">    NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><ul>
<li>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是 storage、atomicity，与在 Interface Builder 连接 UI 元素时自动生成代码一致。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSString应该使用copy而不是strong的属性特性。</li>
</ul>
<blockquote>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<h2 id="点符号语法"><a href="#点符号语法" class="headerlink" title="点符号语法"></a>点符号语法</h2><ul>
<li>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用 getter 或 setter 方法，属性仍然被访问或修改。想了解更多，阅读<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">这里</a>。</li>
</ul>
<blockquote>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSInteger arrayCount = [self.array <span class="built_in">count</span>]<span class="comment">;</span></span><br><span class="line">view.<span class="keyword">backgroundColor </span>= [UIColor <span class="keyword">orangeColor];</span></span><br><span class="line"><span class="keyword">[UIApplication </span><span class="keyword">sharedApplication].delegate;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span>.array.count;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><ul>
<li>NSString、 NSDictionary、 NSArray 和 NSNumber 的字面值应该在创建这些类的不可变实例时被使用。请特别注意 nil 值不能传入 NSArray 和 NSDictionary 字面值，因为这样会导致 crash。</li>
</ul>
<p>应该：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names = @[@<span class="string">"Brian"</span>, @<span class="string">"Matt"</span>, @<span class="string">"Chris"</span>, @<span class="string">"Alex"</span>, @<span class="string">"Steve"</span>, @<span class="string">"Paul"</span>]<span class="comment">;</span></span><br><span class="line">NSDictionary *productManagers = @&#123;@<span class="string">"iPhone"</span>: @<span class="string">"Kate"</span>, @<span class="string">"iPad"</span>: @<span class="string">"Kamal"</span>, @<span class="string">"Mobile Web"</span>: @<span class="string">"Bill"</span>&#125;<span class="comment">;</span></span><br><span class="line">NSNumber *<span class="keyword">shouldUseLiterals </span>= @YES<span class="comment">;</span></span><br><span class="line">NSNumber *<span class="keyword">buildingStreetNumber </span>= @<span class="number">10018</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。</p>
<p>常量常用的命名方法是：若常量局限于某“编译单元”（translation unit，也就是“实现文件”， implementation file）之内，则在前面加字母k, 如kAnimationDuration；若常量在类之外可见，则通常以类名为前缀。应该如 <code>static NSString * const</code> 而不是 <code>static const NSString *</code>。</p>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CompanyName @<span class="meta-string">"RayWenderlich.com"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thumbnailHeight 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量指针：初始化之后不能赋值。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> pt1;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向常量的指针：初始化之后可以赋值，即指向别的常量，指针本身的值可以修改。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * pt2;</span><br></pre></td></tr></table></figure>
<ul>
<li>指向常量的常量指针</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> pt3;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul>
<li>当使用 enum 时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在 SDK 有一个宏 NS_ENUM() 来帮助和鼓励你使用固定的基本类型。</li>
</ul>
<p>例如：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">RWTLeftMenuTopItemType</span>) &#123;</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemMain</span>,</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemShows</span>,</span><br><span class="line">    <span class="type">RWTLeftMenuTopItemSchedule</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">RWTGlobalConstants</span>) &#123;</span><br><span class="line">    <span class="type">RWTPinSizeMin</span> = 1,</span><br><span class="line">    <span class="type">RWTPinSizeMax</span> = 5,</span><br><span class="line">    <span class="type">RWTPinCountMin</span> = 100,</span><br><span class="line">    <span class="type">RWTPinCountMax</span> = 500,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旧的 k-style 常量定义应该避免，除非编写 Core Foundation C 的代码。</p>
<p>不应该：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> &#123;</span></span><br><span class="line">    kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">    kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h2><ul>
<li>大括号在 case 语句中必须的，不仅仅是 case 语句包含多行代码时，大括号都应该加上。</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 这个是不应该的</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Multi-line example using braces</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// 应该的</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// ** fall-through! **</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当在switch使用枚举类型时，’default’是不需要的。例如：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul>
<li>Objective-C 使用 YES 和 NO。因为 true 和 false 应该只在 CoreFoundation， C 或 C++ 代码使用。既然 nil 解析成 NO ，所以没有必要在条件语句比较。不要拿某样东西直接与 YES 比较，因为 YES 被定义为 1 而一个 BOOL 能被设置为8位。</li>
</ul>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == true)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ul>
<li>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为 if 语句；还有，<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="noopener">even more dangerous defect</a> 可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</li>
</ul>
<p>应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="built_in">    return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="built_in">    return</span> success;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="literal">return</span> success;</span><br></pre></td></tr></table></figure>
<h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><p>当需要提高代码的清晰性和简洁性时，三元操作符 ?: 才会使用。单个条件求值常常需要它。多个条件求值时，如果使用 if 语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean 的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是 boolean 类型，那么就不需要括号。</p>
<p>应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSInteger value</span> = 5;</span><br><span class="line"><span class="attribute">result</span> = (value != 0) ? x : y;</span><br><span class="line"><span class="attribute">BOOL isHorizontal</span> = YES;</span><br><span class="line"><span class="attribute">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">result</span> = a &gt; b <span class="meta">? x = c &gt; d ?</span> c : d : y;</span><br></pre></td></tr></table></figure>
<h2 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法"></a>Init方法</h2><p>Init 方法应该遵循 Apple 生成代码模板的命名规则，返回类型应该使用 instancetype 而不是 id。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="type">Airplane</span></span><br><span class="line">+ (instance<span class="keyword">type</span>)airplaneWithType:(<span class="type">RWTAirplaneType</span>)<span class="keyword">type</span>;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>关于更多 instancetype，请查看<a href="http://nshipster.com/instancetype/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry：</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGRect frame</span> = self.view.frame;</span><br><span class="line"><span class="attribute">CGFloat x</span> = CGRectGetMinX(frame);</span><br><span class="line"><span class="attribute">CGFloat y</span> = CGRectGetMinY(frame);</span><br><span class="line"><span class="attribute">CGFloat width</span> = CGRectGetWidth(frame);</span><br><span class="line"><span class="attribute">CGFloat height</span> = CGRectGetHeight(frame);</span><br><span class="line"><span class="attribute">CGRect frame</span> = CGRectMake(0.0, 0.0, width, height);</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CGRect frame</span> = self.view.frame;</span><br><span class="line"><span class="attribute">CGFloat x</span> = frame.origin.x;</span><br><span class="line"><span class="attribute">CGFloat y</span> = frame.origin.y;</span><br><span class="line"><span class="attribute">CGFloat width</span> = frame.size.width;</span><br><span class="line"><span class="attribute">CGFloat height</span> = frame.size.height;</span><br><span class="line"><span class="attribute">CGRect frame</span> = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="黄金路径"><a href="#黄金路径" class="headerlink" title="黄金路径"></a>黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="comment">(void)</span>someMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="comment">([someOther boolValue])</span> &#123;</span><br><span class="line">        <span class="comment">//Do something important</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="built_in">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="built_in">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在成功的情况下，有些 Apple 的 APIs 记录垃圾值( garbage values )到错误参数(如果 non-NULL )，那么判断错误值会导致 false 负值和 crash。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype)sharedInstance </span>&#123;</span><br><span class="line">    static id <span class="keyword">sharedInstance </span>= nil<span class="comment">;</span></span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        <span class="keyword">sharedInstance </span>= [[self alloc] init]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return <span class="keyword">sharedInstance;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这可以防止<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="noopener">有时可能产生的崩溃</a></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span></span><br><span class="line"><span class="comment">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。<br>注：对于模块使用 @import 语法。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Frameworks</span></span><br><span class="line">@<span class="keyword">import</span> QuartzCore;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Models</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTUser.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Views</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTButton.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NYTUserView.h"</span></span><br></pre></td></tr></table></figure>
<h2 id="飞博可接受的缩略词"><a href="#飞博可接受的缩略词" class="headerlink" title="飞博可接受的缩略词"></a>飞博可接受的缩略词</h2><table>
<thead>
<tr>
<th>缩略词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>VC</td>
<td>ViewController</td>
</tr>
<tr>
<td>VM</td>
<td>ViewModel</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h3><p><a href="http://www.iwangke.me/objc-style-guide/" target="_blank" rel="noopener">Google Objective-C Style Guide 中文版</a></p>
<p><a href="http://linfuyan.com/apple-cocoa-coding-style-guide/">Apple 官方 Cocoa 编码规范</a></p>
<p><a href="http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1" target="_blank" rel="noopener">Objective-C编码规范：26个方面解决iOS开发问题</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide/blob/master/README_zh-Hans.md" target="_blank" rel="noopener">纽约时报 移动团队 Objective-C 规范指南</a></p>
<h3 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h3><p><a href="https://google.github.io/styleguide/objcguide.xml" target="_blank" rel="noopener">Google Objective-C Style Guide</a></p>
<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Coding Guidelines for Cocoa</a></p>
<p><a href="https://github.com/raywenderlich/objective-c-style-guide" target="_blank" rel="noopener">Raywenderlich.com Objective-C style guide</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="noopener">NYTimes Objective-C Style Guide</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 指南 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 规范 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apple 官方 Cocoa 编码规范]]></title>
      <url>http://linfuyan.com/apple-cocoa-coding-style-guide/</url>
      <content type="html"><![CDATA[<h2 id="编码命名基础"><a href="#编码命名基础" class="headerlink" title="编码命名基础"></a>编码命名基础</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH" target="_blank" rel="noopener">Code Naming Basics</a></p>
<h3 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h3><h4 id="清晰性"><a href="#清晰性" class="headerlink" title="清晰性"></a>清晰性</h4><ul>
<li>最好是既清晰又简短，但不要为简短而丧失清晰性</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insertObject:atIndex:</td>
<td>好</td>
</tr>
<tr>
<td>insert:at:</td>
<td>不清晰：要插入什么？”at”表示什么？</td>
</tr>
<tr>
<td>removeObjectAtIndex:</td>
<td>好</td>
</tr>
<tr>
<td>removeObject:</td>
<td>这样也不错，因为方法是移除作为参数的对象</td>
</tr>
<tr>
<td>remove</td>
<td>不清晰；要移除什么?</td>
</tr>
</tbody>
</table>
<ul>
<li>名称通常不缩写，即使名称很长，也要拼写完全</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>destinationSelection</td>
<td>好</td>
</tr>
<tr>
<td>destSel</td>
<td>不清晰</td>
</tr>
<tr>
<td>setBackgroundColor</td>
<td>好</td>
</tr>
<tr>
<td>setBkgdColor</td>
<td>不清晰</td>
</tr>
</tbody>
</table>
<p>你可能会认为某个缩写广为人知，但有可能并非如此，尤其是当你的代码被来自不同文化和语言背景的开<br>发人员所使用时。</p>
<ul>
<li><p>然而，你可以使用少数非常常见，历史悠久的缩写。请参考：”可接受的缩略名”一节</p>
</li>
<li><p>避免使用有歧义的 API 名称，如那些能被理解成多种意思的方法名称</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sendPort</td>
<td>是发送端口还是返回一个发送端口?</td>
</tr>
<tr>
<td>displayName</td>
<td>是显示一个名称还是返回用户界面中控件的标题?</td>
</tr>
</tbody>
</table>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><ul>
<li>尽可能使用与 Cocoa 编程接口命名保持一致的名称。如果你不太确定某个命名的一致性，请浏览一下头文件或参考文档中的范例</li>
<li>在使用多态方法的类中，命名的一致性非常重要。在不同类中实现相同功能的方法应该具有相同的名称</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (int)tag</td>
<td>在 NSView， NSCell， NSControl 中有定义</td>
</tr>
<tr>
<td>- (void)setStringValue:(NSString *)</td>
<td>在许多 Cocoa classes 中有定义</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请参考“方法参数”一节。</p>
</blockquote>
<h4 id="不要自我指涉"><a href="#不要自我指涉" class="headerlink" title="不要自我指涉"></a>不要自我指涉</h4><ul>
<li>不要名称自我指涉</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString</td>
<td>好</td>
</tr>
<tr>
<td>NSStringObject</td>
<td>自我指涉</td>
</tr>
</tbody>
</table>
<ul>
<li>掩码(可使用位操作进行组合)和用作通知名称的常量不受该约定限制</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSUnderlineByWordMask</td>
<td>好</td>
</tr>
<tr>
<td>NSTableViewColumnDidMoveNotification</td>
<td>好</td>
</tr>
</tbody>
</table>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>前缀是名称的重要组成部分。它们可以区分软件的功能范畴。通常，软件会被打包成一个框架或多个紧密 相关的框架(如 Foundation 和 Application Kit 框架)。前缀可以防止第三方开发者与苹果公司之间的命 名冲突(同样也可防止苹果内部不同框架之间的命名冲突)</p>
<ul>
<li>前缀有规定的格式。它由两到三个大写字符组成，不能使用下划线与子前缀</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>Cocoa 框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>NS</td>
<td>Foundation</td>
</tr>
<tr>
<td>NS</td>
<td>Application Kit</td>
</tr>
<tr>
<td>AB</td>
<td>Address Book</td>
</tr>
<tr>
<td>IB</td>
<td>Interface Builder</td>
</tr>
</tbody>
</table>
<ul>
<li>命名 class， protocol， structure， 函数，常量时使用前缀；命名成员方法时不使用前缀，因为方法已经在它所在类的命名空间种；同理，命名结构体字段时也不使用前缀</li>
</ul>
<h3 id="书写约定"><a href="#书写约定" class="headerlink" title="书写约定"></a>书写约定</h3><p>在为 API 元素命名时，请遵循如下一些简单的书写约定</p>
<ul>
<li><p>对于包含多个单词的名称，不要使用标点符号作为名称的一部分或作为分隔符(下划线，破折号等)； 此外，大写每个单词的首字符并将这些单词连续拼写在一起。请注意以下限制:</p>
<ul>
<li>方法名小写第一个单词的首字符，大写后续所有单词的首字符。方法名不使用前缀。如:  <code>fileExistsAtPath:isDirectory:</code> 如果方法名以一个广为人知的大写首字母缩略词开头，该规则不适用，如: <code>NSImage</code> 中的 <code>TIFFRepresentation</code></li>
<li>函数名和常量名使用与其关联类相同的前缀，并且要大写前缀后面所有单词的首字符。如: <code>NSRunAlertPanel</code> ， <code>NSCellDisabled</code></li>
<li>避免使用下划线来表示名称的私有属性。苹果公司保留该方式的使用。如果第三方这样使用可能会导致命名冲突，他们可能会在无意中用自己的方法覆盖掉已有的私有方法，这会导致严重的后果。请参考”私有方法”一节以了解私有 API 的命名约定的建议</li>
</ul>
</li>
</ul>
<h3 id="类与协议命名"><a href="#类与协议命名" class="headerlink" title="类与协议命名"></a>类与协议命名</h3><p>类名应包含一个明确 述该类(或类的对象)是什么或做什么的名词。类名要有合适的前缀(请参考“前缀” 一节)。Foundation 及 Application Kit 有很多这样例子，如:NSString， NSData， NSScanner， NSApplication， NSButton 以及 NSEvent。</p>
<p>协议应该根据对方法的行为分组方式来命名。</p>
<ul>
<li>大多数协议仅组合一组相关的方法，而不关联任何类，这种协议的命名应该使用动名词(ing)，以不与 类名混淆。</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSLocking</td>
<td>好</td>
</tr>
<tr>
<td>NSLock</td>
<td>不好，看起来像类名</td>
</tr>
</tbody>
</table>
<ul>
<li>有些协议组合一些彼此无关的方法(这样做是避免创建多个独立的小协议)。这样的协议倾向于与某 个类关联在一起，该类是协议的主要体现者。在这种情形，我们约定协议的名称与该类同名。NSObject 协议就是这样一个例子。这个协议组合一组彼此无关的方法，有用于查询对象在其类层次中位置的方 法，有使之能调用特殊方法的方法以及用于增减引用计数的方法。由于 NSObject 是这些方法的主要 体现者，所以我们用类的名称命名这个协议。</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件的命名方式很重要，我们可以根据其命名知晓头文件的内容。</p>
<ul>
<li>声明孤立的类或协议:将孤立的类或协议声明放置在单独的头文件中，该头文件名称与类或协议同名</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSApplication</td>
<td>NSApplication类</td>
</tr>
</tbody>
</table>
<ul>
<li>声明相关联的类或协议:将相关联的声明(类，类别及协议) 放置在一个头文件中，该头文件名称与主要的类/类别/协议的名字相同。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString.h</td>
<td>NSString 和 NSMutableString 类</td>
</tr>
<tr>
<td>NSLock.h</td>
<td>NSLocking 协议和 NSLock， NSConditionLock， NSRecursiveLock 类</td>
</tr>
</tbody>
</table>
<ul>
<li>包含框架头文件:每个框架应该包含一个与框架同名的头文件，该头文件包含该框架所有公开的头文件。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>Foundation.h</td>
<td>Foundation.framework</td>
</tr>
</tbody>
</table>
<ul>
<li><p>为已有框架中的某个类扩展 API:如果要在一个框架中声明属于另一个框架某个类的范畴类的方法， 该头文件的命名形式为:原类名+“Additions”。如 Application Kit 中的 NSBundleAdditions.h</p>
</li>
<li><p>相关联的函数与数据类型:将相联的函数，常量，结构体以及其他数据类型放置到一个头文件中，并以合适的名字命名。如 Application Kit 中的 NSGraphics.h </p>
</li>
</ul>
<h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF" target="_blank" rel="noopener">Naming Methods</a></p>
<h3 id="一般性规则"><a href="#一般性规则" class="headerlink" title="一般性规则"></a>一般性规则</h3><p>为方法命名时，请考虑如下一些一般性规则:</p>
<ul>
<li>小写第一个单词的首字符，大写随后单词的首字符，不使用前缀。请参考“书写约定”一节。有两种例 外情况:1，方法名以广为人知的大写字母缩略词(如 TIFF or PDF)开头;2，私有方法可以使用统 一的前缀来分组和辨识，请参考“私有方法”一节</li>
<li>表示对象行为的方法，名称以动词开头:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">invokeWithTarget:</span>(id)<span class="string">target:</span>- (<span class="keyword">void</span>)<span class="string">selectTabViewItem:</span>(NSTableViewItem *)tableViewItem</span><br></pre></td></tr></table></figure>
<p>名称中不要出现 do 或 does，因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰</p>
<ul>
<li>如果方法返回方法接收者的某个属性，直接用属性名称命名。不要使用 get，除非是间接返回一个或 多个值。请参考“访问方法”一节。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (NSSize)cellSize</td>
<td>对</td>
</tr>
<tr>
<td>- (NSSize)calcCellSize</td>
<td>错</td>
</tr>
<tr>
<td>- (NSSize)getCellSize</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数要用 述该参数的关键字命名</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数前面的单词要能述该参数。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)viewWithTag:(int)aTag;</td>
<td>对</td>
</tr>
<tr>
<td>- (id)taggedView:(int)aTag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>细化基类中的已有方法:创建一个新方法，其名称是在被细化方法名称后面追加参数关键词</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id)initWithFrame:(NSRect)frameRect;</td>
<td>NSView</td>
</tr>
<tr>
<td>- (id)initWithFrame:(NSRect)frameRect mode:(ind)aMode cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns:(int)colsWide;</td>
<td>NSMatrix - NSView 的子类</td>
</tr>
</tbody>
</table>
<ul>
<li>不要使用 and 来连接用属性作参数关键字</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (int)runModalForDirectory:(NSString *)path file:(NSString *)name types:(NSArray *)fileTypes;</code></td>
<td>对</td>
</tr>
<tr>
<td><code>- (int)runModalForDirectory:(NSString *)path addFile:(NSString *)name addTypes:(NSArray *)fileTypes;</code></td>
<td>错</td>
</tr>
</tbody>
</table>
<p>虽然上面的例子中使用 add 看起来也不错，但当你方法有太多参数关键字时就有问题。</p>
<ul>
<li>如果方法 述两种独立的行为，使用 and 来串接它们</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (BOOL)openFile:(NSString <em>)fullPath withApplication:(NSString </em>)appName andDeactivate:(BOOL)flag;</td>
<td>NSWorkspace</td>
</tr>
</tbody>
</table>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>访问方法是对象属性的读取与设置方法。其命名有特定的格式依赖于属性的 述内容。</p>
<ul>
<li>如果属性是用名词述的，则命名格式为:</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNoun:(<span class="class"><span class="keyword">type</span>)<span class="title">aNoun</span>;</span>- (<span class="class"><span class="keyword">type</span>)<span class="title">noun</span>;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setgColor:<span class="params">(NSColor *)</span>aColor; </span><br><span class="line">- <span class="params">(NSColor *)</span>color;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用形容词述的，则命名格式为:</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setAdjective:<span class="params">(BOOL)</span>flag;- <span class="params">(BOOL)</span>isAdjective;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setEditable:<span class="params">(BOOL)</span>flag; </span><br><span class="line">- <span class="params">(BOOL)</span>isEditable;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用动词 述的，则命名格式为:(动词要用现在时时态)</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setVerbObject:<span class="params">(BOOL)</span>flag;- <span class="params">(BOOL)</span>verbObject;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<pre><code>- (void)setShowAlpha:(BOOL)flag; 
- (BOOL)showsAlpha;
</code></pre><ul>
<li>不要使用动词的过去分词形式作形容词使用</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)setAcceptsGlyphInfo:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL)acceptsGlyphInfo;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setGlyphInfoAccepted:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)glyphInfoAccepted;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>可以使用情态动词(can， should， will 等)来 高清晰性，但不要使用 do 或 does</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void)setCanHide:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL)canHide;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setShouldCloseDocument:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)shouldCloseDocument;</td>
<td>对</td>
</tr>
<tr>
<td>- (void)setDoseAcceptGlyphInfo:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL)doseAcceptGlyphInfo;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>只有在方法需要间接返回多个值的情况下，才使用 get</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</code></td>
<td>NSBezierPath</td>
</tr>
</tbody>
</table>
<p>像上面这样的方法，在其实现里应允许接受 NULL 作为其 in/out 参数，以表示调用者对一个或多个返回 值不感兴趣。</p>
<h3 id="委托方法"><a href="#委托方法" class="headerlink" title="委托方法"></a>委托方法</h3><p>委托方法是那些在特定事件发生时可被对象调用，并声明在对象的委托类中的方法。它们有独特的命名约<br>定，这些命名约定同样也适用于对象的数据源方法</p>
<ul>
<li>名称以标示发送消息的对象的类名开头，省略类名的前缀并小写类第一个字符</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>tableView:<span class="params">(NSTableView *)</span>tableView shouldSelectRow:<span class="params">(int)</span>row;</span><br><span class="line">- <span class="params">(BOOL)</span>application:<span class="params">(NSApplication *)</span>sender openFile:<span class="params">(NSString *)</span>filename;</span><br></pre></td></tr></table></figure>
<ul>
<li>冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的方法</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>applicationOpenUntitledFile:<span class="params">(NSApplication *)</span>sender;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的那条规则也不适用于响应通知的方法。在这种情况下，方法的唯一参数表示通知对象</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>windowDidChangeScreen:<span class="params">(NSNotification *)</span>notification;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>browserDidScroll:<span class="params">(NSBrowser *)</span>sender;</span><br><span class="line">- <span class="params">(NSUndoManager *)</span>windowWillReturnUndoManager:<span class="params">(NSWindow *)</span>window;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will，但最好使用 should</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>windowShouldClose:<span class="params">(id)</span>sender;</span><br></pre></td></tr></table></figure>
<h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><p>管理对象(集合中的对象被称之为元素)的集合类，约定要具备如下形式的方法:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addElement:<span class="params">(elementType)</span>adObj;</span><br><span class="line">- <span class="params">(void)</span>removeElement:<span class="params">(elementType)</span>anObj;</span><br><span class="line">- <span class="params">(NSArray *)</span>elements;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addLayoutManager:<span class="params">(NSLayoutManager *)</span>adObj;</span><br><span class="line">- <span class="params">(void)</span>removeLayoutManager:<span class="params">(NSLayoutManager *)</span>anObj;</span><br><span class="line">- <span class="params">(NSArray *)</span>layoutManagers;</span><br></pre></td></tr></table></figure>
<p>集合方法命名有如下一些限制和约定:</p>
<ul>
<li>如果集合中的元素无序，返回 NSSet，而不是 NSArray</li>
<li>如果将元素插入指定位置的功能很重要，则需具备如下方法:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">insertElement:</span>(elementType)anObj <span class="string">atIndex:</span>(<span class="keyword">int</span>)index; </span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">removeElementAtIndex:</span>(<span class="keyword">int</span>)index;</span><br></pre></td></tr></table></figure>
<p>集合方法的实现要考虑如下细节:</p>
<ul>
<li>以上集合类方法通常负责管理元素的所有者关系，在 add 或 insert 的实现代码里会 retain 元素，在 remove 的实现代码中会 release 元素</li>
<li>当被插入的对象需要持有指向集合对象的指针时，通常使用 set… 来命名其设置该指针的方法，且不 要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形，NSLayoutManager 类使 用如下方法:</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setTextStorage:<span class="params">(NSTextStorage *)</span>textStorage; </span><br><span class="line">- <span class="params">(NSTextStorage *)</span>textStorage;</span><br></pre></td></tr></table></figure>
<p>通常你不会直接调用 setTextStorage:，而是覆写它。</p>
<p>另一个关于集合约定的例子来自 NSWindow 类:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addChildWindow:<span class="params">(NSWindow *)</span>childWin ordered:<span class="params">(NSWindowOrderingMode)</span>place; </span><br><span class="line">- <span class="params">(void)</span>removeChildWindow:<span class="params">(NSWindow *)</span>childWin;</span><br><span class="line">- <span class="params">(NSArray *)</span>childWindows;- <span class="params">(NSWindow *)</span>parentWindow;</span><br><span class="line">- <span class="params">(void)</span>setParentWindow:<span class="params">(NSWindow *)</span>window;</span><br></pre></td></tr></table></figure>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>命名方法参数时要考虑如下规则:</p>
<ul>
<li>如同方法名，参数名小写第一个单词的首字符，大写后继单词的首字符。如:removeObject:(id)anObject</li>
<li>不要在参数名中使用 pointer 或 ptr，让参数的类型来说明它是指针</li>
<li>避免使用 one， two，…，作为参数名</li>
<li>避免为节省几个字符而缩写</li>
</ul>
<p>按照 Cocoa 惯例，以下关键字与参数联合使用:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">..<span class="selector-class">.action</span>:(SEL)aSelector</span><br><span class="line">..<span class="selector-class">.alignment</span>:(int)mode</span><br><span class="line">..<span class="selector-class">.atIndex</span>:(int)index</span><br><span class="line">..<span class="selector-class">.content</span>:(NSRect)aRect</span><br><span class="line">..<span class="selector-class">.doubleValue</span>:(double)aDouble</span><br><span class="line">..<span class="selector-class">.floatValue</span>:(<span class="attribute">float</span>)aFloat</span><br><span class="line">..<span class="selector-class">.font</span>:(NSFont *)fontObj</span><br><span class="line">..<span class="selector-class">.frame</span>:(NSRect)frameRect</span><br><span class="line">..<span class="selector-class">.intValue</span>:(int)anInt</span><br><span class="line">..<span class="selector-class">.keyEquivalent</span>:(NSString *)charCode</span><br><span class="line">..<span class="selector-class">.length</span>:(int)numBytes</span><br><span class="line">..<span class="selector-class">.point</span>:(NSPoint)aPoint</span><br><span class="line">..<span class="selector-class">.stringValue</span>:(NSString *)aString</span><br><span class="line">..<span class="selector-class">.tag</span>:(int)anInt..<span class="selector-class">.target</span>:(id)anObject..<span class="selector-class">.title</span>:(NSString *)aString</span><br></pre></td></tr></table></figure>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>大多数情况下，私有方法命名相同与公共方法命名约定相同，但通常我们约定给私有方法添加前缀，以便 与公共方法区分开来。即使这样，私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时，你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。<br>Cocoa framework 的私有方法名称通常以下划线作为前缀(如:_fooData)，以标示其私有属性。基于这 样的事实，遵循以下两条建议：</p>
<ul>
<li>不要使用下划线作为你自己的私有方法名称的前缀，Apple 保留这种用法。</li>
<li>若要继承 Cocoa framework 中一个超大的类(如:NSView)，并且想要使你的私有方法名称与基类 中的区别开来，你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性，如基于你 公司的名称，或工程的名称，并以“XX_”形式给出。比如你的工程名为”Byte Flogger”，那么就可以是 “BF_addObject:”</li>
</ul>
<p>尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突，这里的意图有所不同:为了防止不<br>小心地覆盖基类中的私有方法。</p>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingFunctions.html#//apple_ref/doc/uid/20001283-BAJGGCAD" target="_blank" rel="noopener">Naming Functions</a></p>
<p>Objective-C 允许通过函数(C 形式的函数) 述行为，就如成员方法一样。 你应当优先使用函数，而不 是类方法，如果隐含的类为单例或在处理函数子系统时。</p>
<p>函数命名应该遵循如下几条规则:</p>
<ul>
<li>函数命名与方法命名相似，但有两点不同:<ol>
<li>它们有前缀，其前缀与你使用的类和常量的前缀相同</li>
<li>大写前缀后紧跟的第一个单词首字符</li>
</ol>
</li>
<li>大多数函数名称以动词开头，这个动词 述该函数的行为</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHighlightRect</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span></span><br></pre></td></tr></table></figure>
<p>查询属性的函数有个更多的规则要遵循:</p>
<ul>
<li>查询第一个参数的属性的函数，省略动词</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">NSEventMaskFromType</span>(<span class="built_in">NSEventType</span> type) </span><br><span class="line"><span class="keyword">float</span> <span class="built_in">NSHeight</span>(<span class="built_in">NSRect</span> rect)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值为引用的方法，使用 Get</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">NSGetSizeAndAlignment</span>(<span class="keyword">const</span> <span class="keyword">char</span> *typePtr, <span class="keyword">unsigned</span> <span class="keyword">int</span>*sizep, <span class="keyword">unsigned</span> <span class="keyword">int</span> *alignp)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 boolean 值的函数，名称使用判断动词 is/does 开头</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecimalIsNotANumber</span>(<span class="keyword">const</span> <span class="built_in">NSDecimal</span> *decimal)</span><br></pre></td></tr></table></figure>
<h2 id="实例变量与数据类型命名"><a href="#实例变量与数据类型命名" class="headerlink" title="实例变量与数据类型命名"></a>实例变量与数据类型命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="noopener">Naming Properties and Data Types</a></p>
<p>这一节 述实例变量，常量，异常以及通知的命名约定。</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>在为类添加实例变量是要注意:</p>
<ul>
<li>避免创建 public 实例变量</li>
<li>使用 @private，@protected 显式限定实例变量的访问权限</li>
<li>确保实例变量名简明扼要地述了它所代表的属性</li>
</ul>
<p>如果实例变量别设计为可被访问的，确保编写了访问方法</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量命名规则根据常量创建的方式不同而大不同。</p>
<h4 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h4><ul>
<li>使用枚举来定义一组相关的整数常量</li>
<li>枚举常量与其 typedef 命名遵守函数命名规则。如来自 NSMatrix.h 中的例子：(本例中的 typedef tag (_NSMatrixMode) 不是必须的)</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_NSMatrixMode</span> &#123; </span></span><br><span class="line">	NSRadioModeMatrix = <span class="number">0</span>, </span><br><span class="line">	NSHighlightModeMatrix = <span class="number">1</span>,</span><br><span class="line">	NSListModeMatrix = <span class="number">2</span>, </span><br><span class="line">	NSTrackModeMatrix = <span class="number">3</span>&#125; NSMatrixMode;</span><br></pre></td></tr></table></figure>
<ul>
<li>位掩码常量可以使用不具名枚举。如:</li>
</ul>
<pre><code>enum {
    NSBorderlessWindowMask = 0,
    NSTitledWindowMask = 1 &lt;&lt; 0,
    NSClosableWindowMask = 1 &lt;&lt; 1,
    NSMiniaturizableWindowMask 1 &lt;&lt; 2,
    NSResizableWindowMask = 1&lt;&lt; 3
};
</code></pre><h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><ul>
<li>使用 const 来修饰浮点常量或彼此没有关联的整数常量</li>
<li>枚举常量命名规则与函数命名规则相同。const 常量命名范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">NSLightGray</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他常量"><a href="#其他常量" class="headerlink" title="其他常量"></a>其他常量</h4><ul>
<li>通常不使用 #define 来创建常量。如上面所述，整数常量请使用枚举，浮点数常量请使用 const</li>
<li>使用大写字母来定义预处理编译宏。如:#ifdef DEBUG</li>
<li>编译器定义的宏名首尾都有双下划线。如:<strong>MACH</strong></li>
<li>为 notification 名及 dictionary key 定义字符串常量，从而能够利用编译器的拼写检查，减少书写错误。Cocoa 框架供了很多这样的范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPKIT_EXTERN <span class="built_in">NSString</span> *<span class="built_in">NSPrintCopies</span>;</span><br></pre></td></tr></table></figure>
<p>实际的字符串值在实现文件中赋予。(注意:APPKIT_EXTERN 宏等价于 Objective-C 中 extern)</p>
<h3 id="异常与通知"><a href="#异常与通知" class="headerlink" title="异常与通知"></a>异常与通知</h3><p>异常与通知的命名遵循相似的规则,但是它们有各自推荐的使用模式。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>虽然你可以处于任何目的而使用异常(由 NSException 类及相关类实现)， Cocoa 通常不使用异常来处 理常规的， 可预料的错误。在这些情形下， 使用诸如 nil， NULL， NO 或错误代码之类的返回值。异常的典 型应用类似数组越界之类的编程错误。</p>
<p>异常由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[Prefix] + UniquePartOfName + Exception</p>
</blockquote>
<p>UniquePartOfName 部分是有连续的首字符大写的单词组成。例如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSColorListIOException</span></span><br><span class="line"><span class="built_in">NSColorListNotEditableException</span></span><br><span class="line"><span class="built_in">NSDraggingException</span></span><br><span class="line"><span class="built_in">NSFontUnavailableException</span></span><br><span class="line"><span class="built_in">NSIllegalSelectorException</span></span><br></pre></td></tr></table></figure>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>如果一个类有委托,那它的大部分通知可能由其委托的委托方法来处理。这些通知的名称应该能够反应其 响应的委托方法。比如,当应用程序 交 NSApplicationDidBecomeActiveNotification 通知时,全局 NSApplication 对象的委托会注册从而能够接收 applicaitonDidBecomeActive: 消息。</p>
<p>通知由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[相关联类的名称] + [Did 或 Will] + [UniquePartOfName] + Notification 例如: </p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSApplicationDidBecomeActiveNotification</span></span><br><span class="line"><span class="built_in">NSWindowDidMiniaturizeNotification</span></span><br><span class="line"><span class="built_in">NSTextViewDidChangeSelectionNotification</span></span><br><span class="line"><span class="built_in">NSColorPanelColorDidChangeNotification</span></span><br></pre></td></tr></table></figure>
<h2 id="可接受的缩略语"><a href="#可接受的缩略语" class="headerlink" title="可接受的缩略语"></a>可接受的缩略语</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE" target="_blank" rel="noopener">Acceptable Abbreviations and Acronyms</a></p>
<p>在设计编程接口时，通常名称不要缩写。然而，下面列出的缩写要么是固定下来的要么是过去被广泛使用<br>的，所以你可以继续使用。关于缩写有一些额外的注意事项:</p>
<ul>
<li>标准 C 库中长期使用的缩写形式是可以接受的。如:”alloc”， “getc”</li>
<li>你可以在参数名中更自由地使用缩写。如:imageRep， col(column)， obj， otherWin</li>
</ul>
<h3 id="常见的缩写"><a href="#常见的缩写" class="headerlink" title="常见的缩写"></a>常见的缩写</h3><table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc</td>
<td>Allocate</td>
<td>msg</td>
<td>Message</td>
</tr>
<tr>
<td>alt</td>
<td>Alternate</td>
<td>nib</td>
<td>Interface Builder archive</td>
</tr>
<tr>
<td>app</td>
<td>Application</td>
<td>pboard</td>
<td>Pasteboard</td>
</tr>
<tr>
<td>calc</td>
<td>Calculate</td>
<td>rect</td>
<td>Rectangle</td>
</tr>
<tr>
<td>dealloc</td>
<td>Deallocate</td>
<td>Rep</td>
<td>Representation</td>
</tr>
<tr>
<td>func</td>
<td>Function</td>
<td>temp</td>
<td>Temporary</td>
</tr>
<tr>
<td>horiz</td>
<td>Horizontal</td>
<td>vert</td>
<td>Vertical</td>
</tr>
<tr>
<td>info</td>
<td>Information</td>
<td>init</td>
<td>Initialize</td>
</tr>
<tr>
<td>max</td>
<td>Maximum</td>
</tr>
</tbody>
</table>
<h3 id="常见的略写"><a href="#常见的略写" class="headerlink" title="常见的略写"></a>常见的略写</h3><p>ASCII， PDF， XML， HTML， URL， RTF， HTTP， TIFF， JPG， GIF， LZW， ROM， RGB， CMYK， MIDI， FTP</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> 指南 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 规范 </tag>
            
            <tag> Ojbective-C </tag>
            
            <tag> 风格 </tag>
            
            <tag> Cocoa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Task 与后退栈解析]]></title>
      <url>http://linfuyan.com/task-and-back-stack/</url>
      <content type="html"><![CDATA[<p>应用程序通常包含多个 Activity。每个 Activity 围绕用户能够执行的指定动作类型和启动其他 Activity 来设计。例如，一个邮件应用程序有一个用来显示新信息列表的 Activity ，当用户选择一条信息，一个新的 Activity 打开用来查看信息。</p>
<p>一个 Activity 可以打开存在设备上的其他应用程序。例如，你的应用想要发送邮件信息，你可以定义一个意图来执行”发送”动作，并包含一些如邮箱地址和信息的数据。其他应用程序的 Activity 声明自己能够处理这种类型的意图，并打开。这个例子中，意图是想要发送邮件，因此邮件应用的创作 Activity 启动(如果多个 Activity 支持相同的意图，系统将让用户来选择)。当邮件发送完成，这个 Activity 退出，看起来就像是自己应用程序的一部分， Android 通过将这些 Activity 保存在相同的 Task 中来维持一致的用户体验。</p>
<p>Task 是用户在执行特定工作时与之交互的一系列 Activity 集合。 Activity 被排列在后退栈中，以每个 Activity 被打开的顺序排列。</p>
<p>对于大部分 Task 而言，设备的主屏幕都是起始位置。当用户触摸应用程序启动器或者主屏幕上的快捷方式时，应用程序的 Task 进入前台。如果应用程序的 Task 不存在(即应用程序最近没有被使用)，那么新的 Task 将被创建，并且应用程序打开的主 Activity 将作为 Task 的根 Activity。</p>
<p>当当前 Activity 启动另外的 Activity ， 新的 Activity 将被推到栈顶并获取焦点。之前的 Activity 仍然在栈中，但是被停止的。当 Activity 被停止时，系统保持了它的用户界面的当前状态。当用户按下返回按钮，当前 Activity 被从栈顶弹出，之前的 Activity 则恢复为之前 UI 所保存下来的状态。 栈中的 Activity 不会被重新排列，只能够被推入到栈中或者从栈中弹出。当被当前 Activity 启动时推入栈中，用户按下后退键时从栈中弹出。后退栈的操作遵循后进先出的原则。下图可视化的展示了随着时间推移 Activity 与后退栈中的关系。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_backstack.png" alt=""></p>
<p>如果用户继续按返回键，每个 Activity 都会从栈中被弹出来展示上一个 Activity ，直到回到主屏幕(或者回到运行 Task 开始的 Activity )。当所有的 Activity 从栈中移出， Task 就不存在了。</p>
<p>Task 是一个相互结合的单元，当用户启动新的 Task 或者通过按下 Home 键来返回主屏幕时，原来的 Task 进入后台。一旦进入后台， Task 中的所有 Activity 被停止，但是 Task 的后退栈中是完整的，只是失去了焦点。一个 Task 可以重新回到前台以便用户打开。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_multitasking.png" alt=""></p>
<p>假设，当前的 Task A 包含 3 个 Activity 在它的栈中，即当前 Activity 下有另外两个。用户按下 Home 键，从应用程序启动器新的应用程序。当主屏幕显示， Task A 进入后台。当新的应用程序启动，系统为新的应用程序启动了 Task B (其中包含自己 Activity 的栈)。在新的应用程序中玩了不久，用户再次回到主屏幕，并选择了先前 Task A 中启动的应用程序。这是 Task A 进入前台，堆栈中的 3 个 Activity 都是完整的，栈顶的 Activity 被恢复。这种情况下，用户可以通过返回主屏幕，再点击应用程序图标来启动。这是 Android 上多任务的一个实例。</p>
<blockquote>
<p>注意：多个 Task 可以同时被维持在后台。但如果用户同时运行太多的后台任务，系统会为了回收内存而销毁后台的 Activity ，这会引起 Activity 状态的丢失。</p>
</blockquote>
<p>由于后退栈中的 Activity 永远不会被重排，如果你的应用程序允许用户从多个 Activity 中启动一个特殊的 Activity ，那么，新的 Activity 实例将被创建并推入栈中，而不是将之前的其他 Activity 实例放到顶部。这样，应用程序中的一个 Activity 可能被实例化多次，如下图所示。当用户使用返回键导航回去时，每个 Activity 的实例将按照被打开的顺序来展示。但是，如果你不想让一个 Activity 被实例化多次，你可以修改这些行为。具体怎么做，在下一节的[管理  Task] 中介绍。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_multiple_instances.png" alt=""></p>
<p>总结一下 Activity 和 Task 的默认行为：</p>
<ol>
<li>当 Activity A 启动 Activity B 时， Activity A 被停止，但系统保存了它的状态，包括滚动的位置和输入的文本等。如果用户在 Activity B 时按下返回键， Activity A 会返回到其原来保存的状态。</li>
<li>当用户按下 Home 键离开 Task ，当前的 Activity 及它所在的 Task 进入后台。系统保持 Task 中每个 Activity 的状态。如果用户通过选择启动图标再次启动 Task ， Task 进入前台，并且在栈顶部的 Activity 被恢复。</li>
<li>如果用户按下返回键，当前的 Activity 被从栈中弹出并销毁。栈中之前的 Activity 被恢复。当 Activity 被销毁，系统不在保持 Activity 的状态。</li>
<li>Activity 可以被实例化多次，即使是来自其他的 Task 。</li>
</ol>
<h2 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h2><p>如上面所讨论的，当 Activity 被停止时，系统的默认行为会保留其状态。这样子，当用户导航回到之前的 Activity 时，将展示之前离开时留下的界面。尽管如此，当 Activity 即将被销毁或者必须要重建时，你依然可以使用回调方法来保持 Activity 的状态。</p>
<p>当系统停止某个 Activity 时，如果需要恢复系统的内存，系统将完全的销毁 Activity 。这种情况下， Activity 状态相关的信息便丢失了。但系统依然知道在后退栈中有 Activity 的一个位置，当 Activity 被带到前台时系统需要重建它，而不是恢复它。为了避免丢失用户以完成的工作，需要在 Activity 中通过实现 onSaveInstanceState() 方法来主动保持状态。</p>
<p>关于如何来保存 Activity 的状态的更多信息，可以查看 Activity 相关文档。</p>
<h2 id="管理-Task"><a href="#管理-Task" class="headerlink" title="管理 Task"></a>管理 Task</h2><p>上面描述的 Android 管理 Task 和后退栈的方式-将所有成功打开的 Activity 放在同一个 Task 及后进先出的堆栈中-在大部分应用程序中工作正常，也不需要担心 Activity 如何与 Task 相关联，以及如何存在后退栈中。有的时候，你想要中断这种普通的行为。也许你想要应用程序中的一个 Activity 打开时开启一个新的 Task ，而不是被放在当前 Task 中。也许你启动一个 Activity 时，想要把已经存在的实例带到前台，而不是在顶上创建一个新的实例。也许你想当用户离开 Task 的时候，后退栈中除了根 Activity 之外的清空其他 Activity 。</p>
<p>通过清单文件中 <code>&lt;activity&gt;</code> 元素的属性以及传递给 startActivity() 的 Intent 中的 flag 可以完成上面的工作，甚至更多其他工作。</p>
<p>可以使用的 <code>&lt;activity&gt;</code> 元素主要属性包括：</p>
<ul>
<li>taskAffinity</li>
<li>launchMode</li>
<li>allowTaskReparenting</li>
<li>clearTaskOnLaunch</li>
<li>alwaysRetainTaskState</li>
<li>finishOnTaskLaunch</li>
</ul>
<p>可以使用的主要 Intent 的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>接下来的章节中，你将看到如何使用这些清单属性和 Intent 的 flag 来定义 Activity 如何与 Task 关联以及他们在后退栈中的行为。</p>
<blockquote>
<p><strong>警告：</strong> 大部分应用程序不应该干扰 Activity 和 Task 的默认行为。如果你觉得非常有必要修改这些默认行为，那么需要做出警告，并测试 Activity 启动以及通过返回键从其他 Activity 或 Task 返回的情况。测试导航是否会和用户所期待的行为冲突。</p>
</blockquote>
<h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p>启动模式用来定义一个新的 Activity 实例如何与当前的 Task 关联。可以通过两种方式来定义不同的启动模式：</p>
<ul>
<li>使用清单文件：当你在清单文件中声明一个 Activity 时，可以指定 Activity 在启动时如何关联 Task。</li>
<li>使用 Intent flag ：调用 startActivity() 时，可以在 Intent 中包含 flag 来声明新的 Activity 与当前 Task 如何关联。</li>
</ul>
<p>这样，如果 Activity A 启动 Activity B ， Activity B 可以在它的清单中定义如何与当前 Task 关联， Activity A 同样可以请求 Activity B 如何与当前 Task 关联。如果都定义了 Activity B 如何与 Task 关联， Activity A 中通过 Intent 定义的请求优先于 Activity 在清单中定义的请求。</p>
<blockquote>
<p><strong>注意</strong>：某些在清单文件中有效的启动模式，在 Intent 中的 flag 是无效的，同样，某些 Intent 中有效的启动模式在清单里定义是无效的。</p>
</blockquote>
<p><strong>使用清单文件</strong></p>
<p>在清单文件中申明 Activity 时，使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性可以指定 Activity 如何与 Task 关联：</p>
<ul>
<li>“standard”（默认模式）</li>
</ul>
<p>系统创建新的 Activity 实例，这个实例位于启动它的 Activity 相同的栈，并且将意图传递给它。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 也能有多个实例。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>如果 Activity 的实例已经存在于当前 Task 的顶部，系统通过调用实例的 onNewIntent() 方法来传递意图到实例，而不是为 Activity 创建一个新的实例。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 可以有多个实例(除非后退栈顶部的 Activity 不是一个已经存在的 Activity 实例)。</p>
<p>例如，假设一个 Task 的后退栈包含根 Activity A ， Activity B ， Activity C 以及 Activity D 在顶部。一个意图到达 Activity D 。如果 D 的启动模式为 “standard” ，新的类实例将被启动，堆栈变成 A-B-C-D-D 。如果 D 的启动模式为 “singleTop” ，已经存在的 D 实例将通过 onNewIntent() 接收意图，一次它还在栈顶，而栈依然是 A-B-C-D 。如果一个意图到达 B ，新的 B 的实例被添加到堆栈中，即使它的启动模式是 “singleTop” 。</p>
<blockquote>
<p><strong>注意</strong>：当新的 Activity 实例被创建，用户可以按下返回按钮来返回到之前的 Activity 。但是当已经存在的 Activity 实例处理了新的 Intent ，用户无法按下返回键返回到通过 onNewIntent() 到来新的 Intent 前的 Activity 状态。</p>
</blockquote>
<ul>
<li>“singleTask”</li>
</ul>
<p>系统创建新的 Task 并在新的 Task 的根实例化 Activity 。如果已经有 Activity 的实例存在于独立的 Task 中，系统通过调用 onNewIntent() 将 Intent 路由到已存在的实例，而不是创建一个新的实例。每次只能有一个 Activity 的实例存在。</p>
<blockquote>
<p><strong>注意</strong>：虽然 Activity 在新的 Task 中打开，后退按钮依然可以返回到用户之前的 Activity 。</p>
</blockquote>
<ul>
<li>“singleInstance”</li>
</ul>
<p>除了系统不再启动其他的 Activity 到持有实例的 Task 中，其他的和 “singleTask” 一样。 这个 Activity 是它的 Task 的唯一成员。任何由它打开的 Activity 在一个独立的 Task 。</p>
<p>另外一个实例， Android 浏览器应用程序声明网页浏览器的 Activity 需要永远在自己的 Task 中打开，即在 <code>&lt;activity&gt;</code> 元素中指定 singleTask 启动模式。这意味着，如果你的应用程序要打开 Android 浏览器，它的 Activity 与你的应用程序将在不同的 Task 中。不论新的 Task 启动浏览器，或者浏览器已经有一个运行在后台的 Task， Task 将被带到前台处理新的 Intent 。</p>
<p>不论 Activity 是在新的 Task 中启动还是在相同的 Task 中启动，返回按钮总是能让用户返回到之前的 Activity 。如果你启动了一个指定 singleTask 启动模式的 Activity ，恰好这时有个 Activity 的实例在后台 Task 中，整个 Task 将进入前台。这种情况下，后退栈中包含在 Task 中的所有 Activity 进入前台，在栈的顶部。下图展示了这个过程。</p>
<p><img src="http://img.uprogrammer.cn/static/images/diagram_backstack_singletask_multiactivity.png" alt=""></p>
<p>更多的在清单中使用启动模式的信息，可以查看 <a href=""><activity>元素</activity></a> 相关文档，这里讨论更多关于 launchMode 属性及可接受的值。</p>
<blockquote>
<p><strong>注意</strong>：Activity 中通过 launchMode 属性指定的行为，可以通过启动 Activity 的意图的 flag 来覆盖。 </p>
</blockquote>
<p><strong>使用意图 flag</strong></p>
<p>启动一个 Activity 时，可以通过在 startActivity() 中传递意图的 flag 来修改 Activity 与 Task 之间的默认关联。可以用来修改默认行为的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>在新的 Task 中启动 Activity 。如果要启动的 Activity 已经有在运行的 Task ， Task 将带着最后被保存的状态到前台， Activity 在 onNewIntent() 中接收新的意图。</p>
<p>这产生的效果与上节讨论的 “singleTask” 启动模式一致。</p>
<ul>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>如果被启动的 Activity 是当前 Activity (即在后退栈的顶部)，已存在的实例调用 onNewIntent() ，而不是创建一个新的 Activity 实例。</p>
<p>这产生的效果与上节讨论的 “singleTop” 启动模式一致。 </p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ul>
<p>如果被启动的 Activity 已经在当前 Task 中，那么所有在其顶部的 Activity 将被销毁，意图将通过 onNewIntent() 传递到被恢复的 Activity 实例，而不是创建一个新的实例。</p>
<p>没有启动模式可以产生这种行为。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 经常和 FLAG_ACTIVITY_NEW_TASK 结合使用。当在一起使用时，这些 flag 是一种在其他 Task 中定位已存在 Activity，并将其放入可以响应意图位置的方式。</p>
<h3 id="处理-affinities"><a href="#处理-affinities" class="headerlink" title="处理 affinities"></a>处理 affinities</h3><p>Affinity 表明 Activity 优先属于哪个 Task 。默认情况下，来自同一个应用程序的 Activity 相互间拥有一个 Affinity 。因此，同一个应用程序的 Activity 优先在同一个 Task 中。尽管如此，你可以修改一个 Activity 的默认 Affinity 。不同应用程序中定义的 Activity 可以共享一个 Affinity ，同一个应用程序中定义的 Activity 也可以被分配在不同的 Task Affinity 中。</p>
<p>通过给定 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性可以修改 Activity 的 Affinity 。</p>
<p>taskAffinity 属性是一个字符串，必须与申明在 <code>&lt;manifest&gt;</code> 元素中的默认包名不同。因为系统使用这个名称来识别应用程序的默认 Task Affinity 。</p>
<p>两种情况下使用 Affinity：</p>
<ul>
<li>当启动 Activity 的意图包含 FLAG_ACTIVITY_NEW_TASK flag 时。</li>
</ul>
<p>默认情况下，新的 Activity 被启动在调用 startActivity() 方法的 Activity 所在 Task 。被推入到调用者相同的后退栈。但如果传递给 startActivity() 的意图中包含 FLAG_ACTIVITY_NEW_TASK flag ，系统寻找另外的 Task 来存放 Activity 。通常是一个新的 Task 。但也不是必须的。当已经存在存在一个 Task 拥有相同的 Affinity 时， Activity 被启动到这个 Task 中，没有时，才启动新的 Task 。</p>
<p>如果这个 flag 使得 Activity 启动到新的 Task 中，用户又按下 Home 键离开它，这里将有许多种方式来让用户导航回 Task 。某些入口（如通知管理器）总是在外部 Task 中启动 Activity ，而不是在自己内部，因此调用 startActivity() 总是在意图中传递 FLAG_ACTIVITY_NEW_ACTIVITY 。如果你需要一个 Activity 可以被外部的入口调用，则使用这个 flag ，需要注意的是用户有独立的方式来返回到启动的 Task ，如通过启动器图标。</p>
<ul>
<li>当一个 Activity 有 allowTaskReparenting 属性并设置为 true 。</li>
</ul>
<h3 id="清空后退栈"><a href="#清空后退栈" class="headerlink" title="清空后退栈"></a>清空后退栈</h3><p>如果用户离开 Task 一段时间，系统将清空 Task 中除根 Activity 之外的所有 Activity 。当用户再次回到 Task ，只有根 Activity 将被回复。系统行为之所以如此，是因为在经历一段相对长的时间，用户将放弃之前所做的一些事情，而返回 Task 是为了开始其他新的事情。</p>
<p>这里有一些 Activity 的属性可以用来修改这个行为：</p>
<ul>
<li>alwaysRetainTaskState</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，上面提到的默认行为将不会发生。 即时经过很长一段时间， Task 也将在栈中保持所有的 Activity 。</p>
<ul>
<li>clearTaskOnLaunch</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，无论用户离开 Task 或是返回它，堆栈将被清空只剩下根 Activity。换句话说，这与 alwaysRetainTaskState 刚刚相反。即时在离开很短的时间，用户也将返回 Task 的初始状态。</p>
<ul>
<li>finishOnTaskLaunch</li>
</ul>
<p>这个属性类似 clearTaskOnLaunch ，但是这个仅作用于单个 Activity ，而不是整个 Task 。这能引起任何 Activity 消失，包括根 Activity 。当它被设置为 true ， Activity 仅仅为当前会话维持 Task 的部分。如果用户离开或者过会儿返回 Task 都不在了。</p>
<h3 id="启动-Task"><a href="#启动-Task" class="headerlink" title="启动 Task"></a>启动 Task</h3><p>通过给定某个 Activity 包含 “android.intent.action.MAIN” 为指定动作， “android.intent.category.LAUNCHER” 为指定类别的意图过滤器，可以将 Activity 作为 Task 的入口。实例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种类型的意图过滤器在应用程序启动器上显示 Activity 的图标和标签。由于这种原因，”singleTask” 和 “singleInstance” 两种启动模式标记 Activity 初始化 Task 只能在 Activity 拥有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时使用。想象一下如果没有这些过滤器将发生什么：一个意图启动了 “singleTask” 的 Activity ，初始化了 Task ，用户在这个 Task 上玩耍了一段时间，然后按下了 Home 键。Task 就进入了后台且不可见。现在用户无法再返回到 Task ，因为应用程序启动器上没有显示…</p>
<p>在那些不需要用户返回到 Activity 的情况，设置 <code>&lt;activity&gt;</code> 元素的 finishOnTaskLaunch 为 true 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
            <tag> Task </tag>
            
            <tag> 后退栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity 详解]]></title>
      <url>http://linfuyan.com/android-activity/</url>
      <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ol>
<li>Activity 是一个提供屏幕的应用程序组件，用户通过它与机器产生交互。</li>
<li>每个 Activity 包含一个窗口( window )，大部分情况下窗口是全屏的，也有可能窗口比屏幕小且在其他窗口的顶部。</li>
<li>一个应用程序由一个或者多个 Activity 组成，这些 Activity 之间是松散的组织在一起的。</li>
<li>每一个 Activity 可以启动其他的 Activity，不同的 Activity 可以执行不同的动作。</li>
<li>新的 Activity 启动以后，原来的 Activity 会被保留到后退栈中，后退栈遵循基本的后进先出的堆栈机制。在当前 Activity 中按返回键退出，当前 Activity 将被从堆栈中弹出、销毁，之前的 Activity 则被恢复。</li>
<li>当 Activity 被启动，或者被停止时，都会通过生命周期回调的方式来通知自己的状态变化。这些状态包括被创建、停止、恢复、销毁，每个回调都提供了在特定状态下执行特定任务的时机。</li>
</ol>
<h2 id="如何创建-Activity"><a href="#如何创建-Activity" class="headerlink" title="如何创建 Activity"></a>如何创建 Activity</h2><ol>
<li>创建 Activity 可以通过创建 Activity 的子类，或者一个已经存在的 Activity 子类来实现。</li>
<li>在创建的子类中实现生命周期的回调方法。其中最重要的是 onCreate 和 onPause。<ul>
<li>必须实现 onCreate 方法，并且在其中调用 setContentView() 来定义用户布局。</li>
<li>在 onPause 中提交当前会话中需要被持久化的更改，以避免用户可能不再回来导致的数据丢失。</li>
</ul>
</li>
</ol>
<h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><ol>
<li>Activity 的用户界面是由一系列的视图层级来提供的。</li>
<li>视图源自于 View 类的对象。每个视图控制 Activity 的窗口上的特定矩形空间，并响应用户交互。</li>
<li>用户提供了一系列内置的视图，包括”控件”和”布局”。<ul>
<li>控件指的是在屏幕上提供的可见、可交互的元素的视图。</li>
<li>布局源自 ViewGroup， 为它的子类提供唯一的布局模型。</li>
</ul>
</li>
<li>可以实现 View 或者 ViewGroup 的子类来创建自己的控件和布局。</li>
<li>常用的视图布局定义方式包括：<ul>
<li>通过资源文件中的 XML 布局，并在 setContentView() 方法中传递资源ID。可以使界面设计的维护和逻辑代码分离。</li>
<li>通过代码创建 View， 并插入到 ViewGroup 来构建视图层级，然后传递根 ViewGroup 给 setContentView()。</li>
</ul>
</li>
</ol>
<h3 id="在清单中声明-Activity"><a href="#在清单中声明-Activity" class="headerlink" title="在清单中声明 Activity"></a>在清单中声明 Activity</h3><ol>
<li>使用 Activity 前，需要在应用清单文件中对其进行声明。在 <code>&lt;application&gt;</code> 元素中添加 <code>&lt;activity&gt;</code> 子元素。</li>
<li><code>&lt;activity&gt;</code> 元素中还有许多属性用来定义Activity 的标签、图标、主题等， <code>android:name</code> 是唯一必须的属性，用于定义 Activity 的名称。</li>
<li>Activity 的名称定义以后，不要随便改动。如果改动，可能造成某些功能无法正常使用。</li>
</ol>
<h3 id="使用意图过滤器"><a href="#使用意图过滤器" class="headerlink" title="使用意图过滤器"></a>使用意图过滤器</h3><ol>
<li><code>&lt;activity&gt;</code> 元素通过 <code>&lt;intent-filter&gt;</code> 元素来定义不同的意图过滤器，用来声明其他应用程序如何激活它。</li>
<li>Android SDK 工具在创建应用程序时自动生成的 Activity 中包含的意图过滤器，声明了 Activity 响应 main 动作，并放在 launcher 类别中。<ul>
<li><code>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</code> 指定这是应用程序的主入口。</li>
<li><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</code> 指定 Activity 被列在系统的应用程序启动器中，这样用户可以启动它。</li>
</ul>
</li>
<li>如果不允许其他的应用程序来启动 Activity，则不要声明任何的意图过滤器。</li>
<li>在应用程序内部，可以通过显式的意图来启动想要的 Activity。</li>
<li>如果定义了意图过滤器，则可以让其他应用程序通过隐式意图来激活 Activity。</li>
<li><code>&lt;intent-filter&gt;</code> 元素中包含有 <code>&lt;action&gt;</code> 元素及可选的 <code>&lt;category&gt;</code> 或者 <code>&lt;data&gt;</code>，这些元素一同指定了 Activity 能响应的意图类型。</li>
</ol>
<h2 id="启动一个-Activity"><a href="#启动一个-Activity" class="headerlink" title="启动一个 Activity"></a>启动一个 Activity</h2><ol>
<li>通过 startActivity() 方法来启动 Activity， 并传递一个 Intent 意图对象。</li>
<li>Intent 对象通过两种方式描述想要启动的 Activity：<ul>
<li>准确的 Activity 对象。</li>
<li>想要执行的动作类型。系统会自动选择合适的 Activity， 可能来自其他的应用程序。</li>
</ul>
</li>
<li>Intent 还可以传递少量的数据给即将启动的 Activity。</li>
<li>使用类名来启动已知的 Activity：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(this, SignInActivity.<span class="keyword">class</span>);</span><br><span class="line">startActivity(<span class="keyword">intent</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用 Intent 来描述要执行的动作，系统从其他应用程序中选择打开合适的 Activity， 如果有多个 Activity， 则由用户来选择：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(<span class="keyword">Intent</span>.ACTION_SEND);</span><br><span class="line"><span class="keyword">intent</span>.putExtra(<span class="keyword">Intent</span>.EXTRA_EMAIL, recipientArray);</span><br><span class="line">startActivity(<span class="keyword">intent</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为结果启动-Activity"><a href="#为结果启动-Activity" class="headerlink" title="为结果启动 Activity"></a>为结果启动 Activity</h3><ol>
<li>如果启动一个 Activity， 并期望从新的 Activity 上接收一个结果，则使用 startActivityForResult()。</li>
<li>要接收新 Activity 上的结果，需要在原 Activity 上实现 onActivityResult() 方法，从其中的 Intent 参数中获取返回结果。</li>
<li>onActivityResult() 方法处理 Activity 返回结果：<ul>
<li>处理成功，则 resultCode 为 RESULT_OK。</li>
<li>需要检查 requestCode 是否与 startActivityForResult() 的第二个参数匹配。</li>
<li>返回的结果以 Intent 带回。</li>
</ul>
</li>
</ol>
<h2 id="关闭-Activity"><a href="#关闭-Activity" class="headerlink" title="关闭 Activity"></a>关闭 Activity</h2><p>通过 finish() 和 finishActivity() 来关闭 Activity。实际上由于 Android 系统自己管理 Activity 的生命，你不应该显示的调用这些方法。</p>
<h2 id="管理-Activity-生命周期"><a href="#管理-Activity-生命周期" class="headerlink" title="管理 Activity 生命周期"></a>管理 Activity 生命周期</h2><ol>
<li>通过实现回调方法来管理 Activity 的生命周期，可以开发一个健壮且灵活的应用程序。 Activity 的生命周期则直接影响到它所关联的其他 Activity， 任务以及后退栈。</li>
<li>Activity 的主要状态：<ul>
<li>Resumed： Activity 处于前台屏幕，且拥有用户焦点。</li>
<li>Paused：其他 Activity 位于前台，但这个 Activity 还是可见的。其他 Activity 位于顶部且没有覆盖整个屏幕。这时候， Activity 还在内存中，<strong>与窗口管理器关联</strong>，但在内存极低的情况下将被系统杀掉。</li>
<li>Stopped： Activity 被其他 Activity 完全覆盖，位于后台。这时候， Activity 还在内存中，<strong>与窗口管理器分离</strong>，当需要内存时将被系统杀掉。</li>
</ul>
</li>
<li>当 Activity 被暂停或者被停止，系统可以通过调用 finish() 或者直接删掉进程的方式丢弃它。重新打开时需要重建。</li>
</ol>
<h3 id="基础的生命周期方法"><a href="#基础的生命周期方法" class="headerlink" title="基础的生命周期方法"></a>基础的生命周期方法</h3><table>
<thead>
<tr>
<th>生命周期方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>Activity 将被创建。</td>
</tr>
<tr>
<td>onStart()</td>
<td>Activity 即将可见。</td>
</tr>
<tr>
<td>onResume()</td>
<td>Activity 已经可见，处于 resumed 状态。</td>
</tr>
<tr>
<td>onPause()</td>
<td>其他 Activity 可见，自己则即将处于 paused 状态。</td>
</tr>
<tr>
<td>onStop()</td>
<td>Activity 不在可见，处于 stopped 状态。</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>Activity 即将被销毁。</td>
</tr>
</tbody>
</table>
<ol>
<li>在实现生命周期方法时，需要调用父类的实现。</li>
<li>实现这些生命周期方法，你可以监控 3 个嵌套的循环。<ul>
<li>完整生命：从 onCreate() 到 onDestroy() 。在 onCreate() 中建立全局状态，并在 onDestroy() 中释放资源。</li>
<li>可见生命：从 onStart() 到 onStop() 。这个过程中，用户可以看到 Activity 并与之交互。</li>
<li>前台生命：从 onResume() 到 onPause()。</li>
</ul>
</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/activity_lifecycle.png" alt="Activity 生命周期"></p>
<h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><ol>
<li>Activity 处于 paused， stopped 时依然存在内存中，所有的数据及状态都存在，因此当被恢复时依然保持退出时的状态。</li>
<li>但处于 paused， stopped 状态的 Activity 可能会被系统杀掉，从而用户重新打开时，与当时提出时不一样了。为了保证能够还原现场，则需要实现 onSaveInstanceState() 回调方法。</li>
<li>系统在 Activity 被销毁之前调用 onSaveInstance() ，通过将需要记住的状态通过键值对的形式保存到 Bundle 参数中。当应用程序被系统杀死，并再次被启动时，会将保存的 Bundle 传递到 onCreate() 和 onRestoreInstanceState() 。从这些方法的 Bundle 参数中，就可以获取到 Activity 被销毁前的状态，并据此恢复 Activity。</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/restore_instance.png" alt="Activity 恢复实例"></p>
<ol start="4">
<li>onSaveInstanceState() 并不是在 Activity 被销毁之前一定会被调用。该方法在 onStop() 之前被调用，是否在 onPause() 前则不确定。</li>
<li>即使你没有实现 onSaveInstanceState() ，在 Activity 的 onSaveInstanceState() 的默认实现中也可以恢复一些状态。由于 onSaveInstanceState() 的默认实现中保存了 UI 的状态，因此，在自己实现 onSaveInstanceState() 时，需要调用父类的 onSaveInstanceState()。</li>
<li>由于 onSaveInstanceState() 不保证一定会被调用，因此不能在这个回调中记录 Activity 状态的变换，也不应该使用它来持久化数据，而应该使用 onPause()。</li>
<li>一个好的，用来测试应用程序恢复状态能力的方法是简单地旋转设备的屏幕方向。</li>
</ol>
<h3 id="处理配置改变"><a href="#处理配置改变" class="headerlink" title="处理配置改变"></a>处理配置改变</h3><p>某些设备配置在运行时会发生改变，如屏幕方向、键盘可用性和语言。当这些改变发生时， Android 重建运行中的 Activity (系统调用 onDestroy() 后马上调用 onCreate() )。这个行为被设计用来帮助应用程序适应新的配置，自动为应用程序重新加载已提供的可替换资源，如为不同屏幕方向和尺寸使用的不同布局。</p>
<p>处理重启的最好方法是使用 onSaveInstanceState() 和 onRestoreInstanceState() (或者 onCreate()) 来保存和恢复 Activity 的状态。</p>
<h3 id="协调多个-Activity"><a href="#协调多个-Activity" class="headerlink" title="协调多个 Activity"></a>协调多个 Activity</h3><p>当一个 Activity 启动另外一个时，两个 Activity 都会经历生命周期的变换。当另一个 Activity 被创建时，第一个 Activity 将暂停，乃至停止(如果它在后台且可见，则不会停止)。如果两个 Activity 之间共享保存在磁盘上的数据，对于理解在第二个 Activity 创建完成之前，第一个 Activity 不会完全停止是非常重要的。第二个 Activity 的启动过程和第一个 Activity 的停止过程重叠。</p>
<p>生命周期回调的顺序是被良好定义的，特别是当两个 Activity 在相同的进程中，且一个启动另外一个。下面是当 Activity A 启动 Activity B 时的操作顺序：</p>
<ol>
<li>执行 Activity A 的 onPause() 方法。</li>
<li>Activity B 的 onCreate() ， onStart() 和 onResume() 方法按顺序执行。(这是 Activity 获取了用户焦点)。</li>
<li>如果 Activity A 不再屏幕上可见， onStop() 方法被执行。</li>
</ol>
<p>可预期的生命周期回调顺序使得你可以管理一个 Activity 到另一个的变换信息。例如，你必须在第一个 Activity 停止时对数据库进行写入，这样接下来的 Activity 可以读取，那么你需要在 onPause() 中写入数据库，而不是在 onStop() 中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities.html</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 上 sublime text 通过命令行打开文件]]></title>
      <url>http://linfuyan.com/faq/open-files-via-cmdline-using-sublime-text/</url>
      <content type="html"><![CDATA[<p>在 Mac 上让 sublime text 通过命令行打开文件，可以提升比较高的效率。</p>
<p>具体过程如下：</p>
<p>1. 首先，在主用户目录下新建 .bash_alias 文件</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.bash<span class="number">_</span><span class="keyword">alias</span></span><br></pre></td></tr></table></figure>
<p>2. 在其中添加如下代码</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">subl</span>=<span class="comment">'open -a /Applications/"Sublime Text 2.app"'</span></span><br><span class="line"><span class="keyword">alias</span> <span class="title">st</span>=subl</span><br></pre></td></tr></table></figure>
<p>3. 使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_alias</span><br></pre></td></tr></table></figure>
<p>4. 可以将上面的命令，添加到 <code>~/.bash_profile</code> 中，这样每次启动就自动使上面的配置生效了。</p>
<p>5. 完成上面步骤，就可以通过如下命令，打开目标文件/目录了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">st</span> path/<span class="keyword">to</span>/dest/dir_or_file</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他的应用也是可以通过类似的方式配置，来提高操作的效率，如下面添加了 mou 来打开文件。</p>
</blockquote>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">mou</span>=<span class="comment">'open -a /Applications/Mou.app'</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> sublime text </tag>
            
            <tag> 使用 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决 The same input jar is specified twice 问题]]></title>
      <url>http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/</url>
      <content type="html"><![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> <span class="keyword">task</span> <span class="string">':joke:proguardRelease'</span>.</span><br><span class="line">&gt; java.io.IOException: The same input jar [<span class="regexp">/Users/</span>lfy<span class="regexp">/Develop/gi</span>ts<span class="regexp">/joke-android/</span>joke<span class="regexp">/libs/</span>eventbus.jar] is specified twice.</span><br></pre></td></tr></table></figure>
<p>今天在打混淆包时，遇到这个错误，刚开始以为是因为有多个项目都引用了 eventbus.jar 库，但当我对项目中的 eventbus.jar 的依赖进行排除时，同样出错。这次报的则是没有 eventbus.jar。 所以打消了我的第一个猜测。</p>
<p>后来发现，是因为以前在用 eclipse 开发时，混淆配置文件中包含有 <code>-libraryjars libs/eventbus.jar</code> 的配置，用来保持 eventbus.jar 不被混淆。在 Android Studio 中， build.gradle 中声明了对这个 jar 包的依赖，则不需要在混淆配置文件中继续声明。</p>
<p>在将所有的 <code>-libraryjars libs/*.jar</code> 注释掉以后，项目可以正常混淆了。</p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> 混淆 </tag>
            
            <tag> proguard </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 使用多说评论框]]></title>
      <url>http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/</url>
      <content type="html"><![CDATA[<p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>
<a id="more"></a>
<p>既然如此，我们以 hueman 主题下在文章末尾配置多说评论框为例作一下说明。</p>
<p>首先，你需要注册一个<a href="http://duoshuo.com" target="_blank" rel="noopener">多说</a>账号并新建一个站点。</p>
<p><img src="http://img.uprogrammer.cn/static/images/duoshuo-create-site.png" alt="多说创建站点"></p>
<p>站点创建完成以后，会跳出代码模板的页面，如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/duoshuo-comment-template.png" alt="多说代码模板"></p>
<p>左侧选择”获取代码”的这栏，然后选中”通用代码”。这就是我们评论框的代码模板，后面我们需要找到合适的地方，将其插入到 hueman 主题中的文章模板里。</p>
<p><img src="http://img.uprogrammer.cn/static/images/hueman-article.png" alt="hueman 文章代码"></p>
<p>在 hueman 主题中，文章的模板在 <code>hueman -&gt; layout -&gt; _partial -&gt; post -&gt; article.ejs</code>  下面。看到上图中，第一个红框圈住的部分，是主题自带的 disqus 评论框的配置。当然我们没有在<strong>项目目录</strong>下的 <code>_config.yml</code> 中配置 disqus_shortname，所以它是不生效的，在咱们的文章页面中看不到。</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">if</span> (post.comments &amp;&amp; config.disqus_shortname)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_thread"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>找到上面这个文章末尾的位置，仿照上面的逻辑判断代码，把多说评论框模板代码添加进来，如上图中的第二个红框圈住的部分。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span> &amp;&amp; <span class="attr">theme.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds-thread"</span> <span class="attr">data-thread-key</span>=<span class="string">"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;"</span> <span class="attr">data-title</span>=<span class="string">"&lt;%= post.title %&gt;"</span> <span class="attr">data-url</span>=<span class="string">"&lt;%= page.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 end --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> duoshuoQuery = &#123;short_name:<span class="string">'&lt;%= theme.duoshuo_shortname %&gt;'</span>&#125;;</span></span><br><span class="line"><span class="actionscript">      (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">        ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</span></span><br><span class="line"><span class="actionscript">        ds.charset = <span class="string">'UTF-8'</span>;</span></span><br><span class="line"><span class="javascript">        (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">         || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span></span><br><span class="line"><span class="undefined">      &#125;)();</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 end --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里大家注意一下：</p>
<p>1. 第一行中判断 !index 代表是非主页的文章。我们是要在主页之外的文章正文下添加评论，所以添加了这个判断。</p>
<p>2. <code>theme.duoshuo_shortname</code>，这里需要我们在主题下面的 <code>_config.yml</code> 中添加 <code>duoshuo_shortname</code> 字段配置才能生效。这里和上面讲到的 <code>config.disqus_shortname</code> 的区别就在于 <code>theme._</code> 开头的是在主题中的 <code>_config.yml</code> 配置， <code>config._</code> 开头是在项目目录下的 <code>_config.yml</code> 配置。</p>
<p>Ok，到这里，打开 <code>hueman -&gt; _config.yml</code> 在其中添加如下代码：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">comments</span> 配置多说评论</span></span><br><span class="line">duoshuo_shortname: 这里就是你在创建站点时填的多说域名</span><br></pre></td></tr></table></figure>
<p>如果多说域名是 <a href="http://abc.duoshuo.com" target="_blank" rel="noopener">http://abc.duoshuo.com</a> ， 那这里 <code>duoshuo_shortname</code> 就是 abc。</p>
<p>3. 多说评论框模板中的变量，我们需要进行替换。原来如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="attribute">class</span>=<span class="string">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="string">"请将此处替换成文章在你的站点中的ID"</span> <span class="attribute">data-title</span>=<span class="string">"请替换成文章的标题"</span> <span class="attribute">data-url</span>=<span class="string">"请替换成文章的网址"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds-thread"</span> <span class="attr">data-thread-key</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> post.layout </span><span class="xml"><span class="tag"><span class="string">%&gt;-&lt;%=</span></span></span><span class="ruby"> post.slug </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span> <span class="attr">data-title</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> post.title </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span> <span class="attr">data-url</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> page.permalink </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>其中， <code>post.layout</code>， <code>post.slug</code>， <code>post.title</code>， <code>page.permalink</code> 都是 Hexo 的内置变量。具体可以查看<a href="https://hexo.io/zh-cn/docs/variables.html" target="_blank" rel="noopener">这里</a>。</p>
<p><img src="http://img.uprogrammer.cn/static/images/duoshuo-article-management.png" alt="多说文章管理"></p>
<p>这样就为 Hexo 站点添加上多说评论框啦，如果还需要在其他的位置添加，过程类似。总结下步骤：</p>
<ol>
<li>注册多说账号，创建新站点。</li>
<li>找到需要添加多说评论框的位置，粘贴多说评论框的模板代码，并作必要的修改。</li>
<li>如果将多说评论框作为配置项，合适的地方，添加配置。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 多说 </tag>
            
            <tag> 评论框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Symbol not found _usdt_create_provider 错误处理]]></title>
      <url>http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/</url>
      <content type="html"><![CDATA[<p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>
<a id="more"></a>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> lazy symbol binding <span class="string">failed:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"></span><br><span class="line"><span class="string">dyld:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"></span><br><span class="line">Trace/BPT <span class="string">trap:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>最终，我是通过多次的 <code>npm install hexo --no-optional</code> 解决的，至于原因是什么，我不太清楚。其他手段也试过，没有成功。</p>
<p>以下是参考过的资料：</p>
<p><a href="https://github.com/trentm/node-bunyan/issues/216" target="_blank" rel="noopener">Still getting lots of DtraceProviderBindings errors on OS X</a></p>
<p><a href="https://github.com/hexojs/hexo/issues/1398" target="_blank" rel="noopener">node.js v0.12.7 install hexo-cli error on mac os x 10.10.4</a></p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 错误 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 使用七牛云同步插件 hexo-qiniu-sync 出错]]></title>
      <url>http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/</url>
      <content type="html"><![CDATA[<p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError: <span class="keyword">Arguments</span> to path.join must be strings</span><br><span class="line">    <span class="built_in">at</span> Object.posix.join (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">at</span> sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">at</span> Object.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">at</span> <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.ret (eval <span class="built_in">at</span> &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    <span class="built_in">at</span> /Users/lfy/ihaowu/node_modules/hexo/lib/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    <span class="built_in">at</span> tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    <span class="built_in">at</span> new Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    <span class="built_in">at</span> Hexo.call (/Users/lfy/ihaowu/node_modules/hexo/lib/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">at</span> runHexoCommand (/usr/local/lib/node_modules/hexo/node_modules/hexo-cli/lib/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="built_in">at</span> tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    <span class="built_in">at</span> Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">at</span> Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">at</span> <span class="keyword">Immediate</span>.Async.drainQueues [<span class="built_in">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="built_in">at</span> processImmediate [<span class="built_in">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>找到关键的部分：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Arguments to path<span class="selector-class">.join</span> must be strings</span><br><span class="line">    at Object<span class="selector-class">.posix</span><span class="selector-class">.join</span> (path<span class="selector-class">.js</span>:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync<span class="selector-class">.js</span>:<span class="number">110</span>:<span class="number">26</span>)</span><br></pre></td></tr></table></figure>
<p>查看源代码中的 sync.js，发现其中的 sync() 方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(file <span class="keyword">in</span> files) &#123;</span><br><span class="line">       <span class="keyword">var</span> fname = path.<span class="keyword">join</span>(local_dir, dir, files[i]); <span class="comment">// 这部分出错</span></span><br><span class="line">       <span class="keyword">var</span> stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == <span class="literal">true</span>) &#123;</span><br><span class="line">           sync(path.<span class="keyword">join</span>(dir, files[i]));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="keyword">var</span> name = path.<span class="keyword">join</span>(dirPrefix, fname.replace(local_dir, <span class="string">''</span>)).replace(/\\/g, <span class="string">'/'</span>).replace(/^\<span class="comment">//g, '');</span></span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面注释部分似乎是传递的参数类型出错了。</p>
<p>查看了官方最新的代码，发现确实不一样。于是将上面的内容替换成下面：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">files.forEach(function(<span class="keyword">file</span>)  &#123;</span><br><span class="line">       var fname = path.<span class="keyword">join</span>(local_dir + <span class="string">''</span>, dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>);</span><br><span class="line">       var stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == <span class="keyword">true</span>) &#123;</span><br><span class="line">           sync(path.<span class="keyword">join</span>(dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           var name = path.<span class="keyword">join</span>(dirPrefix, fname.replace(local_dir, <span class="string">''</span>)).replace(<span class="regexp">/\\/g</span>, <span class="string">'/'</span>).replace(<span class="regexp">/^\//g</span>, <span class="string">''</span>);</span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>问题解决了。</p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 七牛 </tag>
            
            <tag> 同步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[保持兼容性]]></title>
      <url>http://linfuyan.com/material-design-training/maintaining-compatibility/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>某些 material design 特性如 material 主题以及自定义活动转场效果等只在 Android 5.0 ( API 21) 上可用。尽管如此，你依然可以设计的应用程序来使用这些特性，使之运行在支持 material design 的设备上时，能够兼容的在其他较早的 Android 发布版上运行。</p>
<a id="more"></a>
<h2 id="定义可替代的风格"><a href="#定义可替代的风格" class="headerlink" title="定义可替代的风格"></a>定义可替代的风格</h2><p>你可以配置应用程序在支持 material design 的设备上使用 material 主题，在运行较早期版本的 Android 设备上恢复为旧的主题：</p>
<ol>
<li>在 <code>res/values/styles.xml</code> 中定义一个主题继承自旧的主题，如 Holo。</li>
<li>在 <code>res/values-v21/styles.xml</code> 中定义相同名称的主题继承自 material 主题。</li>
<li>在清单文件中设置这个主题为应用程序的主题。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果你的应用程序使用 material 主题，但没有按照这种方式提供一个替代的主题，你的应用程序在早于 Android 5.0 版本上无法运行。</p>
</blockquote>
<h2 id="提供替代的布局"><a href="#提供替代的布局" class="headerlink" title="提供替代的布局"></a>提供替代的布局</h2><p>如果你所涉及的布局是按照 material design 指南，并且没有使用任何在 Android 5.0 (API 21) 上引入的新 XML 属性，那么在之前的 Android 版本也可以正常工作。否则，你需要提供一个可替换的布局。你可以提供可替代的布局来在早先的 Android 版本上自定义应用程序外观。</p>
<p>在 <code>res/layout-v21</code> 里为 Android 5.0 (API 21) 创建布局文件，在 <code>res/layout</code> 里为早先的 Android 版本创建替代的布局文件。例如： <code>res/layout/my_activity.xml</code> 是 <code>res/layout-v21/my_activity.xml</code> 的替代布局。</p>
<p>为了避免重复代码，在 <code>res/values</code> 中定义风格，为新的 API 修改 <code>res/values-v21</code> 中的风格。使用风格继承，在 <code>res/values/</code> 定义基础风格，并在 <code>res/values-v21</code> 中继承它。</p>
<h2 id="使用-Support-Library"><a href="#使用-Support-Library" class="headerlink" title="使用 Support Library"></a>使用 Support Library</h2><p><a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="noopener">Support v7 兼容库</a> r21 及以上包含下面的 material design 特性：</p>
<ul>
<li>当你应用其中一个 <code>Theme.AppCompat</code> 主题时，某些系统组件具有 <a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="noopener">Material design 风格</a>。</li>
<li><code>Theme.AppCompat</code> 主题中的 <a href="https://developer.android.com/training/material/theme.html#ColorPalette" target="_blank" rel="noopener">色彩调色板主题属性</a>。</li>
<li>使用 RecyclerView 控件来显示数据集。</li>
<li>使用 CardView 控件来创建卡片。</li>
<li>使用 Palette 类来从图片中抽取主色彩。</li>
</ul>
<h3 id="系统控件"><a href="#系统控件" class="headerlink" title="系统控件"></a>系统控件</h3><p><code>Theme.AppCompat</code> 主题为以下控件提供了 material design 风格：</p>
<ul>
<li>EditText</li>
<li>Spinner</li>
<li>CheckBox</li>
<li>RadioButton</li>
<li>SwitchCompat</li>
<li>CheckedTextView</li>
</ul>
<h3 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h3><p>通过 Android Support V7 兼容库来获取 material design 风格和自定义调色板，需要应用一个 <code>Theme.AppCompat</code> 主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- extend one of the Theme.AppCompat themes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.MyTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- customize the color palette --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/material_blue_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/material_blue_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/material_green_A200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表和卡片"><a href="#列表和卡片" class="headerlink" title="列表和卡片"></a>列表和卡片</h3><p>通过 Android Supprot V7 兼容库，RecyclerView 和 CardView 控件在早先的 Android 版本上是可用的，但具有如下局限：</p>
<ul>
<li>CardView 上的阴影需要使用额外的内边距来编程实现。</li>
<li>具有圆角的 CardView 无法裁剪其子视图。</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在早于 Android 5.0 (API 21) 版本上使用这些特性需要在项目中通过 Gradle 依赖引入 Android Support V7 兼容库。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查系统版本"><a href="#检查系统版本" class="headerlink" title="检查系统版本"></a>检查系统版本</h3><p>以下特性在 Android 5.0 (API 21) 以上可用：</p>
<ul>
<li>活动转场效果</li>
<li>触摸反馈</li>
<li>显示动画</li>
<li>基于路径的动画</li>
<li>矢量图片</li>
<li>图片着色</li>
</ul>
<p>为了在早先 Android 版本上保持兼容性，需要中调用包含这些特性的 API 前检查系统版本。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否运行在 Android 5.0 以上版本</span></span><br><span class="line"><span class="keyword">if</span> (Build<span class="selector-class">.VERSION</span><span class="selector-class">.SDK_INT</span> &gt;= Build<span class="selector-class">.VERSION_CODES</span><span class="selector-class">.LOLLIPOP</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里调用 material design API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 实现不包含 material design 的特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在清单文件中使用 <code>android:minSdkVersion</code> 和 <code>android:targetSdkVersion</code> 属性来指定 Android 应用程序支持哪些版本。在 Android 5.0 上使用 material design 特性，需要设置 <code>android:targetSdkVersion</code> 属性为 <code>21</code>。更多信息，可以查看<a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html" target="_blank" rel="noopener"><uses-sdk> API 指南</uses-sdk></a>。</p>
</blockquote>
<p>原文：<a href="https://developer.android.com/training/material/compatibility.html" target="_blank" rel="noopener">Maintaining Compatibility</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 兼容 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[定义自定义动画]]></title>
      <url>http://linfuyan.com/material-design-training/defining-custom-animations/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 中的动画能够让应用程序给予用户对于动作的反馈，提供用户交互的视觉持续性。 Material 主题为按钮和活动转场效果提供默认的动画， Android 5.0 (API 21) 以上版本可以定制这些动画，并创建新的：</p>
<ul>
<li>触摸反馈</li>
<li>圆形波纹</li>
<li>活动转场效果</li>
<li>曲线移动</li>
<li>视图状态改变</li>
</ul>
<a id="more"></a>
<h2 id="自定义触摸反馈"><a href="#自定义触摸反馈" class="headerlink" title="自定义触摸反馈"></a>自定义触摸反馈</h2><p>Material design 中的触摸反馈可以为用户与 UI 元素的交互提供持续的视觉确认。按钮上的默认的触摸反馈动画使用新的 RippleDrawable 类，该类在不同的状态切换中使用波纹效果。</p>
<p>大部分情况下，你需要在视图的 XML 中指定视图背景来应用这个功能：</p>
<ul>
<li><code>?android:attr/selectableItemBackground</code> : 实现有边界的波纹。</li>
<li><code>?android:attr/selectableItemBackgroundBorderless</code> : 在视图之上的波纹。它将被绘制在最近的背景不为空的父视图内。</li>
</ul>
<blockquote>
<p><strong>注意</strong>： <code>selectableItemBackgroundBorderless</code> 是在 API 21 中引入的新属性。</p>
</blockquote>
<p>你也可以使用 <code>ripple</code> 元素在 XML 资源中定义 RippleDrawable 。</p>
<p>可以为 RippleDrawable 对象设置颜色。要改变默认的触摸反馈的颜色，使用主题中的 <code>android:colorControlHighlight</code> 属性。</p>
<p>更多信息，可以查看类 RippleDrawable 的 API 参考。</p>
<h2 id="使用显示效果"><a href="#使用显示效果" class="headerlink" title="使用显示效果"></a>使用显示效果</h2><p>当显示或者隐藏一组 UI 元素时，显示动画能提供用户视觉连续性。 ViewAnimationUtils.createCircularReveal() 方法来使用裁剪为圆形动画来显示或隐藏视图。</p>
<p>要实现一个之前不可见的视图使用这种效果：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前不可见的视图</span></span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的最终半径</span></span><br><span class="line"><span class="keyword">int</span> finalRadius = Math.<span class="built_in">max</span>(myView.getWidth(), myView.getHeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为视图创建动画发生器(起始半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使视图可见并启动动画</span></span><br><span class="line">myView.setVisibility(View.VISIBLE);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<p>要隐藏之前可见的视图使用这种效果：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前可见的视图</span></span><br><span class="line"><span class="keyword">final</span> View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的厨师半径</span></span><br><span class="line"><span class="keyword">int</span> initialRadius = myView.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动画(最终半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当动画结束时是视图不可见</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<h2 id="自定义活动转场效果"><a href="#自定义活动转场效果" class="headerlink" title="自定义活动转场效果"></a>自定义活动转场效果</h2><p>在 Material design 特性的应用程序中，活动转场效果提供公共元素在移动和转换上不同状态下的视觉连接。你可以指定自定义的进场/退场效果及活动间的共享元素转场。</p>
<ul>
<li>进场效果决定活动中的视图如何进入场景。例如，在 <em>explode</em> 进场效果中，视图从外部飞入到屏幕的中心。</li>
<li>退场效果决定活动中的驶入如何退出场景。例如，在 <em>explode</em> 退场效果中，视图从中心退出场景。</li>
<li>共享元素转场效果决定活动之间共享视图在两个活动间的转场。例如，在两个活动中同一个图片在不同的位置且尺寸不同， <em>changeImageTransform</em> 共享元素转场在活动之间平滑的平移和缩放这些图片。</li>
</ul>
<p>Android 5.0 (API 21) 支持下面这些进场和退场效果：</p>
<ul>
<li>explode - 从场景中间移入或移出视图。</li>
<li>slide - 从场景的一边移入或移出视图。</li>
<li>fade - 通过修改透明度在场景中添加或者移除视图。</li>
</ul>
<p>所有继承自 Visibility 类的转场支持进场/退场效果。更多信息，查看 API 参考的 Transition 类。</p>
<p>Android 5.0 (API 21) 同时支持共享元素的转场效果：</p>
<ul>
<li>changeBounds - 动画改变目标视图的布局边界。</li>
<li>changeClipBounds - 动画改变目标视图的裁剪边界。</li>
<li>changeTransform - 动画改变目标视图的缩放和旋转。</li>
<li>changeImageTransform - 动画改变图片的尺寸和缩放。</li>
</ul>
<p>如果应用程序中开启了活动转场效果，进入或退出活动时默认的 cross-fading 转场效果将被激活。</p>
<p><img src="http://img.uprogrammer.cn/static/images/SceneTransition.png" alt="带有共享元素的转场效果"></p>
<h3 id="指定自定义转场效果"><a href="#指定自定义转场效果" class="headerlink" title="指定自定义转场效果"></a>指定自定义转场效果</h3><p>首先，定义一个风格继承自 material 主题，并设置 <code>android:windowContentTransitions</code> 属性来开启窗口内容转场。你也可以在风格定义中指定进场，退场和共享元素转场效果。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"BaseAppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"> <span class="comment">&lt;!-- 开启窗口内容转场 --&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml"> <span class="comment">&lt;!-- 指定进场/退场效果 --&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml"> <span class="comment">&lt;!-- 指定共享元素转场 --&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span></span></span><br><span class="line"><span class="css">   @<span class="keyword">transition</span>/<span class="keyword">change_image_transform</span>&lt;/<span class="keyword">item</span>&gt;</span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span></span></span><br><span class="line"><span class="css">   @<span class="keyword">transition</span>/<span class="keyword">change_image_transform</span>&lt;/<span class="keyword">item</span>&gt;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中 <code>change_image_transform</code> 转场效果定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/transition/change_image_transform.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- (see also Shared Transitions below) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">changeImageTransform</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>change_image_transform</code> 元素与 ChangeImageTransform 类相对应。更多信息，可以查看 API 参考 <a href="">Transition</a>。</p>
<p>在代码中，可以通过调用 Window.requestFeature() 方法来开启窗口内容转场。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> inside your activity (<span class="keyword">if</span> you did not enable transitions <span class="keyword">in</span> your theme)</span><br><span class="line">getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> set an <span class="keyword">exit</span> transition</span><br><span class="line">getWindow().setExitTransition(new Explode());</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过调用下面的方法，并传递 Transtion 对象来确定转场效果：</p>
<ul>
<li>Window.setEnterTransition()</li>
<li>Window.setExitTransition()</li>
<li>Window.setSharedElementEnterTransition()</li>
<li>Window.setSharedElementExitTransition()</li>
</ul>
<p>setExitTransition() 和 setSharedElementExitTransition() 定义了调用该方法的活动的退场效果。setEnterTransition() 和 setSharedElementEnterTransition() 则定义调用该方法的活动的进场效果。</p>
<p>要获取转场的完整效果，你取药开启调用与被调用活动的窗口内容转场功能。否则，调用活动可以开始退场效果，但是你最后只能看到一个窗口转场(缩放或者淡入)。</p>
<p>在被调用的活动中使用 Window.setAllowEnterTransitionOverlap() 方法来尽快启动一个进场效果，这能让你拥有很炫酷的进场效果。</p>
<h3 id="使用转场效果启动活动"><a href="#使用转场效果启动活动" class="headerlink" title="使用转场效果启动活动"></a>使用转场效果启动活动</h3><p>如果你开启转场效果并为活动设置了退场效果，当你启动另一个活动时，转场效果将被激活，如下所示：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="name">intent</span>,</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation(<span class="name">this</span>).toBundle())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果你为第二个活动设置了进场效果，当活动开始时转场效果将被激活。要在启动另一个活动时禁用转场效果，提供一个为 <code>null</code> 的可选 bundle。</p>
<h3 id="启动带有共享元素的活动"><a href="#启动带有共享元素的活动" class="headerlink" title="启动带有共享元素的活动"></a>启动带有共享元素的活动</h3><p>创建带有共享元素的两个活动的屏幕转场需要：</p>
<ol>
<li>在主题中开启窗口内容转场。</li>
<li>在风格中指定共享元素转场。</li>
<li>将转场效果定义为 XML 资源。</li>
<li>在布局中的共享元素通过 <code>android:transitionName</code> 属性来分配一样的名字。</li>
<li>使用 ActivityOptions.makeSceneTransitionAnimation() 方法。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取接收点击事件的元素</span></span><br><span class="line"><span class="keyword">final</span> View imgContainerView = findViewById(R.id.img_container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活动中进行转场的公共元素</span></span><br><span class="line"><span class="keyword">final</span> View androidRobotView = findViewById(R.id.image_small);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点击监听</span></span><br><span class="line">imgContainerView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, Activity2.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// 创建转场动画，两个活动布局中的图片使用android:transitionName="robot"进行定义</span></span><br><span class="line">        ActivityOptions <span class="keyword">options</span> = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(<span class="keyword">this</span>, androidRobotView, <span class="string">"robot"</span>);</span><br><span class="line">        <span class="comment">// 启动新的活动</span></span><br><span class="line">        startActivity(intent, <span class="keyword">options</span>.toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过在两个活动中使用 View.setTransitionName() 方法来指定公共元素名称来共享动态视图。</p>
<p>当你结束第二个活动，想要反转转场动画时，调用 Activity.finishAfterTransition() 代替 Activity.finish() 。</p>
<h3 id="启动带多个共享元素的活动"><a href="#启动带多个共享元素的活动" class="headerlink" title="启动带多个共享元素的活动"></a>启动带多个共享元素的活动</h3><p>创建带有多个共享元素的活动转场，在布局中使用 <code>android:transitionName</code> 属性来定义共享元素，或者在活动代码中用 View.setTransitionName() 方法。然后创建 ActivityOptions 对象：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ActivityOptions options</span> = ActivityOptions.makeSceneTransitionAnimation(this,</span><br><span class="line">        Pair.create(view1, <span class="string">"agreedName1"</span>),</span><br><span class="line">        Pair.create(view2, <span class="string">"agreedName2"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="使用曲线移动"><a href="#使用曲线移动" class="headerlink" title="使用曲线移动"></a>使用曲线移动</h2><p>Material design 中的动画依赖于时间插值曲线并运动收空间所限。<br>Animations in material design rely on curves for time interpolation and spatial movement patterns. With Android 5.0 (API level 21) and above, you can define custom timing curves and curved motion patterns for animations.</p>
<p>PathInterpolator 类是基于贝塞尔曲线和一个 Path 对象的新的插值器。这个插值器指定在 1x1 方形上的运动曲线，拥有 (0,0) 和 (1,1) 两个锚点，并且使用构造器参数为指定的控制点。也可以在 XML 资源中定义路径插值器：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;pathInterpolator xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:<span class="attribute">controlX1</span>=<span class="string">"0.4"</span></span><br><span class="line">    android:<span class="attribute">controlY1</span>=<span class="string">"0"</span></span><br><span class="line">    android:<span class="attribute">controlX2</span>=<span class="string">"1"</span></span><br><span class="line">    android:<span class="attribute">controlY2</span>=<span class="string">"1"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>在 material design 规范中系统为 3 种基本曲线提供了 XML 资源。</p>
<ul>
<li><code>@interpolator/fast_out_linear_in.xml</code></li>
<li><code>@interpolator/fast_out_slow_in.xml</code></li>
<li><code>@interpolator/linear_out_slow_in.xml</code></li>
</ul>
<p>可以传递一个 PathInterpolator 对象到 Animator.setInterpolator() 方法。</p>
<p>ObjectAnimator 类有新的构造器来支持一次性使用2个或多个属性，与路径一起来推动坐标。例如，下面的动画会之气使用一个 Path 对象来推动视图的 X 和 Y 属性：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator mAnimator<span class="comment">;</span></span><br><span class="line">mAnimator = ObjectAnimator.ofFloat(<span class="keyword">view</span>, <span class="keyword">View</span>.<span class="keyword">X</span>, <span class="keyword">View</span>.Y, path)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">mAnimator.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画视图状态改变"><a href="#动画视图状态改变" class="headerlink" title="动画视图状态改变"></a>动画视图状态改变</h2><p>StateListAnimator 类定义视图状态改变时运行的动画。下面的实例展示如何在 XML 资源中定义一个 StateListAnimator 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- animate the translationZ property of a view when pressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"@android:integer/config_shortAnimTime"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- you could have other objectAnimator elements</span></span><br><span class="line"><span class="comment">             here for "x" and "y", or other properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_pressed</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:state_focused</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:propertyName</span>=<span class="string">"translationZ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要为视图关联自定义视图状态动画，需要在 XML 资源文件中使用 <code>selector</code> 元素来定义动画绘制器，并将它分配到视图的 <code>android:stateListAnimator</code> 属性。通过代码来分配一个状态列表动画绘制器到视图，则使用 AnimationInflater.loadStateListAnimator() 方法，分配动画绘制器到视图使用 View.setStateListAnimator() 方法。</p>
<p>当你的主题继承自 material 主题，按钮默认由 Z 动画。要禁用按钮的行为，需要设置 <code>android:stateListAnimatro</code> 属性为 <code>@null</code>。</p>
<p>AnimatedStateListDrawable 类可以创建图片用来显示关联视图的状态变化的动画。某些 Android 5.0 上的系统组件默认使用这些动画。下面的实例展示如何使用 XML 资源定义一个 AnimatedStateListDrawable 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-selector</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 为每种状态提供不同的图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/pressed"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableP"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/focused"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableF"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:state_focused</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@id/default"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:drawable</span>=<span class="string">"@drawable/drawableD"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 指定转场效果 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">android:fromId</span>=<span class="string">"@+id/default"</span> <span class="attr">android:toId</span>=<span class="string">"@+id/pressed"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">animation-list</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt1"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:duration</span>=<span class="string">"15"</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/dt2"</span>/&gt;</span></span><br><span class="line">          ...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画矢量图片"><a href="#动画矢量图片" class="headerlink" title="动画矢量图片"></a>动画矢量图片</h2><p>矢量图片在缩放过程中不会丢失清晰度。 AnimatedVectorDrawable 类定义了矢量图片的属性。</p>
<p>通常可以在三个 XML 文件中定义动画矢量图片：</p>
<ul>
<li>在 <code>res/drawable/</code> 中的使用 <code>&lt;vector&gt;</code> 元素定义矢量图片。</li>
<li>在 <code>res/drawable/</code> 中使用 <code>&lt;animated-vector&gt;</code> 元素来定义动画矢量图片。</li>
<li>在 <code>res/anim/</code> 中使用 <code>&lt;objectAnimator&gt;</code> 元素定义一个或多个对象的动画绘制器。</li>
</ul>
<p>动画矢量图片可以推动 <code>&lt;group&gt;</code> 和 <code>&lt;path&gt;</code> 元素的属性。 <code>&lt;group&gt;</code> 元素定义路径或者子组的集合， <code>&lt;path&gt;</code> 元素定义需要绘制的路径。</p>
<p>当你定义一个你需要动画的矢量图片时，使用 <code>android:name</code> 属性来为组和路径分配唯一的名称，这样就可以从动画器的定义中应用他们。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- res/drawable/vectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:height</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:width</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportHeight</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportWidth</span>=<span class="string">"600"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">"300.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:rotation</span>=<span class="string">"45.0"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fillColor</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:pathData</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在矢量图片中，动画矢量图片定义通过名称与组和路径相关联：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/animvectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:drawable</span>=<span class="string">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:name</span>=<span class="string">"rotationGroup"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:animation</span>=<span class="string">"@anim/rotation"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:name</span>=<span class="string">"v"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:animation</span>=<span class="string">"@anim/path_morph"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动画定义为 ObjectAnimator 或者 AnimatorSet 对象。这个实例中的第一个动画绘制器将目标组旋转 360 度：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/rotation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:duration</span>=<span class="string">"6000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:propertyName</span>=<span class="string">"rotation"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueFrom</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueTo</span>=<span class="string">"360"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第二个动画绘制器改变矢量图片的路径从一种形状到另一种。两条路径需要匹配改变：他们需要相同数量的命名，并且每个命令要有相同数量的参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/path_morph.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:duration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:valueFrom</span>=<span class="string">"M300,70 l 0,-70 70,70 0,0   -70,70z"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:valueTo</span>=<span class="string">"M300,70 l 0,-70 70,0  0,140 -70,0 z"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:valueType</span>=<span class="string">"pathType"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 AnimatedVectorDrawable 的 API 参考文档。</p>
<p>原文：<a href="https://developer.android.com/training/material/animations.html" target="_blank" rel="noopener">Defining Custom Animations</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 动画 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用图片]]></title>
      <url>http://linfuyan.com/material-design-training/working-with-drawables/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>图片所具有的下面能力可以帮助你在应用程序中实现 material design。</p>
<ul>
<li>图片着色。</li>
<li>抽取主色彩。</li>
<li>矢量图片。</li>
</ul>
<p>这节课程教你如何在应用程序中使用这些特性。</p>
<a id="more"></a>
<h2 id="对图片资源进行着色"><a href="#对图片资源进行着色" class="headerlink" title="对图片资源进行着色"></a>对图片资源进行着色</h2><p>在 Android 5.0 ( API 21) 及以上，你可以定义透明度对位图和 9 patch 图片进行着色。你可以使用颜色资源或者对应颜色资源的主题属性(如 <code>?android:attr/colorPrimary</code> )对他们进行着色。通常，你只需要一次创建这些资源并对他们自动着色来适应你的主题。</p>
<p>通过 setTint() 方法可以对 BitmapDrawable， NinePatchDrawable 或 VectorDrawable 对象应用着色。也可以在布局中使用 <code>android:tint</code> 和 <code>android:tintMode</code> 属性来设置着色的颜色和模式。</p>
<h2 id="从图片中抽取主色彩"><a href="#从图片中抽取主色彩" class="headerlink" title="从图片中抽取主色彩"></a>从图片中抽取主色彩</h2><p>在 Android Support 库 r21 及以上版本中包含有 Palette 类，可以从一张图片中抽取主色彩。这个类可以抽取下面的突出色彩：</p>
<ul>
<li></li>
<li></li>
</ul>
<p>要抽取这些色彩，当你在加载图片时在后台线程里面传递 Bitmap 对象到 Palette.generate() 静态方法中。如果你没有使用线程，那边调用 Palette.generateAsync() 方法并提供一个监听器。</p>
<p>在 Palette 类中，使用获取方法来从图片获取主要色彩，如 <code>Palette.getVibrantColor</code> 。</p>
<p>在项目中使用 Palette 类时，需要添加下面的 Gradle 依赖到应用程序模块：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:palette-v7:21.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 API 参考中的 Palette 类。</p>
<h2 id="创建矢量图片"><a href="#创建矢量图片" class="headerlink" title="创建矢量图片"></a>创建矢量图片</h2><p>在 Android 5.0 (API 21) 及以上，你可以定义矢量图片，这些图片在缩放过程中不会丢失清晰度。对应于每种屏幕密度需要一个位图文件，所有的屏幕密度仅需要一个矢量文件。要创建矢量图片，你需要在 XML 文件中的 <code>&lt;vector&gt;</code> 元素中定义形状细节。</p>
<p>下面的实例定义了一个心形的矢量图片：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- res/drawable/heart.xml --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- intrinsic size of the drawable --&gt;</span></span></span><br><span class="line"><span class="xml">  android:height="256dp"</span></span><br><span class="line"><span class="xml">  android:width="256dp"</span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- size of the virtual canvas --&gt;</span></span></span><br><span class="line"><span class="xml">  android:viewportWidth="32"</span></span><br><span class="line"><span class="xml">  android:viewportHeight="32"&gt;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- draw a path --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">android:fillColor</span>=<span class="string">"#8fff"</span></span></span></span><br><span class="line"><span class="xml">    android:pathData="M20.5,9.5</span></span><br><span class="line"><span class="xml">                      c-1.955,0,-3.83,1.268,-4.5,3</span></span><br><span class="line"><span class="xml">                      c-0.67,-1.732,-2.547,-3,-4.5,-3</span></span><br><span class="line"><span class="xml">                      C8.957,9.5,7,11.432,7,14</span></span><br><span class="line"><span class="xml">                      c0,3.53,3.793,6.257,9,11.5</span></span><br><span class="line"><span class="xml">                      c5.207,-5.242,9,-7.97,9,-11.5</span></span><br><span class="line"><span class="xml">                      C25,11.432,23.043,9.5,20.5,9.5z" /&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>矢量图片在 Android 中表现为 VectorDrawable 对象。关于 <code>pathData</code> 语法的更多信息，可以查看 <a href="http://www.w3.org/TR/SVG11/paths.html#PathData" target="_blank" rel="noopener">SVG 路径</a>。矢量图片中动画属性相关的更多信息，可以查看<a href="">动画矢量图片</a>。</p>
<p>原文：<a href="https://developer.android.com/training/material/drawables.html" target="_blank" rel="noopener">Working with Drawables</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 图片 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[定义阴影与裁剪视图]]></title>
      <url>http://linfuyan.com/material-design-training/defining-shadows-and-clipping-views/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 为 UI 元素引入了海拔的概念。海拔能够帮助用户理解每个元素的相对重要程度，并关注正在运行的任务。</p>
<p>视图的海拔有 Z 属性来表示，决定它的阴影的视觉展示：拥有更高 Z 值的视图打造更大，更软的阴影。拥有更高 Z 值的视图会挡住低 Z 值的视图，视图的 Z 值多少并不影响视图的尺寸。</p>
<p>阴影由被抬起视图的父视图来绘制，并默认由父视图进行视图裁剪。</p>
<p>在某些动作中，当控件临时上升到其他普通视图之上时。海拔对于创建动画非常有用。</p>
<p>Material design 中海拔相关的更多信息，可以查看 <a href="http://www.google.com/design/spec/what-is-material/objects-in-3d-space.html" target="_blank" rel="noopener">3D 空间中的物体</a>。</p>
<a id="more"></a>
<h2 id="为视图设置海拔"><a href="#为视图设置海拔" class="headerlink" title="为视图设置海拔"></a>为视图设置海拔</h2><p>视图的 Z 值有两个组件：</p>
<ul>
<li>海拔：静态组件。</li>
<li>变换：用于动画的动态组件。</li>
</ul>
<blockquote>
<p>Z = elevation + translationZ</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/shadows-depth.png" alt="不同视图海拔的阴影"></p>
<p>在布局定义中设置视图的海拔，使用 <code>android:elevation</code> 属性。在活动的代码中设置视图的海拔，使用 View.setElevation() 方法。</p>
<p>设置视图的变换使用 View.setTranslationZ() 方法。</p>
<p>新的 ViewPropertyAnimator.z() 和 ViewPropertyAnimator.translationZ() 方法使得视图海拔的动画变得简单。更多信息可以查看开发者指南中的 ViewPropertyAnimator 和 Property Animation。</p>
<p>你可以使用 StateListAnimator 来以声明的方式指定这些动画。当在状态的变化中出发动画时，这将非常有用，例如当用户按下按钮时。更多信息，可以查看 <a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="noopener">动画视图状态改变</a>。</p>
<p>测量 Z 值的单位是 dp。</p>
<h2 id="自定义视图阴影和轮廓"><a href="#自定义视图阴影和轮廓" class="headerlink" title="自定义视图阴影和轮廓"></a>自定义视图阴影和轮廓</h2><p>视图背景图片的边沿决定了它的阴影的默认形状。轮廓代表了图形对象的外围形状并定义了触摸反馈的波纹区域。</p>
<p>假设下面的视图，定义了背景图片：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="attribute">id</span>=<span class="string">"@+id/myview"</span></span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    android:<span class="attribute">elevation</span>=<span class="string">"2dp"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@drawable/myrect"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>背景图片定义为具有圆角的矩形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myrect.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#42000000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"5dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>视图打造了具有圆角的阴影，背景图片定义了视图的轮廓。</p>
<p>提供自定义的轮廓来覆盖视图阴影的默认形状。</p>
<p>在代码中为视图定义自定义的轮廓：</p>
<ol>
<li>继承 ViewOutlineProvider 类。</li>
<li>覆盖 getOutline() 方法。</li>
<li>通过 View.setOutlineProvider() 方法为视图设置新的轮廓提供者。</li>
</ol>
<p>使用 Outline 类中的方法可以来创建椭圆形或者带有圆角的矩形轮廓。视图默认的轮廓提供者从视图的背景中获取轮廓。要阻止视图生成阴影，只要将它的轮廓提供者设置为 <code>null</code> 就可以了。</p>
<h2 id="裁剪视图"><a href="#裁剪视图" class="headerlink" title="裁剪视图"></a>裁剪视图</h2><p>裁剪视图让改变视图的形状变得简单。你可以通过裁剪视图让其与其他设计元素之间保持一致，也可以改变视图的形状来反应用户输入。通过 View.setClipToOutline() 方法或者 <code>android:clipToOutline</code> 属性来对视图的轮廓区域进行裁剪。只有矩形，圆形和圆角矩形轮廓支持裁剪，能否裁剪是由 Outline.canClip() 方法决定的。</p>
<p>要裁剪视图中图片的形状，需要将图片设置为视图的背景，并调用 View.setClipToOutline() 方法。</p>
<p>裁剪视图是一个代价昂贵的操作，因此不要对用于裁剪视图的形状做动画。要达到这样的效果，可以使用<br> <a href="https://developer.android.com/training/material/animations.html#Reveal" target="_blank" rel="noopener">Reveal Effect</a> 动画。</p>
<p> 原文：<a href="https://developer.android.com/training/material/shadows-clipping.html" target="_blank" rel="noopener">Defining Shadows and Clipping Views</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 阴影 </tag>
            
            <tag> 视图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建列表和卡片]]></title>
      <url>http://linfuyan.com/material-design-training/creating-lists-and-cards/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>在应用程序中要创建具备 material design 风格的复杂列表和卡片，可以使用 RecyclerView 和 CardView 组件。</p>
<a id="more"></a>
<h2 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h2><p>RecyclerView 组件是一个更加高级，更加灵活的 ListView 版本。这个组件是这样一个容器，可以用来显示大量的数据集，并且通过维护有限数量的视图来非常高效的滚动。当你拥有大量的数据集，且其中的元素基于用户操作或者网络数据而在运行时改变时，使用 RecyclerView。</p>
<p>RecyclerView 通过提供以下两点来简化显示并处理大数据集：</p>
<ul>
<li>布局管理器来定位数据项</li>
<li>为公共数据项的操作定义默认动画，如删除或者新增数据项</li>
</ul>
<p>你可以灵活地为 RecyclerView 组件定义自定义的布局管理器和动画。</p>
<p><img src="http://img.uprogrammer.cn/static/images/RecyclerView.png" alt="RecyclerView 组件"></p>
<p>使用 RecyclerView 组件时，需要制定一个适配器和布局管理器。继承 <code>RecyclerView.Adapter</code> 类来创建一个适配器。具体的实现则依赖于特定的数据集和视图的类型。更多信息，可以查看下面的实例。</p>
<p><strong>布局管理器</strong>在 RecyclerView 中定位项的视图，并决定当项的视图对用户不可见后何时被复用。要复用(或者回收)一个视图，布局管理器会要求适配从数据集中用一个不同的元素来替换视图的内容。用这种方式来复用视图可以避免由于不必要的视图创建和执行昂贵的 <code>findViewById()</code> 操作，从而提升性能。</p>
<p>RecyclerView 内置了下面的布局管理器：</p>
<ul>
<li>LinearLayoutManager：在垂直或者水平滚动列表中显示项。</li>
<li>GridLayoutManager：通过网格显示项。</li>
<li>StaggeredGridLayout：在错落的网格中显示项。</li>
</ul>
<p>继承 RecyclerView.LayoutManager 类来创建自定义的布局管理器。</p>
<p><img src="http://img.uprogrammer.cn/static/images/list_mail.png" alt="Lists with RecyclerView"></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>在 RecyclerView 中添加和移除项的动画是默认支持的。要自定义这些动画，继承 RecyclerView.ItemAnimator 类并使用 RecyclerView.setItemAnimator() 方法。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的代码实例展示如何添加 RecyclerView 到布局：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A RecyclerView with some commonly used attributes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:id</span>=<span class="string">"@+id/my_recycler_view"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:scrollbars</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦添加一个 RecyclerView 组件到布局中，获得一个对象的句柄，并连接到布局管理器，然后关联一个需要显示的数据的适配器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span> mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">Adapter</span> mAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">LayoutManager</span> mLayoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.my_activity);</span><br><span class="line">        mRecyclerView = (<span class="type">RecyclerView</span>) findViewById(<span class="type">R</span>.id.my_recycler_view);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果你已知 RecyclerView 的内容改变不会改变布局尺寸，使用这个设置可以提升效率。</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线性布局管理器</span></span><br><span class="line">        mLayoutManager = <span class="keyword">new</span> <span class="type">LinearLayoutManager</span>(<span class="keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 制定适配器</span></span><br><span class="line">        mAdapter = <span class="keyword">new</span> <span class="type">MyAdapter</span>(myDataset);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适配器提供对数据集中数据项的访问，为数据项创建视图，并且当原始数据项不再可见时使用新的数据项来替换这些视图的内容。下面的代码实例展示一个有字符串数组组成且使用 TextView 控件显示的简单数据集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mDataset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个数据项的视图提供一个引用。复杂的数据项可能需要多余一个视图，并且在一个 view holder中为每个数据项的所有视图进行访问。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个实例中，每个数据项是仅仅是一个字符串</span></span><br><span class="line">        <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">            mTextView = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供一个合适的构造方法(这取决于数据集类型)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(String[] myDataset)</span> </span>&#123;</span><br><span class="line">        mDataset = myDataset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的视图(由布局管理器调用)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyAdapter.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建视图</span></span><br><span class="line">        View v = LayoutInflater.from(parent.getContext())</span><br><span class="line">                               .inflate(R.layout.my_text_view, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置视图的尺寸，外边距，内边距和布局参数</span></span><br><span class="line">        ...</span><br><span class="line">        ViewHolder vh = <span class="keyword">new</span> ViewHolder(v);</span><br><span class="line">        <span class="keyword">return</span> vh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换视图的内容(由布局管理器调用)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// - 从数据集中获取当前位置的元素</span></span><br><span class="line">        <span class="comment">// - 用该元素替换视图的内容</span></span><br><span class="line">        holder.mTextView.setText(mDataset[position]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据集的大小(由布局管理器调用)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDataset.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建卡片"><a href="#创建卡片" class="headerlink" title="创建卡片"></a>创建卡片</h2><p>CardView 集成自 FrameLayout 类，能够使显示在卡片中的信息在多个平台上拥有一致的外观。 CardView 控件可以拥有阴影和圆角。</p>
<p>使用 <code>card_view:cardElevation</code> 属性来创建带圆角的卡片。 CardView 在 Android 5.0 ( API 21) 及以上版本使用真正的海拔和动态阴影，在早先的版本中则使用可编程的阴影实现。更多信息，查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="noopener">保持兼容性</a>。</p>
<p>使用下面的属性来自定义 CardView 组件的外观：</p>
<ul>
<li>在布局中使用 <code>card_view:cardCornerRadius</code> 属性来设置圆角半径。</li>
<li>在代码中使用 <code>CardView.setRadius</code> 方法来设置圆角半径。</li>
<li>使用 <code>card_view:cardBackgroundColor</code> 属性来设置卡片的背景色。</li>
</ul>
<p>下面的代码实例展示如何在布局中包含 CardView 控件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:card_view</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- A CardView that contains a TextView --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:card_view</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/card_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">card_view:cardCornerRadius</span>=<span class="string">"4dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/info_text"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，查看 CardView 的 API 引用。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>RecyclerView 和 CardView 控件是 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="noopener">Supprot V7 兼容包</a>中的一部分。要在项目中使用这些组件，需要添加下面的 Gradle 依赖到应用模块中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> CardView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Material 主题]]></title>
      <url>http://linfuyan.com/material-design-training/using-the-material-theme/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>新的 material 主题提供：</p>
<ul>
<li>可以设置调色板的系统组件。</li>
<li>系统组件的触摸反馈动画。</li>
<li>活动转场效果动画。</li>
</ul>
<a id="more"></a>
<p>使用调色板，你可以根据自己的品牌标识来自定义 material 主题的外观。可以通过主题属性来为状态栏和 action bar 着色，如下图所示。</p>
<p><img src="http://img.uprogrammer.cn/static/images/ThemeColors.png" alt="自定义 material 主题"></p>
<p>系统组件拥有新的设计以及触摸反馈动画。你可以自定义应用程序的调色板，触摸反馈动画以及活动转场效果。</p>
<p>Material 主题定义如下：</p>
<ul>
<li><code>@android:style/Theme.Material</code>: 深色版本</li>
<li><code>@android:style/Theme.Material.Light</code>: 浅色版本</li>
<li><code>@android:style/Theme.Material.Light.DarkActionBar</code></li>
</ul>
<p>可使用的 material 风格列表，可以查看 R.style 的 API 引用。</p>
<p><img src="http://img.uprogrammer.cn/static/images/MaterialDark.png" alt="图1 深色 material 主题"></p>
<p><img src="http://img.uprogrammer.cn/static/images/MaterialLight.png" alt="图2 浅色 material 主题"></p>
<blockquote>
<p><strong>注意：</strong> Material 主题仅仅在 Android 5.0 (API 21) 及以上系统版本可用。 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="noopener">Support V7 兼容包</a> 为一些组件提供了具备 material 设计风格的主题，以及自定义调色板的支持。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="noopener">保持兼容性</a>。</p>
</blockquote>
<h2 id="自定义调色板"><a href="#自定义调色板" class="headerlink" title="自定义调色板"></a>自定义调色板</h2><p>为了自定义主题的基本颜色来适应自己的品牌，需要继承 material 主题，并使用主题属性来定义自己的自定义颜色。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- inherit from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Main theme colors --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--   your app branding color for the app bar --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimary"</span>&gt;</span>@color/primary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--   darker variant for the status bar and contextual app bars --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;</span>@color/primary_dark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--   theme UI controls like checkboxes and text fields --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:colorAccent"</span>&gt;</span>@color/accent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义状态栏"><a href="#自定义状态栏" class="headerlink" title="自定义状态栏"></a>自定义状态栏</h2><p>Material 主题可以很方便的自定义状态栏，因此你可以指定一个颜色来适应自己的品牌并提供足够的对比来显示白色的状态栏图标。继承 material 主题，并且使用 <code>android:statusBarColr</code> 属性来为状态来设置自定义颜色。默认情况下， <code>android:statusBarColor</code> 继承 <code>android:colorPrimaryDark</code> 的值。</p>
<p>你也可以自己在状态栏上进行绘制。例如，你想要在一张照片上显示透明的状态栏，并且使用微薄的深色渐变来确保白色的状态栏图标可见。要实现这个功能，将 <code>android.statusBarColor</code> 属性设置为 <code>@android:color/transparent</code> 并且根据要求设置窗口标识。可以使用 Window.setStatusBarColor() 方法来设置动画或者淡出。</p>
<blockquote>
<p><strong>注意</strong>：状态栏大部分情况下应该有区别于主要工具栏的明显轮廓，除非你需要在工具栏后显示丰富的意象或者媒体内容，并且所使用的渐变需要保证图标依然可见。</p>
</blockquote>
<p>当你自定义导航栏和状态栏时，你可以使两者都是透明的或者仅仅修改状态栏。其他情况下导航栏需要保持黑色。</p>
<h2 id="主题个性视图"><a href="#主题个性视图" class="headerlink" title="主题个性视图"></a>主题个性视图</h2><p>定义在 XML 布局中的元素可以指定 <code>android:theme</code> 属性，用来引用一个主题资源。这个属性为元素和其子元素修改主题，当要替换界面的某个部分的主题调色板时，这是很有用的。</p>
<p>原文：<a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="noopener">Using the Material Theme</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 主题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[准备开始]]></title>
      <url>http://linfuyan.com/material-design-training/get-started/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>创建具有 material design 特性的应用程序，步骤如下：</p>
<ol>
<li>审查 <a href="">material design 规范</a>。</li>
<li>应用 material <strong>主题</strong>到应用程序。</li>
<li>根据 material design 指南创建<strong>布局</strong>。</li>
<li>确定视图的<strong>海拔</strong>来打造阴影。</li>
<li>为列表和卡片使用系统<strong>组件</strong>。</li>
<li>在应用程序中自定义<strong>动画</strong>。</li>
</ol>
<a id="more"></a>
<h3 id="维持向后兼容"><a href="#维持向后兼容" class="headerlink" title="维持向后兼容"></a>维持向后兼容</h3><p>你可以为应用程序添加许多 material design 特性，同时对低于 Android 5.0 的版本保持兼容。更多信息，可以查看 <a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="noopener">保持兼容性</a>。</p>
<h3 id="升级应用程序使之具备-material-design"><a href="#升级应用程序使之具备-material-design" class="headerlink" title="升级应用程序使之具备 material design"></a>升级应用程序使之具备 material design</h3><p>要升级已经存在的应用程序来包含 material design，根据 material design 指南来升级布局。同时确保包含深度，触摸反馈和动画。</p>
<h3 id="创建具备-material-design-的新应用程序"><a href="#创建具备-material-design-的新应用程序" class="headerlink" title="创建具备 material design 的新应用程序"></a>创建具备 material design 的新应用程序</h3><p>如果要创建一个具备 material design 特性的应用程序，<a href="http://www.google.com/design/spec" target="_blank" rel="noopener">material design 指南</a> 提供了一个紧密结合的设计框架。按照这些指南，使用 Android 框架中的新特性来设计和开发应用程序。</p>
<h2 id="应用-material-主题"><a href="#应用-material-主题" class="headerlink" title="应用 material 主题"></a>应用 material 主题</h2><p>要应用 material 主要到应用程序中，需要指定一种风格继承自 <code>android:Theme.Material</code> :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/values/styles.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- your theme inherits from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- theme customizations --&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Material 主题提供了升级过的系统组件来为触摸反馈和活动的转场效果设置调色和默认动画。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="noopener">使用 Material 主题</a>。</p>
<h2 id="设计布局"><a href="#设计布局" class="headerlink" title="设计布局"></a>设计布局</h2><p>除了应用和自定义 material 主题之外，布局需要与 material design 指南保持一致。在设计布局时，需要注意下面几点：</p>
<ul>
<li>基线表格</li>
<li>注解行</li>
<li>空白</li>
<li>触摸目标尺寸</li>
<li>布局结构</li>
</ul>
<h2 id="指定视图的海拔"><a href="#指定视图的海拔" class="headerlink" title="指定视图的海拔"></a>指定视图的海拔</h2><p>视图可以打造阴影，视图的海拔值决定它的阴影尺寸以及它的绘制顺序。在布局中使用 <code>android:elevation</code> 属性来设置视图的海拔。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="attribute">id</span>=<span class="string">"@+id/my_textview"</span></span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">text</span>=<span class="string">"@string/next"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@color/white"</span></span><br><span class="line">    android:<span class="attribute">elevation</span>=<span class="string">"5dp"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>新的 <code>translationZ</code> 属性可以用来创建动画来反映视图海拔的临时变化。当<a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="noopener">响应触摸事件</a>时，海拔的改变会非常有用。</p>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="noopener">定义阴影及裁剪视图</a>。</p>
<h2 id="创建列表和卡片"><a href="#创建列表和卡片" class="headerlink" title="创建列表和卡片"></a>创建列表和卡片</h2><p>RecyclerView 是一个更加具有可插拔性的 ListView 版本，支持不同的布局类型，提供性能改进。 CardView 可以为不同的应用程序中在卡片内显示的信息提供一致的外观。下面的实例代码展示如何在布局中包含 CardView 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="selector-class">.support</span><span class="selector-class">.v7</span><span class="selector-class">.widget</span><span class="selector-class">.CardView</span></span><br><span class="line">    android:id=<span class="string">"@+id/card_view"</span></span><br><span class="line">    android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"200dp"</span></span><br><span class="line">    card_view:cardCornerRadius=<span class="string">"3dp"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/android<span class="selector-class">.support</span><span class="selector-class">.v7</span><span class="selector-class">.widget</span><span class="selector-class">.CardView</span>&gt;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="noopener">创建列表和卡片</a>。</p>
<h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><p>Android 5.0 (API 21) 包含用来在应用程序中创建自定义动画的新的 API 。例如，你可以在一个活动中启用活动的转场效果并定义一个退出的转场效果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// enable transitions</span></span><br><span class="line">        getWindow().requestFeature(<span class="type">Window</span>.<span class="type">FEATURE_CONTENT_TRANSITIONS</span>);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_my);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onSomeButtonClicked(<span class="type">View</span> view) &#123;</span><br><span class="line">        getWindow().setExitTransition(<span class="keyword">new</span> <span class="type">Explode</span>());</span><br><span class="line">        <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="keyword">this</span>, <span class="type">MyOtherActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">        startActivity(intent,</span><br><span class="line">                      <span class="type">ActivityOptions</span></span><br><span class="line">                          .makeSceneTransitionAnimation(<span class="keyword">this</span>).toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你从这个活动启动另外一个活动时，退场效果将会被激活。</p>
<p>可以查看<a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="noopener">定义自定义动画</a>来学些更多新的动画 API 。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Material Design 概览]]></title>
      <url>http://linfuyan.com/material-design-training/training-index/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 是一种为视觉，动作和交互而设计的规范，易于理解，跨平台、跨设备。要在 Android 应用程序中使用 material design，需要参照 [material design 规范] 中描述的指南，并使用 Android 5.0 ( API 21) 上的新组件和功能。</p>
<a id="more"></a>
<p>这个课程展示如何通过下面的元素来创建具备 material design 的应用程序。</p>
<ul>
<li>Material 主题</li>
<li>列表及卡片组件</li>
<li>自定义阴影和视图裁剪</li>
<li>矢量图片</li>
<li>自定义动画</li>
</ul>
<p>这个课程同时讲授在你的应用中使用 material design 时如何对低于 Android 5.0 (API 21) 版本进行兼容。</p>
<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><h3 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a><a href="http://www.linfuyan.com/material-design-training/get-started/" target="_blank" rel="noopener">准备开始</a></h3><p>学习如何将应用程序升级到使用 material design。</p>
<h3 id="使用-Material-主题"><a href="#使用-Material-主题" class="headerlink" title="使用 Material 主题"></a><a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="noopener">使用 Material 主题</a></h3><p>学习如何应用 material design 样式到应用程序。</p>
<h3 id="创建列表和卡片"><a href="#创建列表和卡片" class="headerlink" title="创建列表和卡片"></a><a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="noopener">创建列表和卡片</a></h3><p>学习如何使用系统组件来创建具有统一观感的列表和卡片。</p>
<h3 id="定义阴影和裁剪视图"><a href="#定义阴影和裁剪视图" class="headerlink" title="定义阴影和裁剪视图"></a><a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="noopener">定义阴影和裁剪视图</a></h3><p>学习如何设置视图的海拔来创建自定义阴影及如何裁剪视图。</p>
<h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a><a href="http://www.linfuyan.com/material-design-training/working-with-drawables/" target="_blank" rel="noopener">使用图片</a></h3><p>学习如何创建矢量图片及如何给图片资源着色。</p>
<h3 id="定义自定义动画"><a href="#定义自定义动画" class="headerlink" title="定义自定义动画"></a><a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="noopener">定义自定义动画</a></h3><p>学习如何创建视图的自定义动画以及具有共享元素的活动转场效果。</p>
<h3 id="保持兼容性"><a href="#保持兼容性" class="headerlink" title="保持兼容性"></a><a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="noopener">保持兼容性</a></h3><p>学习如何对低于 Android 5.0 的系统维持兼容性。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
            <category> 官方 Material Design 培训 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 教程 </tag>
            
            <tag> Material Design </tag>
            
            <tag> 概览 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公司高速发展是对团队最好的管理]]></title>
      <url>http://linfuyan.com/fast-growth-is-best-management-for-team/</url>
      <content type="html"><![CDATA[<h2 id="因地制宜选择合适的管理风格"><a href="#因地制宜选择合适的管理风格" class="headerlink" title="因地制宜选择合适的管理风格"></a>因地制宜选择合适的管理风格</h2><p>管理者的风格粗略来讲可以分为两类，一类是管得比较细致的，他能够把目标定的很清晰，也有很强的决策能力和准确的方向性，能够把工作目标分解规划的非常细致，让手下的团队能按照整个计划往前推进，这是一种风格，相对来讲比较集权。</p>
<p>另一类是甩手掌柜的做法，只定一个大概的目标，并不管下面的团队到底怎么去执行完成，只看最后的结果。</p>
<p>就我来说的话，我算是两种管理风格都可以，比较切换自如。如果团队特别残缺，那我可能就管理得比较细致，从一开始就要把团队搭建起来、培养好，如果这个团队是自我学习能力很强，每个人战斗力都很好，又是在做一些创新性的东西，需要很自由的空间的话，那就可以给他放权。</p>
<p>两种管理风格没有优劣之分，作为一个技术管理者，还是要根据实际的情况，看不同的团队状况及整个公司业务发展所处的阶段，灵活地选择解决问题的方法，不要墨守成规。</p>
<h2 id="公司的高速发展是对团队最好的管理"><a href="#公司的高速发展是对团队最好的管理" class="headerlink" title="公司的高速发展是对团队最好的管理"></a>公司的高速发展是对团队最好的管理</h2><p>但对高速发展的互联网公司来说，公司本身的高速发展，就是对团队最好的管理，也是对员工最好的激励。比方说小米，从传统意义的管理上来说，小米内部的管理是很混乱的，结构扁平，面临很大的挑战和压力，但实际上，由于小米的快速发展和扩张，很多员工都像打了鸡血一样在那儿拼命干。在我看来这是非常关键的一点，如果公司特别有前途、有活力，让每个人都觉得特别有干劲的话，其实也不需要在管理上去做太多的事情。</p>
<p>如果一个公司本身在走下坡路，不管管理多么精细化、工作安排多么合理、对员工激励多么到位，在管理上做再多的工作，真正底下做事情的员工还是没有什么成就感的。</p>
<p>另外，从管理的角度来说，选对人很重，选的人不合适，哪怕你花再多的心思、再多的努力，做事情还是事倍功半的；但如果能选对人的话，其实不需要你做太多，他就能把事情做得很好。</p>
<p>所以，在我看来，这两点是管理中最重要的，一是公司本身业务在蒸蒸日上，一是选对人。</p>
<h2 id="问题通常会以缺人的方式爆发"><a href="#问题通常会以缺人的方式爆发" class="headerlink" title="问题通常会以缺人的方式爆发"></a>问题通常会以缺人的方式爆发</h2><p>很多公司的问题都是以缺人的方式爆发出来的，比方说管理不善、业务方向不清楚导致开发效率低、产品功能规划不合理导致更多研发能力投入等，很多问题最终反馈到公司缺研发上，这时如果用招人的方式去解决的话，通常会掩盖很多问题，但如果能把其他问题解决掉，你会发现你其实是并不需要这么多研发人员的。</p>
<p>特别对互联网公司来说，尤其是纯线上的，研发就是最后一个环节，所以前面所有的问题最终都会集中爆发在研发这个环节上，这是我特别想跟很多互联网公司的管理层说的，他们应该慢慢意识到这样的问题。</p>
<p>另外缺人也是因为，现在很多公司忽视了对员工的培养。很多公司觉得与其花一两年培养一个人，还不一定能留住他，还不如多花点钱直接去别的公司挖人。大家都这么想，都不培养人才，反而去挖人的话，就会导致挖人的成本更高，那人员再次流失的时候，自己的人才梯队又没有跟上，就会被迫用更高的成本去挖人，最终变成一个恶性循环。这个问题也是值得各互联网公司注意的。</p>
<h2 id="要建立学习型的组织"><a href="#要建立学习型的组织" class="headerlink" title="要建立学习型的组织"></a>要建立学习型的组织</h2><p>可能有互联网公司觉得，业务如此繁忙，研发人员已经是996地工作了，哪有时间去培训呢。但实际上，作为一个研发人员，每天能高效率工作的时间是有限的，3个小时已经非常饱满了，其他很多时间精力都是被分散在开会、沟通、协调等很多事物上。</p>
<p>所以，如果能把产品规划变得更有计划性，把研发资源用在刀刃上，真正让研发人员的工作规范化、合理化的话，其实研发人员一天工作8个小时够了，你就可以拿出2、3个小时来专门搞培训。</p>
<p>而且最重要的是，研发人员可以建立学习型的组织。我的做法是，把每个员工学习能力的提升列入他们的KPI里，每个人每个月都会给他们安排一项学习计划，学习他以前不熟悉的技术，每个月底的时候，他还需要专门为这项技术准备一个演讲，去培训其他人。如果他真的能把这个技术给大家讲明白的话，那他就是真的掌握了，同时也让其他人开始了解并学习这项技术。所以，一个学习型的组织，大家互相学习、互相培训，10个人的话就是10颗脑袋一起学习，就能同时了解10种技术。</p>
<p>如果能坚持下去，形成这样一种学习型的文化以后，你就会发现整个研发团队的技术能力的提升速度是非常惊人的，并且不会再占用你额外的时间。而且当你再招一个资历较浅的新员工时，他也在能在这种环境中快速提升，通常半年左右时间就能符合要求了。这样，在公司内部建立一个人才梯队，当你的老员工流失时，新员工很快就能顶上，就不再害怕老员工流失了。</p>
<p>当然，一开始的团队可能没有这样的意识，就需要你作为管理者强行去推动，把要求列入KPI，很认真地考核他，慢慢地，团队就会形成这样的氛围和文化，自然而然就能成长得很好。</p>
<h2 id="技术人要多分享与交流"><a href="#技术人要多分享与交流" class="headerlink" title="技术人要多分享与交流"></a>技术人要多分享与交流</h2><p>沟通能力不足是很多研发人员普遍都有的问题，他们在跟非研发的人沟通时会存在很大的障碍，会沉浸在自己的世界里，只说他自己想说的话题，而不去考虑对方的感受和接受能力，导致对方没法跟他沟通下去。</p>
<p>因此，我觉得对研发人员来说，不管是多做一些技术分享、技术交流，还是在网上多写一些文章，都能锻炼自己的表达能力，能有更多的机会走出去跟别人沟通，从而客观地审视自己身上的缺点，有目的地去改正或弥补。</p>
<p>另外，社区的影响力也与日俱增。原先的时候，大家的技术通常都比较专用，彼此之间缺少共同语言，导致不同公司不同领域的技术人员很难直接交流。但从开源浪潮起来之后，国内大概是2003年，大概是我开始做 JavaEye 网站的时候，这种情况就改变了，大家开始用同样的东西，比如说 Java 的 Spring 、 Hibernate 。同样的技术、同样的框架，交流就有共同话语了，这时，你把你擅长的技术领域分享出来，就能聚集更多的人，你的影响力就能覆盖更大的范围。</p>
<p>使用的技术越通用，交流的意义也就越大。而互联网开发这块，因为大家都在用通用的技术，所以交流的意义就特别大。</p>
<h2 id="创业从开荒进入短兵相接时代"><a href="#创业从开荒进入短兵相接时代" class="headerlink" title="创业从开荒进入短兵相接时代"></a>创业从开荒进入短兵相接时代</h2><p>我特别有感触的是，2010年以后，特别是2013年之后，创业这件事所需要的素质，跟我原来在2006年，也就是9年之前，完全不一样了，也是因为整个互联网行业所处的时代完全不一样了。</p>
<p>10年前，也就是05年、06年的时候，互联网还处在一个开垦阶段，还有很多荒地，你只要去开垦总会有收获，也不会跟别人形成特别激烈的竞争，也没有一个大家伙把整个天花板遮住。可以说是大航海时代，有大片的空白，大家都在发现新大陆，用户也是处在增量发展阶段，大家吸引的都是新用户，彼此之间不会形成特别激烈的碰撞。所以在那个时代，特别重要的是把产品做好，通过好的产品吸引用户，只要把产品做得非常有竞争力，就足够促使你成功了。这是我在10年前看到的状况。</p>
<p>但现在，特别是2010年之后，中国互联网早期的阶段已经走完了，PC时代的用户或流量渠道已经被瓜分完了。而到2013年下半年、2014年年初，移动互联网的流量也已经被瓜分完了，因为中国智能手机出货量增长率的顶峰是在2014年，到2015年就已经大幅度下滑了。</p>
<p>这就说明，到2014年，用户已经被抢光了，也意味着竞争所处的时代不一样了，你创业时抢的都是别人手里的用户，或者是从别的APP里抢用户的时间，所以竞争已经进入一个短兵相接的阶段了。</p>
<p>这时，一个特别明显的感觉是，你光把产品做好没有用了，需要创业团队的综合能力特别强，除了产品、研发的能力之外，融资能力已经成为创业团队的一项标配，还要具备很强的获取流量或者说市场能力，如果你做O2O的话，还得有很强的线下业务能力。</p>
<p>所以，现在创业，一个或两个创始人已经很难玩得转了，通常需要组建一个3-5人强大的创业团队，每个人都是各负其责，有负责战略的、业务的、产品的、研发的、市场的等等，一个团队配合起来才能把事情做好。这是我现在看到的一个比较大的不同之处。</p>
<blockquote>
<p>技术人的交流是很有必要的，特别是在现在这样一个激烈竞争的时代，技术人仅仅坐在家里、公司里面钻研自己的技术已经不行了，需要走出去学习、交流，去看整个时代、整个行业是怎样快速往前发展的，交流对技术人职业生涯发展起到的作用是越来越大了。</p>
<p>以上是丁香园技术副总裁范凯在 EGO 上的分享。</p>
<p>来源：<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTU2MTg3MQ==&amp;mid=210785109&amp;idx=1&amp;sn=b89a0a9d938d01d6eac5b6ff06db4f05&amp;scene=23&amp;srcid=09167OQEKlJvekBiN0bxH7vv#rd" target="_blank" rel="noopener">丁香园技术副总裁范凯：公司高速发展是对团队最好的管理</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 团队管理 </tag>
            
            <tag> 技术交流 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用 Git 命令使用教程]]></title>
      <url>http://linfuyan.com/git-cmd-user-guide/</url>
      <content type="html"><![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>
<a id="more"></a>
<p><img src="http://img.uprogrammer.cn/static/images/%e5%b8%b8%e7%94%a8Git%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8%e6%95%99%e7%a8%8b.png" alt="常用 Git 命令使用教程"></p>
<h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>1. 在安装完成 Git 后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱。</p>
<p>设置的主要命令是 <code>git config</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="selector-class">.name</span> <span class="string">"your name"</span>  	<span class="comment">// 设置全局用户名</span></span><br><span class="line">git config --global user<span class="selector-class">.email</span> <span class="string">"your email"</span>	<span class="comment">// 设置邮箱</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>--global</code> 指定为全局配置，不使用该参数，则为当前所在仓库配置。</p>
<p>2. 除了用户名、邮箱之外，还有很多的配置可以用来自定义 Git，如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> color.ui <span class="literal">true</span>		<span class="comment">// 让 Git 显示不同的颜色</span></span><br><span class="line">git config core.ignorecase <span class="literal">true</span>			<span class="comment">// 让 Git 对仓库中的文件大小写敏感</span></span><br></pre></td></tr></table></figure>
<p>3. 查看所有的已经做出的配置：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>-l</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/git-config.gif" alt="git config"></p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="创建-Git-版本库"><a href="#创建-Git-版本库" class="headerlink" title="创建 Git 版本库"></a>创建 Git 版本库</h3><p>在本地创建 Git 版本库，需要使用 <code>git init</code> 命令。</p>
<p>首先，你需要新建一个存放版本库的目录，然后进入到该目录所在路径，然后执行：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure>
<p>然后查看目录结构中，就可以看到包含有 <code>.git</code> 子目录，这就说明创建版本库成功了。</p>
<p><img src="http://img.uprogrammer.cn/static/images/git-init.gif" alt="git init"></p>
<h3 id="将文件添加到版本库"><a href="#将文件添加到版本库" class="headerlink" title="将文件添加到版本库"></a>将文件添加到版本库</h3><p>要将一个文件纳入到版本库管理，首先要将其添加到暂存区(这里不做深入介绍)，然后才能提交到仓库中。</p>
<p>1. 将文件添加到暂存区，使用的是 <code>git add</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> Readme.md		// 添加单个文件到暂存区</span></span><br><span class="line"><span class="bash">git add .				// 将当前目录下所有修改添加到暂存区，除按照规则忽略的之外</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边空文件夹是不会被添加到暂存区中的。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/git-add.gif" alt="git add"></p>
<p>2. 将暂存区中的文件，提交到仓库中。需要使用 <code>git commit</code>：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit		<span class="comment">// 如果暂存区有文件，则将其中的文件提交到仓库</span></span><br><span class="line">git commit -m 'your comments' 		<span class="comment">// 带评论提交，用于说明提交内容、变更、作用等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边直接用 <code>git commit</code> 提交，会先弹出添加评论的页面。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/git-commit.gif" alt="git commit"></p>
<h3 id="查看仓库的状态"><a href="#查看仓库的状态" class="headerlink" title="查看仓库的状态"></a>查看仓库的状态</h3><p>不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure>
<p>来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，我使用最多的一个命令。</p>
<h3 id="查看仓库中的具体修改"><a href="#查看仓库中的具体修改" class="headerlink" title="查看仓库中的具体修改"></a>查看仓库中的具体修改</h3><p>很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code> 来查看具体的修改内容。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff	<span class="comment">// 查看版本库中所有的改动</span></span><br><span class="line">git diff Readme<span class="selector-class">.md</span>		<span class="comment">// 查看具体文件的改动</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/git-diff.gif" alt="git diff"></p>
<h3 id="查看提交历史记录"><a href="#查看提交历史记录" class="headerlink" title="查看提交历史记录"></a>查看提交历史记录</h3><p>有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">	// 显示所有提交的历史记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline	// 单行显示提交历史记录的内容</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</p>
<p><img src="http://img.uprogrammer.cn/static/images/git-log.gif" alt="git log"></p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>有了 <code>git log</code> 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--hard</span> HEAD^		<span class="string">//</span> 回退到上一个提交版本</span><br><span class="line">git reset <span class="params">--hard</span> HEAD^^		<span class="string">//</span> 回退到上上一个提交版本</span><br><span class="line">git reset <span class="params">--hard</span> 'commit_id'	<span class="string">//</span> 会退到 commit_id 指定的提交版本</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/git-reset-1.gif" alt="git reset --hard"></p>
<h3 id="回到未来的某个提交"><a href="#回到未来的某个提交" class="headerlink" title="回到未来的某个提交"></a>回到未来的某个提交</h3><p>当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。</p>
<p>因此，想要回到未来的某个提交，先通过 <code>git reflog</code> 从历史命令中找到想要回到的提交版本的 ID，然后通过 <code>git reset --hard</code> 来切换。</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git </span><span class="string">reflog</span></span><br><span class="line"><span class="string">git </span><span class="string">reset </span><span class="built_in">--hard</span> <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/git-reflog.gif" alt="git reflog"></p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。</p>
<p>1. 丢弃工作区中文件的修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Readme<span class="selector-class">.md</span>	<span class="comment">// 如果 Readme.md 文件在工作区，则丢弃其修改</span></span><br><span class="line">git checkout -- .			<span class="comment">// 丢弃当前目录下所有工作区中文件的修改</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/git-checkout-1.gif" alt="git checkout --"></p>
<p>2. 丢弃已经进入暂存区的修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span> Readme.md 	// 将 Readme.md 恢复到 <span class="keyword">HEAD</span> 提交版本的状态</span><br></pre></td></tr></table></figure>
<p><img src="http://img.uprogrammer.cn/static/images/git-reset-head.gif" alt="git reset HEAD"></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Readme<span class="selector-class">.md</span> 	<span class="comment">// 删除已经被提交过的 Readme.md</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/git-rm.gif" alt="git rm"></p>
<p><strong><code>git rm</code> 与 先 rm 然后 <code>git add</code> 的区别</strong></p>
<p><img src="http://img.uprogrammer.cn/static/images/rm-and-git-add.gif" alt="rm and git add"></p>
<p>更详细的可以参考：<a href="http://yang3wei.github.io/blog/2013/02/03/git-rm-he-rm-de-qu-bie/" target="_blank" rel="noopener">“git rm” 和 “rm” 的区别</a></p>
<blockquote>
<p>注意：上图中的结果是在 git 1.9.1 版本上的操作。在 git 2.0 以上两者没有区别了。</p>
</blockquote>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是版本控制系统中很重要的一个概念，在 Git 中新建、合并等分支的操作非常轻量便捷，因此我们会很经常的用到。</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>查看分支使用 <code>git branch</code>：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch		<span class="comment">// 查看本地分支信息</span></span><br><span class="line">git branch -v 	<span class="comment">// 查看相对详细的本地分支信息</span></span><br><span class="line">git branch -av 	<span class="comment">// 查看包括远程仓库在内的分支信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 <code>git branch</code> 的输出内容中，有一个分支，前面带有 <code>*</code> 号，这标识我们当前所在的分支。</p>
</blockquote>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>当我们要修复一个 Bug，或者开发一个新特性，甚至是在初学的时候怕打乱原来的代码，都可以新建一个分支来避免对原来代码的影响。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">dev</span>	<span class="comment">// 新建一个名称为 dev 的分支</span></span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>当我们创建完分支以后，我们需要切换到新建的分支，否则，所有的修改，还是在原来的分支上。事实上，所有的改动，只能影响到当前所在的分支。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">dev</span>	<span class="comment">// 新建完 dev 分支以后，通过该命令切换到 dev 分支</span></span><br></pre></td></tr></table></figure>
<h3 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> dev		<span class="comment">// 新建 dev 分支，并切换到该分支上</span></span><br></pre></td></tr></table></figure>
<p>这个命令合并了前两个独立的命令，平常使用中一般这样使用。</p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>当我们修复完成一个 Bug，或者开发完成一个新特性，我们就会把相关的 Bug 或者 特性的上修改合并回原来的主分支上，这时候就需要 <code>git merge</code> 来做分支的合并。</p>
<p>首先需要切换回最终要合并到的分支，如 <code>master</code>：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="keyword">master</span>		<span class="title">// 切换回 master</span> 分支</span><br><span class="line">git merge dev			// 将 dev 分钟中的修改合并回 <span class="keyword">master</span> <span class="title">分支</span></span><br></pre></td></tr></table></figure>
<p>合并回主分支的时候，后面可能会面临到冲突的问题。冲突的解决暂不在这里说明。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当之前创建的分支，完成了它的使命，如 Bug 修复完，分支合并以后，这个分支就不在需要了，就可以删除它。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">dev</span>		<span class="comment">// 删除 dev 分支</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>上面的所有命令都是针对本地仓库的操作。当我们希望多个人来协作时，会将代码发布到一个统一的远程仓库，然后多个人在本地操作以后，在推送到远程仓库。其他人协作时，需要先同步远程仓库的内容，再推送自己的修改。</p>
<h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>如果你本地没有仓库，希望从已有的远程仓库上复制一份代码，那么你需要 <code>git clone</code>。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/git/git.git 	// 通过 https 协议，克隆 Github 上 git 仓库的源码</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">linfuyan</span>@github.com/git/git.git	// 通过 ssh 协议，克隆 Github 上 git 仓库的源码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git clone</code> 后面的仓库地址，可以支持多种协议，如 https， ssh 等。</p>
</blockquote>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>如果你已经有了一个本地仓库，如之前创建的 <code>git-guide</code>，然后你打算将它发布到远程，供其他人协作。那么使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> origin your_remote_git_repo		<span class="comment">// 为本地仓库添加远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="推送本地的内容到远程仓库"><a href="#推送本地的内容到远程仓库" class="headerlink" title="推送本地的内容到远程仓库"></a>推送本地的内容到远程仓库</h3><p>当本地仓库中，代码完成提交，就需要将代码等推送到远程仓库，这样其他协作人员可以从远程仓库同步内容。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin <span class="keyword">master</span> <span class="title">// 第一次推送时使用，可以简化后面的推送或者拉取命令使用</span></span><br><span class="line"><span class="title">git</span> push origin <span class="keyword">master</span>	<span class="title">// 将本地 master</span> 分支推送到 origin 远程分支</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code> 参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。</p>
</blockquote>
<h3 id="从远程仓库获取最新内容"><a href="#从远程仓库获取最新内容" class="headerlink" title="从远程仓库获取最新内容"></a>从远程仓库获取最新内容</h3><p>在多人协作过程中，当自己完成了本地仓库中的提交，想要向远程仓库推送前，需要先获取到远程仓库的最新内容。</p>
<p>可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin <span class="keyword">master</span>	<span class="title"></span></span><br><span class="line"><span class="title">git</span> pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure>
<p><code>git fetch</code> 和 <code>git pull</code> 之间的区别：</p>
<ol>
<li><code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li><code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
</ol>
<blockquote>
<p>注意：建议多使用 <code>git fetch</code>。</p>
</blockquote>
<h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">remote</span> <span class="selector-attr">[-v]</span>		<span class="comment">// 显示远程仓库信息</span></span><br></pre></td></tr></table></figure>
<h3 id="建立本地分支和远程分支的关联"><a href="#建立本地分支和远程分支的关联" class="headerlink" title="建立本地分支和远程分支的关联"></a>建立本地分支和远程分支的关联</h3><p>在本地仓库中的分支和远程仓库中的分支是对应的。一般情况下，远程仓库中的分支名称和本地仓库中的分支名称是一致的。</p>
<p>有的时候，我们会需要指定本地分支与远程分支的关联。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream <span class="string">'local_branch'</span> origin/remote_branch</span><br></pre></td></tr></table></figure>
<h3 id="修改本地仓库对应的远程仓库地址"><a href="#修改本地仓库对应的远程仓库地址" class="headerlink" title="修改本地仓库对应的远程仓库地址"></a>修改本地仓库对应的远程仓库地址</h3><p>当远程的仓库地址发生变化时，需要修改本地仓库对应的远程仓库的地址。主要应用在<a href="http://blog.csdn.net/hongshan50/article/details/23663043" target="_blank" rel="noopener">工程迁移</a>过程中。</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="string">origin </span><span class="string">url</span></span><br></pre></td></tr></table></figure>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>在项目开发过程中，当一个版本发布完成时，是需要对代码打上标签，便于后续检索。获取处于其他的原因，需要对某个提交打上特定的标签。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="selector-tag">a</span> <span class="string">'tagname'</span> -m <span class="string">'comment'</span> <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 参数指定标签名， <code>-m</code> 添加备注信息， ‘commit_id’ 指定打标签的提交。</p>
<h3 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span>		<span class="title">// 查看本地仓库中的所有标签</span></span><br></pre></td></tr></table></figure>
<h3 id="查看具体标签信息"><a href="#查看具体标签信息" class="headerlink" title="查看具体标签信息"></a>查看具体标签信息</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git show tagname</span></span><br></pre></td></tr></table></figure>
<h3 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h3><p>如果打的标签出错，或者不在需要某个标签，则可以删除它。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/tagname</span></span><br></pre></td></tr></table></figure>
<h3 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h3><p>打完标签以后，有需要推送到远程仓库。</p>
<p>1. 推送单个标签到远程仓库</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> tagname</span><br></pre></td></tr></table></figure>
<p>2. 一次性推送所有标签到远程仓库。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="临时保存修改"><a href="#临时保存修改" class="headerlink" title="临时保存修改"></a>临时保存修改</h3><p>在执行很多的 Git 操作的时候，是需要保持当前操作的仓库/分支处于 clean 状态，及没有未提交的修改。如 <code>git pull</code>， <code>git merge</code> 等等，如果有未提交的修改，这些将无法操作。</p>
<p>但是做这些事情的时候，你可能修改了比较多的代码，却又不想丢弃它。那么，你需要把这些修改临时保存起来，这就需要用到 <code>git stash</code>。</p>
<p>1. <strong>临时保存修改</strong>，这样仓库就可以回到 clean 状态。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  stash		<span class="comment">// 保存本地仓库中的临时修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以多次的 <code>git stash</code> 来保存不同的临时修改。</p>
</blockquote>
<p>2. <strong>查看临时保存</strong>。当你临时保存以后，后面还是要取回来的，那它们在哪里呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">list</span>	<span class="comment">// 显示所有临时修改</span></span><br></pre></td></tr></table></figure>
<p>3. 当我们处理完其他操作时，想要恢复临时保存的修改。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash apply		<span class="comment">// 恢复所有保存的临时修改</span></span><br><span class="line">git stash <span class="keyword">pop</span>		<span class="comment">// 恢复最近一次保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>4. 或者，我们后面觉得临时保存不想要了，那可以丢弃它。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">clear</span>		<span class="comment">// 丢弃所有保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>这些是我目前在项目中经常会用到的操作，这里整理下来，可以作为一个手册。对于 Git 的理解或者更多的解释，并不在这里体现。大家可以参考其他更多的资料。</p>
<p>更多阅读：</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的 Git 教程</a><br><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="noopener">Git Community Book 中文版</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4233881.html" target="_blank" rel="noopener">Git 对象模型</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4235448.html" target="_blank" rel="noopener">探索 .git 目录</a></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
            <tag> 命令 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 指南 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不懂技术的人不要对懂技术的人说这很容易实现]]></title>
      <url>http://linfuyan.com/im-sure-it-will-only-take-you-a-few-days-to-code/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/static/images/non-technical-people-cant-estimate-developmen.jpg" alt=""></p>
<p>“这个网站相当简单，所有你需要做的就是完成 X，Y，Z。你看起来应该是技术很好，所以，我相信，你不需要花费太多时间就能把它搭建起来。”</p>
<p>我时不时的就会收到这样的 Email 。写这些邮件的人几乎都是跟技术不沾边的人，或正在研究他们的第一个产品。起初，当听到人们这样的话，我总是十分的恼怒。他们在跟谁辩论软件开发所需要的时间？但后来我意识到，即使我自己对自己的项目预测要花去多少开发时间,我也是一筹莫展。如果连我自己都做不好，我何必对那些人恼怒呢？</p>
<a id="more"></a>
<p>真正让我郁闷的不是他们预估的错误。问题在于他们竟然认为自己可以做出正确的估计。作为开发人员，我们经常会发现，在软件开发的问题上，一个外行人会很自然的把复杂的事情估计的很简单。</p>
<p>这并不是为我们的愤怒找借口。但这引起了另外一个有趣的问题：为什么我们天生的预测复杂性的能力在遇到编程问题时会失灵？</p>
<p>为了回答这个问题，让我们来认识一下我们的大脑如何估计事情的。有些事情对于一些没有经验的人也很容易预估正确，但有些事情则不然。</p>
<p>我们来想想观看一个人弹吉他。即使你从来没有弹过吉他，在观看了一场弹奏《玛丽有只小羊羔( Mary had a Little Lamb )》的吉他表演后，你也能大概推测出这很简单，一个人不需要太高的技术就能演奏出来。同样，当观看了有人演奏 D 大调的《卡农( Pachabel’s Canon )》后，你也很容易推测出，这很复杂，需要很长时间的练习才能演奏的出来。</p>
<p>为什么我们能够很迅速准确的预估这两首曲子的复杂性呢？这是跟我们用来判断一个事情简单和还是复杂的方法有关的。我们的大脑有一些现成的模式来完成这些事情，首先一个就是根据速度。这种情况下，大脑会辨别每秒钟演奏的东西。根据每秒钟演奏了多少东西，我们很容易有一个直观的判断曲子的复杂度。因为用吉他演奏一首歌是一种物理过程，一种感官上的活动，我们的大脑很容易依此来推测速度，继而转换成复杂度。</p>
<p>我们还有另外一个天生的推测依据：体积。想想把一个帐篷和一栋公寓放在一起对比。即使一个人从来没有学过建筑学，他也能告诉你通常设计和建造一个帐篷会比设计和建造一栋公寓要简单。为什么？因为我们天生的会使用物理体积作为事物复杂性的一个指标。</p>
<p>当然。上面说的这两种逻辑分析并不是总是100%的有效。但大多数情况下，人们就是这样干，而且很成功。大多数情况中，我们在对物理过程评估时，我们的大脑会对物理事物进行有效的关联，不需要依赖之前的经验。</p>
<p>现在让我们来谈谈软件。当一个不懂技术的人试图对软件开发时间进行评估时，有两个很基本的直观指标在辅助他们：以体积为指标的复杂度和以速度为指标的复杂度。但他们没有意识到，软件跟他们想象的不一样。软件本质上不是有形物质。没有体积和速度。它的极小的组成部分可能会时不时的在电脑屏幕上闪现。正因为如此，当面对开发一个 web 应用时(或任何类型的软件)，我们的基本直观感觉失效了。</p>
<p>这第一点，速度，很显然根本不可能被外行人拿来对软件进行评估。于是很自然的，他们倾向于使用体积指标进行评估。要么是根据描述文档的页数，要么是根据软件的功能用例数或特征数。</p>
<p>有时候，这种评估手段确实有效！当面对一个静态网站，没有特别的设计要求，外行人很容易用这种方法估计出开发时间。但是，通常情况下，对于软件开发，体积并不能真实有效的反映复杂度。</p>
<p>不幸的是，对于软件的复杂度，唯一有效的推测方法是依据经验。而且还不是时时都好用。作为一个程序员，我知道，根据我之前开发过的相似的功能特征，我可以估计出现在的这些功能特征各自要多少开发时间。然后，我把总时间加起来，这就得到了完成整个项目需要的大致时间。然而，事实情况中，每个项目在开发过程中都遇到二、三个瓶颈。这些瓶颈会肆意的消耗程序员的大量时间，你在遇到它们之前根本不会有所预见。它们会拖住整个项目，致使工期延后数周甚至数月。</p>
<p>这些是没有经验的人在评估复杂度时不会理解的。他们不明白在其他事情上都很灵的方法，为什么放到软件开发上就不灵了。所以，下一次当你听到有人说”我想你几天时间就能把它开发出来”时，不管是谁说的，都不要懊恼。深呼吸一下，告诉他这篇文章的地址，自己该干什么还干什么。</p>
<p>译文来自：<a href="http://www.vaikan.com/im-sure-it-will-only-take-you-a-few-days-to-code/" target="_blank" rel="noopener">不懂技术的人不要对懂技术的人说这很容易实现</a><br>英文原文：<a href="http://danshipper.com/non-technical-people-cant-estimate-developmen" target="_blank" rel="noopener">I’m Sure It Will Only Take You A Few Days To Code</a></p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 开发 </tag>
            
            <tag> 周期 </tag>
            
            <tag> 评估 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 如何保持页面文件不被渲染]]></title>
      <url>http://linfuyan.com/keep-pages-at-your-hexo-blog/</url>
      <content type="html"><![CDATA[<p>假设要保持 keep.html 文件原样输出，不被渲染：</p>
<p>1. 将 keep.html 文件放在 <code>source</code> 目录下。</p>
<p>2. 打开 <code>_confi.yml</code> 配置文件，添加 <code>skip_render:</code>，并声明 keep.html 文件如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">skip_render</span>: <span class="meta">keep</span>.html</span><br></pre></td></tr></table></figure>
<p>3. 如果需要保持多个文件，可以按照如下声明：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: <span class="string">[file1, files, ...]</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> skip render </tag>
            
            <tag> 页面 </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 6.0 新功能及主要 API 变更]]></title>
      <url>http://linfuyan.com/android-m-changes/</url>
      <content type="html"><![CDATA[<p>伴随着新的特性和功能， Android 6.0 (API 级别 23)带来了一系列系统和 API 行为的变更。这篇文章中将介绍一些在应用程序中需要理解和注意的主要变更点。</p>
<blockquote>
<p>如果你之前已经发布过 Android 应用程序，要意识到这些变更对应用程序的影响。</p>
</blockquote>
<a id="more"></a>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>这个版本中引入了新的权限模型，现在用户可以在运行时直接管理应用程序的权限。这个模型基于用户对权限控制的更多可见性，同时为应用程序的开发者提供更流畅的应用安装和自动升级。用户可以为已安装的每个应用程序独立的授予或者取消权限。</p>
<p>在运行于目标版本 Android 6.0 (API 级别 23) 及以上的应用程序中，必须在运行时检查并请求权限。通过新的 <code>checkSelfPermission()</code> 方法来确定你的应用程序是否已经被授权。通过新的 <code>requestPermissions()</code> 方法来请求权限。即使你的应用程序运行的目标版本不是 Android 6.0 (API 级别 23)，你也应该在新的授权模型下来测试应用程序。</p>
<p>在应用程序中支持新的权限模型的更多详细信息，可以查看<a href="https://developer.android.com/training/permissions/index.html" target="_blank" rel="noopener">使用系统权限</a>。如何在应用程序中使用权限，相关提示可以查看<a href="https://developer.android.com/training/permissions/best-practices.html#testing" target="_blank" rel="noopener">权限最佳实践</a>。</p>
<h2 id="休眠与应用挂起-Doze-and-App-Standby"><a href="#休眠与应用挂起-Doze-and-App-Standby" class="headerlink" title="休眠与应用挂起( Doze and App Standby )"></a>休眠与应用挂起( Doze and App Standby )</h2><p>这个版本为空闲的设备和应用程序引入了电源节能优化。这个特性将影响所有应用程序，故确保自己的应用程序在这些新模式下进行测试。</p>
<ul>
<li><p><strong>休眠</strong>：如果用户将设备拔下，并将其静置，关闭屏幕，经过一段时间，设备将进入休眠模式。这时候，设备试图让系统保持在一个睡眠的状态。这种模式下，设备周期性的恢复平常的操作，以便应用程序同步，系统则可以处理一些延时的操作。</p>
</li>
<li><p><strong>应用挂起</strong>：应用挂起则允许系统当用户不再使用应用程序时，将其定义为空闲。当用户经过一段时间没有触摸应用程序时，系统可以做这个决定。设备被拔线时，系统禁用网络访问，停止应用程序的同步及操作，则被认为是空闲。</p>
</li>
</ul>
<p>学习更多关于电源节能的变更，查看<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对休眠与应用挂起的优化</a>。</p>
<h2 id="移除-Apache-HTTP-客户端"><a href="#移除-Apache-HTTP-客户端" class="headerlink" title="移除 Apache HTTP 客户端"></a>移除 Apache HTTP 客户端</h2><p>Android 6.0 发布版移除了对 Apache HTTP 客户端的支持。如果你的应用程序使用该客户端，并且目标运行版本为 Android 2.3 (API 级别9) 及以上，需要使用 <code>HttpURLConnection</code> 类来代替。这个 API 更加的高效，因为它通过对用户透明的压缩、响应缓存来减少网络开销，并最小化电量消耗。要继续使用 Apache HTTP 的 API，你需要在 <code>build.gradle</code> 文件中声明下面的编译期依赖：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">android</span> &#123;</span><br><span class="line">    <span class="attribute">useLibrary</span> <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BoringSSL"><a href="#BoringSSL" class="headerlink" title="BoringSSL"></a>BoringSSL</h2><p>Android 从 OpenSSL 转移到了 <a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">BoringSSL</a> 库。如果你在应用程序中使用 Android NDK，千万不要将加密库链接到除 NDK API 之外的任何库，如 <code>libcrypto.so</code> 和 <code>libssl.so</code>。这些库不是公开 API，有可能在没有收到通知的情况下在发布版和设备间发生变更或中断。这种情况你将把自己暴露在安全威胁下。你应该修改自己的本地代码来通过 JNI 调用 Java 加密 API 或者静态链接你选择的一个加密库。</p>
<h2 id="访问硬件标识符"><a href="#访问硬件标识符" class="headerlink" title="访问硬件标识符"></a>访问硬件标识符</h2><p>为了给用户更多的数据保护，从这个版本开始， Android 移除了通过 WiFi 和蓝牙 API 来在应用程序中可编程的访问本地硬件标示符。现在 <code>WifiInfo.getMacAddress()</code> 和 <code>BluetoothAdapter.getAddress()</code> 方法都将返回 <code>02:00:00:00:00:00</code> 常量。</p>
<p>要通过蓝牙和 WiFi 扫描来访问附近外部设备的硬件标示符，应用程序需要 <code>ACCESS_FINE_LOCATION</code> 和 <code>ACCESS_COARSE_LOCATION</code> 权限：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/net/wifi/WifiManager.html#getScanResults\(\" target="_blank" rel="noopener"><code>WifiManager.getScanResults()</code></a>)</li>
<li><a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#ACTION_FOUND" target="_blank" rel="noopener"><code>BluetoothDevice.ACTION_FOUND</code></a></li>
<li><a href="https://developer.android.com/reference/android/bluetooth/le/BluetoothLeScanner.html#startScan\(android.bluetooth.le.ScanCallback\" target="_blank" rel="noopener"><code>BluetoothLeScanner.startScan()</code></a>)</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在一个运行 Android 6.0 (API 级别 23) 的设备初始化后台的 WiFi 或蓝牙扫描时，操作对于外部设备是可见的，且被赋予一个随机的 MAC 地址。</p>
</blockquote>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>这个版本移除了 <code>Notification.setLatestEventInfo()</code> 方法。使用 Notification.Builder 类来代替构造方法。要重复的更新通知，要重用 Notification.Builder 实例。调用 build() 方法来获取更新过的 Notification 实例。</p>
<p><code>adb shell dumpsys nnotification</code> 命令不在答应通知文本。使用 <code>adb shell dumpsys notification --noredcat</code> 命令来在同志对象中打印文本。</p>
<h2 id="AudioManager-变更"><a href="#AudioManager-变更" class="headerlink" title="AudioManager 变更"></a>AudioManager 变更</h2><p>通过 AudioManager 类来直接设置音量或者使流静音已经不再支持。 setStreamSolo() 方法被弃用，你需要调用 requestAudioFocus() 来代替。类似的， setStreamMute() 方法被弃用，替换为 adjustStreamVolume() 方法并传递方向值 ADJUST_MUTE 或 ADJUST_UNMUTE。</p>
<h2 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h2><p>当用户在应用程序中选择文本时，你可以在<a href="http://www.google.com/design/spec/patterns/selection.html#selection-text-selection" target="_blank" rel="noopener">悬浮工具栏</a>中显示文本选择工作，如剪切、复制、粘贴。用户交互实现与<a href="https://developer.android.com/guide/topics/ui/menus.html#CABforViews" target="_blank" rel="noopener">为独立视图启动上下文动作模式</a>中描述的上下文动作栏类似。</p>
<p>为文本选择实现悬浮工具栏，需要在已存在的应用程序中做如下修改：</p>
<ol>
<li><p>在 View 或者 Activity 对象中，通过修改 <code>startActionMode(Callback)</code> 为 <code>startActionMode(Callback, ActionMode.TYPE_FLOATING)</code> 来改变 ActionMode。 </p>
</li>
<li><p>使已经存在的 <code>ActionMode.Callback</code> 的实现继承自 ActionMode.Callback2 。</p>
</li>
<li><p>重载 onGetContentRect() 方法来提供内容 Rect 对象(如文本选择矩形)在视图中的坐标。</p>
</li>
<li><p>如果矩形位置不在有效，并且这是需要刷新的唯一元素，则调用 invalidateContentRect() 方法。</p>
</li>
</ol>
<p><img src="http://img.uprogrammer.cn/static/images/text-selection.gif" alt="文本选择"></p>
<p>如果你在使用 Android 22.2 修订版的兼容包，悬浮工具栏不是向后兼容的，且使用默认的 ActionMode 对象。这导致悬浮工具栏无法显示。在 AppCompatActivity 中启用 ActionMode，首先调用 getDelegate() ，然后在返回的 AppCompatDelegate 对象中调用 setHandleNativeActionModesEnabled()，并设置输入参数为 <code>false</code>。这个调用为框架返回可控的 ActionMode 对象。在运行 Android 6.0 (API 级别 23) 的设备上，这允许框架支持 ActionBar 或悬浮工具栏模式。在 Android 5.1 (API 级别 22) 或更低版本，只有 ActionBar 是支持的。</p>
<h2 id="浏览器书签变更"><a href="#浏览器书签变更" class="headerlink" title="浏览器书签变更"></a>浏览器书签变更</h2><p>这个版本移除了对全局书签的支持。 <code>android.provider.Browser.getAllBookmark()</code> 和 <code>android.provider.Browser.saveBookmark()</code> 方法被移除。同样的， <code>READ_HISTORY_BOOKMARKS</code> 和 <code>WRITE_HISTORY_BOOKMARKS</code> 权限被移除。如果你的应用程序的目标运行版本为 Android 6.0 (API 级别 23) 或者更高，不要从全局提供者访问书签或者使用书签权限。现在，你的应用程序需要内部保存书签数据。</p>
<h2 id="Android-Keystore-变更"><a href="#Android-Keystore-变更" class="headerlink" title="Android Keystore 变更"></a>Android Keystore 变更</h2><p>在这个版本中， <a href="https://developer.android.com/training/articles/keystore.html" target="_blank" rel="noopener">Android Keystore 提供器</a> 不在支持 DSA。 ECDSA 则仍然被支持。</p>
<p>当安全锁屏被禁用或重置时，不要求加密的 key 将不再被删除。要求加密的 key 则会在这些事件中被删除。</p>
<h2 id="Wi-Fi-和-网络变更"><a href="#Wi-Fi-和-网络变更" class="headerlink" title="Wi-Fi 和 网络变更"></a>Wi-Fi 和 网络变更</h2><p>这个版本为 Wi-Fi 和 网络 API 引入了下面的行为变更：</p>
<ul>
<li>应用程序只有在创建了 WifiConfiguration 对象以后，才能更变这些对象的状态。当 WifiConfiguration 被用户或者其他应用程序创建时，你将不允许修改和删除这些 WifiConfiguration 对象。</li>
<li>在之前的版本中，如果应用程序使用 enableNetwork() ，并设置 <code>disableAllOthers=true</code> 来强制设备连接到指定的 Wi-Fi 网络，设备将和其他网络断开。这个版本中，这些设备将不再和其他网络断开。如果应用程序的 <code>targetSdkVersion</code> 是 20 或者更低，则会连接被选中的 Wi-Fi 网络。如果应用程序的 <code>targetSdkVersion</code> 是 21 或者更高，使用多网络 API (如 openConnection()， bindSocket() 及新的 bindProcessToNetwork() 方法)来确保它的网络通信是发给被选中的网络。</li>
</ul>
<h2 id="摄像头服务变更"><a href="#摄像头服务变更" class="headerlink" title="摄像头服务变更"></a>摄像头服务变更</h2><p>在这个版本中，在摄像头服务中访问共享资源的模式发生了变更，不再是以前的”先到先得”，而是具备高优先级的将优先处理。服务行为的变更包括：</p>
<ul>
<li><p>访问摄像头子系统的资源，包括打开和配置摄像设备，依赖于客户端应用进程的优先级。用户可见或者在前台活动的应用程序进程往往具备更高的优先级，使得摄像资源更易获得，也更加可靠。</p>
</li>
<li><p>当更高优先级的应用程序视图使用摄像头时，具有低权限的活动摄像头客户端应用程序可能被中断。在被弃用的 Camera API 中，错误会在被中断客户端的 onError() 中被调用。在 Camera2 API 中，错误结果则在 onDisconnected() 中被调用。</p>
</li>
<li><p>在具备适合摄像头硬件的设备上，不同的应用进程可以同时独立地打开和使用独立的摄像头设备。虽然如此，多进程使用时，同时访问摄像头会造成设备性能的急剧下降，这将被摄像头服务所检测到并不被允许。这个变更使得由于较低优先级而被中断的客户端，即使当没有其他应用直接访问时，也会试图访问一样的设备。</p>
</li>
<li><p>改变当前用户会导致之前用户账号的应用程序中活动那个的摄像头客户端被中断。对摄像头的访问是被当前设备用户所限制的。实际上，这意味着当用户切换到不同的账户下时，原来的”访客”账号所使用的摄像头子系统是不可能继续运行的。</p>
</li>
</ul>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>通过 newInstance() 方法 ART 运行时现在正确的实现了访问规则。这个变更修复了之前版本中 Dalvik 检查访问规则时的错误。如果你的应用程序使用 newInstance() 方法，且你想要覆盖访问检查，调用 setAccessible() 方便，并设置参数为 <code>true</code>。如果你的应用程序使用 <a href="https://developer.android.com/tools/support-library/features.html#v7-appcompat" target="_blank" rel="noopener">v7 兼容库</a> 和 <a href="https://developer.android.com/tools/support-library/features.html#v7-recyclerview" target="_blank" rel="noopener">v7 recyclerview 库</a>。你需要升级应用程序中的相关库到最新版本。否则，需要确保 XML 中所引用的自定义类已经被升级，其构造方法是可访问的。</p>
<p>这个版本升级了动态链接器的行为。动态连接器现在可以理解库的 <code>soname</code> 和 它的路径之间的区别，且实现了通过 <code>soname</code> 来搜索。在加载时，之前可用的应用程序可能会被提示具有不可用的 <code>DT_NEEDED</code> 条目(通常是在构建机器文件系统中的绝对路径)。</p>
<p><code>dlopen(3) RTLD_LOCAL</code> 标志现在被正确实现了。 <code>RTLD_LOCAL</code> 是默认的，因此调用 <code>dlopen(3)</code> 是不明确使用 <code>RTLD_LOCAL</code> 是有效的(除非应用之前有明确使用 <code>RTLD_GLOBAL</code> )。使用 <code>RTLD_LOCAL</code> ，标记在调用 <code>dlopen(3)</code> 加载库之前是不可用的(这与被 <code>DT_NEEDED</code> 条目引用恰恰相反)。</p>
<p>在之前版本的 Android，如果你的应用请求系统来加载包含文本重定位段的动态链接库，系统会显示警告，但允许继续加载库。从这个版本开始，如果你的目标运行 SDK 版本为 23 或以上，系统会拒绝这个库。为了辅助检测库是否被成功加载，应用程序需要为 <code>dlopen(3)</code> 失败添加日志，并在 <code>dlerror(3)</code> 返回值中包含问题的描述文本。学习更多关于如何处理文本重定位段，可以查看这个<a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide" target="_blank" rel="noopener">指南</a>。</p>
<h2 id="APK-验证"><a href="#APK-验证" class="headerlink" title="APK 验证"></a>APK 验证</h2><p>Android 平台现在执行更加严格的 APK 验证。如果一个文件在清单文件中被声明，但在 APK 中却没有，那么这个 APK 被认为是无效的。如果任意的内容被移除， APK 需要重新签名。</p>
<h2 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h2><p>通过 USB 端口的设备连接现在默认被设置为充电模式。想要通过 USB 连接来访问设备和它的内容，用户需要为这些交互提供明确的授权。如果你的应用程序支持用户通过 USB 端口与设备交互，需要确保这些交互被明确启用。</p>
<h2 id="Android-for-Work-变更"><a href="#Android-for-Work-变更" class="headerlink" title="Android for Work 变更"></a>Android for Work 变更</h2><p>这个版本包括下面的 Android for Work 行为变更：</p>
<ul>
<li><p><strong>个人上下文中的联系人</strong>。Google 拨号器通话记录现在可以在用户查看已通话记录时显示当前联系人。在 Google 拨号器中通过设置 <code>setCrossProfileCallerIdDisabled()</code> 为 <code>true</code> 来隐藏当前联系人。当设置 <code>setBluetoothContactSharingDisabled()</code> 为 <code>false</code> 时，当前联系人能通过蓝牙显示在设备联系人中。默认情况下，其设置为 <code>true</code>。</p>
</li>
<li><p><strong>移除 Wi-Fi 配置</strong>：由外部拥有者添加(如通过 addNetworkd() 方法)的 Wi-Fi 配置现在在当前 profile 被删除时也将被移除。</p>
</li>
<li><p><strong>紧闭 Wi-Fi 配置</strong>：如果 <code>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</code> 为非空时，任何由活动的设备拥有者创建的 Wi-Fi 配置将不能用户被修改和删除。用户可以创建和修改自己的 Wi-Fi 配置。活动的设备拥有者拥有编辑和移除任意 Wi-Fi 配置的特权，包括不是由他们创建的配置。</p>
</li>
<li><p><strong>通过 Google 账号下载使用策略控制器</strong>：当一个要求 WPC 应用程序来管理的 Google 账号被添加到管理上下文之外的设备中时，添加账号流程会提示用户安装合适的 WPC。这些行为也可以应用到通过在初始设备创建向导中 <strong>设置 &gt; 账号</strong> 添加的账号。</p>
</li>
<li><p><strong>制定 DevicePolicyManager API 行为变更</strong>：</p>
<ul>
<li>调用 <code>setCameraDisabled()</code> 方法来影响当前调用用户的摄像头。</li>
<li>此外， <code>setKeyguardDisabledFeatures()</code> 方法对 Profile 用户是可用的，与设备拥有者一样。</li>
<li>Profile 拥有者可以设置键盘守卫的约束：<ul>
<li>KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT 将影响到 profile 父用户的键盘守卫设置。</li>
<li>KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS 只会影响在 profile 中由应用程序生成的通知。</li>
</ul>
</li>
<li>createAndInitializeUser() 和 createUser() 方法已经被弃用。</li>
<li>当给定用户的应用程序在前台运行时， setScreenCaptureDisabled() 方法将阻塞辅助结构。</li>
<li>SHA-256 的默认值为 EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 。为保持兼容性， SHA-1 仍然被支持，但在将来会被移除。 EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM 则仅接受 SHA-256。</li>
<li>原来存在的设备初始化 API 在 Android 6.0 (API 级别 23) 中被移除了。</li>
<li>EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 被移除，因此 NFC bump provisioning 无法通过编程的方式解锁重置被保护的设备。</li>
<li>现在在被管理的设备中通过 NFC 可以使用 EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE 来传递数据给设备拥有者的应用程序。</li>
<li>Android M 上的 Android for Work API 是经过优化的，包括 Work 配置，辅助层及其他。新的 DevicePolicyManager 权限 API 不会影响 Android 之前版本的应用程序。</li>
<li>当用户通过 ACTION_PROVISION_MANAGED_PROFILE 或者 ACTION_PROVISION_MANAGED_DEVICE 意图，从创建流程中的同步部分返回时，系统将返回 RESULT_CANCELED 结果码。</li>
</ul>
</li>
<li><p><strong>其他 API 变更</strong>：</p>
<ul>
<li>数据用法： <code>android.app.usage.NetworkUsageStates</code> 类重命名为 NetworkStats。</li>
</ul>
</li>
<li><strong>全局设置变更</strong>：<ul>
<li>下面的设置不能继续通过 setGlobalSettings() 方法设置：<ul>
<li><code>BLUETOOTH_ON</code></li>
<li><code>DEVELOPMENT_SETTINGS_ENABLED</code></li>
<li><code>MODE_RINGER</code></li>
<li><code>NETWORK_PREFERENCE</code></li>
<li><code>WIFI_ON</code></li>
</ul>
</li>
<li>下面全局设置可以通过 setGlobalSettings() 方法设置：<ul>
<li>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原文：<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="noopener">Android 6.0 Changes</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Marshmallow </tag>
            
            <tag> 6 </tag>
            
            <tag> 更新 </tag>
            
            <tag> API </tag>
            
            <tag> 变更 </tag>
            
            <tag> 新功能 </tag>
            
            <tag> 特性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 配置 scheme 及 configuration]]></title>
      <url>http://linfuyan.com/iOS-scheme-and-configuration-setting/</url>
      <content type="html"><![CDATA[<h4 id="新建共享-scheme"><a href="#新建共享-scheme" class="headerlink" title="新建共享 scheme"></a>新建共享 scheme</h4><p>Xcode -&gt; Manage schemes…</p>
<p><img src="http://img.uprogrammer.cn/static/images/scheme-manage-1.png" alt=""></p>
<p>点击左下角的 + 来添加新的 scheme。添加成功以后，勾选新的 scheme 后面的 Shared 将scheme 设置为共享，这样在版本控制系统中可以包含这个项目设置。参与协作的人获得这份代码，就可以共享这个 scheme。</p>
<h4 id="新建-Configuration"><a href="#新建-Configuration" class="headerlink" title="新建 Configuration"></a>新建 Configuration</h4><p><img src="http://img.uprogrammer.cn/static/images/scheme-manage-2.png" alt=""></p>
<ol>
<li>打开项目 Project 的 info 标签。</li>
<li>点击2中的 <code>+</code>，选择 <code>Duplicate &quot;Release&quot; Configuraton</code>。</li>
<li>修改新建的 Configuration 的名称，本文中为 InHouse。</li>
</ol>
<h4 id="设置-Configuration-对应的签名及-Profile"><a href="#设置-Configuration-对应的签名及-Profile" class="headerlink" title="设置 Configuration 对应的签名及 Profile"></a>设置 Configuration 对应的签名及 Profile</h4><p><img src="http://img.uprogrammer.cn/static/images/scheme-manage-3.png" alt=""></p>
<ol>
<li>打开项目中 Target 的 Build Setting 标签。</li>
<li>在 Code Signing 栏目中设置对应的签名和 Profile，其中2和3是 Jenkins 打包中需要用到的，设置为正式签名及企业账号导出的 Profile。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> scheme </tag>
            
            <tag> configuration </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[响应式编程2分钟简介]]></title>
      <url>http://linfuyan.com/2-minute-introduction-to-rx/</url>
      <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877" target="_blank" rel="noopener">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>
<a id="more"></a>
<p>现在来考虑包含鼠标位置信息的点击事件。如果你把这些事件画在一条时间轴上，则看起来像这样：</p>
<p><img src="http://img.uprogrammer.cn/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<p>这是个事件流( <em>stream</em> of <em>event</em> )，或者叫” <strong>Observable</strong> “。</p>
<p>这些点击事件来自于鼠标，因此整个事件流是不可变的，这种情况下，当它被定义，你无法从中添加或者删除。</p>
<p>但是，如果我们仅仅对 <code>x &lt; 250</code> 的点击事件感兴趣呢？我们能否通过过滤来建立一个新的流，就像我们之前对数组所做的那样呢？</p>
<p><img src="http://img.uprogrammer.cn/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<blockquote>
<p>filter((event) -&gt; event.x &lt; 250)</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/static/images/2_minute_rx_2.png" alt="click event after filter"></p>
<p>既然这样，不可变数组与 <strong>Obserable</strong> 有什么不同呢？不仅仅这样，你可以应用 map、 filter、 reduce 等操作到这两者上。对于 <strong>Obserable</strong> ，你还可以应用这些操作： <code>merge</code>,  <code>delay</code>,  <code>concat</code>,  <code>buffer</code>,  <code>distinct</code>,  <code>first</code>,  <code>last</code>,  <code>zip</code>,  <code>startWith</code>,  <code>window</code>,  <code>takeUntil</code>,  <code>skip</code>,  <code>scan</code>,  <code>sample</code>,  <code>amb</code>,  <code>join</code>,  <code>flatMap</code> 等。</p>
<p><strong>把它想象成异步的不可变数组。</strong></p>
<p>在 underscore.js 中 Rx 被认为是事件。但想一想，到底什么是事件呢？你的应用中的大部分东西能否是个事件呢？</p>
<p>“应用启动”事件，”接口数据返回”事件，”按键按下”事件，”界面刷新”事件，”设备休眠”事件，等等。</p>
<p>实际上，几乎所有的东西都可以看做是事件的流。问题只在于如何以合适的方式来组合它们。</p>
<p>这就是响应式编程的2分钟介绍。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 响应式编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 响应式 </tag>
            
            <tag> 编程 </tag>
            
            <tag> rx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在 Ubuntu 14.04 上通过 apt-get 安装 Apache Tomcat 7]]></title>
      <url>http://linfuyan.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/</url>
      <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于-Apache-Tomcat"><a href="#关于-Apache-Tomcat" class="headerlink" title="关于 Apache Tomcat"></a>关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>
<a id="more"></a>
<h3 id="步骤一-先决条件"><a href="#步骤一-先决条件" class="headerlink" title="步骤一 - 先决条件"></a>步骤一 - 先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照 Ubuntu 14.04 上搭建服务器中的 1-4 步来学习完成它。我们这里使用创建的 <code>demo</code> 用户来完成后续的教程。</p>
<h3 id="步骤二-安装-Tomcat"><a href="#步骤二-安装-Tomcat" class="headerlink" title="步骤二 - 安装 Tomcat"></a>步骤二 - 安装 Tomcat</h3><p>首先，你需要升级 apt-get 软件包列表：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<p>现在你已经准备好安装 Tomcat。运行以下命令，开始安装：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install tomcat7</span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装 Tomcat 。这将同时安装 Tomcat 和它的依赖，例如 Java，同时，它将创建一个 <code>tomcat7</code> 用户，并以默认设置启动 Tomcat 。</p>
<p>这时候， Tomcat 并没有完全安装完成，但你可以通过在浏览器中输入本地域名或IP地址之后加 <code>:8080</code> 的方法来访问默认页面。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//your_ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你会看到一个闪屏页面，显示 “It works” ，和其他附加信息。现在，我们要深入到 Tomcat 的安装过程。</p>
<h3 id="步骤三-安装额外软件包"><a href="#步骤三-安装额外软件包" class="headerlink" title="步骤三 - 安装额外软件包"></a>步骤三 - 安装额外软件包</h3><p><em>注意：</em>如果你对 Tomcat 足够了解，且不需要 Web 管理接口，文档和示例，那这个章节不是必须的。如果你是第一次接触 Tomcat ，请继续。</p>
<p>通过以下代码，你将安装 Tomcat 的在线文档， Web接 口（管理 Web 应用），以及一些示例应用。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install tomcat7-docs tomcat7-admin tomcat7-examples</span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装这些软件包。后面我们会讲到这些工具的用法和配置。接下来，我们要安装 JDK 。</p>
<h3 id="步骤四-安装-JDK-可选"><a href="#步骤四-安装-JDK-可选" class="headerlink" title="步骤四 - 安装 JDK (可选)"></a>步骤四 - 安装 JDK (可选)</h3><p>如果你打算在服务器上开发应用，你需要安装本章节中提到的软件。</p>
<p>JDK 确保我们可以开发运行在 Tomcat 服务器上的 Java 应用。运行以下命令来安装 <code>openjdk-7-jdk</code>:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure>
<p>作为 JDK 的附件， Tomcat 文档上建议同时安装用来构建 Java 应用 Apache Ant 工具及包括 Git 在内的源码控制系统。通过下面的命令来安装它们：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ant git</span><br></pre></td></tr></table></figure>
<p>Apache Ant 的更多信息，可查阅其<a href="http://ant.apache.org/manual/index.html" target="_blank" rel="noopener">官方文档</a>。 Git 使用教程可以参考<a href="https://www.digitalocean.com/community/articles/how-to-use-git-effectively" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="步骤五-配置-Tomcat-Web-管理器"><a href="#步骤五-配置-Tomcat-Web-管理器" class="headerlink" title="步骤五 - 配置 Tomcat Web 管理器"></a>步骤五 - 配置 Tomcat Web 管理器</h3><p>想要使用步骤三中安装的 Web 应用管理器，需要先登录到 Tomcat 服务器。首先需要编辑修改 <code>tomcat-users.xml</code> ：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>tomcat7<span class="regexp">/tomcat-users.xml</span></span><br></pre></td></tr></table></figure>
<p>该文件充满了用于说明如何配置的注释。你需要删除下面两行之间的所有注释。如需要用作参考，则保留。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;tomcat-users&gt;</span></span><br><span class="line"><span class="section">&lt;/tomcat-users&gt;</span></span><br></pre></td></tr></table></figure>
<p>你需要添加一个用户，可以访问 <code>manager-gui</code> 和 <code>admin-gui</code> （我们在步骤三种安装的管理界面）。你可以通过如下的配置来定义一个用户。如果需要，确保修改用户名和密码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">roles</span>=<span class="string">"manager-gui,admin-gui"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存并退出 <code>tomcat-users.xml</code> 文件。重启 Tomcat 服务，以便修改配置生效。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>tomcat7 restart</span><br></pre></td></tr></table></figure>
<h3 id="步骤六-访问-Web-界面"><a href="#步骤六-访问-Web-界面" class="headerlink" title="步骤六 - 访问 Web 界面"></a>步骤六 - 访问 Web 界面</h3><p>现在，我们已经配置了一个管理员用户，从 Web 浏览器访问 Web 管理器页面。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//your-ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你可以看到的页面如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/tomcat7_ubuntu1404_3.png" alt="image"></p>
<p>从上面可以看到，里面有四个链接到步骤三中安装的软件包：</p>
<ul>
<li>tomcat7-docs: Tomcat 的在线文档。通过 <code>http://your_ip_address:8080/docs/</code> 来访问</li>
<li>tomcat7-examples: Tomcat 7 Servlet 和 JSP 示例。你可以点击这些示例 Web 应用来了解它们是怎么工作的（通过源码可以了解它们是怎么实现的）。通过 <code>http://your_ip_address:8080/examples/</code> 来访问</li>
<li>tomcat7-admin ( Web 应用管理器): Tomcat Web 应用管理器。通过这里来管理你的 Java 应用。</li>
<li>tomcat7-admin (主机管理器): Tomcat 虚拟主机管理器。</li>
</ul>
<p>通过打开链接 <code>http://your_ip_address:8080/manager/html</code> ，来查看 Web 应用管理器：</p>
<p><img src="http://img.uprogrammer.cn/static/images/tomcat7_ubuntu1404_1.png" alt="image"></p>
<p>这个Web应用管理器使用来管理Java应用的。你可以在这里执行应用的启动，停止，重新加载，部署，下架等操作。还可以对应用做一些诊断（如内存泄露）。最后，你服务器的相关信息被显示在页面的最底部。</p>
<p>通过打开链接 <code>http://your_ip_address:8080/host-manager/html</code> ，来查看虚拟主机管理器：</p>
<p><img src="http://img.uprogrammer.cn/static/images/tomcat7_ubuntu1404_2.png" alt="image"></p>
<p>在虚拟主机管理页面，你可以为应用程序添加虚拟主机。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>Tomcat 的安装到此结束。你现在就可以免费得来部署自己的 Web 应用。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> tomcat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
            <tag> Apache </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 14.04 </tag>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
            <tag> Ant </tag>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是 Jenkins?]]></title>
      <url>http://linfuyan.com/what-is-jenkins/</url>
      <content type="html"><![CDATA[<h3 id="什么是Jenkins"><a href="#什么是Jenkins" class="headerlink" title="什么是Jenkins"></a>什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
<ul>
<li><strong>持续构建/测试软件项目</strong>，类似于 <code>CruiseControl</code> 或者 <code>DamageControl</code> 。简而言之， Jenkins 提供一个使用简单地持续集成系统，使得开发人员更方便的集成项目修改，让用户更容易地获取较新的构建版本。自动化持续构建极大提高了生产力。</li>
<li><strong>监控外部运行任务的执行</strong>，比如配置在本地或者远程的 <code>cron</code> 或 <code>procmail</code> 任务。拿 <code>cron</code> 举个例子，你将收到的是一些包含输出结果的常规电子邮件，提醒你勤快地处理它们，当它们出错时，也可以第一时间提醒你。 Jenkins 保存这些输出，并使得出现问题时的通知变得简单。</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Jenkins 所提供(拥有)的特性如下：</p>
<ol>
<li><strong>易于安装</strong>：只需要一个名为 jenkins.war 的 Java jar 包，或者将它发布到 servlet 容器。不需要其他附件安装，不需要数据库。</li>
<li><strong>易于配置</strong>：整个 Jenkins 的配置都可以通过它友好的 Web 界面来完成。不在需要别扭的 XML 手动配置，如果你依然愿意，可以继续使用。</li>
<li><strong>修改设置的支持</strong>： Jenkins 可以从 <code>Subversion/CVS</code> 生成一系列的修改列表来完成构建。这种方式也非常的前卫，因为减少了从存储库加载资源的步骤。</li>
<li><strong>永久的链接地址</strong>： Jenkins 为大部分的页面提供了简洁可读的 URL ，包括诸如” <code>latest build/latest successful build</code> “这样的永久性链接，可以很轻易的从其他地方链接过来。</li>
<li><strong>RSS/邮件/即时通行集成</strong>：通过 RSS 或者邮件来获取失败时的实时通知，轻而易举地监控构建结果。</li>
<li><strong>标记构建过程</strong>：当构建完成以后，可以对其进行标记存储。</li>
<li><strong>JUnit/TestNG 测试报告</strong>： JUnit 的测试报告及历史信息，可以表格形式总结与展示，比如构建在什么时候开始出错等等。历史趋势以图表形式绘制出来。</li>
<li><strong>分布式构建</strong>： Jenkins 可以分配构建/测试到多台电脑商。</li>
<li><strong>文件指纹</strong>： Jenkins 可以跟踪那次构建生成了哪些 jar 包，哪些构建使用了哪个版本的 jar 包等等。这些对不是 Jenkins 内部产生的 jar 包也有效，非常适合于项目中的依赖跟踪。</li>
<li><strong>插件支持</strong>： Jenkins 可以轻易地通过第三方插件进行扩展。你甚至可以为自己的团队使用编写合适的 Jenkins 插件。</li>
</ol>
<h3 id="Jenkins-由来"><a href="#Jenkins-由来" class="headerlink" title="Jenkins 由来"></a>Jenkins 由来</h3><p>目前持续集成（ CI ）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，只在缓和和稳固软件的构建过程，并且能够帮助你的开发团队应对如下挑战：</p>
<ul>
<li>软件构建自动化：配置完成后， CI 系统会依照预先定制的时间表，或者针对某一特定事件，对目标软件进行构建。</li>
<li>构建可持续的自动化检查： CI 系统能持续地获取新增或者修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时， CI 系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力。</li>
<li>构建可持续的自动化测试：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知给相关的当事人。</li>
<li>生成后后续过程的自动化：当自动化检查和测试成功完成以后，软件构建的周期中可能需要一些额外的任务，诸如生成文档，打包软件，部署构建到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。</li>
</ul>
<p>部署一个 CI 系统需要的最低要求是，一个可获取的源代码仓库，一个包含构建脚本的项目。</p>
<p>CI 系统的基本结构，如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/jenkins-basic-structure.jpg" alt="image"></p>
<p>该系统的各个组成部分是按如下顺序发挥作用的：</p>
<ol>
<li>开发这检入代码到源代码仓库。</li>
<li>CI 系统会为每一个项目创建一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</li>
<li>CI 系统会在对应的工作区内执行构建过程。</li>
<li>如果配置存在，构建完成后， CI 系统会在一个新的构建中执行定义的一套测试。完成后出发通知（RSS，邮箱等等）给相关的当事人。</li>
<li>如果配置存在，在构建成功后，这个构建会被打包并转移到一个部署目标（如应用服务器）或存储为软件仓库中的一个新版本。软件仓库可以是 CI 系统的一部分，也可以是一个外部的仓库，诸如一个文件或者服务器或者像 Java.net 、 SourceForge 之类的网站。</li>
<li>CI 系统通常会根据请求发起相应地操作，诸如及时构建、生成报告，或者检索一些构建好的构件。</li>
</ol>
<p>Jenkins 就是这样的一个 CI 系统。它的主要目标在于监控软件开发流程，快速显示问题。所以能保证开发人员以及相关人员省时省力提高开发效率。</p>
<p>在整个开发过程中， CI 的作用主要是控制：当系统在代码库中探测到修改是，它将运行构建的任务委托给构建过程本身。如果构建失败了，那么 CI 将通知相关人员，然后继续监视存储库。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins01.html" target="_blank" rel="noopener">Jenkins是什么</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins" target="_blank" rel="noopener">Meet Jenkins</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> jenkins </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 持续集成 </tag>
            
            <tag> jenkins </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 构建 </tag>
            
            <tag> CI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Hueman 主题添加侧边栏添加微信公众号二维码]]></title>
      <url>http://linfuyan.com/hexo-your-blog/add-weixin-qrcode-to-hueman-sidebar/</url>
      <content type="html"><![CDATA[<p>这篇文章中，我们来在 Hueman 主题的侧边栏中添加微信公众号的二维码。</p>
<p>1. 找到 themes/hueman 下的配置文件 _config.yml，添加 weixin 变量配置为二维码地址。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置关注微信公众号</span></span><br><span class="line">weixin: http:<span class="regexp">//img</span>.uprogrammer.cn<span class="regexp">/static/im</span>ages<span class="regexp">/qrcode_for_gh_3ad92a8fc23c_860.jpg</span></span><br></pre></td></tr></table></figure>
<p>2. 在 themes/huema/layout/_widget 目录下新建 weixin.ejs 文件，添加如下代码</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">if</span> (theme.weixin)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-wrap"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> theme.weixin </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span>/&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里根据是否存在1中的微信二维码链接来控制这个模块的显示。可以根据实际需要设置样式。</p>
</blockquote>
<p>3. 修改 themes/hueman/_config.yml , 在 widgets 添加 weixin。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">-<span class="ruby"> weixin</span></span><br><span class="line"><span class="ruby">- recent_posts</span></span><br><span class="line"><span class="ruby">- tagcloud</span></span><br><span class="line"><span class="ruby">- category</span></span><br><span class="line"><span class="ruby">- archive</span></span><br><span class="line"><span class="ruby">- tag</span></span><br><span class="line"><span class="ruby">- links</span></span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>本节中通过将微信公众账号的二维码作为一个组件( weixin.ejs )，利用 hueman 主题已有的侧边栏配置，非常方便的实现了微信公众账号二维码的添加。</p>
<p>同时也欢迎大家关注：非典型程序员</p>
<p><img src="http://img.uprogrammer.cn/static/images/qrcode_for_gh_3ad92a8fc23c_860.jpg" alt="非典型程序员"></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hueman </tag>
            
            <tag> 微信公众号 </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[声明式编程范式初探]]></title>
      <url>http://linfuyan.com/declarative-programming-intro/</url>
      <content type="html"><![CDATA[<p>语言编程语言可以分成两类：</p>
<ul>
<li>命令式</li>
<li>声明式</li>
</ul>
<p>事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。</p>
<p><img src="http://img.uprogrammer.cn/categaries-of-programming-paradigm.jpg" alt="编程范式的简单分类"></p>
<p>与命令式编程相对的声明式编程（ declarative programming ）。顾名思义，声明式编程由若干规范（ specification ）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。</p>
<a id="more"></a>
<h4 id="声明式编程的发源"><a href="#声明式编程的发源" class="headerlink" title="声明式编程的发源"></a>声明式编程的发源</h4><p>声明式编程发轫于人工智能的研究，主要包括函数式编程（ functional programming ，简称 FP ）和逻辑式编程（ logic programming ，简称 LP ）。其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。</p>
<p>其实支持它们的语言出现得并不比命令式的晚多少——最早的函数式语言 Lisp （ <strong>LIS</strong>t <strong>P</strong>rocessor ）已有半个世纪的历史，最早之一的逻辑式语言 Prolog （ <strong>PRO</strong>gramming in <strong>LOG</strong>ic ）也与 C 同龄。只是由于大多数更多地用于学术研究而非商业应用，颇有些‘养在深闺人未识’的味道。</p>
<p>起源的不同决定了这两大类范式代表着迥然不同的编程理念和风格：命令式编程是行动导向（ Action-Oriented ）的，因而算法是显性而目标是隐性的；声明式编程是目标驱动（ Goal-Driven ）的，因而目标是显性而算法是隐性的。为便于说明，我们分别用三种代表性的语言来实现阶乘（ factorial ）运算。</p>
<h4 id="阶乘的三种编程实现"><a href="#阶乘的三种编程实现" class="headerlink" title="阶乘的三种编程实现"></a>阶乘的三种编程实现</h4><p>C(命令式) –</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> factorial(<span class="built_in">int</span> <span class="built_in">n</span>) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> f = <span class="number">1</span>;</span><br><span class="line">	for (; <span class="built_in">n</span> &gt; <span class="number">0</span>; --<span class="built_in">n</span>) f *= <span class="built_in">n</span>;</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Liap(函数式) –</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun factorial(<span class="built_in">n</span>)</span><br><span class="line">  (<span class="built_in">if</span> (= <span class="built_in">n</span> <span class="number">0</span>)</span><br><span class="line">	<span class="number">1</span>                               //  若<span class="built_in">n</span>等于<span class="number">0</span>，则<span class="built_in">n</span>!等于<span class="number">1</span></span><br><span class="line">	(* <span class="built_in">n</span> (factorial(- <span class="built_in">n</span> <span class="number">1</span>)))))      //  否则<span class="built_in">n</span>!等于<span class="built_in">n</span>* (<span class="built_in">n</span>-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Prolog(逻辑式) –</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">0</span>! 等于<span class="number">1</span></span><br><span class="line">factorial(<span class="number">0</span>,<span class="number">1</span>).</span><br><span class="line">// 若M等于<span class="built_in">N</span>-<span class="number">1</span>且 M!等于Fm且F等于<span class="built_in">N</span>*Fm，则<span class="built_in">N</span>! 等于F</span><br><span class="line">factorial(<span class="built_in">N</span>,F) <span class="symbol">:</span>-   M is <span class="built_in">N</span>-<span class="number">1</span>, factorial(M,Fm), F is <span class="built_in">N</span> * Fm.</span><br></pre></td></tr></table></figure>
<p>以上三段代码区别在哪里？ C 明确给出了阶乘的迭代算法，而 Lisp 仅描述了阶乘的递归定义， Prolog 则陈述了两个关于阶乘的断言。</p>
<h4 id="声明式编程的本质"><a href="#声明式编程的本质" class="headerlink" title="声明式编程的本质"></a>声明式编程的本质</h4><p>我们最早接触的变量是代数方程中的 x、y、z 等，本质上是抽象化的符号，变量值是该符号在给定约束条件下的允许值。而命令式编程中的变量本质上是抽象化的内存，变量值是该内存的储存内容。通俗地说，前者好比姓名，所指之人是固定的；后者好比住址，所住之人是变化的。此外，等号在代数中是一种约束，而在许多命令式语言中则表示赋值。因此 i = i + 1 可以在命令式编程中出现，但绝不可能在数学推理中出现 —— 除非在反证法中。</p>
<p>声明式编程让我们重回数学思维：函数式编程类似代数中的表达式变换和计算，逻辑式编程则类似数理逻辑推理。其中的变量也如数学中的一样，是抽象符号而非内存地址，因此没有赋值运算，不会产生变量被改写的副作用（ side-effect ），也不存在内存分配和释放的问题。这既简化了代码，也减少了调试——不妨想一想，有多少bug是由于某个变量被意外改写或内存管理不慎而造成的？</p>
<p><strong>声明式语言与命令式语言的相通之处</strong></p>
<ul>
<li>首先，所有高级语言都建立于低级语言之上，最终转化为机器语言，声明式语言也不例外。</li>
<li>其次，声明式语言与命令式语言并非泾渭分明，而是互相交叉渗透的。一些‘非纯粹’ 的声明式语言也提供变量赋值和流程控制，而一些命令式语言也在逐渐发展，通过利用其他程序或增加新的语言特征来实现声明式编程。</li>
</ul>
<p>总的说来，在命令式语言中融入声明式的元素应当是一种趋势。尤其是函数式，它的一些特征已经在许多命令式语言中得到了支持。比较而言，声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简洁清晰、易于修改和维护。从这种意义上说，声明式语言天然地就比命令式语言更高级。</p>
<blockquote>
<p>既然声明式编程有这么多好处，为什么命令式语言不仅占大多数，而且流行程度也不减呢？</p>
</blockquote>
<blockquote>
<p>编程语言的流行程度与其擅长的领域关系密切。声明式语言——尤其是函数式语言和逻辑式语言——擅长基于数理逻辑的应用，如人工智能、符号处理、数据库、编译器等，对基于业务逻辑的、尤其是交互式或事件驱动型的应用就不那么得心应手了。而大多数软件是面向用户的，交互性强、多为事件驱动、业务逻辑千差万别，显然命令式语言在此更有用武之地。</p>
</blockquote>
<p>值得指出的是，声明式编程并不仅仅局限于函数式和逻辑式。比方说， C# 中的 attribute 、 Java 中的 annotation 和 XDoclet 库等采用的也是具有声明式特征的属性导向式编程（ Attribute-Oriented Programming ，简称 @OP ）。再比如， Prograph 、 SISAL 等数据流语言（ dataflow language ）采用的数据流式编程（ Dataflow Programming ）与函数式编程有不少共同点，同样属于声明式的范畴。还有一些语言如 Oz 、 CHIP 等支持与逻辑式编程相交的约束式编程（ Constraint Programming ）。此外，大家熟悉的数据库语言 SQL ，样式语言 XSLT、 CSS，标记语言 HTML 、 XML 、 SVG ，规范语言 IDL （ Interface Description Language ）等等都是声明式的。算上它们，声明式语言所占的比例也是非常可观的。此前之所以没有提及，一方面，不少声明式语言采用的范式并没有专门的名称；另一方面，这些语言大多是领域特定语言，并且不少并非图灵完备的，有的连运算都没有。毕竟，目前我们的重点还是放在通用编程语言上。</p>
<p>其实用 Lisp 实现阶乘的方法也可以用在 C 上：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> factorial(<span class="built_in">int</span> <span class="built_in">n</span>) </span><br><span class="line">&#123;</span><br><span class="line">    return <span class="built_in">n</span> == <span class="number">0</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * factorial(<span class="built_in">n</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 C 的递归实现。除了细微的语法差别外，二者的确很相似，这说明用命令式语言也可以讲出声明式的味道。实际上，命令式语言提倡迭代而不鼓励递归，早期的 Fortran 甚至都不支持递归。一则迭代比递归更符合命令式的思维模式，因为前者贴近机器语言而后者贴近数学语言；二则除尾递归（ tail recursion ）外，一般递归比迭代的开销（ overhead ）大。相反，声明式语言提倡递归而不支持迭代。就语法而言，它不允许迭代中的循环变量；就视角而言，迭代着眼微观过程而递归着眼宏观规律。</p>
<p>归根结底，<strong>编程是寻求一种机制，将指定的输入转化为指定的输出。</strong>三种范式对此提供了截然不同的解决方案：</p>
<ul>
<li>命令式把程序看作一个自动机，输入是初始状态，输出是最终状态，编程就是设计一系列指令，通过自动机执行以完成状态转变；</li>
<li>函数式把程序看作一个数学函数，输入是自变量，输出是因变量，编程就是设计一系列函数，通过表达式变换以完成计算；</li>
<li>逻辑式把程序看作一个逻辑证明，输入是题设，输出是结论，编程就是设计一系列命题，通过逻辑推理以完成证明。</li>
</ul>
<p>绘成表格如下：</p>
<table>
<thead>
<tr>
<th>范式</th>
<th>程序</th>
<th>输入</th>
<th>输出</th>
<th>程序设计</th>
<th>程序运行</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令式</td>
<td>自动机</td>
<td>初始状态</td>
<td>最终状态</td>
<td>设计指令</td>
<td>命令执行</td>
</tr>
<tr>
<td>函数式</td>
<td>数学函数</td>
<td>自变量</td>
<td>因变量</td>
<td>设计函数</td>
<td>表达式变换</td>
</tr>
<tr>
<td>逻辑式</td>
<td>逻辑证明</td>
<td>题设</td>
<td>结论</td>
<td>设计命题</td>
<td>逻辑推理</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 基础理论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 语言 </tag>
            
            <tag> 范式 </tag>
            
            <tag> 命令式 </tag>
            
            <tag> 声明式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Ubuntu 14.04 上安装Linux, Apache, MySQL, PHP (LAMP)组件]]></title>
      <url>http://linfuyan.com/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04/</url>
      <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04</a></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>“ LAMP “组件是一组典型的安装在一起的开源软件，用于服务器搭建动态网站和 Web 应用。实际上，这是一个首字母缩写的组合，代表了 Linux 操作系统安装 <strong>A</strong>pache Web 服务器。网站的数据存储在 <strong>M</strong>ySQL 数据库中，并由 <strong>P</strong>HP 提供动态内容。</p>
<a id="more"></a>
<p>在这篇向导中，我们将在 Ubuntu 14.04 Droplet 上搭建 LAMP 。 Ubuntu 提供了我们的第一个需求：一个 <strong>L</strong>inux 操作系统。</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照<a href="https://www.digitalocean.com/community/articles/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="noopener">Ubuntu 14.04上搭建服务器</a>中的1-4步来学习完成它。</p>
<h3 id="步骤一-安装Apache"><a href="#步骤一-安装Apache" class="headerlink" title="步骤一 - 安装Apache"></a>步骤一 - 安装<strong>A</strong>pache</h3><p>Apache web 服务器是目前世界上最流行的 web 服务器，是挂载站点的最佳默认选择。</p>
<p>我们将通过 Ubuntu 的包管理器 <code>apt</code> 来便捷地安装 Apache。这个包管理器让我们可以毫无痛苦的从 Ubuntu 维护的存储库中来安装大多数的软件。更多关于 <code>apt</code> 的信息，可以看这里<a href="https://www.digitalocean.com/community/articles/how-to-manage-packages-in-ubuntu-and-debian-with-apt-get-apt-cache" target="_blank" rel="noopener">如何使用 apt</a>。</p>
<p>为了我们的目标，我们可以从输入这些命令开始：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install apache2</span><br></pre></td></tr></table></figure>
<p>由于我们使用 <code>sudo</code> 命令，这些操作在 root 权限下执行。这将要求你输入常规用户的密码来验证你的意图。</p>
<p>在此之后，你的 web 服务器就安装好了。</p>
<p>你可以马上做一些验证来确定一起如预期进行。在浏览器中输入你服务器的公网IP地址：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//your_server_IP_address</span></span><br></pre></td></tr></table></figure>
<p>你将看到默认的 Ubuntu 14.04 Apache 页面，这个页面展示的目的是出于测试及显示信息。看起来他是这样的：</p>
<p><img src="http://img.uprogrammer.cn/static/images/default_apache.png" alt="image"></p>
<p>如果你看到这个页面，说明你的 web 服务器正确安装了。</p>
<h4 id="如何找到你的服务器的公网-IP-地址"><a href="#如何找到你的服务器的公网-IP-地址" class="headerlink" title="如何找到你的服务器的公网 IP 地址"></a>如何找到你的服务器的公网 IP 地址</h4><p>如果你不知道服务器的公网IP地址是什么，可以有多重方式来找到。通常，这个地址是你用来通过SSH来连接你的服务器的。</p>
<p>在命令行下，有一些方法来找到。首先，你可以使用 <code>iproute2</code> 工具来获取地址，输入以下命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ip</span> addr show eth0 | grep inet | awk <span class="string">'&#123; print <span class="variable">$2</span>; &#125;'</span> | sed <span class="string">'s/\/.*$//'</span></span><br></pre></td></tr></table></figure>
<p>这个将返回一行或两行输出。这两个都是正确地地址，但是你的电脑只能用其中之一，因此放松地尝试每一个。</p>
<p>另一种方法是通过外部的第三方工具来查看你的服务器。你可以通过访问一个确定的服务器来查看自己的IP地址。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">http:</span><span class="comment">//icanhazip.com</span></span><br></pre></td></tr></table></figure>
<p>不论你用哪种方法获取到了自己的IP地址，你可以在浏览器的地址栏中来访问服务器。</p>
<h3 id="步骤二-安装-MySQL"><a href="#步骤二-安装-MySQL" class="headerlink" title="步骤二 - 安装 MySQL"></a>步骤二 - 安装 <strong>M</strong>ySQL</h3><p>现在我们已经安装了 web 服务器，并正常运行，是时候安装 MySQL 了。 MySQL 是一个数据库管理系统。最基本的，它用来组织和访问用来存储我们站点信息的数据库。</p>
<p>我们再次用 <code>apt</code> 工具来获取和安装软件。这次，我们还需要安装一些其他的辅助工具包，来让安装的组件相互通信:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install mysql-server php5-mysql</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在这里，你不需要在执行这个命令之前，执行 <code>sudo apt-get update</code> 。因为我们在之前安装 Apache 的时候已经执行过了。你电脑上的包索引已经是最新的了。</p>
<p>在安装过程中，你的服务器会让你为 MySQL 的 root 用户选择并设置密码。这在 MySQL 中是一个具有管理员权限的账号。这个有点类似于操作系统中的 root 账号（尽管如此，你目前所配置的账号仅针对 MySQL ）。</p>
<p>当安装结束，我们需要运行一些额外的命令，来保证我们的 MySQL 环境足够安全。</p>
<p>首先，我们需要告诉 MySQL 来创建它用于存储信息的数据库目录结构。你需要输入：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> mysql_install_db</span><br></pre></td></tr></table></figure>
<p>然后我们要运行一些简单地安全脚本来消除默认的危险配置，并锁定数据的访问。通过输入如下命令，来开始使用交互脚本：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>你会被要求输入所设置的 MySQL 的 root 账号密码。接下来，会被问到是否想要修改密码，如果你对现有的密码满意，输入 <code>n</code> 代表 <code>no</code> 并提交。</p>
<p>接下来的问题中，你只需简单地回车来使用默认配置。这样做会移除一些测试用户和数据库，禁止 root 用户远程登录，加载这些新的配置，以便我们的修改在 MySQL 中立即生效。</p>
<p>到这里，你的数据库系统已经建立，可以继续下一步。</p>
<h3 id="步骤三-安装-PHP"><a href="#步骤三-安装-PHP" class="headerlink" title="步骤三 - 安装 PHP"></a>步骤三 - 安装 <strong>P</strong>HP</h3><p>PHP 是我们安装的一个组件，用于处理代码以显示动态内容。它可以运行脚本，连接到 MySQL 数据库来获取信息，并传输处理好的内容到web服务器来显示。</p>
<p>我们可以再次利用 <code>apt</code> 工具来安装我们的组件。同样，我们会包含一些辅助包：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5 libapache2-mod-php5 php5-mcrypt</span><br></pre></td></tr></table></figure>
<p>这样安装 PHP 将不会有任何问题，我们将马上测试。</p>
<p>在大部分情况下，当请求文件夹时，我们需要修改 Apache 服务器上处理文件的方式。现在，如果一个用户向服务器请求目录， Apache 会首先寻找名为 <code>index.html</code> 的文件。我们需要告诉我们的 web 服务器优先处理 PHP 文件，因此我们让 Apache 首先寻找 <code>index.php</code> 。</p>
<p>要完成这个，输入以下命令来在文本编辑器中打开 <code>dir.conf</code> 文件：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apache2<span class="regexp">/mods-enabled/</span>dir.conf</span><br></pre></td></tr></table></figure>
<p>找到如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">    DirectoryIndex index<span class="selector-class">.html</span> index<span class="selector-class">.cgi</span> index<span class="selector-class">.pl</span> index<span class="selector-class">.php</span> index<span class="selector-class">.xhtml</span> index.htm</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>我们将其中的 <code>index.php</code> 移到第一项的位置，在 <code>DirectoryIndex</code> 之后，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">	DirectoryIndex index<span class="selector-class">.php</span> index<span class="selector-class">.html</span> index<span class="selector-class">.cgi</span> index<span class="selector-class">.pl</span> index<span class="selector-class">.xhtml</span> index.htm</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>当操作完成，按下 <code>CTRL-X</code> 保存并退出文件。你需要输入 <code>Y</code> 来确认保存，并点击回车来确认文件保存位置。</p>
<p>在这之后，我们需要重启 Apache web 服务器来使配置修改生效。输入以下命令来完成：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>apache2 restart</span><br></pre></td></tr></table></figure>
<h4 id="安装-PHP-模块"><a href="#安装-PHP-模块" class="headerlink" title="安装 PHP 模块"></a>安装 PHP 模块</h4><p>为了扩展 PHP 的功能，我们可以选择安装一些额外的模块。</p>
<p>查看可选的 PHP 模块和库，可以在系统中输入如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">cache</span> <span class="keyword">search</span> php5-</span><br></pre></td></tr></table></figure>
<p>结果是所有你可以安装的可选组件，并给出每项的简短介绍。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php5-cgi - server-side, HTML-embedded scripting <span class="keyword">language</span> (CGI binary)</span><br><span class="line">php5-cli - <span class="keyword">command</span>-<span class="built_in">line</span> interpreter <span class="keyword">for</span> the php5 scripting <span class="keyword">language</span></span><br><span class="line">php5-common - Common <span class="keyword">files</span> <span class="keyword">for</span> packages built from the php5 <span class="keyword">source</span></span><br><span class="line">php5-curl - CURL module <span class="keyword">for</span> php5</span><br><span class="line">php5-dbg - Debug symbols <span class="keyword">for</span> PHP5</span><br><span class="line">php5-dev - Files <span class="keyword">for</span> PHP5 module development</span><br><span class="line">php5-gd - GD module <span class="keyword">for</span> php5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>如果想要获取每个模块更多的信息，你可以在互联网上搜索或者通过如下命令查看包内的详细介绍：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">cache </span><span class="keyword">show </span>package_name</span><br></pre></td></tr></table></figure>
<p>这将会有许多输出，其中有个名为 <code>Description-en</code> 的区域对模块所提供的功能有详细的解释。</p>
<p>比如说，想要知道 <code>php5-cli</code> 模块的用处，我们可以输入：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">cache </span><span class="keyword">show </span>php5-cli</span><br></pre></td></tr></table></figure>
<p>从大片的输出信息中，你会看到与如下类似的的内容：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line">SHA256: <span class="number">91</span>cfdbda65df65c9a4a5bd3478d6e7d3e92c53efcddf3436bbe9bbe27eca409d</span><br><span class="line">Description-en: <span class="keyword">command</span>-line <span class="title">interpreter</span> <span class="title">for</span> <span class="title">the</span> <span class="title">php5</span> <span class="title">scripting</span> <span class="title">language</span></span><br><span class="line">This package provides <span class="keyword">the</span> /usr/bin/php5 <span class="keyword">command</span> <span class="title">interpreter</span>, <span class="title">useful</span> <span class="title">for</span></span><br><span class="line">testing PHP scripts <span class="built_in">from</span> <span class="keyword">a</span> <span class="built_in">shell</span> <span class="keyword">or</span> performing general <span class="built_in">shell</span> scripting tasks.</span><br><span class="line">.</span><br><span class="line">The following extensions are built <span class="keyword">in</span>: bcmath bz2 calendar Core ctype <span class="built_in">date</span></span><br><span class="line">dba dom ereg exif fileinfo <span class="built_in">filter</span> <span class="keyword">ftp</span> gettext hash iconv libxml mbstring</span><br><span class="line">mhash openssl pcntl pcre Phar posix Reflection session shmop SimpleXML soap</span><br><span class="line">sockets SPL standard sysvmsg sysvsem sysvshm tokenizer wddx xml xmlreader</span><br><span class="line">xmlwriter zip zlib.</span><br><span class="line">.</span><br><span class="line">PHP (recursive acronym <span class="keyword">for</span> PHP: Hypertext Preprocessor) is <span class="keyword">a</span> widely-used</span><br><span class="line"><span class="built_in">open</span> source general-purpose scripting language that is especially suited</span><br><span class="line"><span class="keyword">for</span> web development <span class="keyword">and</span> can be embedded <span class="keyword">into</span> HTML.</span><br><span class="line">Description-md5: f8450d3b28653dcf1a4615f3b1d4e347</span><br><span class="line">Homepage: <span class="keyword">http</span>://www.php.net/</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>搜索之后，如果你决定要安装某些包，你可以像之前安装软件一样，使用 <code>apt-get</code> 命令来安装这些包。</p>
<p>假设我们想要安装所需的 <code>php5-cli</code> 包，我们输入：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install php5-cli</span><br></pre></td></tr></table></figure>
<p>如果你想要安装多个模块，你可以在 <code>apt-get install</code> 命令之后，列出每个包名，包名之间以空格隔开。像这样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install package1 package2 <span class="built_in">..</span>.</span><br></pre></td></tr></table></figure>
<p>到此，我们的组件安装并配置完毕。接下来，我们要测试 PHP。</p>
<h3 id="步骤四-在-Web-服务器上测试-PHP"><a href="#步骤四-在-Web-服务器上测试-PHP" class="headerlink" title="步骤四 - 在 Web 服务器上测试 PHP"></a>步骤四 - 在 Web 服务器上测试 PHP</h3><p>为了测试我们的系统已经正确配置 PHP ，我们可以新建一个基本的 PHP 脚本。</p>
<p>这个脚本命名为 <code>inifo.php</code> 。为了 Apache 可以正确找到并处理它，它将被保存在名为 <code>web root</code> 的确定目录中。</p>
<p>在 Ubuntu 14.04中，这个目录是 <code>/var/www/html/</code> 。通过以下命令在目标位置新建文件。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>这将打开一个空文件，我们需要在文件中输入如下有效的PHP代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">	phpinfo();</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>操作完成，保存并关闭文件。</p>
<p>现在要测试我们的服务器是否可以正确显示由 PHP 脚本生成的内容。在 web 浏览器中访问这个页面，这时，你需要服务器的公网 IP 地址。</p>
<p>你需要访问的地址如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//your_server_IP_address/info.php</span></span><br></pre></td></tr></table></figure>
<p>你看到的页面显示如下：</p>
<p><img src="http://img.uprogrammer.cn/static/images/default_php.png" alt="image"></p>
<p>这个页面给出了你 web 服务器上的 PHP 信息。这对于你调试，并确保配置信息正确非常有用。</p>
<p>如果这个成功，那么 PHP 已经可以正常运行。</p>
<p>测试完毕，你需要删除这个文件。因为，这会向未授权用户泄露你服务器的信息。输入以下命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>如果你需要查看配置信息，可以再次建立这个文件。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> LAMP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Apache </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> MySQL </tag>
            
            <tag> PHP </tag>
            
            <tag> LAMP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么预期的软件开发周期总是不够?]]></title>
      <url>http://linfuyan.com/why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/</url>
      <content type="html"><![CDATA[<p>有国外开发者在 Quora 提了这个问题：“为什么软件开发周期通常是预期的两三倍？” 并补充问：“这是开发人员的错误？ 是管理失误？ 是因为做事方法不对， 或者说缺乏好的方法？还是说这就是软件开发流程的特点？” Michael Wolfe 在2012年1月28日给的回复，非常经典，截至我们发布时已有8016个赞。以下是译文。</p>
<p>让我们先沿着海岸线，从旧金山（SF）走路去洛杉矶（LA），去拜访我们住在Newport Beach的朋友，我拿出地图在上面画出了行进路线。</p>
<p><img src="http://img.uprogrammer.cn/gcgl01.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>全程大约有400英里，如果我们每天走10小时每小时4公里的话，只用10天就可以到达目的地。立刻打电话给我们的朋友预定下周六的晚餐，告诉他们下周六晚上六点我们一定会准时出现，朋友们已经等不及了！</p>
<p>第二天清晨，我们带着准备冒险的兴奋起床，背起行囊，拿出地图，准备计划我们冒险的第一天，看一眼地图，噢，不！</p>
<p><img src="http://img.uprogrammer.cn/gcgl02.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>哇，海岸线上有这么多迂回曲折的线路。每天行进40英里的话，10天后只能勉强到达Half Moon Bay（半月湾？）。这趟旅行至少有500英里，而不是400。赶紧打电话给我们的朋友，将晚餐顺延至下下周周二。人还是应该现实一点。朋友们有点失望，不过仍然盼望见到我们，况且花 12 天从 SF 到 LA 也不赖。</p>
<p>把不开心的事丢到一边，准备出发。两小时过后，我们才刚刚走出动物园。出了什么事？我们低头看了一下脚下的路：</p>
<p><img src="http://img.uprogrammer.cn/gcg03.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天哪，这样走路也太慢了！有沙子、海水、阶梯、溪流，还有海边愤怒的海狮！这样我们只能按每小时2公里的速度前进，只有我们预估一般的速度。要么我们现在每天走20小时，要么再把晚餐推迟一个星期。好吧，让我们各退一步：每天走12个小时，把晚餐安排到下下周的周末。只好再打电话给朋友告诉他们这个情况。朋友们有些不高兴，但还是表示可以，到时候见。</p>
<p>在辛苦走了12小时后，我们准备在 Moss Beach 扎营休息。靠，要把帐篷在风中立起来根本不可能。直到半夜才开始休息。不过没什么大不了：明天在加快点速度就可以了。</p>
<p>第二天早上睡过头了，早上10点才醒，起来浑身酸痛精疲力尽。艹，今天没法走12个小时了，先走10个小时，明天可以走14个小时。收拾东西出发。</p>
<p>再缓慢行进了几个小时之后，我发现伙伴脚有点跛。妈的，是水泡。必须现在解决它，在这些问题开始减慢我们的速度前，必须将它们扼杀在萌芽状态。我慢跑了45分钟到达内陆3英里远的Pescadero，买了一些创可贴再快速跑回去给朋友包扎了一下。我快累坏了，太阳也快下山了，又浪费了一天的时间。到我们准备休息前今天只走了6英里。但是我们确实需要补充一下供给。一切都很好，明天我们就能赶上。</p>
<p>第二天醒来，扎紧脚上的绷带准备出发。转角之后突然发现，靠！这是个啥？</p>
<p><img src="http://img.uprogrammer.cn/gcgl04.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>你妹的地图上怎么没标出它！现在我们只能往内陆走3英里，绕过这些被联邦政府用栅栏保护起来的区域，中途迷路了两次，在中午前才好不容易又回到了海岸线。今天的时间过了一大半，而我们才前进了差不多1英里。好吧，不过我们不会再打电话给朋友推迟了，今天我们会一直走到午夜试着赶上进度。</p>
<p>晚上在大雾里断断续续地睡了一夜。一大早被我的伙伴叫醒，他一阵阵的头疼，还有点发烧，我问他能不能坚持一下。“你在想什么呢，混蛋，我已经连续三天在这么冷的雾中赶路，没有休息过了。“好吧，今天看来只能黄了，只能在原地好好恢复了。现在我们已经有经验了，今天好好休息明天再走14个小时，还有几天的时间，我们一定能够做到！</p>
<p>第二天我们昏昏沉沉地起来了。我看了一眼随身的地图：</p>
<p><img src="http://img.uprogrammer.cn/gcgl05.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天啊！我们已经走了10天旅程里的第5天还没有离开海湾区域！太荒唐了！我们要重新估计一下准确的时间再打给朋友，搞不好会被骂，但至少得找一个现实一点的目标。</p>
<p>同伴说，我们在四天里走了40英里，这趟旅程至少又600英里，那就至少要60天，安全一点的说法说不定要70天，“没门…是，以前我是没走路从SF去过LA，但肯定不会要70天的时间，如果告诉他们我们要到复活节才能到，那要被他们笑死的“，我说。</p>
<p>我接着说，“如果你能保证每天走16个小时，我们就能把落下的时间补回来！我知道很困难，但现在是最关键的时刻，别抱怨了！”伙伴对我吼道 “一开始又不是我告诉别人下周日我们就能到的！因为你犯的这个错差点要我的命！”</p>
<p>两个人就这样不说话了。我还是没打出电话，等我的伙伴明天冷静一点我再决定，我也愿意做一些更合理的承诺。</p>
<p>第二天上午，我们一直待在各自的帐篷中直到一场暴风雨袭来。我们赶紧收拾好东西直到10点才摆脱危险。浑身酸痛，又长了好多新水泡。之前发生的事谁也没提，直到发现我那愚蠢的伙伴把水壶落下了，又被我指责了一顿，我们不得不再花30分钟回去取它。</p>
<p>我心里记得我们的厕纸已经快用完了，下次到一个小镇的时候应该囤一点。在我们又转个弯后，才发现一条湍急的河流挡住了去路，这时我突然感到肚子一阵难受……</p>
<p>本文来自伯乐在线：<a href="http://blog.jobbole.com/45756/" target="_blank" rel="noopener">趣文：为什么软件开发周期通常是预期的两三倍？</a>，译者：</p>
<p>英文出处：<a href="http://www.quora.com/Engineering-Management/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3" target="_blank" rel="noopener">Engineering Management: Why are software development task estimations regularly off by a factor of 2-3?</a></p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 开发 </tag>
            
            <tag> 周期 </tag>
            
            <tag> 估计 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 安装出现 Cannot find module 错误]]></title>
      <url>http://linfuyan.com/faq/install-hexo-occur-connot-find-module-error/</url>
      <content type="html"><![CDATA[<p>在安装 Hexo 的过程中，有时会遇到下面的错误：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>从提示上看，问题的原因是缺少某些库，估计是由于天朝网络的问题，导致某些库没有完成下载就停止了。</p>
<p>可以换一个<a href="http://www.linfuyan.com/faq/npm-taobao-registry/" target="_blank" rel="noopener">国内的 npm 源</a>，然后重新安装 Hexo：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install hexo —<span class="literal">no</span>-optional</span><br></pre></td></tr></table></figure>
<p>原文：<a href="http://segmentfault.com/a/1190000002979092#articleHeader5" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002979092#articleHeader5</a></p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 安装 </tag>
            
            <tag> 错误 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm 官网镜像无法连接怎么办?]]></title>
      <url>http://linfuyan.com/faq/npm-taobao-registry/</url>
      <content type="html"><![CDATA[<p>在安装 Hexo 是需要先安装 Node.js，这个过程中会因为 npm 无法连接到官方 registry 而导致失败。</p>
<p>后来在网上搜到有淘宝的镜像，具体的配置方法有如下几种：</p>
<p>1. 通过 config 命令</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry <span class="comment">https:</span>//<span class="comment">registry.npm.taobao.org</span> </span><br><span class="line">npm <span class="comment">info underscore</span> //如果上面配置正确这个命令会有字符串<span class="comment">response</span></span><br></pre></td></tr></table></figure>
<p>2. 命令行指定</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npm</span> --registry https://registry.npm.taobao.org <span class="literal">info</span> underscore</span><br></pre></td></tr></table></figure>
<p>3. 编辑 ~/.npmrc 加入下面内容</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>第三种方案只需配置一次。</p>
<p>原文：<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank" rel="noopener">使用npm安装一些包失败了的看过来（npm国内镜像介绍）</a></p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
            <tag> taobao </tag>
            
            <tag> registry </tag>
            
            <tag> 镜像 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 技能树]]></title>
      <url>http://linfuyan.com/iOS-skills/</url>
      <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 iOS 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="noopener">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/Android-skills" target="_blank" rel="noopener">Android 技能</a>请猛戳这里。</p>
<p><img src="http://img.uprogrammer.cn/static/images/iOS-skills.png" alt="iOS 技能树"></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习路线 </tag>
            
            <tag> 技能 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 进阶 </tag>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 技能树]]></title>
      <url>http://linfuyan.com/Android-skills/</url>
      <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 Android 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="noopener">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/iOS-skills" target="_blank" rel="noopener">iOS 技能</a>请猛戳这里。</p>
<p><img src="http://img.uprogrammer.cn/static/images/Android-skills.png" alt="Android 技能树"></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习路线 </tag>
            
            <tag> 技能 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Are you trying to connect to a TLS-enabled daemon without TLS？]]></title>
      <url>http://linfuyan.com/faq/docker-trying-to-connect-to-a-tls-enabled-daemon-without-tls/</url>
      <content type="html"><![CDATA[<p>在 Mac 上通过 boot2docker 启动 docker 时，运行 docker 命令出现下面的提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post http:///var/run/docker.sock/v1.19/containers/<span class="keyword">create</span>: dial unix /<span class="keyword">var</span>/run/docker.sock: <span class="keyword">no</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory. </span><br><span class="line"><span class="keyword">Are</span> you trying <span class="keyword">to</span> <span class="keyword">connect</span> <span class="keyword">to</span> a TLS-enabled daemon <span class="keyword">without</span> TLS?</span><br></pre></td></tr></table></figure>
<p>这时候需要重启 boot2docker：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> boot2docker stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> boot2docker start</span></span><br></pre></td></tr></table></figure>
<p>然后根据提示设置变量，如下图：</p>
<p><img src="http://img.uprogrammer.cn/static/images/mac-docker-tls.png" alt="在 Mac 上通过 boot2docker 启动 docker 时异常"></p>
<p>OK，最后在终端中输入：<code>docker version</code> 验证是否成功。</p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Docker </tag>
            
            <tag> boot2docker </tag>
            
            <tag> TLS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OS X 上 使用 Docker 安装 Hexo]]></title>
      <url>http://linfuyan.com/hexo-your-blog/dockerize-hexo-on-mac/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这篇中介绍如何在 Mac OS X 上使用 Docker 来安装 Hexo。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
            <tag> 安装 </tag>
            
            <tag> Docker </tag>
            
            <tag> 博客 </tag>
            
            <tag> 个人 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OS X 上 Hexo 安装]]></title>
      <url>http://linfuyan.com/hexo-your-blog/install-hexo-on-mac/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这篇文章描述 Mac OS X 环境下的 Hexo 安装，其他的系统环境安装略有不同。可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>Hexo 依赖于 Node.js 及 Git，故在安装 Hexo 前必须检查并安装 Node.js 及 Git。</p>
<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>安装 Git 的方法也是多种多样，这边简单提一下，大家可以寻着这些思路来自己完成 Git 的安装。</p>
<p><strong>方案一、</strong>通过 Xcode 来安装 Git</p>
<ol>
<li>从 AppStore 下载 Xcode。</li>
<li>打开 Xcode -&gt; Preferences 点击下载选项，下载 Command Line Tools 安装。</li>
</ol>
<p><strong>方案二、</strong>安装 SourceTree 等客户端。</p>
<p><strong>方案三、</strong>通过 <a href="http://code.google.com/p/git-osx-installer/" target="_blank" rel="noopener">git-osx-installer</a> 安装。</p>
<p>安装完成以后，在终端中输入 <code>git --version</code> 查看 Git 版本，来确认是否安装成功。</p>
<blockquote>
<p>在开始 Git 的使用之前，需要有一些公共的参数配置，如 username， email 等。这些不在本文讨论范围。</p>
</blockquote>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>node.js 的安装也是方法多样，这里简单提下思路。</p>
<p><strong>方案一、</strong><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方</a>的 .pkg 文件安装，个人觉得是最方便的。</p>
<p><strong>方案二、</strong>下载 <a href="https://github.com/nodejs/node" target="_blank" rel="noopener">node.js 源码</a>，自己编译。</p>
<p><strong>方案三、</strong>通过 Homebrew 安装。</p>
<p><strong>方案四、</strong>通过 nvm 安装。</p>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完以后，就可用 npm 安装 Hexo 了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli		// 安装 Hexo 程序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog					// 新建博客目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog						// 到博客目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init						// 初始化 Hexo 博客目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install 					// 安装依赖和插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s						// 启动服务器在本地进行预览</span></span><br></pre></td></tr></table></figure>
<p>在浏览器中打开 <code>http://localhost:4000</code>，看到博客首页的话，至此安装就完成了。</p>
<p><img src="http://img.uprogrammer.cn/static/images/hexo-preview.png" alt="hexo 预览"></p>
<blockquote>
<p>为了说明问题，上面的截图是后面补的。 </p>
</blockquote>
<p>这节也比较简单，也可以查看<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo 官网</a>的对应章节。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
            <tag> 安装 </tag>
            
            <tag> 博客 </tag>
            
            <tag> 个人 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 简介]]></title>
      <url>http://linfuyan.com/hexo-your-blog/hexo-introduce/</url>
      <content type="html"><![CDATA[<p>这篇文章是<a href="http://www.linfuyan.com/hexo-your-blog" target="_blank" rel="noopener">《一步一步打造自己的 Hexo 博客》</a>系列的开篇，为了让这篇《 Hexo 简介》看上去足够充实，当然会有许多的内容来源于网络，甚至有的我也已找不到出处或者考证其真实性。这里想稍稍补充一下自己寻找博客，并最终落脚 Hexo 之旅。</p>
<p>我想很多技术人员都会有写一些博客的想法，而最初我曾尝试过在 CSDN，JavaEye(现在已经是 ItEye 了，不小心暴露年龄)，但实在难以忍受的是上面的排版，当然还有网络时快时慢等等，写文章之外需要忍受其他许许多多的不痛快。虽然这也只是我没有写技术博客的原因之一，但没有坚持下来却是实实在在的事情了。</p>
<p>后来继续开始写一些东西，是在我发现了 Markdown 这个好东西，10分钟内入门，不用再手动选择插入图片、链接，不用再选中斜体、加粗，不用选字号… 我想我是一个极懒的人。现在，我只需要打开 Mou，一路写下来，轻巧方便，再也不用担心烦杂的操作，不用担心联网的问题了。</p>
<p>有了 Markdown，我便开始寻找能够支持 Markdown 的博客， Wordpress、Typecho… Markdown 是支持的，但却要么庞大、要么不尽如人意(写完文章以后，需要手动再复制粘贴到内容编辑器里面保存等)。直到 Github Pages，再到现在的 Hexo，当 Hexo 搭建，并配置完成以后，再写文章、发布，就是本地的一条命令了，简直再方便不过。</p>
<a id="more"></a>
<p>说了这么多，回到 Hexo 介绍上来，这些摘自 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo 官网</a>。</p>
<h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><blockquote>
<h3 id="快速、简洁且高效的博客框架"><a href="#快速、简洁且高效的博客框架" class="headerlink" title="快速、简洁且高效的博客框架"></a>快速、简洁且高效的博客框架</h3></blockquote>
<h2 id="Hexo-有什么优势？"><a href="#Hexo-有什么优势？" class="headerlink" title="Hexo 有什么优势？"></a>Hexo 有什么优势？</h2><blockquote>
<h4 id="超快速度"><a href="#超快速度" class="headerlink" title="超快速度"></a>超快速度</h4><p>Node.js 所带来的超快生成速度，让上百个页面在几秒瞬间完成渲染。</p>
<h4 id="支持-Markdown"><a href="#支持-Markdown" class="headerlink" title="支持 Markdown"></a>支持 Markdown</h4><p>Hexo 支持 Github Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
<h4 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h4><p>只需一条指令即可部署到 Github Pages，Heroku 或者其他网站。</p>
<h4 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h4><p>Hexo 用用强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。</p>
</blockquote>
<h2 id="Hexo-适合谁？"><a href="#Hexo-适合谁？" class="headerlink" title="Hexo 适合谁？"></a>Hexo 适合谁？</h2><p>这是一个免费开源的博客程序，任何人都可以使用和修改。但是不同于 Wordpress，Hexo 由于需要使用Github, Git, Markdown, Node.js 这样的工具，好多插件、widget 都需要自己安装、设置。所以适合那些有一定计算机基础，喜欢折腾的人。但是，不要恐惧，只要跟着本教程走，就能很方便地让自己的博客飞起来。<a href="http://zipperary.com/2013/05/28/Hexo-guide-1/" target="_blank" rel="noopener">摘自：Hexo系列教程：（一）Hexo介绍</a></p>
<p>好吧，这篇就写到这里。想了解关于 Hexo 的更多，不方便找谷歌，就度娘就是啦。后面我们将开始自己的 Hexo 博客打造之旅。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 个人 </tag>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 开发者证书制作、App ID 与推送配置及 Provisioning Profiles 创建]]></title>
      <url>http://linfuyan.com/ios-cer-appid-push-profile/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1. <strong>开发者证书</strong></p>
<p>分为开发和发布两种，类型为 <code>iPhone Development</code>， <code>iPhone Distribution</code>。这个是最基础的，开发证书用于真机调试，发布证书则用于上传到 AppStore，是一个基础证书，用来证明开发者身份。</p>
<p>2. <strong>App ID</strong></p>
<p>这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了 PassBook，GameCenter，以及更为场景的 push 服务。如果选中了 push 服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的 App ID。</p>
<p>3. <strong>推送证书</strong></p>
<p>分为开发和发布两种，类型分别为 <code>Apple Development iOS Push Services</code>， <code>Apple Production iOS Push Services</code>，该证书在 App ID 配置中创建生成，和开发者证书一样，放在服务端程序上。</p>
<p>4. <strong>Provisioning Porfiles</strong></p>
<p>在后续部分中，简称为 profile 文件。该文件将 App ID，开发者证书，硬件绑定在一起。在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在 profile 文件中添加真机的 <code>udid</code>，是真机调试和上架 AppStore 所必需的。</p>
<a id="more"></a>
<p>平常我们的制作流程一般都是按照这样的顺序：</p>
<ol>
<li>利用开发者账号登录开发者中心</li>
<li>创建开发者证书、App ID</li>
<li>在 App ID 中开通推送服务</li>
<li>在开通推送服务的选项下面创建推送证书</li>
<li>之后在 profile 文件中绑定所有的证书ID，添加调试真机等</li>
</ol>
<h2 id="制作开发者证书"><a href="#制作开发者证书" class="headerlink" title="制作开发者证书"></a>制作开发者证书</h2><p>要制作开发者证书，首先登录开发者中心，找到证书配置版块，点击证书，显示如下页面：</p>
<p><img src="http://img.uprogrammer.cn/iOS_cer_list.png" alt="开发者证书列表"></p>
<p>点击右上角加号，进入创建页面：</p>
<p><img src="http://img.uprogrammer.cn/iOS_cer_create.png" alt="开发者证书创建"></p>
<p>创建开发证书和发布证书步骤是一样的，开发证书用于真机调试，发布证书用于提交到 AppStore，这里以开发证书的制作为例。</p>
<p>选择 “iOS App Development” 选项，点击下方的继续按钮，提示需要创建证书签名请求( CSR )。</p>
<h3 id="手动创建证书签名请求-CSR"><a href="#手动创建证书签名请求-CSR" class="headerlink" title="手动创建证书签名请求( CSR )"></a>手动创建证书签名请求( CSR )</h3><p>在 Mac 上的应用程序文件夹中，打开钥匙串访问。</p>
<p>在钥匙串访问的下拉菜单中，选择 “钥匙串访问” &gt; “证书助理” &gt; “从证书颁发机构请求证书…”。</p>
<p><img src="http://img.uprogrammer.cn/create_csr_1.png" alt="创建 CSR"></p>
<ul>
<li><p>在”证书助理”窗口，输入如下信息：</p>
<ul>
<li>在用户邮箱地址中，输入邮箱地址。</li>
<li>常用名称中，输入私钥的名称。</li>
<li>保留 CA 点子邮件地址为空。</li>
<li>在请求选项组中，选中”存储到磁盘”</li>
</ul>
</li>
<li><p>点击”继续”完成 CSR 的创建。</p>
</li>
</ul>
<p><img src="http://img.uprogrammer.cn/create_csr_2.png" alt="创建 CSR"></p>
<p><img src="http://img.uprogrammer.cn/create_csr_3.png" alt="创建 CSR"></p>
<p><img src="http://img.uprogrammer.cn/create_csr_4.png" alt="创建 CSR"></p>
<blockquote>
<p>CSR 文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字，之后在开发者中心将该 CSR 文件提交。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/create_csr_5.png" alt="上传 CSR"></p>
<p><img src="http://img.uprogrammer.cn/create_csr_6.png" alt="生成 cer"></p>
<p>上传 CSR 到开发者中心，就会生成开发者证书。将开发者证书下载保存，双击安装。可以在钥匙串访问的登录证书中可以查看，其中专用密钥的名字即为 CSR 请求文件中的常用名称。同样的方法可以配置发布证书。</p>
<blockquote>
<p>在生成不同的证书的时候可以上传同一个 CSR 文件。(这边似乎不会有什么影响?)</p>
</blockquote>
<h2 id="App-ID-与推送证书配置"><a href="#App-ID-与推送证书配置" class="headerlink" title="App ID 与推送证书配置"></a>App ID 与推送证书配置</h2><p><img src="http://img.uprogrammer.cn/app_id.png" alt="App ID 版块"></p>
<p>进入 App ID 版块，点击右上角的加号，添加新的应用：</p>
<p><img src="http://img.uprogrammer.cn/create_app_id_1.png" alt="创建 App ID"></p>
<p><img src="http://img.uprogrammer.cn/create_app_id_2.png" alt="创建 App ID"></p>
<p><img src="http://img.uprogrammer.cn/create_app_id_3.png" alt="创建 App ID"></p>
<p>新建 App ID 时，勾选 push 可选项，为该 App ID 所对应的应用添加推送功能，。</p>
<p>新应用添加完毕，选择该应用进行编辑，此时其中的 <code>Push Notifications</code> 为可配置的。</p>
<p><img src="http://img.uprogrammer.cn/create_app_id_4.png" alt="创建 App ID"></p>
<p>根据上一节中”制作开发者证书”的步骤，完成上图中证书的创建，然后下载保存，并双击安装。</p>
<blockquote>
<p>虽然在创建证书版块也可以直接创建推送证书，但是还是建议在 App ID 中勾选 push 服务后再在此处创建，这样可以避免因为忘了开通 push 服务而导致推送不可用的情况发生。</p>
</blockquote>
<h2 id="创建-profile-文件"><a href="#创建-profile-文件" class="headerlink" title="创建 profile 文件"></a>创建 profile 文件</h2><p><img src="http://img.uprogrammer.cn/create_profiles_1.png" alt="创建 profiles"></p>
<p>打开 provisioning profiles 版块，点击右上角加号创建 profile 文件。</p>
<p><img src="http://img.uprogrammer.cn/create_profiles_2.png" alt="创建 profiles"></p>
<p>可以选择开发、发布及 Ad Hoc 三种 profile 文件。开发 profile 文件用于真机测试，发布 profile 文件则用于提交发布。Ad Hoc 这里暂不讨论。</p>
<p>会自动选择匹配的 App ID。另外下拉项中还可以选择 wildCard 格式，该格式为自动生成，使用 * 通配符，适用于批量的，没有推送，PassCard 等服务的应用；我们选择我们刚刚创建的 App ID, 之后下一步选择证书：</p>
<p><img src="http://img.uprogrammer.cn/create_profiles_3.png" alt="创建 profiles"></p>
<p><img src="http://img.uprogrammer.cn/create_profiles_4.png" alt="创建 profiles"></p>
<p>继续，这里有一个区别，因为开发 profile 文件用于真机调试，所以我们需要绑定真机。由于之前已经有添加过设备，所以这里直接全选添加。如果没有的话，需要将真机的 udid 复制出来在此添加。发布 profile 文件则没有这一步。</p>
<p><img src="http://img.uprogrammer.cn/create_profiles_5.png" alt="创建 profiles"></p>
<p>填写 profile 文件名称，点击生成：</p>
<p><img src="http://img.uprogrammer.cn/create_profiles_6.png" alt="创建 profiles"></p>
<p>最终生成 .mobileprovision 文件，可以点击下载保存。双击安装。</p>
<p>在 Xcode 中可以看到效果如下：</p>
<p><img src="http://img.uprogrammer.cn/create_profiles_7.png" alt="创建 profiles"></p>
<p>到这里为止，iOS 开发者证书的制作，配置 App ID 和推送证书，以及 profile 文件的创建就都完成了。</p>
<p>本文根据 <a href="http://blog.csdn.net/holydancer/article/details/9219333" target="_blank" rel="noopener">《苹果所有常用证书，appID,Provisioning Profiles配置说明及制作图文教程（精）》</a> 进行整理。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 开发者证书 </tag>
            
            <tag> App ID </tag>
            
            <tag> push </tag>
            
            <tag> provision </tag>
            
            <tag> profile </tag>
            
            <tag> 图文教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveX 之 Operator]]></title>
      <url>http://linfuyan.com/reactivex-operator/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">http://reactivex.io/documentation/operators.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
<p>更新历史：1月13日</p>
</blockquote>
<p>每个特定语言版本的响应式扩展实现了一套具体的操作集合。虽然有一些重叠，依然有一些操作只在特定的版本中实现，并且每种语言趋向于将相似的操作命名成其他语言中已经为大家所熟悉的名称。</p>
<p>这篇文章列举出响应式扩展集合中被认为核心的操作，并链接到更多说明的页面上。这些页面将解释这些操作如何工作，哪些特定版本的响应式扩展又是怎样实现这些操作。</p>
<a id="more"></a>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建<em>Observable</em></h2><p>创建新的<em>Observable</em>的<em>Operator</em>。</p>
<ul>
<li><code>Create</code> - 通过编程方式调用<em>observer</em>的方法，从零创建<em>Observable</em></li>
<li><code>Defer</code> - 直到<em>observer</em>订阅，为每个<em>observer</em>创建全新的<em>Observable</em></li>
<li><code>Empty/Never/Throw</code> - 创建具有精确与有限行为的<em>Observable</em></li>
<li><code>From</code> - 转化其他对象或者数据结构为<em>Observable</em></li>
<li><code>Interval</code> - 创建产生整型数序列的<em>Observable</em>，序列元素间的间隔为interval</li>
<li><code>Just</code> - 转化对象或者对象的集合成为<em>Observable</em>，且<em>Observable</em>产生的值为这些对象或是对象的集合</li>
<li><code>Range</code> - 创建一个可以产生整型数序列区间的<em>Observable</em></li>
<li><code>Repeat</code> - 创建可以重复产生特殊项或项目序列的<em>Observable</em></li>
<li><code>Start</code> - 创建产生函数返回值的<em>Observable</em></li>
<li><code>Timer</code> - 创建一段给定时间以后产生单一项的<em>Observable</em></li>
</ul>
<h2 id="变换Observable"><a href="#变换Observable" class="headerlink" title="变换Observable"></a>变换<em>Observable</em></h2><p>变换<em>Observable</em>产生的项的<em>Operator</em>。</p>
<ul>
<li><code>Buffer</code> - 周期性的收集<em>Observable</em>中的项放入bundle中，并产生这些bundle而不是一次性产生这些项</li>
<li><code>FlatMap</code> - 将<em>Observable</em>所产生的多个项目变换为多个<em>Observable</em>，然后将这些<em>Observable</em>的产生值拉平为一个<em>Observable</em></li>
<li><code>GroupBy</code> - 将<em>Observable</em>分隔为<em>Observable</em>的集合，这些新的<em>Observable</em>通过key来对原来的<em>Observable</em>组织成不同的项的组</li>
<li><code>Map</code> - 将<em>Observable</em>产生的每个项应用函数变换映射</li>
<li><code>Scan</code> - 对<em>Observable</em>产生的每个项进行函数变换，有序的产生成功的值</li>
<li><code>Window</code> - 周期性的将<em>Observable</em>产生的项进行分隔成子集，放入<em>Observable window</em>，并产生这些<em>window</em>而不是一次性产生这些项</li>
</ul>
<h2 id="过滤Observable"><a href="#过滤Observable" class="headerlink" title="过滤Observable"></a>过滤<em>Observable</em></h2><p>选择性的从源<em>Observable</em>中产生项的<em>Operator</em>。</p>
<ul>
<li><code>Debounce</code> - 在一段特定的时间之内从<em>Observable</em>中只产生一个项</li>
<li><code>Distinct</code> - 过滤掉<em>Observable</em>中产生的重复的项</li>
<li><code>ElementAt</code> - 从<em>Observable</em>中拿到第N个项</li>
<li><code>Filter</code> - 从<em>Observable</em>中产生符合预设条件的项</li>
<li><code>First</code> - 从<em>Observable</em>中产生第一个项或者产生符合条件的第一个项</li>
<li><code>IgnoreElements</code> - 直到结束是通知，否则忽略<em>Observable</em>产生的所有项</li>
<li><code>Last</code> - 产生<em>Observable</em>中的最后一项</li>
<li><code>Sample</code> - 在特定的时间间隔内从<em>Observable</em>产生最近的项</li>
<li><code>Skip</code> - 跳过<em>Observable</em>产生的前n个项</li>
<li><code>SkipLast</code> - 跳过<em>Observable</em>产生的最后n个项</li>
<li><code>Take</code> - 产生<em>Observable</em>产生的前n个项</li>
<li><code>TakeLast</code> - 产生<em>Observable</em>产生的最后n个项</li>
</ul>
<h2 id="组合Observable"><a href="#组合Observable" class="headerlink" title="组合Observable"></a>组合<em>Observable</em></h2><p>操作多个源<em>Observable</em>来创建新的<em>Observable</em>的<em>Operator</em></p>
<ul>
<li><code>And/Then/When</code> - 以<code>Pattern</code>和<code>Plan</code>的形式，组合两个或多个<em>Observable</em>产生的项集</li>
<li><code>CombineLatest</code> - 不论两个<em>Observable</em>中产生了项，通过特定的函数来组合每个<em>Observable</em>中的最后一项，并产生他们的结果</li>
<li><code>Join</code> - </li>
<li><code>Merge</code> -</li>
<li><code>StartWith</code> - </li>
<li><code>Switch</code> - </li>
<li><code>Zip</code> - 通过特定的函数将多个<em>Observable</em>的产生项组合成单一项，每个组合依赖于函数结果。</li>
</ul>
<h2 id="错误处理Operator"><a href="#错误处理Operator" class="headerlink" title="错误处理Operator"></a>错误处理<em>Operator</em></h2><p>帮助从<em>Observable</em>错误通知中修复的<em>Operator</em></p>
<ul>
<li><code>Catch</code> - 通过没有错误的继续产生序列来从<code>onError</code>通知中修复</li>
<li><code>Retry</code> - 如果源<em>Observable</em>发送了<code>onError</code>通知，重新订阅它并期待它可以没有错误的完成</li>
</ul>
<h2 id="Observable工具集Operator"><a href="#Observable工具集Operator" class="headerlink" title="Observable工具集Operator"></a><em>Observable</em>工具集<em>Operator</em></h2><p>一系列操作<em>Observable</em>的有用的工具箱<em>Operator</em></p>
<ul>
<li><code>Delay</code> - 将<em>Observable</em>产生项延迟一个特定的时间</li>
<li><code>Do</code> - 注册一个动作来响应<em>Observable</em>的生命周期事件</li>
<li><code>Materialize/Dematerialize</code> - 将产生的项或者发出的通知看成产生项，或者逆转这个过程</li>
<li><code>ObserveOn</code> - 明确<em>Observer</em>观察<em>Observable</em>所在的<em>Scheduler</em></li>
<li><code>SubscribeOn</code> - 明确<em>Observable</em>被订阅后所使用的<em>Scheduler</em></li>
<li><code>TimeInterval</code> - 将产生项的<em>Observable</em>转化为这些项之间产生的时间间隔</li>
<li><code>Timeout</code> - 镜像源<em>Observable</em>，并在特定的时间范围内没有项产生时发出错误通知</li>
<li><code>Timestamp</code> - 给每个<em>Observable</em>产生项附加时间戳</li>
<li><code>Using</code> - 创建一个与<em>Observable</em>具有相同寿命的一次性资源</li>
</ul>
<h2 id="条件和布尔Operator"><a href="#条件和布尔Operator" class="headerlink" title="条件和布尔Operator"></a>条件和布尔<em>Operator</em></h2><p>评估一个或多个<em>Observable</em>或<em>Observable</em>产生的项</p>
<ul>
<li><code>All</code> - 确定是否所有的<em>Observable</em>产生项符合标准</li>
<li><code>Amb</code> - 有两个或者多个源<em>Observable</em>，只对其中的第一个<em>Observable</em>产生其项</li>
<li><code>Contains</code> - 确定<em>Observable</em>是否包含一个特殊的项</li>
<li><code>DefaultIfEmpty</code> - 从源<em>Observable</em>产生项，如果为空，则产生默认项</li>
<li><code>SequenceEqual</code> - 确定是否两个<em>Observable</em>产生同样的项序列</li>
<li><code>SkipUntil</code> - 丢弃一个<em>Observable</em>所有的产生项，直到第二个<em>Observable</em>产生了项</li>
<li><code>SkipWhile</code> - 丢弃一个<em>Observable</em>所有产生项，直到某个特定条件不成立</li>
<li><code>TakeUntil</code> - 当第二个<em>Observable</em>产生了项，第一个<em>Observable</em>丢弃所有的产生项</li>
<li><code>TakeWhile</code> - 当某个特定条件不成立，<em>Observable</em>丢弃所有的产生项</li>
</ul>
<h2 id="数学与聚合Operator"><a href="#数学与聚合Operator" class="headerlink" title="数学与聚合Operator"></a>数学与聚合<em>Operator</em></h2><p>操作<em>Observable</em>所有产生项的序列的<em>Operator</em></p>
<ul>
<li><code>Average</code> - 计算<em>Observable</em>所有产生项的平均值，并产生这个平均值</li>
<li><code>Concat</code> - 拼接两个或者多个<em>Observable</em></li>
<li><code>Count</code> - 计算源<em>Observable</em>产生的项的个数，并产生这个值</li>
<li><code>Max</code> - 确定并产生<em>Observable</em>产生值中的最大值</li>
<li><code>Min</code> - 确定并产生<em>Observable</em>产生值中的最小值</li>
<li><code>Reduce</code> - 对<em>Observable</em>产生的每个项应用函数变换，并且有序的产生最终变换结果</li>
<li><code>Sum</code> - 计算<em>Observable</em>所有产生项的和，并产生这个和的值</li>
</ul>
<h2 id="Connectable-Observable-Operator"><a href="#Connectable-Observable-Operator" class="headerlink" title="Connectable Observable Operator"></a><em>Connectable Observable Operator</em></h2><p>特殊的<em>Observable</em>具有更多的动态的精确控制的订阅方式。</p>
<ul>
<li><code>Connect</code> - 指示一个可连接的<em>Observable</em>开始产生项到它的订阅者</li>
<li><code>Publish</code> - 转化一个普通的<em>Observable</em>为一个可连接的<em>Observable</em></li>
<li><code>RefCount</code> - 使一个可链接的<em>Observable</em>的行为跟普通的<em>Observable</em>一样</li>
<li><code>Replay</code> - 确保所有观察者看到的产生项序列一样，即使它们在<em>Observable</em>产生项以后才订阅</li>
</ul>
<h2 id="Blocking-Observable-Operator"><a href="#Blocking-Observable-Operator" class="headerlink" title="Blocking Observable Operator"></a><em>Blocking Observable Operator</em></h2><ul>
<li><code>To</code> - 将<em>Observable</em>转化为其他对象或者数据结构</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 响应式编程 </category>
            
            <category> rxjava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rxjava </tag>
            
            <tag> reactivex </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> frp </tag>
            
            <tag> Operator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveX 之 Observable]]></title>
      <url>http://linfuyan.com/reactivex-observable/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">http://reactivex.io/documentation/observable.html</a></p>
<p>对译文有建议，请发邮件或下方评论给我，万分感谢。</p>
</blockquote>
<blockquote>
<p>更新历史：1月13日</p>
</blockquote>
<p>在RxJava中一个对象实现了<em>Observer</em>接口则被一个<em>Observable</em>类对象所订阅。订阅者则针对<em>Obserable</em>对象产生的值（包括项及项的序列）做响应。这种模式便利了异步操作，因为不用在等待<em>Obserable</em>产生对象时进行阻塞，它以订阅者的形式创建了一个哨兵，用于在<em>Observable</em>在将来的时间产生任何输出时提供合适的响应。</p>
<p>这篇文章解释什么是响应式模式以及什么是<em>Observable</em>与观察者(观察者怎样对<em>Observable</em>进行订阅)。</p>
<blockquote>
<p>文档中的解释将采用”marble diagrams”的形式。下图说明”marble diagrams”怎样展示<em>Observable</em>以及<em>Observable</em>之间的转换。</p>
<p><img src="http://reactivex.io/assets/operators/legend.png" alt="Observables"></p>
</blockquote>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在许多软件编程任务中，你或多或少都希望自己编写的代码能够逐步的运行完成，因为你是一个一个的写下来的。但是在响应式编程范式中，许多代码并行的执行，其结果将在后来被观察者以任意的顺序捕获下来。在这种情况下，你不是调用一个方法，而是以<em>Observable</em>的形式为获取和转换数据定义一种机制，并将<em>Observable</em>订阅给订阅者。在预置的机制下当<em>Observable</em>产生的值到达时，观察者的哨兵捕获并对此进行响应。</p>
<p>这种解决方案的优点在于，当你有许多没有相互依赖的任务需要运行时，你可以在同一时刻启动它们，而不是需要在一个任务开始之前，等待其中的一个任务的结束。这样，你执行所有任务的所花费的时间只是其中耗时最长的任务的时间。</p>
<p>有许多种形式来描述这种异步编程和设计的模型。这篇文档将使用下面的形式：<em>Subscriber</em>(有时是<em>Observer</em>)订阅<em>Observable</em>类对象。也就是<em>Subscriber</em>对象订阅<em>Observable</em>。<em>Observable</em>产生值，并通过调用<em>Subscriber</em>的方法来发送通知给<em>Subscriber</em>。</p>
<p>在其他文档或者上下文，有时我们也会将<em>Subscriber</em>称为<em>watcher</em>或<em>reactor</em>。这个模型通常被被认为是<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">响应模式</a>。</p>
<h1 id="建立订阅者"><a href="#建立订阅者" class="headerlink" title="建立订阅者"></a>建立订阅者</h1><p>这篇文档通常使用Groovy来做代码示例，实际上，你可以在任何基于JVM的语言上使用RxJava，如Clojure，Scala，JRuby或是Java本身。</p>
<p>与典型的响应式编程中无序的异步、并行不同，在传统的方法调用中，流程一般是这样的：</p>
<ol>
<li>调用一个方法。</li>
<li>将方法的返回值保存在一个变量中。</li>
<li>使用这个变量以及它的新值做一些有用的事情。</li>
</ol>
<p>或是用代码表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// make the <span class="keyword">call</span>, assign its <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">to</span> <span class="string">`returnVal`</span></span><br><span class="line">returnVal = someMethod(itsParameters);</span><br><span class="line">// <span class="keyword">do</span> something useful <span class="keyword">with</span> returnVal</span><br></pre></td></tr></table></figure>
<p>在异步模型中，流程则更像是这样：</p>
<ol>
<li>定义一个方法来使用异步调用的返回值进行处理，这个方法是<em>Subscriber</em>的一部分。</li>
<li>用一个<em>Observable</em>类对象来定义异步调用本身。</li>
<li>通过订阅来将<em>Subscriber</em>关联<em>Observable</em>(这也同时初始化方法调用)。</li>
<li>继续你的业务逻辑；无论方法调用何时返回，<em>Subscriber</em>的方法开始对<em>Observable</em>所产生的项(返回值)进行操作。</li>
</ol>
<p>用代码表示是这样：</p>
<figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defines, but does not invoke, the Subscriber's onNext handler</span></span><br><span class="line"><span class="comment">// (in this example, the Subscriber is very simple and has only an onNext handler)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myOnNext</span> </span>= &#123; it -&gt; do something useful <span class="keyword">with</span> it &#125;;</span><br><span class="line"><span class="comment">// defines, but does not invoke, the Observable</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myObservable</span> </span>= someObservable(itsParameters);</span><br><span class="line"><span class="comment">// subscribes the Subscriber to the Observable, and invokes the Observable</span></span><br><span class="line">myObservable.subscribe(myOnNext);</span><br><span class="line"><span class="comment">// go on about my business</span></span><br></pre></td></tr></table></figure>
<h1 id="onNext-onCompleted-以及onError"><a href="#onNext-onCompleted-以及onError" class="headerlink" title="onNext,onCompleted,以及onError"></a>onNext,onCompleted,以及onError</h1><p><code>subscribe()</code>方法可以接受1-3个方法，或者是一个<code>Subscriber</code>对象，或是任何实现了<code>Observer</code>接口（包含了这3个方法）的对象：</p>
<p><strong>onNext</strong>:当<em>Observable</em>产生了一个值时，<em>Observable</em>将调用它的<em>Subscriber</em>上的这个方法。这个方法将<em>Observable</em>所产生的值作为它的参数。</p>
<p><strong>onError</strong>:当<em>Observable</em>无法产生所预期的数据或是遇到了其他一些错误，<em>Observable</em>将调用它的<em>Subscriber</em>上的这个方法。这会使<em>Observable</em>停止，且不再掉调用<code>onNext</code>和<code>onCompleted</code>。<code>onError</code>将产生错误的误差指示作为它的参数。</p>
<p><strong>onCompleted</strong>:在没有发生任何错误的情形下，<em>Observable</em>将在最后一次调用<code>onNext</code>之后调用其观察者的这个方法。</p>
<p>一个更加完整的<code>subscribe()</code>示例如下所示：</p>
<figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myOnNext</span>     </span>= &#123; item -&gt; <span class="comment">/* do something useful with item */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myError</span>      </span>= &#123; throwable -&gt; <span class="comment">/* react sensibly to a failed call */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myComplete</span>   </span>= &#123; <span class="comment">/* clean up after the final response */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myObservable</span> </span>= someMethod(itsParameters);</span><br><span class="line">myObservable.subscribe(myOnNext, myError, myComplete);</span><br><span class="line"><span class="comment">// go on about my business</span></span><br></pre></td></tr></table></figure>
<h1 id="Unsubscribing-退订"><a href="#Unsubscribing-退订" class="headerlink" title="Unsubscribing(退订)"></a>Unsubscribing(退订)</h1><p>在一些响应式扩展实现中，有专门的观察者接口，<code>Subscriber</code>来实现<code>unsubscribe()</code>方法。你可以调用这个方法来表明<em>Subscriber</em>不再对当前订阅的任何<em>Observable</em>感兴趣了。当不再有其他对其感兴趣的<em>Observer</em>，这些<em>Observable</em>可以选择停止产生新的值。</p>
<p>这个退订的结果会级联的影响到<em>Observer</em>所订阅的<em>Observable</em>上的操作链，这将导致操作链上的每个链接都停止产生项目。但这个并无法保证立即发生，当不再有<em>Subscriber</em>关注这些产生的值时，在短时间内，<em>Observable</em>可能仍然会产生新的值。</p>
<h1 id="命名规范的注意事项"><a href="#命名规范的注意事项" class="headerlink" title="命名规范的注意事项"></a>命名规范的注意事项</h1><p>每一种特定语言的响应式扩展的实现都有自己的命名怪癖。这之间没有统一的命名标准，但在每个实现之间有许多的共性。</p>
<p>此外，在某些上下文中这些名称具有不同的含义，或者在一些特定的语言实现中显得尴尬。</p>
<p>举个例子：存在<code>onEvent</code>的命名模式(如：<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>)。在许多上下文中，这些命名表明的是被注册的事件处理器上的方法。在<em>ReactiveX</em>中，这些命名则表示事件处理器本身。</p>
<h1 id="“热”和”冷”Observable"><a href="#“热”和”冷”Observable" class="headerlink" title="“热”和”冷”Observable"></a>“热”和”冷”<em>Observable</em></h1><p><em>Observable</em>什么时候开始产生它的值序列呢？这个依赖于<em>Observable</em>。一个”热”的<em>Observable</em>将在它被新建之后便开始产生值，因此，任何订阅这种<em>Observable</em>的<em>Observer</em>将从这些序列的中间开始观察。另一方面，一个”冷”的<em>Observable</em>在开发产生值之前，会一直等待<em>Observer</em>订阅它。这样可以保证一个<em>Observer</em>看到从头开始的完整序列。</p>
<p>在响应式扩展的某些实现中，存在称为<em>Connectable</em>的<em>Observable</em>。这样的<em>Observable</em>直到它的<code>connect</code>方法被调用才开始产生值，不能是否有<em>Observer</em>已经订阅它。</p>
<h1 id="组装Observable-Operator"><a href="#组装Observable-Operator" class="headerlink" title="组装Observable Operator"></a>组装<em>Observable Operator</em></h1><p><em>Observable</em>和<em>Observer</em>仅仅是响应式扩展的开始。它是标准观察者模式的轻量扩展，比起一个简单的回调，它更适合与处理事件序列。</p>
<p>响应式扩展的真正力量在于，所有的<em>Operator</em>可以被变换，组合，操作，并和<em>Observable</em>所产生的值序列一起工作。</p>
<p>这些响应式扩展操作能让你通过利用所有回调的优点，以声明的方式将异步序列组织在一起。同时避免传统异步编程系统中的嵌套回调处理。</p>
<p>该文章将不同的操作及他们的示例用户组织在如下的页面中：</p>
<ul>
<li><a href="">Creating创建</a></li>
<li><a href="">Transforming变换</a></li>
<li><a href="">Filtering过滤</a></li>
<li><a href="">Combining组合</a></li>
<li><a href="">Error Handling错误处理</a></li>
<li><a href="">Utility工具</a></li>
<li><a href="">Conditional and Boolean条件与布尔</a></li>
<li><a href="">Mathematical and Aggregate</a></li>
<li><a href="">Backpressure</a></li>
<li><a href="">Connectable Observables</a></li>
<li><a href="">Blocking Observables</a></li>
</ul>
<p>这些页面所包含的信息一些操作并不是响应式扩展的核心组成部分，但却是一些特定语言的实现或是可选模块。</p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 响应式编程 </category>
            
            <category> rxjava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rxjava </tag>
            
            <tag> reactivex </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> frp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出 RxJava (二、操作符)]]></title>
      <url>http://linfuyan.com/grokking-rxjava-part-2/</url>
      <content type="html"><![CDATA[<p>在<a href="http://www.linfuyan.com/grokking-rxjava-part-1" target="_blank" rel="noopener">第一篇博客</a>中，我介绍了 RxJava 的一些基础知识，同时也介绍了 map() 操作符。当然如果你并没有意愿去使用 RxJava 我一点都不诧异，毕竟才接触了这么点儿。看完这篇博客，我相信你肯定想立即在你的项目中使用 RxJava 了，这边博客将介绍许多 RxJava 中的操作符， RxJava 的强大性就来自于它所定义的操作符。</p>
<a id="more"></a>
<p>首先先看一个例子：</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>假设我有这样的一个方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法根据输入的字符串返回一个网站的 url 列表</span></span><br><span class="line">Observable&lt;List&lt;<span class="keyword">String</span>&gt;&gt; query(<span class="keyword">String</span> <span class="built_in">text</span>);</span><br></pre></td></tr></table></figure>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇博客的内容，我们可能会写出下面的代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">query</span>(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="selector-class">.subscribe</span>(urls -&gt; &#123;</span><br><span class="line">        <span class="selector-tag">for</span> (String <span class="attribute">url </span>: urls) &#123;</span><br><span class="line">            <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个 URL，只能在 Subscriber 中来做。我们竟然没有使用如此酷的 map() 操作符！！！</p>
<p>当然，我可以使用 map 操作符，map 的输入是 urls 列表，处理的时候还是要 for each 遍历，一样很蛋疼。</p>
<h3 id="万幸的是"><a href="#万幸的是" class="headerlink" title="万幸的是"></a>万幸的是</h3><p>我们有 Observable.from() 方法，它接收一个集合作为输入，然后每次输出一个元素给 subscriber：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.<span class="keyword">from</span>(<span class="string">"url1"</span>, <span class="string">"url2"</span>, <span class="string">"url3"</span>)</span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>我们来把这个方法使用到刚才的场景：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="keyword">subscribe(urls </span>-&gt; &#123;</span><br><span class="line">        Observable.from(urls)</span><br><span class="line">            .<span class="keyword">subscribe(url </span>-&gt; System.out.println(url))<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>虽然去掉了 for each 循环，但是代码依然看起来很乱。多个嵌套的 subscription 不仅看起来很丑，难以修改，更严重的是它会破坏我们现在还没有讲到的 RxJava 的特性。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>救星来了，他就是 flatMap()。</p>
<p>Observable.flatMap() 接收了一个 Observable 的输出作为输入，同时输出另外一个 Observable。直接看代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;, Observable&lt;<span class="built_in">String</span>&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public Observable&lt;<span class="built_in">String</span>&gt; call(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; urls) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(urls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用 lambda 可以大大简化代码长度：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">query</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>!")</span><br><span class="line">    <span class="selector-class">.flatMap</span>(<span class="selector-tag">urls</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">Observable</span><span class="selector-class">.from</span>(<span class="selector-tag">urls</span>))</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">url</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">url</span>));</span><br></pre></td></tr></table></figure>
<p>flatMap() 是不是看起来很奇怪？为什么它要返回另外一个 Observable 呢？理解 flatMap 的关键点在于，flatMap 输出的新的 Observable 正是我们在 Subscriber 想要接收的。现在 Subscriber 不再收到 List<string>，而是收到一系列单个的字符串，就像 Observable.from() 的输出一样。</string></p>
<p>这部分也是我当初学 RxJava 的时候最难理解的部分，一旦我突然领悟了， RxJava 的很多疑问也就一并解决了。</p>
<h3 id="还可以更好"><a href="#还可以更好" class="headerlink" title="还可以更好"></a>还可以更好</h3><p>flatMap() 实在不能更赞了，它可以返回任何它想返回的 Observable 对象。</p>
<p>比如下面的方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网站的标题，如果404了返回null</span></span><br><span class="line">Observable&lt;<span class="keyword">String</span>&gt; getTitle(<span class="keyword">String</span> URL);</span><br></pre></td></tr></table></figure>
<p>接着前面的例子，现在我不想打印 URL 了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个 URL，并且返回值不是一个 String，而是一个输出 String 的 Observable 对象。使用 flatMap() 可以简单的解决这个问题。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;<span class="keyword">String</span>, Observable&lt;<span class="keyword">String</span>&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> Observable&lt;<span class="keyword">String</span>&gt; call(<span class="keyword">String</span> url) &#123;</span><br><span class="line">            <span class="built_in">return</span> getTitle(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(title -&gt; System.out.<span class="built_in">println</span>(title));</span><br></pre></td></tr></table></figure>
<p>使用 lambda：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))</span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));</span><br></pre></td></tr></table></figure>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回 Observable 对象的方法组合在一起！帅呆了！</p>
<p>不止这些，我还将两个 API 的调用组合到一个链式调用中了。我们可以将任意多个 API 调用链接起来。大家应该都应该知道同步所有的 API 调用，然后将所有 API 调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了 callback hell （多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h3 id="丰富的操作符"><a href="#丰富的操作符" class="headerlink" title="丰富的操作符"></a>丰富的操作符</h3><p>目前为止，我们已经接触了两个操作符， RxJava 中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？</p>
<p>getTitle() 返回 null 如果 url 不存在。我们不想输出 “null”，那么我们可以从返回的 title 列表中过滤掉 null 值！</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))</span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)</span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));</span><br></pre></td></tr></table></figure>
<p>filter() 输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))</span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));</span><br></pre></td></tr></table></figure>
<p>take() 输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(urls -&gt;</span> Observable.from(urls))</span><br><span class="line">    .<span class="function"><span class="title">flatMap</span>(url -&gt;</span> getTitle(url))</span><br><span class="line">    .<span class="function"><span class="title">filter</span>(<span class="built_in">title</span> -&gt;</span> <span class="built_in">title</span> != null)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .<span class="function"><span class="title">doOnNext</span>(<span class="built_in">title</span> -&gt;</span> saveTitle(<span class="built_in">title</span>))</span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(<span class="built_in">title</span> -&gt;</span> System.out.println(<span class="built_in">title</span>));</span><br></pre></td></tr></table></figure>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava 包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了 RxJava 的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇博客不打算讲自定义操作符，如果你想的话，请自行 Google 吧。</p>
<h3 id="感觉如何？"><a href="#感觉如何？" class="headerlink" title="感觉如何？"></a>感觉如何？</h3><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava 也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个 API，对 API 返回的数据进行了处理，然后保存到磁盘。但是我们的 Subscriber 并不知道这些，它只是认为自己在接收一个 Observable<string> 对象。良好的封装性也带来了编码的便利！</string></p>
<p>在第三部分中，我将介绍 RxJava 的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
<p>原文链接：<a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="noopener">Grokking RxJava, Part 2: Operator, Operator</a><br>译文来源：<a href="http://http://blog.csdn.net/lzyzsd/article/details/44094895" target="_blank" rel="noopener">深入浅出RxJava（二：操作符）</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 响应式编程 </category>
            
            <category> rxjava </category>
            
            <category> 深入浅出RxJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rxjava </tag>
            
            <tag> reactivex </tag>
            
            <tag> rxandroid </tag>
            
            <tag> 反应式编程 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成]]></title>
      <url>http://linfuyan.com/continuous-integration-of-ios-application-with-jenkins-git-cocoapods-fir.im/</url>
      <content type="html"><![CDATA[<p>本文说明如何在 Mac OSX 环境下，使用 Jenkins 对基于 CocoaPods 进行依赖管理的 iOS 项目做自动打包与持续集成，并将最终的安装包发布到 fir.im 上供下载。</p>
<h4 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h4><ol>
<li>实现 iOS 项目自动打包，需要有 Mac OSX 环境。本文中使用的是一台普通的 Mac mini，并安装 Mac OSX 10.10 Yosemite。</li>
<li>本文中使用的自动打包脚本依赖于 <code>xcodebuild</code> 及 <code>xcrun</code>，故需要确保安装 Xcode，并且系统中安装有 Xcode 的命令行工具。具体命令行如何打包，可以查看 <a href="http://" target="_blank" rel="noopener">iOS 命令行打包</a></li>
<li>本文中代码的版本控制工具使用 Git。Mac OSX 安装完成 Xcode 以后自带 Git，故不用另外安装。</li>
<li>iOS 项目使用 CocoaPods 进行依赖管理，故 Mac OSX 需要安装 CocoaPods。具体可以查看 <a href="http://" target="_blank" rel="noopener">CocoaPods 使用</a></li>
<li>需要确保 Jenkins 服务器所在的机器上拥有对应的证书和 Profile 文件，才能够顺利打包。什么是证书和 Profile 文件，可以查看 <a href="http://" target="_blank" rel="noopener">iOS 证书和 Profile 文件</a></li>
<li>在 Mac OSX 下安装并配置好 Jenkins。Jenkins 的安装不在本文论述范围内，具体可以查看 <a href="http://" target="_blank" rel="noopener">Mac OSX 安装 Jenkins</a></li>
<li>Jenkins 配置好相关插件，本文中使用到 <code>Git plugin</code>， <code>Git client plugin</code>， <code>Xcode integration</code> 等插件。如何安装 Jenkins 插件，可以查看 <a href="http://" target="_blank" rel="noopener">Jenkins 插件安装</a></li>
<li>本文中代码所使用的文件目录结构如下。不同的文档结构会对 Jenkins 中嵌入的 Shell 脚本造成影响。即在实际项目源码位于根目录再下一级目录。</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Art				<span class="string">//</span> 项目目录</span><br><span class="line">    |<span class="params">--Art</span>		<span class="string">//</span> 实际项目源码目录</span><br><span class="line">    	|<span class="params">--Art</span></span><br><span class="line">    	|<span class="params">--project</span>.xcdoeproj</span><br><span class="line">    	|<span class="params">--project</span>.xcworkspace</span><br><span class="line">    	|<span class="params">--Podfile</span></span><br><span class="line">    	|--<span class="string">...</span></span><br><span class="line">    |<span class="params">--bin</span>			<span class="string">//</span> 存放部分二进制文件的目录，实际中并未使用</span><br><span class="line">    |<span class="params">--doc</span>			<span class="string">//</span> 本项目相关的文档目录</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>使用具有配置权限的用户登录 Jenkins，选择”新建”，”构建一个自由风格的软件项目”，并确定。这里新建了一个名为 <code>iOS-project-ci</code> 的 job。</p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-1.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<h3 id="配置构建基本信息"><a href="#配置构建基本信息" class="headerlink" title="配置构建基本信息"></a>配置构建基本信息</h3><p>填写相关 job 的信息，如名称、描述。</p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-2.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>可以选择构建过程，并进行一些设置。这里选择”参数化构建过程”，添加一个 <code>Text Parameter</code>，并做相关设置。</p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-3.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-4.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>高级项目选项，本文中没有做任何设置。</p>
<h3 id="配置项目源码"><a href="#配置项目源码" class="headerlink" title="配置项目源码"></a>配置项目源码</h3><p>源码管理中选择 Git，配置仓库地址，认证账户，需要构建的分支等。</p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-5.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>根据项目需要构建触发器，本文中没有做任何设置，项目的构建由用户手动触发。</p>
<h3 id="配置构建过程"><a href="#配置构建过程" class="headerlink" title="配置构建过程"></a>配置构建过程</h3><h4 id="配置-CocoaPods"><a href="#配置-CocoaPods" class="headerlink" title="配置 CocoaPods"></a>配置 CocoaPods</h4><p>由于本文中项目代码目录没有在根目录下，且使用 CocoaPods 进行依赖管理，故先增加一个 Shell 脚本的构建步骤。</p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-6.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>其中 <code>cd Art</code> 是进入到 Podfile 文件所在目录，即实际项目源码目录。 <code>pod install</code> 用于更新实际项目的源码依赖。完整的 pod 更新可能会很好使，可以考虑 <code>pod install --no-repo-update</code></p>
<h4 id="配置-Xcode-integration"><a href="#配置-Xcode-integration" class="headerlink" title="配置 Xcode integration"></a>配置 Xcode integration</h4><p>新增 Xcode integration 构建过程</p>
<p><strong>基础配置</strong></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-7.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<ol>
<li>本文的项目中使用 <code>workspace</code>， 所以 Target 可以不填。</li>
<li>Configuration 是在 Xcode 中的配置，默认有 Debug 和 Release，这里的 InHouse 为我自己在项目中的配置，使用企业签名的对应用进行打包。</li>
<li>将应用打包成 .ipa 文件。</li>
<li>这里设置 .ipa 文件的名称。其中 $BUILD_NUMBER 为 Jenkins 提供的系统变量，为当前的构建版本号。</li>
<li>这里设置 构建过程输出目录。其中 $WORKSPACE 为 Jenkins 提供的系统变量，为构建根目录。</li>
</ol>
<p><strong>代码签名及密钥配置</strong></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-8.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>本文中采用在 Xcode 项目中新增共享 scheme 的方式，在 scheme 内部对代码签名和 Profile 做了配置，同时 Jenkins 所在的 Mac OSX 中有对应的证书和 Profile，所以1，2中不需要做特殊配置，如果配置，将替换 scheme中的配置。</p>
<p>在打包的过程中，命令会由于系统的安全设置提醒输入密码，3中可以设置密钥所在路径及系统用户密码。</p>
<blockquote>
<p>具体如何新增共享 scheme 及配置，可以查看<a href="http://" target="_blank" rel="noopener">iOS 配置 scheme 和 configuration</a></p>
</blockquote>
<p><strong>Xcode 高级构建配置</strong></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-9.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<ol>
<li>这里的 <code>Art-Ci</code> 就是我在 Xcode 项目中新建的 scheme。</li>
<li>本文中的项目包含有 workspace，这里设置对应路径，注意不需要带上 .xcworkspace 后缀。</li>
<li>Xcode 项目所在目录</li>
<li>Xcode 项目文件，这里需要带上 .xcodeproj 后缀。</li>
<li>设置构建输出目录。</li>
</ol>
<h4 id="发布到-fir-im"><a href="#发布到-fir-im" class="headerlink" title="发布到 fir.im"></a>发布到 fir.im</h4><p>添加一个 Shell 构建步骤，输入如下命令：</p>
<p><code>fir p $WORKSPACE/build/art_$BUILD_NUMBER.ipa -c &quot;$release_note&quot;</code></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-10.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>这里发布到 fir.im，使用了其官方提供的 fir-cli 工具。 <code>$WORKSPACE/build/art_$BUILD_NUMBER.ipa</code> 获取到最终打包的 .ipa 文件路径， $release_note 为我们在”带参数构建”中添加的参数。 fir-cli 的使用，具体查看<a href="http://blog.fir.im/fir_cli/" target="_blank" rel="noopener">官方工具 fir-cli 使用说明</a></p>
<p>完成以上配置，应用并保存配置。</p>
<h4 id="添加其他构建后步骤"><a href="#添加其他构建后步骤" class="headerlink" title="添加其他构建后步骤"></a>添加其他构建后步骤</h4><p>可以在构建完成以后，配置邮件通知等操作以便及时将构建结果通知到相应的人员。</p>
<h4 id="启动构建"><a href="#启动构建" class="headerlink" title="启动构建"></a>启动构建</h4><p><img src="http://img.uprogrammer.cn/iOS-project-ci-11.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p><img src="http://img.uprogrammer.cn/iOS-project-ci-12.png" alt="Jenkins、Git、CocoaPods、Fir.im 实现 iOS 应用持续集成"></p>
<p>设置参数，点击”开始构建”，构建过程便被触发。如果构建成功，最终 iOS 应用将被发布到 fir.im 上，并进行访问。例如，本文中的项目最终可以通过 <a href="http://fir.im/yiwai" target="_blank" rel="noopener">http://fir.im/yiwai</a> 来访问并下载安装。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> jenkins </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> jenkins </tag>
            
            <tag> git </tag>
            
            <tag> cocoapods </tag>
            
            <tag> fir.im </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出 RxJava (一、基础篇)]]></title>
      <url>http://linfuyan.com/grokking-rxjava-part-1/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 正在 Android 开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现 RxJava 真是太棒了。</p>
<p>这里仅仅是帮助你了解 RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解 RxJava 背后的思想，并且喜欢上 RxJava。</p>
<a id="more"></a>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>RxJava 最核心的两个东西是 Observables （被观察者，事件源）和 Subscribers （观察者）。 Observables 发出一系列事件，Subscribers 处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web接口调用返回的数据。。。）</p>
<p>一个 Observable 可以发出零个或者多个事件，直到结束或者出错。每发出一个事件，就会调用它的 Subscriber 的 onNext 方法，最后调用 Subscriber.onNext() 或者 Subscriber.onError() 结束。</p>
<p>Rxjava 的看起来很像设计模式中的观察者模式，但是有一点明显不同，那就是如果一个 Observerble 没有任何的 Subscriber，那么这个 Observable 是不会发出任何事件的。</p>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>创建一个 Observable 对象很简单，直接调用 Observable.create 即可。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; myObservable = Observable.create(</span><br><span class="line">    new Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber&lt;? super String&gt; <span class="function"><span class="keyword">sub</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">sub</span>.<span class="title">onNext</span></span>("Hello, world!");</span><br><span class="line">            <span class="function"><span class="keyword">sub</span>.<span class="title">onCompleted</span></span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里定义的 Observable 对象仅仅发出一个 Hello World 字符串，然后就结束了。接着我们创建一个 Subscriber 来处理 Observable 对象发出的字符串。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; mySubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里 subscriber 仅仅就是打印 observable 发出的字符串。通过 subscribe 函数就可以将我们定义的 myObservable 对象和 mySubscriber 对象关联起来，这样就完成了 subscriber 对 observable 的订阅。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(mySubscriber)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>一旦 mySubscriber 订阅了 myObservable， myObservable 就是调用 mySubscriber 对象的 onNext 和 onComplete 方法，mySubscriber 就会打印出 Hello World！</p>
<h4 id="更简洁的代码"><a href="#更简洁的代码" class="headerlink" title="更简洁的代码"></a>更简洁的代码</h4><p>是不是觉得仅仅为了打印一个 hello world 要写这么多代码太啰嗦？我这里主要是为了展示 RxJava 背后的原理而采用了这种比较啰嗦的写法，RxJava 其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化 Observable 对象的创建过程。RxJava 内置了很多简化创建 Observable 对象的函数，比如 Observable.just 就是用来创建只发出一个事件就结束的 Observable 对象，上面创建 Observable 对象的代码可以简化为一行。</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Observable</span>&lt;String&gt; myObservable = <span class="keyword">Observable</span>.just(<span class="string">"Hello, world!"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来看看如何简化 Subscriber，上面的例子中，我们其实并不关心 OnComplete 和 OnError，我们只需要在 onNext 的时候做一些处理，这时候就可以使用 Action1 类。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;<span class="keyword">String</span>&gt; onNextAction = <span class="keyword">new</span> Action1&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>subscribe 方法有一个重载版本，接受三个 Action1 类型的参数，分别对应 OnNext， OnComplete， OnError 函数。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(<span class="keyword">on</span>NextAction, <span class="keyword">on</span>ErrorAction, <span class="keyword">on</span>CompleteAction);</span><br></pre></td></tr></table></figure>
<p>这里我们并不关心 onError 和 onComplete，所以只需要第一个参数就可以</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(onNextAction)<span class="comment">;</span></span><br><span class="line">// Outputs <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码最终可以写成这样：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">              System.out.<span class="built_in">println</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 java8 的 lambda 可以使代码更简洁。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>!")</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">s</span>));</span><br></pre></td></tr></table></figure>
<p>Android 开发中，强烈推荐使用<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="noopener">retrolambda</a>这个 gradle 插件，这样你就可以在你的代码中使用 lambda 了。</p>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>让我们做一些更有趣的事情吧！<br>比如我想在 hello world 中加上我的签名，你可能会想到去修改 Observable 对象：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>! <span class="selector-tag">-Dan</span>")</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">s</span>));</span><br></pre></td></tr></table></figure>
<p>如果你能够改变 Observable 对象，这当然是可以的，但是如果你不能修改 Observable 对象呢？比如 Observable 对象是第三方库提供的？比如我的 Observable 对象被多个 Subscriber 订阅，但是我只想在对某个订阅者做修改呢？<br>那么在 Subscriber 中对事件进行修改怎么样呢？比如下面的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>!")</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">s</span> + " <span class="selector-tag">-Dan</span>"));</span><br></pre></td></tr></table></figure>
<p>这种方式仍然不能让人满意，因为我希望我的 Subscribers 越轻量越好，因为我有可能会在 mainThread 中运行 subscriber。另外，根据响应式函数编程的概念， Subscribers 更应该做的事情是“响应”，响应 Observable 发出的事件，而不是去修改。如果我能在某些中间步骤中对 “Hello World！” 进行变换是不是很酷？</p>
<h3 id="操作符（Operators）"><a href="#操作符（Operators）" class="headerlink" title="操作符（Operators）"></a>操作符（Operators）</h3><p>操作符就是为了解决对 Observable 对象的变换的问题，操作符用于在 Observable 和最终的 Subscriber 之间修改 Observable 发出的事件。RxJava 提供了很多很有用的操作符。</p>
<p>比如 map 操作符，就是用来把把一个事件转换为另一个事件的。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">  .<span class="built_in">map</span>(<span class="keyword">new</span> Func1&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">String</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">          <span class="built_in">return</span> s + <span class="string">" -Dan"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(s -&gt; System.out.<span class="built_in">println</span>(s));</span><br></pre></td></tr></table></figure>
<p>使用 lambda 可以简化为：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="function"><span class="title">map</span>(s -&gt;</span> s + <span class="string">" -Dan"</span>)</span><br><span class="line">    .<span class="function"><span class="title">subscribe</span>(s -&gt;</span> System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>是不是很酷？ map() 操作符就是用于变换 Observable 对象的， map 操作符返回一个 Observable 对象，这样就可以实现链式调用，在一个 Observable 对象上多次使用 map 操作符，最终将最简洁的数据传递给 Subscriber 对象。</p>
<h4 id="map操作符进阶"><a href="#map操作符进阶" class="headerlink" title="map操作符进阶"></a>map操作符进阶</h4><p>map 操作符更有趣的一点是它不必返回 Observable 对象返回的类型，你可以使用 map 操作符返回一个发出新的数据类型的 observable 对象。</p>
<p>比如上面的例子中，subscriber 并不关心返回的字符串，而是想要字符串的 hash 值。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="built_in">map</span>(<span class="literal">new</span> Func1&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">Integer</span> call(<span class="built_in">String</span> s) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(i -&gt; System.out.println(<span class="built_in">Integer</span>.toString(i)));</span><br></pre></td></tr></table></figure>
<p>很有趣吧？我们初始的 Observable 返回的是字符串，最终的 Subscriber 收到的却是 Integer，当然使用 lambda 可以进一步简化代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>!")</span><br><span class="line">    <span class="selector-class">.map</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">s</span><span class="selector-class">.hashCode</span>())</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">i</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">Integer</span><span class="selector-class">.toString</span>(<span class="selector-tag">i</span>)));</span><br></pre></td></tr></table></figure>
<p>前面说过，Subscriber 做的事情越少越好，我们再增加一个 map 操作符：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Observable</span><span class="selector-class">.just</span>("<span class="selector-tag">Hello</span>, <span class="selector-tag">world</span>!")</span><br><span class="line">    <span class="selector-class">.map</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">s</span><span class="selector-class">.hashCode</span>())</span><br><span class="line">    <span class="selector-class">.map</span>(<span class="selector-tag">i</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">Integer</span><span class="selector-class">.toString</span>(<span class="selector-tag">i</span>))</span><br><span class="line">    <span class="selector-class">.subscribe</span>(<span class="selector-tag">s</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">s</span>));</span><br></pre></td></tr></table></figure>
<h3 id="不服？"><a href="#不服？" class="headerlink" title="不服？"></a>不服？</h3><p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1. Observable 和 Subscriber 可以做任何事情。</p>
<p>Observable 可以是一个数据库查询， Subscriber 用来显示查询结果； Observable 可以是屏幕上的点击事件， Subscriber 用来响应点击事件； Observable 可以是一个网络请求， Subscriber 用来显示请求结果。</p>
<p>2. Observable 和 Subscriber 是独立于中间的变换过程的。</p>
<p>在 Observable 和 Subscriber 中间可以增减任何数量的 map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>
<p>原文链接：<a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/" target="_blank" rel="noopener">Grokking RxJava, Part 1: The Basics</a><br>译文来源：<a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="noopener">深入浅出RxJava（一：基础篇）</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 响应式编程 </category>
            
            <category> rxjava </category>
            
            <category> 深入浅出RxJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> rxjava </tag>
            
            <tag> reactivex </tag>
            
            <tag> rxandroid </tag>
            
            <tag> 反应式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生成 SSH 密钥]]></title>
      <url>http://linfuyan.com/generating-ssh-keys/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/800px-SSH_Communications_Security_logo.svg.png" alt="生成 SSH 密钥"></p>
<p>Git 仓库可以通过 git:// 来访问，目前类似 Github，Gitcafe，Coding等基于 Git 的托管服务都提供有配置 SSH 密钥，来访问托管仓库的功能。本文中将通过为 Github 账号配置 SSH 密钥来访问仓库为例，说明 SSH 密钥配置过程。</p>
<p>SSH 密钥是用于识别信任的电脑的一种方式，可以免去输入密码。下面的步骤将带你生成一个 SSH 密钥，并将其添加到你的 Github 账号。</p>
<a id="more"></a>
<h2 id="步骤1：检查-SSH-密钥"><a href="#步骤1：检查-SSH-密钥" class="headerlink" title="步骤1：检查 SSH 密钥"></a>步骤1：检查 SSH 密钥</h2><p>首先，需要检查电脑上是否有已经存在的 SSH 密钥。打开终端并输入：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> -al ~<span class="string">/.ssh</span></span><br><span class="line"><span class="comment"># Lists the files in your .ssh directory, if they exist</span></span><br></pre></td></tr></table></figure>
<p>查看文件夹中列出的文件中是否已经有 SSH 公钥。默认情况下，公钥的文件名会是下面中的一个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> id_dsa.pub</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> id_ecdsa.pub</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> id_ed25519.pub</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> id_rsa.pub</span></span><br></pre></td></tr></table></figure>
<p>如果你看到列出的文件已经存在一对公钥和私钥(如：id_rsa.pub 和 id_rsa)，而你打算用来连接 Github，那么可以跳过步骤2，直接查看步骤3。</p>
<blockquote>
<p>提示：如果你收到一个 ~/.ssh 不存在的错误，别担心，我们在步骤2中将创建它。</p>
</blockquote>
<h2 id="步骤2：生成新的-SSH-密钥"><a href="#步骤2：生成新的-SSH-密钥" class="headerlink" title="步骤2：生成新的 SSH 密钥"></a>步骤2：生成新的 SSH 密钥</h2><p>1、继续打开终端，复制并粘贴下面的文本。确保用你的 Github 邮箱替换掉其中的地址。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="comment"># Creates a new ssh key, using the provided email as a label</span></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair.</span></span><br></pre></td></tr></table></figure>
<p>2、强烈建议保持默认设置，因此你在被提示”输入文件以保存密钥”时，直接按<strong>回车</strong>继续：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure>
<p>3、提示输入口令：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): [<span class="keyword">Type</span> <span class="type">a </span>passphrase]</span><br><span class="line"># Enter same passphrase again: [<span class="keyword">Type</span> <span class="type">passphrase </span>again]</span><br></pre></td></tr></table></figure>
<p>4、输口令以后，你将得到一个 SSH 密钥的指纹或者<code>ID</code>。看起来像这样：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Your</span> <span class="selector-tag">identification</span> <span class="selector-tag">has</span> <span class="selector-tag">been</span> <span class="selector-tag">saved</span> <span class="selector-tag">in</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">you</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span>.</span><br><span class="line"># <span class="selector-tag">Your</span> <span class="selector-tag">public</span> <span class="selector-tag">key</span> <span class="selector-tag">has</span> <span class="selector-tag">been</span> <span class="selector-tag">saved</span> <span class="selector-tag">in</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">you</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span>.</span><br><span class="line"># <span class="selector-tag">The</span> <span class="selector-tag">key</span> <span class="selector-tag">fingerprint</span> <span class="selector-tag">is</span>:</span><br><span class="line"># <span class="selector-tag">01</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:f4</span><span class="selector-pseudo">:3b</span><span class="selector-pseudo">:ca</span><span class="selector-pseudo">:85</span><span class="selector-pseudo">:d6</span><span class="selector-pseudo">:17</span><span class="selector-pseudo">:a1</span><span class="selector-pseudo">:7d</span><span class="selector-pseudo">:f0</span><span class="selector-pseudo">:68</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:f0</span><span class="selector-pseudo">:a2</span><span class="selector-pseudo">:db</span> <span class="selector-tag">your_email</span>@<span class="selector-tag">example</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>
<h2 id="步骤3：添加密钥到-ssh-agent"><a href="#步骤3：添加密钥到-ssh-agent" class="headerlink" title="步骤3：添加密钥到 ssh-agent"></a>步骤3：添加密钥到 ssh-agent</h2><p>配置 ssh-agent 程序来使用 SSH 密钥，可以避免每次被提示输入口令：</p>
<p>1、确保 ssh-agent 是可用的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start the ssh-agent in the background</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line"><span class="comment"># Agent pid 59566</span></span><br></pre></td></tr></table></figure>
<p>2、添加密钥到 ssh-agent</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-<span class="keyword">add</span><span class="bash"> ~/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：如果你在步骤2中没有生成新的 SSH 密钥，而是使用已经存在的密钥，那你需要替换上面命令中的 id_rsa 为你已经存在的私钥文件的名称。</p>
</blockquote>
<h2 id="步骤4：添加-SSH-密钥到你的账号"><a href="#步骤4：添加-SSH-密钥到你的账号" class="headerlink" title="步骤4：添加 SSH 密钥到你的账号"></a>步骤4：添加 SSH 密钥到你的账号</h2><p>配置你的 Github 账号来使用 SSH 密钥：</p>
<p>复制 SSH 密钥到剪贴板，记住你可能将密钥命名为 id_dsa.pub， id_ecdsa.pub 或者 id_ed25519.pub，那么需要修改下列命令中的文件名：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br><span class="line"><span class="comment"># Copies the contents of the id_rsa.pub file to your clipboard</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：也可以直接用文本编辑器等打开公钥文件，然后复制其中的内容。</p>
<p>警告：在复制过程中一定不能添加任何新行或者空格。</p>
</blockquote>
<p>添加复制的密钥到 Github：</p>
<p>1、找到账户管理，点击其中的“设置”。</p>
<p>2、找到 SSH 密钥，点击添加 SSH 密钥。</p>
<p>3、在标题输入框中添加新密钥的描述文本。例如，如果你在使用个人的 Mac，可以设置密钥名称为 “Personal MacBook Air”。</p>
<p>4、在密钥输入框中粘贴刚才复制的密钥。</p>
<p>5、点击添加。</p>
<p>6、输入 Github 账号密码来确认。</p>
<h2 id="步骤5：测试连接"><a href="#步骤5：测试连接" class="headerlink" title="步骤5：测试连接"></a>步骤5：测试连接</h2><p>为了确保一切工作正常，接下来将 SSH 到 Github。这么做的时候，你需要使用密码来验证。这个密码就是你之前创建的 SSH 密钥的口令。</p>
<p>1、打开终端并输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Attempts to ssh to GitHub</span></span><br></pre></td></tr></table></figure>
<p>2、第一次你将看到下面的警告：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host 'github.com (<span class="number">207.97</span><span class="number">.227</span><span class="number">.239</span>)' can't be established.</span><br><span class="line"><span class="comment"># RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="comment"># Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
<p>核实你看到的消息中的指纹，并输入: <code>yes</code>：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span></span><br><span class="line"><span class="comment"># provide shell access.</span></span><br></pre></td></tr></table></figure>
<p>3、如果出现上面的信息，并且用户是你 ，那么你的 SSH 密钥就安装成功了。如果你收到了关于 <code>access denied</code> 的消息，那么就是失败了，那么请确认前面的步骤，重新来过。</p>
<p>以上为 Mac 平台生成 SSH 密钥的步骤，Windows、Linux 平台略有不同。</p>
<p>原文链接：<a href="https://help.github.com/articles/generating-ssh-keys/#platform-mac" target="_blank" rel="noopener">Generating SSH keys</a></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> ssh </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS App 生命周期]]></title>
      <url>http://linfuyan.com/lifecycle-of-an-ios-application/</url>
      <content type="html"><![CDATA[<p>对于iOS应用程序，关键的是要知道你的应用程序是否正在前台或后台运行。由于系统资源在iOS设备上较为有限，一个应用程序必须在后台与前台有不同的行为。操作系统也会限制你的应用程序在后台的运行，以提高电池寿命，并提高用户与前台应用程序的体验。当应用程序在前台和后台之间切换时，操作系统将会通知您的应用程序。你可以通过这些通知来修改你的应用程序的行为。</p>
<p>当你的应用程序在前台活动时，系统会发送触摸事件给它进行处理。在UIKit的基础设施做了大部分的事件传递给你的自定义对象工作。所有您需要做的是覆盖在相应的对象的方法来处理这​​些事件。对于控件，UIKit会通过处理你的触摸事件，或者其他一些有趣的事情发生时调用您的自定义代码，比如当文本字段中的值更改。</p>
<a id="more"></a>
<h4 id="1-应用程序的状态"><a href="#1-应用程序的状态" class="headerlink" title="1. 应用程序的状态"></a>1. 应用程序的状态</h4><p><code>Not running</code> (未运行)：程序没启动。</p>
<p><code>Inactive</code>(未激活)：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</p>
<p><code>Active</code>(激活)：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。</p>
<p><code>Backgroud</code>(后台)：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<p><code>Suspended</code>(挂起)：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
<p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-1.png" alt="iOS 应用生命周期"></p>
<h4 id="2-各个程序运行状态时代理的回调"><a href="#2-各个程序运行状态时代理的回调" class="headerlink" title="2. 各个程序运行状态时代理的回调"></a>2. 各个程序运行状态时代理的回调</h4><p><strong>2.1 告诉代理进程启动但还没进入状态保存</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"①告诉代理进程启动但还没进入状态保存"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.2 告诉代理启动基本完成程序准备开始运行</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"②告诉代理启动基本完成程序准备开始运行"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.window.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.3 当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    // Sent when the application is about <span class="keyword">to</span> move <span class="keyword">from</span> active <span class="keyword">to</span> inactive <span class="keyword">state</span>. This can occur <span class="keyword">for</span> certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the <span class="keyword">user</span> quits the application and it begins the transition <span class="keyword">to</span> the background <span class="keyword">state</span>.</span><br><span class="line">    // Use this method <span class="keyword">to</span> pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method <span class="keyword">to</span> pause the game.</span><br><span class="line">    NSLog(@<span class="string">"③当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.4 当应用程序进入活动状态执行</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">applicationDidBecomeActive</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"④当应用程序进入活动状态执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.5 当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    // Use this method <span class="keyword">to</span> release shared resources, save <span class="keyword">user</span> data, invalidate timers, and store enough application <span class="keyword">state</span> information <span class="keyword">to</span> restore your application <span class="keyword">to</span> its current <span class="keyword">state</span> <span class="keyword">in</span> case it is terminated later.</span><br><span class="line">    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the <span class="keyword">user</span> quits.</span><br><span class="line">    NSLog(@<span class="string">"⑤当程序被推送到后台的时候调用"</span>);</span><br><span class="line">    </span><br><span class="line">    [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"begin Background Task With Expiration Handler"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.6 当程序从后台将要重新回到前台时候调用</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">applicationWillEnterForeground</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"⑥当程序从后台将要重新回到前台时候调用"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.7 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置UIApplicationExitsOnSuspend的键值</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">applicationWillTerminate</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span></span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"⑦当程序将要退出是被调用"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.8 当程序载入后执行</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>applicationDidFinishLaunching:<span class="params">(UIApplication *)</span>application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"⑧当程序载入后执行"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序启动时：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:55</span><span class="selector-pseudo">:14.706</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ①告诉代理进程启动但还没进入状态保存</span><br><span class="line"></span><br><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:55</span><span class="selector-pseudo">:14.708</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ②告诉代理启动基本完成程序准备开始运行</span><br><span class="line"></span><br><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:55</span><span class="selector-pseudo">:14.709</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ④当应用程序进入活动状态执行</span><br></pre></td></tr></table></figure>
<p>按下Home键返回主界面：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:56</span><span class="selector-pseudo">:11.756</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ③当应用程序将要入非活动状态执行</span><br><span class="line"></span><br><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:56</span><span class="selector-pseudo">:11.814</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ⑤当程序被推送到后台的时候调用</span><br></pre></td></tr></table></figure>
<p>再次打开程序：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:57</span><span class="selector-pseudo">:19.200</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ⑥当程序从后台将要重新回到前台时候调用</span><br><span class="line"></span><br><span class="line">2014<span class="selector-tag">-07-01</span> 15<span class="selector-pseudo">:57</span><span class="selector-pseudo">:19.201</span> <span class="selector-tag">LifeCycle</span><span class="selector-attr">[5845:60b]</span> ④当应用程序进入活动状态执行</span><br></pre></td></tr></table></figure>
<h4 id="3-加载应用程序进入前台"><a href="#3-加载应用程序进入前台" class="headerlink" title="3. 加载应用程序进入前台"></a>3. 加载应用程序进入前台</h4><p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-2.png" alt="iOS 应用生命周期"></p>
<h4 id="4-加载应用程序进入后台"><a href="#4-加载应用程序进入后台" class="headerlink" title="4. 加载应用程序进入后台"></a>4. 加载应用程序进入后台</h4><p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-3.png" alt="iOS 应用生命周期"></p>
<h4 id="5-基于警告式响应中断"><a href="#5-基于警告式响应中断" class="headerlink" title="5. 基于警告式响应中断"></a>5. 基于警告式响应中断</h4><p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-4.png" alt="iOS 应用生命周期"></p>
<p>当出现这种中断时，我们需要在<code>- (void)applicationWillResignActive:(UIApplication *)application</code> 方法中进行如下操作：</p>
<ol>
<li><p>停止timer 和其他周期性的任务</p>
</li>
<li><p>停止任何正在运行的请求</p>
</li>
<li><p>暂停视频的播放</p>
</li>
<li><p>如果是游戏那就暂停它</p>
</li>
<li><p>减少OpenGL ES的帧率</p>
</li>
<li><p>挂起任何分发的队列和不重要的操作队列（你可以继续处理网络请求或其他时间敏感的后台任务）</p>
</li>
</ol>
<p>当程序回到active状态，我们需要在<code>- (void)applicationDidBecomeActive:(UIApplication *)application</code> 方法中重新开始上述任务。不过游戏要回到暂停状态，不能自动开始。</p>
<h4 id="6-进入后台运行"><a href="#6-进入后台运行" class="headerlink" title="6. 进入后台运行"></a>6. 进入后台运行</h4><p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-5.png" alt="iOS 应用生命周期"></p>
<p>当应用程序进入后台时，我们应该做些什么？</p>
<p>保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死。</p>
<p>释放尽可能释放的内存。</p>
<p><code>- (void)applicationDidEnterBackground:(UIApplication *)application</code> 方法有大概5秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。</p>
<p>如果还需要长时间的运行任务，可以在该方法中调用</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">application</span> beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(<span class="name">@</span><span class="string">"begin Background Task With Expiration Handler"</span>)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">    &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>应用程序在后台时的内存使用：请求后台运行时间和启动线程来运行长时间运行的任务。</p>
<p>在后台时，每个应用程序都应该释放最大的内存。系统努力的保持更多的应用程序在后台同时 运行。不过当内存不足时，会终止一些挂起的程序来回收内存，那些内存最大的程序首先被终止。</p>
<p>事实上，应用程序应该的对象如果不再使用了，那就应该尽快的去掉强引用，这样编译器可以回收这些内存。如果你想缓存一些对象提升程序的性能，你可以在进入后台时，把这些对象去掉强引用。</p>
<p>下面这样的对象应该尽快的去掉强引用：</p>
<ol>
<li><p>图片对象</p>
</li>
<li><p>你可以重新加载的 大的视频或数据文件</p>
</li>
<li><p>任何没用而且可以轻易创建的对象</p>
</li>
</ol>
<p>在后台时，为了减少程序占用的内存，系统会自动在回收一些系统帮助你开辟的内存。比如：</p>
<ol>
<li><p>系统回收Core Animation的后备存储。</p>
</li>
<li><p>去掉任何系统引用的缓存图片</p>
</li>
<li><p>去掉系统管理数据缓存强引用</p>
</li>
</ol>
<h4 id="7-返回前台运行"><a href="#7-返回前台运行" class="headerlink" title="7. 返回前台运行"></a>7. 返回前台运行</h4><p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-6.png" alt="iOS 应用生命周期"></p>
<p>在暂停状态的应用程序必须准备处理任何排队的通知时，它返回到前台或后台执行状态。暂停的应用程序不执行任何代码，因此不能处理与方向的变化，时间的变化，偏好的变化，以及许多其他会影响应用程序的外观或状态的通知。为了确保这些更改不会丢失，系统排队许多相关的通知，并把它们传递给应用程序，只要它开始再次执行代码（无论是在前景或背景）。为了防止由偏快转为超载与它恢复时通知您的应用程序，该系统凝聚事件，并提供一个单一的通知（每个相关类型），反映了净变化，因为你的应用程序被暂停。</p>
<h4 id="8-程序终止"><a href="#8-程序终止" class="headerlink" title="8. 程序终止"></a>8. 程序终止</h4><p>程序只要符合以下情况之一，只要进入后台或挂起状态就会终止：</p>
<ol>
<li><p>iOS4.0以前的系统</p>
</li>
<li><p>app是基于iOS4.0之前系统开发的。</p>
</li>
<li><p>设备不支持多任务</p>
</li>
<li><p>在Info.plist文件中，程序包含了 <code>UIApplicationExitsOnSuspend</code> 键。</p>
</li>
</ol>
<p>app如果终止了，系统会调用app的代理的方法 <code>- (void)applicationWillTerminate:(UIApplication *)application</code>，这样可以让你可以做一些清理工作。你可以保存一些数据或app的状态。这个方法也有5秒钟的限制。超时后方法会返回程序从内存中清除。</p>
<p>注意：用户可以手工关闭应用程序。</p>
<h4 id="9-The-Main-Run-Loop-主运行循环"><a href="#9-The-Main-Run-Loop-主运行循环" class="headerlink" title="9. The Main Run Loop 主运行循环"></a>9. The Main Run Loop 主运行循环</h4><p>Main Run Loop负责处理用户相关的事件。UIApplication对象在程序启动时启动main run Loop，它处理事件和更新视图的界面。看Main Run Loop就知道，它是运行在程序的主线程上的。这样保证了接收到用户相关操作的事件是按顺序处理的。 </p>
<p>用户操作设备，相关的操作事件被系统生成并通过UIKit的指定端口分发。事件在内部排成队列，一个个的分发到Main run loop 去做处理。UIApplication对象是第一个接收到时间的对象，它决定事件如何被处理。触摸事件分发到主窗口，窗口再分发到对应出发触摸事件的View。其他的事件通过其他途径分发给其他对象变量做处理。 </p>
<p>大部分的事件可以在你的应用里分发，类似于触摸事件，远程操控事件（线控耳机等）都是由app的 responder objects 对象处理的。Responder objects 在你的app里到处都是，比如：UIApplication 对象，view对象，view controller 对象，都是resopnder objects。大部分事件的目标都指定了resopnder object，不过事件也可以传递给其他对象。比如，如果view对象不处理事件，可以传给父类view或者view controller。</p>
<p><img src="http://img.uprogrammer.cn/ios-app-lifecycle-7.png" alt="iOS 应用生命周期"></p>
<p>英文原文：<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/ManagingYourApplicationsFlow/ManagingYourApplicationsFlow.html#//apple_ref/doc/uid/TP40007072-CH4-SW20" target="_blank" rel="noopener">App States and Multitasking</a><br>译文出处：<a href="http://www.cnblogs.com/EverNight/p/3818570.html" target="_blank" rel="noopener">iOS App的生命周期</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 应用程序 </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个成功的 Git 分支模型]]></title>
      <url>http://linfuyan.com/a-successful-git-branching-model/</url>
      <content type="html"><![CDATA[<p>原文来自：<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a><br>译文来自：<a href="http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/" target="_blank" rel="noopener">一个成功的 Git 分支模型</a></p>
<p>这是作者在2010年5月的一篇博文，作者所处的团队进行了一系列的 Git 实践，并总结出文章中的 Git 工作流，再到后来基于此开发了 Git 工作流工具 Git flow，在现在看来，对于初接触 Git 的团队仍然是绝好的指导。</p>
<hr>
<p>本文中我会展示一种开发模型，一年前该模型就已经被我用在所有的项目中（包括工作中的项目和私有项目），结果是非常成功的。我早就想为此写点东西，可直到现在才有时间。本文不会讲述任何项目的细节，只会涉及到分支策略和发布管理。</p>
<a id="more"></a>
<p><img src="http://img.uprogrammer.cn/git-branch-1.png" alt="一个成功的 Git 分支模型"></p>
<p>本文使用 Git 作为所有源码的版本控制工具。</p>
<h2 id="为什么是-Git？"><a href="#为什么是-Git？" class="headerlink" title="为什么是 Git？"></a>为什么是 Git？</h2><p>要全面了解 Git 与其它集中式版本控制系统相比的优劣，可以参考这个页面。这方面的争论可谓是硝烟弥漫。作为一个开发者，所有这些工具中我最钟情于 Git。Git 的的确确改变了人们考虑合并及分支的方式。在我之前所处的经典 CVS/Subversion 世界中，合并/分支总是被认为是有点可怕的事情（“小心合并冲突，丫会恶心到你”），因此你只应偶尔干这种事情。</p>
<p>但有了 Git，这类事情就变得非常简单，分支及合并甚至被认为是你日常版本控制操作的核心之一。例如，在 CVS/Subversion 的书中，分支及合并往往在后面的章节才被介绍（针对高级用户），但在每一本 Git 的书中，该内容已经在前3章中介绍（基础）。</p>
<p>简单及易重复性带来的好处就是，分支及合并变得不再可怕。版本控制工具本该帮助我们方便的进行和分支及合并操作。</p>
<p>简单介绍下工具后，让我们来看开发模型。我讲介绍的模型本质上只是一组步骤，每个团队成员都必须遵循这些步骤以形成一个可靠管理的软件开发过程。</p>
<h3 id="去中心化但仍保持中心化"><a href="#去中心化但仍保持中心化" class="headerlink" title="去中心化但仍保持中心化"></a>去中心化但仍保持中心化</h3><p>在这个分支模型中我们使用的，且被证实工作得很好的仓库配置，其核心是一个中心“真理”仓库。注意只有该仓库才被认为是中心库（由于 Git 是 DVCS [分布式版本控制系统]，在技术层面没有中心库这一东西）。之后我们用 origin 指代该仓库，因为大多数 Git 用户都熟悉这个名称。</p>
<p><img src="http://img.uprogrammer.cn/git-branch-2.png" alt="一个成功的 Git 分支模型"></p>
<p>每个开发者都对 origin 做 push 和 pull 操作。不过除了这种中心化的 push-pull 关系外，每个开发者还可以从其他开发者或者小组处 pull 变更。例如，可能两个或更多的开发者一起开发一个大的特性，在往 origin 永久性的 push 工作代码之前，他们之间可以执行一些去中心化的操作。在上图中，分别有 Alice 和 Bob、Alice 和 David、Clair 和 David这些小组。</p>
<p>从技术上来说，这仅仅是 Alice 定义一个 Git remote，名字为 bob，指向 Bob 的仓库，反过来也一样。</p>
<h3 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h3><p>此开发模型的核心主要受现有的模型启发。中心仓库包含了两个主要分支，这两个分支的寿命是无限的：</p>
<ul>
<li>master</li>
<li>develop</li>
</ul>
<p><img src="http://img.uprogrammer.cn/git-branch-3.png" alt="一个成功的 Git 分支模型"></p>
<p>每个 Git 用于都应该熟悉 origin 上的 master 分支。与 master 分支平行存在的，是另外一个名为 develop 的分支。</p>
<p>我们认为 origin/develop 分支上的 HEAD 源码反映了开发过程中最新的提交变更。有人会称之为“集成分支”。该分支是自动化每日构建的代码源。</p>
<p>当 develop 分支上的源码到达一个稳定的状态时，就可以发布版本。所有 develop 上的变更都应该以某种方式合并回 master 分支，并且使用发布版本号打上标签。稍后我们会讨论具体操作细节。</p>
<p>因此，每次有变化被合并到 master 分支时，根据定义这就是一次新的产品版本发布。我们趋向于严格遵守该规范，所以理论上来说，每次 master 有提交时，我们都可以使用一个 Git 钩子（hook）脚本来自动构建并部署软件至产品环境服务器。</p>
<h3 id="支持性分支"><a href="#支持性分支" class="headerlink" title="支持性分支"></a>支持性分支</h3><p>紧接着主要分支 master 和 develop，我们的开发模型使用多种支持性分支来帮助团队成员间实现并行开发、追踪产品特性、准备产品版本发布、以及快速修复产品问题。与主要分支不同的是，这些分支的寿命是有限的，它们最终都会被删除。</p>
<p>我们会用到的分支有这几类：</p>
<ul>
<li>特性分支（feature branch）</li>
<li>发布分支（release branch）</li>
<li>热补丁分支（hotfix branch）</li>
</ul>
<p>上述每种分支都有特定的用途，它们各自关于源自什么分支、合并回什么分支，都有严格的规定。稍后我们逐个进行介绍。</p>
<p>从技术角度来说，这些分支一点都不“特殊”。分支按照我们对其的使用方式进行分类。技术角度它们都一样是平常的 Git 分支。</p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>可能的分支来源：develop<br>必须合并回：develop<br>分支命令约定：任何除 master, develop, <code>release-*</code>, 或 <code>hotfix-*</code> 以外的名称</p>
<p>特性分支（有时也被称作 topic 分支）是用来为下一发布版本开发新特性。当开始开发一个特性的时候，该特性会成为哪个发布版本的一部分，往往还不知道。特性分支的重点是，只要特性还在开发，该分支就会一直存在，不过它最终会被合并回 develop 分支（将该特性加入到发布版本中），或者被丢弃（如果试验的结果令人失望）。</p>
<p><img src="http://img.uprogrammer.cn/git-branch-4.png" alt="一个成功的 Git 分支模型"></p>
<p>特性分支往往只存在于开发者的仓库中，而不会出现在 origin。</p>
<h4 id="创建一个特性分支"><a href="#创建一个特性分支" class="headerlink" title="创建一个特性分支"></a>创建一个特性分支</h4><p>开始开发新特性的时候，从 develop 分支创建特性分支。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> myfeature develop</span><br><span class="line">Switch to <span class="selector-tag">a</span> new branch “myfeature”</span><br></pre></td></tr></table></figure>
<h4 id="合并完成的特性回-develop"><a href="#合并完成的特性回-develop" class="headerlink" title="合并完成的特性回 develop"></a>合并完成的特性回 develop</h4><p>完成的特性应该被合并回 develop 分支以将特性加入到下一个发布版本中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switch to branch ‘develop’</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge –no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure>
<p>上述代码中的 –no-ff 标记会使合并永远创建一个新的 commit 对象，即使该合并能以 fast-forward 的方式进行。这么做可以避免丢失特性分支存在的历史信息，同时也能清晰的展现一组 commit 一起构成一个特性。比较下面的图：</p>
<p><img src="http://img.uprogrammer.cn/git-branch-5.png" alt="一个成功的 Git 分支模型"></p>
<p>在第2张图中，已经无法一眼从 Git 历史中看到哪些 commit 对象构成了一个特性——你需要阅读日志以获得该信息。在这种情况下，回退（revert）整个特性（一组commit）就会比较麻烦，而如果使用了 –no-diff 就会简单很多。</p>
<p>是的，这么做会造成一些（空的） commit 对象，但这么做是利大于弊的。</p>
<p>可惜的是，我没能找到方法让 –no-diff 成为默认的 git merge 行为参数，但其实应该这么做。</p>
<h3 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h3><p>可能的分支来源：develop<br>必须合并回：develop 和 master<br>分支命名约定：release-*</p>
<p>发布分支为准备新的产品版本发布做支持。它允许你在最后时刻检查所有的细节。此外，它还允许你修复小 bug 以及准备版本发布的元数据（例如版本号，构建日期等等）。在发布分支做这些事情之后，develop 分支就会显得比较干净，也方便为下一大版本发布接受特性。</p>
<p>从 develop 分支创建发布分支的时间通常是 develop 分支（差不多）能反映新版本所期望状态的时候。至少说，这是时候版本发布所计划的特性都已经合并回了 develop 分支。而未来其它版本发布计划的特性则不应该合并，它们必须等到当前的版本分支创建好之后才能合并。</p>
<p>正是在发布分支创建的时候，对应的版本发布才获得一个版本号——不能更早。在该时刻之前， develop 分支反映的是“下一版本”的相关变更，但不知道这“下一版本”到底会成为0.3还是1.0，直到发布分支被创建。版本号是在发布分支创建时，基于项目版本号规则确定的。</p>
<h4 id="创建一个发布分支"><a href="#创建一个发布分支" class="headerlink" title="创建一个发布分支"></a>创建一个发布分支</h4><p>发布分支从 develop 分支创建。例如，假设1.1.5是当前的产品版本，同时我们即将发布下个版本。develop 分支的状态已经是准备好“下一版本”发布了，我们也决定下个版本是1.2（而不是1.1.6或者2.0）。因此我们创建发布分支，并且为其赋予一个能体现新版本号的名称：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b</span> releases-<span class="number">1.2</span> develop</span><br><span class="line">Switched <span class="keyword">to</span> <span class="keyword">a</span> <span class="keyword">new</span> branch “release-<span class="number">1.2</span>”</span><br><span class="line">$ ./bump-<span class="keyword">version</span>.<span class="keyword">sh</span> <span class="number">1.2</span></span><br><span class="line">Files modified successfully. <span class="keyword">version</span> bumped <span class="keyword">to</span> <span class="number">1.2</span>.</span><br><span class="line">$ git commit -<span class="keyword">a</span> -<span class="keyword">m</span> “Bumped <span class="keyword">version</span> <span class="keyword">number</span> <span class="keyword">to</span> <span class="number">1.2</span>”</span><br><span class="line">[release-<span class="number">1.2</span> <span class="number">74</span>d9424] Bumped <span class="keyword">version</span> <span class="keyword">number</span> <span class="keyword">to</span> <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">files</span> changed. <span class="number">1</span> insertions(+). <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure>
<p>创建新分支并转到该分支之后，我们设定版本号。这里的 bump-version.sh 是一个虚构的 shell 脚本，它修改一些本地工作区的文件以体现新的版本号。（当然这也可以手动完成——这里只是说要有一些文件变更）接着，提交新版本号。</p>
<p>新的发布分支可能存在一段时间，直到该版本明确对外交付。这段时间内，该分支上可能会有一些 bug 的修复（而不是在 develop 分支上）。在该分支上添加新特性是严格禁止的。新特性必须合并到 develop 分支，然后等待下一个版本发布。</p>
<h4 id="结束一个发布分支"><a href="#结束一个发布分支" class="headerlink" title="结束一个发布分支"></a>结束一个发布分支</h4><p>当发布分支达到一个可以正式发布的状态时，我们就需要执行一些操作。首先，将发布分支合并至 master （记住，我们之前定义 master 分支上的每一个 commit 都对应一个新版本）。接着，master 分支上的 commit 必须被打上标签（tag），以方便将来寻找历史版本。最后，发布分支上的变更需要合并回 develop，这样将来的版本也能包含相关的 bug 修复。</p>
<p>前两步在 Git 中的操作：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch ‘<span class="literal">master</span>’</span><br><span class="line">$ git merge –no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>现在版本发布完成了，而且为未来的查阅提供了标签。</p>
<p><strong>提醒：</strong>你可能同时也会想要用 -s 或者 -u <key> 来对标签进行签名。</key></p>
<p>为了能保留发布分支上的变更，我们还需要将分支合并回 develop。在 Git 中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch ‘develop’</span><br><span class="line">$ git <span class="keyword">merge</span> –<span class="keyword">no</span>-ff <span class="keyword">release</span><span class="number">-1.2</span></span><br><span class="line"><span class="keyword">Merge</span> made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>这一操作可能会导致合并冲突（可能性还很大，因为我们改变了版本号）。如果发现，则修复之并提交。</p>
<p>现在工作才算真正完成了，最后一步是删除发布分支，因为我们已不再需要它：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">release</span><span class="number">-1.2</span></span><br><span class="line">Deleted branch <span class="built_in">release</span><span class="number">-1.2</span> (was ff452fe).</span><br></pre></td></tr></table></figure>
<h3 id="热补丁分支"><a href="#热补丁分支" class="headerlink" title="热补丁分支"></a>热补丁分支</h3><p>可能的分支来源：master<br>必须合并回：develop 和 master<br>分支命名约定：hotfix-*</p>
<p><img src="http://img.uprogrammer.cn/git-branch-6.png" alt="一个成功的 Git 分支模型"></p>
<p>热补丁分支和发布分支十分类似，它的目的也是发布一个新的产品版本，尽管是不在计划中的版本发布。当产品版本发现未预期的问题的时候，就需要理解着手处理，这个时候就要用到热补丁分支。当产品版本的重大 bug 需要立即解决的时候，我们从对应版本的标签创建出一个热补丁分支。</p>
<p>使用热补丁分支的主要作用是（ develop 分支上的）团队成员可以继续工作，而另外的人可以在热补丁分支上进行快速的产品 bug 修复。</p>
<h4 id="创建一个热补丁分支"><a href="#创建一个热补丁分支" class="headerlink" title="创建一个热补丁分支"></a>创建一个热补丁分支</h4><p>热补丁分支从 master 分支创建。例如，假设1.2是当前正在被使用的产品版本，由于一个严重的 bug，产品引起了很多问题。同时，develop 分支还处于不稳定状态，无法发布新的版本。这时我们可以创建一个热补丁分支，并在该分支上修复问题：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix<span class="number">-1.2</span><span class="number">.1</span> master</span><br><span class="line">Switched to a new branch “hotfix<span class="number">-1.2</span><span class="number">.1</span>″</span><br><span class="line">$ ./bump-version.sh <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span><span class="number">.1</span>.</span><br><span class="line">$ git commit -a -m “Bumped version number to <span class="number">1.2</span><span class="number">.1</span>″</span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> <span class="number">41e61</span>bb] Bumped version number to <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line"><span class="number">1</span> files <span class="section">changed</span>, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure>
<p>不要忘了在创建热补丁分之后设定一个新的版本号！</p>
<p>然后，修复 bug 并使用一个或者多个单独的 commit 提交。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m “Fixed severe production problem”</span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files <span class="section">changed</span>, <span class="number">32</span> insertions(+), <span class="number">17</span> deletions(-)</span><br></pre></td></tr></table></figure>
<h4 id="结束一个热补丁分支"><a href="#结束一个热补丁分支" class="headerlink" title="结束一个热补丁分支"></a>结束一个热补丁分支</h4><p>修复完成后，热补丁分支需要合并回 master，但同时它还需要被合并回 develop，这样相关的修复代码才会同时被包含在下个版本中。这与我们完成发布分支很类似。</p>
<p>首先，更新 master 分支并打上标签。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch ‘<span class="literal">master</span>’</span><br><span class="line">$ git merge –no-ff hotfix-<span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>提醒：</strong>你可能同时也会想要用 -s 或者 -u <key> 来对标签进行签名。</key></p>
<p>接着，将修复代码合并到 develop：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch ‘develop’</span><br><span class="line">$ git <span class="keyword">merge</span> –<span class="keyword">no</span>-ff hotfix<span class="number">-1.2</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">Merge</span> made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>这里还有个例外情况，如果这个时候有发布分支存在，热补丁分支的变更则应该合并至发布分支，而不是 develop。将热补丁合并到发布分支，也意味着当发布分支结束的时候，变更最终会被合并到 develop。（如果 develop 上的开发工作急需热补丁并无法等待发布分支完成，这时你也已经可以安全地将热补丁合并到 develop 分支。）</p>
<p>最后，删除临时的热补丁分支：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix<span class="number">-1.2</span><span class="number">.1</span></span><br><span class="line">Deleted branch hotfix<span class="number">-1.2</span><span class="number">.1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然这个分支模型中没有什么特别新鲜的东西，但本文起始处的“全景图”事实上在我们的项目中起到了非常大的作用。它帮助建立了优雅的，易理解的概念模型，使得团队成员能够快速建立并理解一个公用的分支和发布过程。</p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 工作流 </tag>
            
            <tag> 分支模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员真正的价值]]></title>
      <url>http://linfuyan.com/the-real-value-of-programmers/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/14064631_iVnR.jpg" alt="程序员真正的价值"></p>
<blockquote>
<p>问：池老师，我是个不爱互动的人，但是您所有的文章我都看了，非常感谢您的引导，我入手了人生第一台 MBP。现在问题来了，但是找不到更合适的人解答，只能求助于您了，如果您有时间的话。问题是这样的：我有个32bit unix file（开启一个服务进程），在 Mac 上执行时错误提示是：exec format error，但是在 Linux 服务器却可以执行，为何？Mac 上有可以运行的方案吗？期待您的回复，不胜感激。</p>
</blockquote>
<blockquote>
<p>答：Linux 和 OS X 是不同的操作系统，可以尝试在 OS X 里重新编译这个文件。</p>
</blockquote>
<blockquote>
<p>问：非常感谢！如果没有文件源码是不是就只能认命了？</p>
</blockquote>
<blockquote>
<p>答：可以在 Mac 上装 Docker，然后对服务进行端口映射就可以了。</p>
</blockquote>
<blockquote>
<p>答：茅塞顿开。谢池老师。</p>
</blockquote>
<p>以上是我和一位读者的对话，这位小伙子在拿到答案之后像一缕烟尘一样消失无踪，之后再也没有出现过。</p>
<a id="more"></a>
<p>在微信上加了很多 MacTalk 的读者之后，经常会收到一些奇奇怪怪的问题，关于职场、关于选择、关于朋友、关于 Mac、关于技术等等，不一而足。但是我能回答的却很少。问题不好没法回答，问题太复杂没法回答，问题领域超出我的认知也没法回答，耗时太长的问题我也没 时间回答，实在是惭愧的紧。好在偶尔也能够帮助一些小伙伴解决一些实际问题，心理上略感安慰，比如上面这个问题。</p>
<p>把这段程序员之间的对话翻译一下，大致是这么个故事：</p>
<p>一位读者有一个32位的 Unix 可执行文件，可以在某种版本的 Linux 服务器上正常运行，运行这个文件作用就是起个进程，开端口，然后与其他程序进行交互。但是这个文件拿到 Mac 上完全没办法运行。就在他趴在 Mac 上愁肠百结万念俱灰的时候，突然想到了「池老师」。不就是这个老家伙把 Mac 夸的像一朵玫瑰一样，让每个程序员都去采摘么？现在扎手了，你不管谁管？于是他给我发来消息，意思就是管也得管，不管也得管，您看着办。</p>
<p>我拿到问题一看，不难。Linux 和 OS X 虽然师出同门，都是从老前辈 Unix 那儿毕业的，但是后来毕竟各练各的，在 Linux 编译好的程序不可能在 OS X 上用，但是在 OS X 上重新编译一下可能就没事了。我把这个想法告诉了这位程序员，得到的反馈是：对不起哥，没有源代码！</p>
<p>我被这个冷酷的回复震惊了，立刻意识到刚才的想法并不是最优解决方案，因为在重新编译的过程中，各种包的依赖关系和编译错误足以让你焦头烂额，我随即提供了 B 计划：在 OS X 上安装 Docker，轻量级的容器 Docker 可以运行各种版本的 Linux，把文件扔到 Docker 里，然后通过主机和 Docker 之间的端口映射即可轻松解决这一问题。</p>
<p>虽然这里面会涉及很多技术细节，但是方向是没有问题的，所以这位程序员立刻表示「茅塞顿开」，然后「biu」的一声就在屏幕对面消失了，没有留给我说「不客气」的机会。</p>
<p>这个问题装个 Linux 虚拟机也可以解决，但是虚拟机过于耗费资源，而且不如 Docker 灵活，所以不是最佳解决方案。Docker 是。</p>
<p>做为一个程序员，我们除了要掌握多门程序语言和多种数据库，了解前端技术、后端技术，通晓网络七层架构，知道 TCP/IP三次握手和四次挥手，编写漂亮的代码，设计优美的架构… 之外，我们还要解决研发、程序运行和产品上线过程中遇到的各种问题，而且被要求以最 小的代价来解决问题… 我们容易吗？</p>
<p>除了编程技巧和程序设计能力，解决问题的稳准狠是衡量一个程序员是否优秀的重要因素之一，也是资深技术 人员真正的价值所在。在科技浪潮澎湃、技术信息扑面而来的今天，一位刚毕业的大学生如果足够勤奋，他可以在两三个月之内掌握一门编程语言，并编写出像模像 样的软件，他们的学习速度甚至超过了我们这些老程序员，但是解决问题的能力是无法速成的，只能依靠时间、经验和惨痛的教训历练而成。有时候还需要灵感和运气。</p>
<p>很多军迷读了大量的军事著作和历史小说，常常羡慕那些名将的风采，并浩叹自己「生不逢时」。但是名将不是那么容易炼成的。历史上叱诧风 云的名将凤毛麟角，他们亲自持刀上阵追击敌人，见识战场的惨烈，目睹敌人的尸体，看到战友被杀，知道被刀看中会流血死去，他们冷酷无情，坚如磐石，在全军即将崩溃的时候发现敌人的弱点并进行攻击，在瞬息万变的战场进行决断，在多次失败后从无数士兵的尸体里站起来重新出发去挑战那个战胜你的对手，在所有人对你说「指导员，我们上吧」的时候，坚定的说出那三个字：再等等！</p>
<p>如果你做不到这些，那还是做个最终会被张飞枪挑的小兵吧。</p>
<p>优秀的程序员同样如此，菜鸟常常羡慕高手在谈笑之间让难题灰飞烟灭，而自己却苦苦思索而不得入门之法，殊不知这些高手同样经历了名将的那些腥风血雨。他们在 清晨的微光里编写代码，在轰鸣的机房中调试程序，他们彻夜不眠就是为了解决一个 bug，他们要承受数据丢失或上线失败的痛苦，默默吞下眼泪，准备下一次的战斗。不停的学习、实践和思索，成千上万个小时之后，高手史成。</p>
<p>同样的问题，高手的解决思路和小球是截然不同的。一般来说，只要不是世界难题，给足时间、空间和人力，都能解决。如果你遇到问题告诉上级，这个问题交给我了，两年之内搞的妥妥哒，那就不要怪项目组组团把你打出翔来，因为大家要的是分分钟解决，不是两年。在这个唯快不破的年代，我们没有这么多的时间，所以要通过逆向思维、经验教训、辗转腾挪、借力打力等方式以最小的代价快速解决问题。这才是老程序员的价值。</p>
<p>再举个例子，一个运行良好的线上应用在你修改 bug 增加功能之后重新上线出现了一些莫名其妙的问题，比如占用资源增加或运行一段时间宕机等等，怎么解决？</p>
<p>常规的做法就是通过阅读日志、模拟线上环境和调试程序来定位错误。容易的 bug 用这些方式基本就能搞定了，但是更隐蔽的 bug 会耗费大量的时间和人力。更好的方式是什么？</p>
<p>首先，排查是程序问题还是环境问题，把线上程序恢复到运行正常时的老版本，如果出现了同样的问题，那就是生产环境发生了改变。如果运行正常，要么是你修改老 bug 时引入了新 bug，要么是新增加的代码出现了问题。</p>
<p>其次，阅读产品的 changelog，根据代码提交的时间线构建系统，通过二分法排查，定位是哪部分代码引起的问题。</p>
<p>第三，排除了所有的不可能，剩下的无论看起来如何不可能，就是它干的。</p>
<p>以上只是一个简单的例子，实际的情况可能比这个例子复杂一百倍，需要我们综合使用各种方式进行交叉比对和错误排查才能解决。这仅仅是遇到问题解决问题，更多的时候是需要你提出问题，并解决问题，那是更高的境界。</p>
<p>很多人学了那么多编程语言，写了十几年程序，最终依然无法做到以最小的代价解决问题，不禁让人扼腕叹息。</p>
<p>程序员真正的价值是什么？以最小的代价解决问题！知行合一，方可无敌于天下。</p>
<p>原文作者：池建强 (微信公众号：MacTalk)</p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> 价值 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何辨认身边的聪明人？]]></title>
      <url>http://linfuyan.com/how-to-identify-smart-people-around-you/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/cmr.jpg" alt="如何辨认身边的聪明人？"></p>
<p>谢邀。</p>
<p>我来谈一下个人分辨周围聪明人的一些主要标准。</p>
<p>首先要明确的是一些基本原则。</p>
<p><strong>首先，具有特定领域的专业知识不代表聪明。</strong>比如一个下水道工人和一个挖掘机工人，各自都是各自职业领域的老手，哪个更聪明？这就不好说了。所以分辨的标准不应该是针对特定领域的，而应该是普适的。</p>
<p><strong>再比如看学历，也不一定靠谱。</strong>我们抛开盖茨、乔布斯这些辍学的不谈，一个本科生和一个博士生哪个聪明？这也不好说，说不定本科生本科期间就做出了不错的科研成果，但是本科毕业没有继续做科研而直接去工作了，那他一定比博士生笨或者聪明吗？说不准的。</p>
<p><strong>还有比如看出身，也不靠谱。</strong>因为个人经历和交友圈的关系，我周围的很多朋友都是名校出身，北清复交牛剑HYPS什么的很多，很多聚会上名校学生的数量远比非名校的多，那这种情况下出身本身就不具有太大的分辨性。虽然名校出来的普遍会让人觉得聪明点（具体原因可以参考下文），但是即使是同一个学校出来的人，也会有很容易被识别出来的聪明程度的差别。</p>
<a id="more"></a>
<p>那么我会通过什么来辨别聪明人呢？我有<strong>六个标准，两两一组分为基础指标，现实指标，和高层指标三个类别。基础、现实、高层的分类不是想说明轻重和高低，只是为了方便大家理解。</strong></p>
<p><strong>基础指标的第一个标准，是元认知（Metacognition）能力。</strong></p>
<blockquote>
<p>元认知能力，就是“对于认知的认知”和“关于知识的知识”，简单来说就是对于自我的认知过程的思考。关于元认知，网上有不少资料，大家可以通过搜索引擎找一下通俗的材料，感兴趣的也可以找相关的心理学文献读一下。</p>
<p>具有强元认知能力的人，通常表现是学习能力很强，因为他们对于自己的认知和学习过程很了解，能够在快速的自我思考和自省后产生出优化过的学习策略。</p>
<p>他们对自己的认知能力有较强的管控能力，懂得利用自己的认知能力的优势和已有知识框架来调节和评估新知识的摄入，这些人能够很快的把新知识融入到已有的知识当中。<strong>用乔布斯的话说，就是把已经划出的点连起来，而元认知能力高的人连得特别快。</strong></p>
</blockquote>
<p><strong>基础指标的第二个标准，是有具有逻辑性的思维跳跃能力。</strong></p>
<blockquote>
<p>一般的交谈过程，通常就是先讲A，再讲B，再讲C，再讲D……</p>
<p>但是我发觉，当和一些比较聪明的人聊天的时候，或者看其他的聪明人聊天的时候，通常不是一步一步走，而是跨着大步跳的，也就是先讲A，再讲D，再讲F，再讲J……这样。<strong>这种ADFJ的交谈方式，和前面的ABCD的交谈方式在逻辑上是一样的，并不是随机的思维跳跃，而是一些中间的逻辑步骤，因为交谈的双方都已经提前想到，并且一个眼神一个动作就心照不宣了，所以不需要每一步都讲一遍，直接说下一步就好了。</strong></p>
<p>比如之前有个我觉得比我聪明好多的做医生的朋友来我家做客，我在厨房做饭，客人们在闲聊，中间聊到癌症的事情。我就想到个段子，然后说“骑摩托车戴安全帽也能增加得癌症的概率。”这个段子其实说的还是蛮直接的，我也觉得对方肯定听得懂，所以就没有补充或者继续讲，而那位医生朋友就直接回了一句“是啊，上次和主任一起去查房，主任就说其中一位老太太比其他病人更可能得癌症，因为she has the syndrome of having too many birthdays。”然后大家就会心一笑。</p>
<p>跟聪明程度相仿的人交谈起来跳跃的节奏是很舒适的，逻辑上也能很自然的过渡。但是如果两个人节奏差别过大，一方要经常说完A后补充说B和C才能继续说D，甚至中间还要加个B1、B2，那就是另外一种情况了。</p>
</blockquote>
<p><strong>现实指标的第一个标准，是好奇心。</strong></p>
<blockquote>
<p>其实，前面提到的元认知和思维跳跃，都属于聪明的下层建筑，而最能直观体现一个人是否聪明的标准是好奇心。</p>
<p>一个聪明人，通常是对生活中各种事情充满了广泛的好奇的，也正是这种好奇，让他有更多的机会获得新的知识。</p>
<p><strong>好奇心和聪明程度是个鸡和蛋的情况。</strong>一个人的学习能力再强，如果好奇心不够，那他也不会去了解各种新东西；而如果一个人缺乏对事物的广泛了解，他就很难看到那些自己不理解的东西，也就不容易产生较强的好奇心。</p>
</blockquote>
<p>用苏格拉底的话说，“我唯一知道的事，就是我一无所知。”</p>
<p><strong>现实指标的第二个标准，是用简单的语言解释复杂的问题的能力。</strong></p>
<blockquote>
<p>经常能在包括知乎等网络社区，看到一些专业人士解释专业的或者技术性的问题，他们会很热心的花很多时间讲问题背后的原理，列出各种外行人很难看懂的公式、推导过程和专业术语，自己解答的很辛苦，读者大多没看懂，双方都不开心——“我都花了这么多功夫讲了你们怎么还是听不懂”和“你讲了这么一大堆不明觉厉，我还是不懂。”</p>
<p>而我接触到的一些很聪明的人，很多都在自己的专业领域有深入的研究，而这些聪明人的共同特点是在解释专业问题时会刻意避免使用别人可能听不懂的大词、黑话和专业用语。</p>
<p><strong>刻意的选用简单的语言，至少说明两个问题，一是说话的人懂得换位思考，能够从对方角度分析和评价自己的表达，是对于知识的学习具有评估能力的体现；</strong>其次，很多专业用语和大词其实是专家直接沟通的工具，<strong>当你面对的听众不是专家的时候，你就不能用这些工具“偷懒”，这样对于说话者的要求就更高了，对于知识掌握程度的要求也更高。</strong>知乎上的一些比较有名的心理学、统计学、健身等等专业领域的用户，解答问题时通常都有这样的特点。</p>
<p>有个很有意思的年度科普活动叫作火焰挑战（flame challenge），组织方每年会出一个题目，然后要求参赛者制作一个视频，把这个题目用一个11岁小孩能听懂的话解释清楚。听起来很有趣，但是做起来还是很难的，历年的题目有“火焰是什么”、“颜色是什么”等。各位可以试试自己解释下“火焰是什么”这个题目，然后想一下你的解释能不能让一个11岁的小孩听懂。知乎上就有类似的题目，各位可以去看看那些题目下的回答是不是用简单的语言说清楚了的。</p>
</blockquote>
<p><strong>高层指标的第一个标准，是对于观点的态度。</strong></p>
<blockquote>
<p>具体表现在几个方面，比如对于自己不了解的领域少发表观点，这其实是上面说到的懂得越多越有好奇心的一种侧面体现；还有就是能够容纳不同的观点，甚至完全相反的观点，这其实是上面提到的换位思考能力的一种侧面体现；还有就是不迷信、不执迷不悟，当新的信息和证据证明自己原来的观点是错误的时候，能够改变自己的观点。</p>
<p>这几点说起来不难，其实大家都会说，但是自身做起来的时候真的蛮难的，因为这还要涉及到情商、面子等社交属性。</p>
</blockquote>
<p><strong>高层指标的第二个标准，是对于别人的态度。</strong></p>
<blockquote>
<p>一个人是不是善良，是很重要的一个标准。当然，准确的来说，善良并不代表聪明，聪明的坏人多了去了，事实上，想要做一个成功的坏人，也是需要聪明的，不够聪明的话坏事都做不到太大。</p>
<p>但是“好人”和“坏人”是很主观的判断。通常情况下，每个人在自己心中都是好人，连恐怖份子都不把自己当坏人的，他们在自己眼中是自由斗士和真理的捍卫者，是非常“高尚”的。</p>
<p>所以<strong>我说的善良，其实是对于别人的态度，就是说他是否能够通过分享、辅导、以身作则等方式帮助别人改善和提高，达成共赢的局面。</strong>帮助别人提高，想想都是极难的，大概是要把前面的五个标准都完成的差不多才能做到。</p>
</blockquote>
<p>当然不能排除存在那些很聪明，但是坚持“不但我要成功，而且我要别人都失败”的人，不过这种人我还真是不感兴趣，这样的人是不是聪明无所谓，我总是会尽量避免的。</p>
<p>本文转自知乎社区，作者”谢熊猫君”。</p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 聪明人 </tag>
            
            <tag> 原则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[团队做代码评审中审查清单的使用实践]]></title>
      <url>http://linfuyan.com/stop-more-bugs-with-our-code-review-checklist/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/062749_2Ex2_12.gif" alt="团队做代码评审中审查清单的使用实践"></p>
<p>在我们关于高效代码审查的博文中，我们建议使用一个检查清单。在代码审查中，检查清单是一个非常好的工具——它们保证了审查可以在你的团队中始终如一的进行。它们也是一种保证常见问题能够被发现并被解决的便利方式。</p>
<p>软件工程学院的研究表明，程序员们会犯15-20种常见的错误。所以，通过把这些错误加入到检查清单当中，你可以确保不论什么时候，只要这些错误发生了，你就能发现它们，并且可以帮助你杜绝这些错误。</p>
<a id="more"></a>
<p>为了帮助你开始创建一个清单，这里列出了一些典型的内容：</p>
<h2 id="代码审查清单"><a href="#代码审查清单" class="headerlink" title="代码审查清单"></a>代码审查清单</h2><h3 id="常规项"><a href="#常规项" class="headerlink" title="常规项"></a>常规项</h3><ul>
<li>代码能够工作么？它有没有实现预期的功能，逻辑是否正确等。</li>
<li>所有的代码是否简单易懂？</li>
<li>代码符合你所遵循的编程规范么？这通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。</li>
<li>是否存在多余的或是重复的代码？</li>
<li>代码是否尽可能的模块化了？</li>
<li>是否有可以被替换的全局变量？</li>
<li>是否有被注释掉的代码？</li>
<li>循环是否设置了长度和正确的终止条件？</li>
<li>是否有可以被库函数替代的代码？</li>
<li>是否有可以删除的日志或调试代码？</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？</li>
<li>在哪里使用了第三方工具，返回的错误是否被捕获？</li>
<li>输出的值是否进行了检查并且编码？</li>
<li>无效的参数值是否能够处理？</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li>是否有注释，并且描述了代码的意图？</li>
<li>所有的函数都有注释吗？</li>
<li>对非常规行为和边界情况处理是否有描述？</li>
<li>第三方库的使用和函数是否有文档？</li>
<li>数据结构和计量单位是否进行了解释？</li>
<li>是否有未完成的代码？如果是的话，是不是应该移除，或者用合适的标记进行标记比如‘TODO’？</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。</li>
<li>是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。</li>
<li>单元测试是否真正的测试了代码是否可以完成预期的功能？</li>
<li>是否检查了数组的“越界“错误？</li>
<li>是否有可以被已经存在的API所替代的测试代码？</li>
</ul>
<p><strong>你同样需要把特定语言中有可能引起错误的问题添加到清单中。</strong></p>
<p>这个清单故意没有详尽的列出所有可能会发生的错误。你不希望你的清单是这样的，太长了以至于从来没人会去用它。仅仅包含常见的问题会比较好。</p>
<h2 id="优化你的清单"><a href="#优化你的清单" class="headerlink" title="优化你的清单"></a>优化你的清单</h2><p>把使用清单作为你的起点，针对特定的使用案例，你需要对其进行优化。一个比较棒的方式就是让你的团队记录下那些在代码审查过程中临时发现的问题，有了这些数据，你就能够确定你的团队常犯的错误，然后你就可以量身定制一个审查清单。确保你删除了那些没有出现过的错误。（你也可以保留那些出现概率很小，但是非常关键的项目，比如安全相关的问题）。</p>
<h2 id="得到认可并且保持更新"><a href="#得到认可并且保持更新" class="headerlink" title="得到认可并且保持更新"></a>得到认可并且保持更新</h2><p>基本规则是，清单上的任何条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判定。这样可以防止判断的不一致。和你的团队分享这份清单并且让他们认同你清单的内容是个好主意。同样的，要定期检查你的清单，以确保各条目仍然是有意义的。</p>
<p>有了一个好的清单，可以提高你在代码审查过程中发现的缺陷个数。这可以帮助你提高代码标准，避免质量参差不齐的代码审查。</p>
<p>原文来自：<a href="http://blog.fogcreek.com/increase-defect-detection-with-our-code-review-checklist-example/" target="_blank" rel="noopener">Stop More Bugs with our Code Review Checklist</a><br>译文来自：<a href="http://blog.jobbole.com/83595/" target="_blank" rel="noopener">程序员必备的代码审查（Code Review）清单</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 经验实践 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码评审 </tag>
            
            <tag> 最佳实践 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OSX 上 Android Studio 编译使用 JAVA8 及 retrolambda 的项目出错解决方案]]></title>
      <url>http://linfuyan.com/faq/java8-excecution-failed-for-task-compileDebugJava/</url>
      <content type="html"><![CDATA[<p>问题发生环境及表现：</p>
<ol>
<li>Mac OSX Yosemite 系统</li>
<li>项目中使用 retrolambda 及 java8</li>
<li>在 Android Studio 中直接 build 时出现如下错误：</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编译器 (<span class="number">1.8</span><span class="number">.0</span>_40) 中出现异常错误。 如果在 Bug Parade 中没有找到该错误, 请在 Java Developer Connection (http:<span class="comment">//java.sun.com/webapps/bugreport) 中建立 Bug。请在报告中附上您的程序和以下诊断信息。谢谢。</span></span><br><span class="line">com.sun.tools.javac.<span class="built_in">code</span>.Symbol$CompletionFailure: 找不到java.lang.invoke.MethodType的类文件</span><br><span class="line"><span class="built_in">Error</span>:Execution failed <span class="keyword">for</span> task ':app:_compileDebugJava'.</span><br><span class="line">&gt; Compilation failed; see the compiler <span class="built_in">error</span> <span class="keyword">output</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FAILURE: </span>Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task ':app:_compileDebugJava'.</span><br><span class="line">&gt; Compilation failed; see the compiler error output for details.</span><br></pre></td></tr></table></figure>
<p>问题探索及解决方案：</p>
<ol>
<li>首先确保根据 <a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="noopener"> gradle-retrolambda 官方文档</a>正确配置</li>
<li>在系统中设置 JAVA8_HOME 等环境变量。设置完成以后在正常情况下在终端中可以正常编译。</li>
<li>这时在 Android Studio 中直接 build 依然不行，原因是 Android Studio 在启动过程中不会读取 <code>/home/user/.bash_profile</code> 或 <code>/home/user/.bashrc</code>，因此 <code>build.gradle</code> 中 retrolambda 的配置无法获取正确的 JAVA8_HOME 路径。</li>
<li>可行的解决方案：<ul>
<li>通过终端重新启动 Android Studio，这样可以读取 <code>/home/user/.bash_profile</code> 或 <code>/home/user/.bashrc</code> 中设置的环境变量</li>
<li>设置系统级的环境变量，如在 <code>/etc/profile</code> 中添加 JAVA8_HOME</li>
</ul>
</li>
</ol>
<p>参考：<a href="https://github.com/evant/gradle-retrolambda/issues/17" target="_blank" rel="noopener">https://github.com/evant/gradle-retrolambda/issues/17</a></p>
]]></content>
      
        <categories>
            
            <category> FAQ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Mac </tag>
            
            <tag> JAVA8 </tag>
            
            <tag> retrolambda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么Google要执行严格的编码编写规范]]></title>
      <url>http://linfuyan.com/google-coding-standards/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/uprogrammer-编码风格.jpg" alt="为什么Google要执行严格的编码编写规范"></p>
<p>本篇是<a href="http://www.linfuyan.com/google-code-review" target="_blank" rel="noopener">谷歌是如何做代码审查的</a>的续篇。</p>
<p>我们在谷歌所做事情中另外一个让我感到异常有效、有用的制度是严格的编码规范。</p>
<p>在到Google工作之前，我一直认为编码规范没有什么用处。我坚信这些规范都是官僚制度下产生的浪费大家的编程时间、影响人们开发效率的东西。</p>
<p>我是大错特错了。</p>
<a id="more"></a>
<p>在谷歌，我可以查看任何的代码，进入所有谷歌的代码库，我有权查看它们。事实上，这种权限是很少人能拥有的。但是，让我感到惊讶的却是，如此多的编码规范—缩进，命名，文件结构，注释风格—这一切让我出乎意料的轻松的阅读任意一段代码，并轻易的看懂它们。这让我震惊—因为我以为这些规范是微不足道的东西。它们不可能有这么大的作用—但它们却起到了这么大的作用。当你发现只通过看程序的基本语法结构就能读懂一段代码，这种时间上的节省不能不让人震撼！</p>
<p>反对编码规范的人很多，下面是一些常见的理由，对于这些理由，我以前是深信不疑。</p>
<p><strong>这是浪费时间！</strong></p>
<p>我是一个优秀的程序员，我不愿意浪费时间干这些愚蠢的事。我的技术很好，我可以写出清晰的、易于理解的代码。为什么我要浪费时间遵守这些愚蠢的规范？答案是：统一是有价值的。就像我前面说的—你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。</p>
<p><strong>我是个艺术家！</strong></p>
<p>这种话很滑稽，但它反映了一种常见的抱怨。我们程序员对于自己的编码风格通常怀有很高的自负。我写出的的代码的确能反映出我的一些特质，它是我思考的一种体现。它是我的技能和创造力的印证。如果你强迫我遵守什么愚蠢的规范，这是在打压我的创造力。可问题是，你的风格里的重要的部分，它对你的思想和创造力的体现，并不是藏身于这些微不足道的句法形式里。(如果是的话，那么，你是一个相当糟糕的程序员。)规范事实上可以让人们可以更容易的看出你的创造力—因为他们看明白了你的作品，人们对你的认识不会因不熟悉的编码形式而受到干扰。</p>
<p>所有人都能穿的鞋不会合任何人的脚！</p>
<p>如果你使用的编码规范并不是为你的项目专门设计的，它对你的项目也许并不是最佳方案。这没事。同样，这只是语法：非最优并不表示是不好。对你的项目来说它不是最理想的，但并不能表明它不值得遵守。不错，对于你的项目，你并没有从中获得该有的好处，但对于一个大型公司来说，它带来的好处是巨大的。除此之外，专门针对某个项目制定编码规范一般效果会更好。一个项目拥有自己的编码风格无可厚非。但是，根据我的经验，在一个大型公司里，你最好有一个统一的编码规范，特定项目可以扩展自己特定的项目方言和结构。<br>我善长制定编码规范！</p>
<p>这应该是最常见的抱怨类型了。它是其它几种反对声音的混合体，但它却有自身态度的直接表现。有一部分反对者深信，他们是比制定编码规范的人更好的程序员，俯身屈从这些小学生制定的规范，将会降低代码的质量。对于此，客气点说，就是胡扯。纯属傲慢自大，荒唐可笑。事实上他们的意思就是，没有人配得上给他们制定规范，对他们的代码的任何改动都是一种破坏。如果参照任何一种合理的编码规范，你都不能写出合格的代码，那只能说你是个烂程序员。<br>当你按照某种编码规范进行编程时，必然会有某些地方让你摇头不爽。肯定会在某些地方你的编码风格会优于这些规范。但是，这不重要。在某些地方，编码规范也有优于你的编程风格的时候。但是，这也不重要。只要这规范不是完全的不可理喻，在程序的可理解性上得到的好处会大大的补偿你的损失。</p>
<p>但是，如果编码规范真的是完全不可理喻呢？</p>
<p>如果是这样，那就麻烦了：你被糟蹋了。但这并不是因为这荒谬的编码规范。这是因为你在跟一群蠢货一起工作。想通过把编码规范制定的足够荒谬来阻止一个优秀的程序员写出优秀的代码，这需要努力。这需要一个执著的、冷静的、进了水的大脑。如果这群蠢货能强行颁布不可用的编码规范，那他们就能干出其它很多傻事情。如果你为这群蠢货干活，你的确被糟蹋了—不论你干什么、有没有规范。(我并不是说罕有公司被一群蠢货管理；事实很不幸，我们这个世界从来就不缺蠢货，而且很多蠢货都拥有自己的公司。)</p>
<p>译文出处: <a href="http://www.vaikan.com/google-coding-standards/" target="_blank" rel="noopener">为什么谷歌要执行严格的代码编写规范</a><br>英文原文: <a href="http://scientopia.org/blogs/goodmath/2011/07/14/stuff-everyone-should-do-part-2-coding-standards/" target="_blank" rel="noopener">Stuff Everyone Should Do (part 2): Coding Standards</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 经验实践 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> google </tag>
            
            <tag> 代码评审 </tag>
            
            <tag> 代码风格 </tag>
            
            <tag> 编码规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google是如何做代码审查的]]></title>
      <url>http://linfuyan.com/google-code-review/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/uprogrammer-code-review.png" alt="Google是如何做代码审查的"></p>
<p>在上一篇文章中提到过，我已经不在Google工作了。我还没有想清楚应该去哪里—有两三个非常好的工作机会摆在我面前。因为在这段做决定时间里，我不再受雇于任何人，我想可以写一些专业性的东西，一些很有趣，但也会在同事和管理工作中导致关系紧张的东西。</p>
<p>Google是一个非常优秀的公司。他们做出了很多令人称赞的东西—既是公司外部，人们可以看到的东西，也是公司内部。有一些在公司内部并不属于保密的事情，在外部并没有给予足够广泛的讨论。这就是我今天要说的。</p>
<a id="more"></a>
<p>让Google的程序如此优秀的一个最重要的事情看起来是非常的简单：代码审查。并不是只有Google做这个事情—代码审查已经被广泛的认可为一种非常好的做法，很多人都在这样做。但我还没有看到第二家这样大的公司能把这种事情运用的如此普遍。在Google，<strong>没有程序</strong>，任何产品、任何项目的程序代码，可以在没有经过有效的代码审查前提交到代码库里的。</p>
<p><strong>所有人</strong>都要经过代码审查。并且很正规的：这种事情应该成为任何重要的软件开发工作中一个基本制度。并不单指产品程序——所有东西。它不需要很多的工作，但它的效果是巨大的。</p>
<p>从代码审查里能得到什么？</p>
<p>很显然：在代码提交前，用第二群眼睛检查一遍，防止bug混入。这是对其最常见的理解，是对代码审查的好处的最广泛的认识。但是，依我的经验来看，这反倒是它<strong>最不重要</strong>的一点。人们确实在代码审查中找到了bug。可是，这些在代码审查中能发现的绝大部分bug，很显然，都是微不足道的bug，程序的作者花几分钟的时间就能发现它们。真正需要花时间去发现的bug不是在代码审查里能找到的。</p>
<p>代码审查的最大的功用是纯社会性的。如果你在编程，而且知道将会有同事检查你的代码，你编程态度就完全不一样了。你写出的代码将更加整洁，有更好的注释，更好的程序结构——因为你知道，那个你很在意的人将会查看你的程序。没有代码审查，你知道人们最终还是会看你的程序。但这种事情不是立即发生的事，它不会给你带来同等的紧迫感，它不会给你相同的个人评判的那种感受。</p>
<p>还有一个非常重要的好处。代码审查能传播知识。在很多的开发团队里，经常每一个人负责一个核心模块，每个人都只关注他自己的那个模块。除非是同事的模块影响了自己的程序，他们从不相互交流。这种情况的后果是，每个模块只有一个人熟悉里面的代码。如果这个人休假或——但愿不是——辞职了，其他人则束手无策。通过代码审查，至少会有两个人熟悉这些程序——作者，以及审查者。审查者并不能像程序的作者一样对程序十分了解——但他会熟悉程序的设计和架构，这是极其重要的。</p>
<p>当然，没有什么事情能简单的做下来的。依我的经验，在你能正确的进行代码审查前，你需要花时间锻炼学习。我发现人们在代码审查时经常会犯一些错误，导致不少麻烦——尤其在一些缺乏经验的审查者中经常的出现，他们给了人们一个很遭的代码审查的体验，成为了人们接受代码审查制度的一个障碍。</p>
<p>最重要的一个原则：代码审查用意是在代码提交前找到其中的问题——你要发现是它的正确。在代码审查中最常犯的错误——几乎每个新手都会犯的错误——是，审查者根据自己的编程习惯来评判别人的代码。</p>
<p>对于一个问题，通常我们能找出十几种方法去解决。对于一种解决方案，我们能有百万种编码方案来实现它。作为一个审查者，你的任务不是来确保被审查的代码都采用的是你的编码风格——因为它不可能跟你写的一样。作为一段代码的审查者的任务是确保由作者自己写出的代码是正确的。一旦这个原则被打破，你最终将会倍感折磨，深受挫折——这可不是我们想要的结果。</p>
<p>问题在于，这种错误是如此的普遍而易犯。如果你是个程序员，当你遇到一个问题，你能想到一种解决方案——你就把你想到的方案作为标准答案。但事情不是这样的——作为一个好的审查者，你需要明白这个道理。</p>
<p>代码审查的第二个易犯的毛病是，人们觉得有压力，感觉非要说点什么才好。你知道作者用了大量的时间和精力来实现这些程序——不该说点什么吗？</p>
<p>不，你不需要。</p>
<p>只说一句“哇，不错呀”，任何时候都不会不合适。如果你总是力图找出一点什么东西来批评，你这样做的结果只会损害自己的威望。当你不厌其烦的找出一些东西来，只是为了说些什么，被审查人就会知道，你说这些话只是为了填补寂静。你的评论将不再被人重视。</p>
<p>第三是速度。你不能匆匆忙忙的进行一次代码审查——但你也要能迅速的完成。你的同伴在等你。如果你和你的同事并不想花太多时间进行代码复查，你们很快的完成，那被审查者会觉得很沮丧，这种代码审查带来的只有失望的感觉。就好象是打搅了大家，使大家放下手头的工作来进行审查。事情不该是这样。你并不需要推掉手头上的任何事情来做代码审查。但如果中途耽误了几个小时，你中间还要休息一会，喝杯茶，冲个澡，或谈会儿闲话。当你回到审查现场，你可以继续下去，把事情做完。如果你真是这样，我想没有人愿意在那干等着你。</p>
<p>译文出处: <a href="http://scientopia.org/blogs/goodmath/2011/07/06/things-everyone-should-do-code-review/" target="_blank" rel="noopener">Things Everyone Should Do: Code Review</a><br>原文出处: <a href="http://www.vaikan.com/things-everyone-should-do-code-review/" target="_blank" rel="noopener">http://www.vaikan.com/things-everyone-should-do-code-review/</a></p>
]]></content>
      
        <categories>
            
            <category> 开发技术 </category>
            
            <category> 经验实践 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> google </tag>
            
            <tag> 代码评审 </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[做这样的 APP 要多久]]></title>
      <url>http://linfuyan.com/how-long-does-developing-an-app-need/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/how-long-does-developing-a-app-need.jpeg" alt="做这样的 APP 要多久"></p>
<blockquote>
<p>这是一个“如有雷同，纯属巧合”的故事，外加一些废话，大家请勿对号入座。开始了……</p>
</blockquote>
<p>我有些尴尬地拿着水杯，正对面坐着来访的王总，他是在别处打拼的人，这几年据说收获颇丰，见移动互联网如火如荼，自然也想着要进来干一场，尽管王总从事的行当也算跟IT沾边，但毕竟太长时间不接触技术，有些东西不太熟，总要咨询下我这个在一线开发混了十几年的老程序员，十几年的开发，有好几种可能性，不过这不是重点，所以暂时忽略掉这个细节吧。</p>
<a id="more"></a>
<p>我之所以尴尬，是对王总的需求有些不知如何回答，仿佛陷入了某种习惯性的沉思中。</p>
<p>王总站了起来，把手机递到我面前，说：“你看看，就这样一个APP。”他不太熟练地在屏幕上划了几下，我并没有很认真地看，因为我知道这个问题很难，那就是所有的开发者都会被问，并且可能是被问得最频的一个问题：“开发这么一个APP需要多长时间？”我很想说不知道，这可能是最直截了当和准确的回答，但面对王总这位老朋友，我要是这么回答估计有些失礼，所以这个时候，我除了大致思量了一下他所指的那个APP大致涉及到哪些方面之外，还要组织下自己的语言，如何用非常得体的话告诉他，这个事情我估算不出。“你看，就这么简单的一个APP”，王总继续在屏幕上拨弄了几下，然后带着几分期待的眼神看着我。</p>
<p>我谨慎地说：“坦白说，我说不准，我这方面经验也不是很足，尽管做过APP开发，但又跟这个很不一样，得具体分析好所有的逻辑，才能估算出时间。”</p>
<p>王总对我的说法似乎不以为然，他晃了晃手机，说：“我要求不多，其实比这个还简单”，他指着屏幕上某些地方，继续说：“这个，这个，这个都可以不要，只需要这么一个列表，里面有详情，可以查看修改……”</p>
<p>我心里很自然地想到这是很典型的“想当然简单”的态度，我想我得让他认识到这个问题的复杂程度，我反问道：“需要登录吗？”</p>
<p>王总稍作停顿后，说：“那当然。”</p>
<p>“什么登录？用户名密码方式，还是手机登录，抑或像QQ，微博，微信这种可以借用的第三方登录？”</p>
<p>王总这回似乎想了一下：“作为移动互联网，我想手机登录肯定是要的，QQ，微博，对了，微信，微信最好也要……哦，你前面说用户名密码，这个应该也是要的吧。”</p>
<p>我很流利地接着问：“那总得有注册，如果你打算用手机登录，那得找个短信平台，还有微信登录，你得先做好企业身份认证，对了，有登录，有密码，那密码找回功能也得有吧。”</p>
<p>“这是肯定的。”</p>
<p>“同时有多种登录途径，你必须要想出一种合理的逻辑来将它们‘整合’，最常见的当然是账号绑定，例如给你的账号绑定手机号码，这样就能用手机号来登录同样一个账号，对微信登录也同理，但如今移动互联网的用户们都挺厌恶注册流程的，所以往往会要求直接手机登录或者直接微信登录，自动完成注册过程，那考虑这种情况，如果用户先用微信登录，然后再用手机登录，而不是绑定，那么就会产生两个不同的账号，而且无法将其再‘整合’起来，我们得想出一套比较完善的方案……”</p>
<p>王总对我所说的似乎有些缺乏耐心：“没必要这么复杂吧？你看看这个APP，这些不都有吗？”</p>
<p>“有没有我前面所描述的那个问题，你尝试过了吗？”</p>
<p>但王总似乎对问题并不关心，他只想知道做这么一个APP需要多长时间，当然要多少钱，这也是他关心的问题，他拿出了信心满满的语气：“有问题怕什么？困难算什么？这些我相信都能解决，但时间很要紧，得快，我们的竞争对手不会等我们，就这么一个东西，你想想看，要多久？”</p>
<p>看他的架势，像十足那种混得风生水起的成功人士，而我这种身份低微的程序员在他面前确实是有口难言，我本来还想继续告诉他细节的重要性，却被他打断：“不，不需要有多精确，你只需要估算一个范围，两个星期？或是两个月？”</p>
<p>我觉得我没必要再隐瞒什么了：“我真的不知道，也许一支优秀的团队两个星期就能做好（不过我自己可不相信有这么牛逼的团队），但我很明显不是那个能创造这种奇迹的人。”我心想其实就算说出了“两个星期到两年”这么一个开玩笑式的范围，也可能是错的。</p>
<p>王总似乎对我这样的回答很失望。但他是个执行力很强的人，想做一件事，就一定会行动，行动一定快，一定要有结果，这种雷厉风行的行事风格，确实，我挺欣赏，不过他的这个项目，我可真帮不上忙，但我还是出于礼貌，说道：“技术方面有什么问题，还是可以来问我的。”</p>
<p>====================== 不怎么华丽的分隔线 ======================</p>
<p>“做一个APP需要多长时间？”这个问题估计比测一个人还能活几天还难，一个条件如此不充分的问题，如何回答呢？</p>
<p>总体来说，需求越是明确，团队越是成熟，估算出来的时间就越是准确。而软件开发这个事情，不管发展多少年，不管提出了怎样的方法论，都没办法像传统制造业那样把“工时”算得那么精确，其内部错综复杂的逻辑关系使然，软件工程，绝无可能量产。</p>
<p>用户看到的只是一个APP，如果他用的是iOS系统，也许他根本就不会接触Android，不知道开发者除了iOS版之外，还需要做一个Android版，（有没可能还有Windows版？这样工作量无疑更大）或者，网页版搞定一切？也许你真正动手做过后就不会这么认为，再说微信小店那种模式真能适用于所有场合么？而且，如果不是网络出现异常的话，一般用户也不会注意到服务器的存在，服务器总是那么默默无闻地为用户全天候地工作，它的开发难度恐怕也不亚于APP本身，而负责APP运维的还需一些人力，大了之后甚至需要组建一个专业团队，他们需要一个“后台”，能随时查看和处理数据，如果需要随时随地都能查看和处理数据，恐怕还得给后台专门弄个APP。</p>
<p>这个道理就有点类似：我们看到了战机在天上华丽地完成了歼敌任务，以为只是战机本身很牛，往往忽视了战机相关的那些配套，如果没有娴熟的飞行员、作战指挥中心、地面雷达、预警机、补给、机场或航母、地勤人员等等，那么战机将失去战斗力。APP也一样，它不是一个只要能跑起来就完事的东西，支持它的配套设施和维护工作丝毫不比APP本身简单。</p>
<p>除开这些大的方面，细节上也带有许多的不确定性，所以一支成熟的团队尤为重要，一个经验丰富的开发者会知道，至少大致知道这个开发过程会遇到哪些问题，哪些问题比较简单，哪些问题则可能需要耗费大量的时间，这得依赖经验。我有一句话常常挂在嘴边，那就是：“没做过的东西别轻易说简单。”“想当然简单”的态度对项目没有任何好处，如果自己不确定，那么去咨询一个有这方面经验的人，就算得不到具体的答案也有大致的方向，沿着这些方向研究一下，就能知道会面临的那些问题，当然往往还不是全部。</p>
<p>关于“低估了难度”这事情，我过去的公司有个经典故事，当时有个小项目，就是准备把一套已经在仪器上使用的只支持英语的程序增加多语言支持，程序并不大，涉及内容也不算太多，工程师一开始认为这只是个简单的翻译工作，顶多两个星期就能完成，但一做下去就发现不简单，首先翻译得找专业人士来做，自己做不好，我们没人精通欧洲各国语言，接下来还有单位换算，有些国家用公制，有些用英制，这个得考虑，包括日期显示格式也得考虑，一下子不知道多了多少工作，这些都差不多了之后又发现了德语单词过长，我们的仪器的屏幕显示不下，超出范围，于是再调字体，做精简，前前后后开会讨论了N次，最后想Release的时候发现这么一改，程序的Size变大了很多，有些仪器的存储器装不下，这下大家可都傻了，优化呗，精简呗，程序开始有些凌乱不堪了，最后勉强通过质控部检验，总算发布了，发觉足足搞了半年。不过如今想想之所以耗费了这么多时间，一个很重要的原因是经验不足，对多语言，国际化这块不熟，走了不少弯路，所以我前面也提到，成熟的团队尤为重要。</p>
<p>我们在估算项目时间的时候，往往只算了“写代码的时间”，而把那些和老板或客户扯皮，做需求分析，设计，测试，和修复bug的时间不考虑进去，而这些时间加起来通常比写代码的时间多出不少，我个人是不轻易为了讨好老板而把完成时间说得很短的，为啥？——根本做不到嘛，干嘛要撒谎？如果一个需要一星期完成的新功能开发，我通常得把这个时间double，这已经算比较“不保守”的了。</p>
<p>即便只算写代码的时间，也往往会被低估，老板或客户对你开发的东西很可能不满意，或许你误解了他的功能需求，或者界面有点卡顿，或者这个图标颜色不好看，你是开发者，不是美工，虽然凑合可以当一下美工，但毕竟不专业，更重要的是做做UI设计，做做图这种事情，也得耗费不少时间，当你为“一个像素”焦头烂额的时候，是不是很渴望团队中有一名设计师？这时候得提醒下老板：你必须要在时间和功能之间，做点取舍。老板当然很不高兴，但也不得不在功能上做出了一些妥协。虽然这样做能让难产的项目早点上线，但却为来日项目的失败，给老板添加了一个很好的借口：我们的工程师太差了，没按我说的去做。</p>
<p>老板或客户除了会抱怨你做出来的东西不够好看之外，还会再提很多东西：这个界面能不能改成多选，能否增加通知功能，已读未读状态要有，界面能不能再流畅点，昨晚程序咋“闪退”了一次……需求只管提功能，但没说具体这个UI要多美观，也没说程序稳定性要好，更没涉及到要达到多大的吞吐量，当然，可能更重要的——安全性也没提，你心一惊：是啊，如果有黑客，不，只要稍微懂一点技术的恶意用户想刷爆我们的服务器，那简直太简单了，而这些防护措施我都没做！所幸的是项目名气太小，暂时无需考虑这个。（貌似大多数APP都活不到需要考虑这个的时候）</p>
<p>所有这些，你说功能也好，细节也好，稳健性也好，都不是能自动从土里长出来的东西，都得需要花时间去想，去做，有些甚至还是个“系统工程”，如果头痛医头脚痛医脚去做的话，系统里到处充满“飞线”，无疑会给将来的维护留下了许多隐患。攻城狮的你，都考虑了吗？更别说老板为了节省成本而给你购置的低性能电脑让你整天抓狂这些“无关紧要”的事。</p>
<p>====================== 不怎么华丽的分隔线 ======================</p>
<p>话说王总告别我之后就以迅雷不及掩耳之势注册了公司，注册了域名，搞到了办公室，还一下子叫来了一帮子人风风火火地搞了起来，这种发展势头，这种干劲，我只有自叹不如。心底里真有些后悔怎么没跟他去干事业，不过这只是感性的一瞬间，理性又在接下来的几百毫秒里将我拉了回来：还是别去好，跟他沟通不来的。</p>
<p>王总的项目后来以一飞冲天之势迅猛发展，而他如今已经是一家估值几亿的公司的CEO，我嘛，越来越觉得自己是个Loser，独自坐在办公室里，还是拿着那个水杯，懊恼不已——打住！这样是不是比较有戏剧性？可虽然一开始我就声明此故事“如有雷同，纯属巧合”，但也不能胡乱瞎编，真正的结局是：确实风风火火弄了几个月，后来就突然杳无音讯了，本来想打电话问问王总究竟怎样，无奈他变成了另一个超级忙人，再无心思跟我聊家常了。嗯，结局还是差不多，我还是那个继续苦逼地坐在办公室里的程序员，唉，别想了，开工吧！</p>
<p>原文来自：博客园 <a href="http://www.cnblogs.com/guogangj/p/4676836.html" target="_blank" rel="noopener">《搞个这样的APP要多久？》</a></p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> App </tag>
            
            <tag> Android开发 </tag>
            
            <tag> iOS开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[以Facebook为案例剖析科技公司应有的工具文化]]></title>
      <url>http://linfuyan.com/tool-culture-for-tech-corporation-like-facebook/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/facebook-tool.jpg" alt="以Facebook为案例剖析科技公司应有的工具文化"></p>
<p>本文由 @王淮 Harry 哥 撰写，摘自他即将出版的新书。王淮是 Facebook 早期员工，中国藉第二位工程师第一位研发经理。</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前段时间和大众点评的 CEO 张涛聊天的时候碰到内部工具这个话题，我们都非常推崇一个优秀的技术公司应有有一个非常强势的工具文化。在工具上，我有很深的体会，我说那不如我把我的理解通过 Facebook 的一些实践例子来阐述一下，希望对科技公司有些帮助。</p>
<p>不断发展、改进公司的内部工具，可以极大提高每个员工的工作效率，可以减少运营人员的数目；这样既改善了整体协调，又减少了整体开支。</p>
<a id="more"></a>
<p>为了帮助工程师更好地进行产品开发，Facebook 对于内部工具（Tools）是非常非常关注的。招聘我进公司的总监黄易山，就是这方面一个最有力的倡导者，他极度建议，公司要把最好的人才放到工具开发那一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以得到提高，而不仅仅是工程师。</p>
<p>Facebook 有两个工具组。一个叫研发工具组（Dev Tools），专门负责研发工具的开发和维护，所有有助于工程师开发速度和质量的工具，主要服务对象是内部工程师。另外一个叫网站支持和工具组（Site Support and Tools），主要负责公司里面所有的通用工具的开发和维护，关注的主要是方便用户和 Facebook 的交流以及 Facebook 内部的沟通，主要都是通讯工具，服务对象是用户和所有员工。</p>
<h4 id="研发工具有哪些呢？"><a href="#研发工具有哪些呢？" class="headerlink" title="研发工具有哪些呢？"></a>研发工具有哪些呢？</h4><p>一开始新的工程师加入 Facebook，需要分配自己的开发服务器，Facebook 就做了一个工具来管理分配所有的开发专用服务器。在一个页面上你可以很清晰的看到所有的开发服务器，包括哪些人是现在的使用者，什么时候申请分配的，服务器的操作系统版本，配置信息等等；对于空余的服务器，你可以一键申请，并自动初始化该服务器。这让刚加入的菜鸟们可以迅速的获得自己的研发活动空间。</p>
<p>工程师最重要的工作就是写代码。针对代码管理，Facebook 做了很多工具，这里解释部分工具供参考。Facebook 的代码库管理是通过一种叫 GIT 的开源管理系统，为此开发了一些工具来集成 GIT。比如，一个工具是在提交代码之前自动的检测所修改的代码是否符合公司代码规范，如果不符合，该工具会自动警告，但把决定权交给工程师。Facebook 提倡对修改的代码写测试案例，在代码提交时会自动检测是否存在覆盖这些修改的测试案例，如果没有，会警告，但工程师仍然可以强制提交。但这种情况下代码若出错给网站带来巨大危害的话，工程师可能会被严厉批评，因为这本是可以避免的错误，是人性的狂傲忽视了工具的提醒。在代码审查（Code Review）方面，Facebook 做了一个可视化的工具，现已开源，叫 Phabricator；工程师可以在页面上非常方便的针对每一段（单行或者多行）代码进行交互讨论；负责审查的工程师可以接受代码改变，可以提出疑问要求原作者继续修改，可以提出自己不适合以推出该代码审查，等等。只有代码被明确接受之后才能被工程师提交到服务器端的代码库，这一点集成到提交工具中强制执行。基本理念就是凡是被很多人不断重复的好的习惯，要将其自动化，绑定到工具之中。以“Don’t make me think”的方式来推广好的 practice。</p>
<p>Facebook 的代码发布是灰度发布，所以做了一个方便设计灰度发布的工具。在这个工具中，工程师和产品经理（也可以授权给其他非研发人员）可以设计新产品发布的目标人群特点（比如年龄，性别，地域，教育，等等方面做出限制）及发布的人群比例（在0-100% 之间自由调整），所有的改变不需要代码的改变，只需要在工具页面上点击鼠标即可，让灰度发布变得很轻松。</p>
<p>发布的过程由一个利用点对点（BitTorrent）算法实现的工具进行多线程同时发布，对于更新几十万台机器只需要几十分钟。由于是不间断的发布，对公众的服务不可以停，所以 Facebook 会将一部分的机器从公众服务状态中拿下来，更新之后再放回，然后继续下一批，直到所有机器都被更新。这样就可以保证在任意状态都有足够多的机器来支持用户访问。整个工程都是通过工具来自动实现。而监控这个发布工程的进展，也有一个工具检测并且将其进度可视化，你可以很方便的看到哪些服务器更新了，现在正在更新哪些服务器，整个网站的进度是百分之几，等等。</p>
<p>发布之后的数据监测更是重点。Facebook 做了很多工具让数据监测变得容易。数据收集只要1-2行代码即可完成，数据的整理分类存储皆在后台的上万台服务器上自动完成，数据的可视化报表只需要通过一个页面工具点点鼠标设置即可即时生成，而不需要任何代码；数据波动的自动警报也可以设置，可以自动发邮件发短信，可以要求 24 小时全球轮班的站点稳定工程部门（Site Reliability Engineering)按照你既定的反应方案，直到最后打电话给你，直接把你从床上拽起来。在 4 年半内这样的事件发生在我身上至少有 10 次了。</p>
<p>还有一种工具是人为的，我们组经常用。就是把最最重要的目标及相关的任务，目标日期，负责人等信息写到白板上挂到我们最近的墙。每天一抬头就可以看到，每次开会都会路过，时刻提醒我们最最重要的事情是什么。这种工具对我们组非常有效。</p>
<h4 id="网站支持和内部通讯工具有哪些呢？"><a href="#网站支持和内部通讯工具有哪些呢？" class="headerlink" title="网站支持和内部通讯工具有哪些呢？"></a>网站支持和内部通讯工具有哪些呢？</h4><p>在所有通讯工具以上，是处理用户和 Facebook 之间通讯的工具。 针对常见的问题（尤其是关于如何使用某项功能的问题），Facebook 在用户提交的时候，尝试将其引导到网站帮助或 FAQ 的网页。但这无法满足所有人，尤其是和个人特殊情况相关的问题，仍然有很大一批的用户会坚持提交问题，这时候 Facebook 内部的处理工具做得最重要的事情就是把相关问题自动分配到最相关的运营组（routing），比如和支付欺诈相关的问题应当自动分配到反欺诈运维组的那十几个人那边。然后工具会提供常见的通用解决方案，比如如果是选择退款，可以做到一键退款，绝大多数的回信内容自动产生（用户姓名，原问题等个体信息都会自动嵌入），运维人员可以选择要不要修改内容，然后选择发送。如果针对某一个功能的问题突然多起来，工具会自动发现，并提醒运维人员手动查看；运维人员可以根据实际情况决定要不要工程师介入寻找并修复可能的问题根源。所有用户问题的回复率，回复满意度，交互次数等等都会被统计或抽样统计，以保证客服服务的质量。</p>
<p>另外一个重要的工具就是招聘的工具。Facebook 有一套专门的做题系统（Puzzle System）尝试去筛选可靠的工程师。这套系统是一个专门的 Recruiting Engineering 组做的，包括题库的管理和更新，自动提交系统和打分系统等等。如果在解题这个环节脱颖而出的话公司猎头（Recruiter）会给工程师打电话安排下一步的电话面试。另外一种活动电话面试的途径是通过内部推荐。所有的内部推荐都是通过专门的人才提交工具来上传简历，这个工具和整个招人系统结合，并注明这是一个内部推荐，谁是推荐人。而整个面试，包括谁应该参与面试，谁参与了面试，每一步面试官对应聘者的评价和打分，都在工具里被很好的记录和显示出来，当然还有必不可少的权限控制 – 只有参加面试的人员才能够看到关于应聘者整个流程的所有资料。最后，该工具允许打印所有的相关资料以帮助决策委员会讨论该应聘者时拥有所有相关数据。</p>
<p>还有一个重要工具就是每六个月一次的业绩评价工具。这个工具要允许员工自己对自己评价，员工互相评价，员工和老板之间互评，等等；还要考虑权限的管理。并不是一个很容易开发的工具。这个工具一开始是内部开发，但后来还是决定使用 Rypple 来提供专业的业绩评价工具。</p>
<h4 id="关于工具的一些思考"><a href="#关于工具的一些思考" class="headerlink" title="关于工具的一些思考"></a>关于工具的一些思考</h4><p>在 Rypple 的例子中要强调一点，Facebook 是一个工具驱动的公司，但这并不表示所有的工具都要自己开发。工具开发是手段，而不是目的，Facebook 的目的是打造一个最好的社交网站。因此，如果某个需要的工具有其他更专业的人做得更好的话，Facebook 非常乐意付费买他们的服务，而把自己的精力集中在核心产品上。这就是为什么 Facebook 花大笔钱购买数据库软件 MySQL 的支持服务，购买 Rypple 的工具的原因。</p>
<p>还有很多其他的工具。Facebook 希望通过工具的方式来解决所有可能想到的问题，比如要请假有相应的工具，你可以说明休息多长时间，你需要让哪些人知道这些情况等；所有新的想法的提出，讨论，让在线头脑风暴变成了可能；各种电子设备如电脑，手机等 IT 服务的请求和处理，也通过工具来解决……能够想到的地方就尽可能用工具。与物理工具不同，计算机工具可以实现“杠杆效应”的反复累积，通过组合这些“杠杆效应”可以达到更高的层级。</p>
<p>因此，公司的工作效率，影响到你需要雇用的员工数，公司的成本究竟是多少，并将直接影响到公司内部产品的独创性。黄易山就认为，工具团队不应该是一个由二线员工组成的“事后诸葛亮”的后勤部门，公司里最有才华的工程师应该用公司自己的工具来工作，并且企业文化里要优先反映这些。当公司过了最一开始开发原型证明概念的萌芽阶段之后，开发出优秀的工具并继续加以改善、更新，这比寻找下一个伟大的创意更重要。</p>
<p>我最近跟国内一些技术公司的高管们讨论过有关工具的话题，有些人非常赞同，也想通过工具来解决很多工程性的问题。比如，你要在公司里推广一些规范性方面的规则，一种传统的方法就是反反复复地强调，另一种就是开发出好用的工具，把这些东西固化在里面，借助工具进行强制性地推广，就解决了很多问题。像 Facebook 没有专门的软件质量测试人员，都是工程师自己进行，公司也有这方面的工具，把测试过程中重复性的工作集中起来，自动化实现，只有一些必须要个性化处理的由工程师具体再去做。再比如我在开发反欺诈系统时，将欺诈案例识别直接抛给人工处理当然是最简单的方式，但我们希望通过自动处理来解决大部分的欺诈案例，而把精力则放在那些确实需要单独处理的特殊案例上，最后决定的方向是“进行自动处理”和“建立反馈机制”，设计出用于用户报告(外部工具)和案例审查(内部工具)的工具。这样一来，我们也可以自动采集客户支持部门的处理意见，并集成到下一轮的机器学习中去，工具会越加精确和聪明且与时俱进。</p>
<p>在 Facebook 2005～2006年的发展中，公司根据不断增长的用户数量，聘请了成比例的客户服务人员。当后来有1,000万用户时，公司的客户服务人员不到 20 个。到 Facebook 的用户数量达到 1 亿时，很明显，公司不能用相同的速度来增加员工数量，所以公司让内部方案团队与客户服务分析师的工作配合得更加紧密，建立了更具创新性的工具和用户界面，极大地提高了客户服务部门的工作效率。通过内部工具团队的产品，他们分析了目前已完成建立的工作并创建了定制方案来提高效率，方法是让电脑去做可自动化处理的部分并优化用户体验，这样客户服务分析师就可以专注于人工最擅长处理的事务。</p>
<p>不断发展、改进公司的内部工具，可以减少运营人员的雇用，让每个员工的效率更高，这样既改善了整体协调（员工数量少意味着协调更容易进行），又减少了整体开支。如今，Facebook 的每一位工程师服务的用户数超过 100 万，虽然用户数量的持续增长，这种效率优势更加明显。</p>
<h4 id="工具文化的最大挑战"><a href="#工具文化的最大挑战" class="headerlink" title="工具文化的最大挑战"></a>工具文化的最大挑战</h4><p>不过有一个现实的最大挑战是，工具团队要招聘新员工有一定的难度。Facebook 的用户已经达到数亿，而且还在不断增长，如果你开发的是直接面向用户的产品，每天有那么多人在使用，那带来的成就感非常棒。而你要说服新员工去开发内部工具，说这样可以带给工程师以及其他同事更高的效率、最终帮助公司做出更好的产品，相对是间接并缺乏吸引力的。 所以，工具团队在招聘上花了很多工夫，想各种办法找到合适的人。</p>
<p>一种方式是用一些具体的工具提高效率的案例和数据来做理性说服；这需要在开发工具的同时要检测工具使用前后的效率变化。当你有确确实实的数字来告诉最好的工程师，来吧，我们对公司的贡献不比做产品的那些人差，正是我们的工具让他们的效率提高了这么多，所以所有人的工作成果都有我们的一部分功劳。当然，为了吸引内部最好的人才愿意到工具团队，企业文化中也一定要着重反映出这一点：在不同的公开场合私下会面都不断的强调其重要性，让所有人都清楚，公司将内部工具视为持续的重要投资。另外一个可供参考的窍门就是集中精力努力说服几位整个工程部门认同的顶尖工程师加入工具组，具有很好的示范效果和磁铁效应。如果真正做到如此重视，最优秀的工程师是愿意加入工具团队的，可以大大提升同事们的效率，从而更好地服务于用户，这也是一种外部用户所感受不到的成就感。</p>
<p>原文出处：<a href="http://www.yl1001.com/article/5251403246321684.htm" target="_blank" rel="noopener">http://www.yl1001.com/article/5251403246321684.htm</a></p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> facebook </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[怎样成为全栈工程师（Full Stack Developer）？]]></title>
      <url>http://linfuyan.com/how_to_become_a_full_stack_developer/</url>
      <content type="html"><![CDATA[<p><img src="http://img.uprogrammer.cn/how-to-become-a-full-stack-developer.jpg" alt="怎样成为全栈工程师（Full Stack Developer)"></p>
<blockquote>
<p>补充一下Full Stack Developer的定义和标准：What is a Full Stack developer ？</p>
</blockquote>
<p>Is it reasonable to expect mere morals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers. Well, what does that mean? To me, <strong>a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology…</strong></p>
<p>以下是来自知乎网友顾鹏的答案，一个例子来说明怎样成为全栈工程师。</p>
<a id="more"></a>
<p>做这样一个简单的 app:</p>
<p>一个天气应用，干净清爽的界面，天气信息一目了然。它不仅可以精确预测未来 10 天的天气，还可以显示某地的历史天气信息。它具有自定义提醒功能，支持 web 版本， iOS 版， Android 版。</p>
<p>为什么想要做这样一个 App ？因为你喜欢旅行，但没找到一个天气 App 可以提供你下个月或者某个特定月份的天气信息；因为你懒你没有每天看天气预报的习惯，你想要在第二天温度达到 30 度以上或者温差有 +/-7 度的时候，获得温馨提示；因为你要成为一个 Full Stack Engineer ，你必须不断训练每个 stack 的能力。</p>
<h2 id="Web版"><a href="#Web版" class="headerlink" title="Web版"></a>Web版</h2><p>你决定用 MySql 来存储用户数据，用 NoSql 存储历史天气数据。你用 Redis 作为 cache ，缓存一些最常请求的天气数据。你用 Python 写后台，功能简单，后台不复杂，用户注册登录，抓取返回某城市的天气数据，某地的历史天气数据，很快便搞定。</p>
<p>后台开发并测试好了，接下来是 Web 前端。你十分清楚一个好的 UI 设计对一个 App 的重要性，你也明白 UI 的设计不只是为了美观，更重要的是提高信息的可读性和程序的可用性。幸好你平日的积累这次派上用场了。你把之前保存下来的上百个优秀的UI设计作品拿来研究，你从书架上拿出Norman 的那本经典 - The Design of Everyday Things 重新细读。最终你用白纸黑笔敲定了第一个版本的 UI，简洁直观，没有任何多余的设计，所有元素的排列间距 大小颜色都恰到好处。你相信即使天气不好，但用户只要使用这个 App 都会有着愉悦的心情。</p>
<p>那么开始写前端吧。啊，别急，都忘了还有 Icon 和 Logo ，可是不会 PS ，不会 AI ，不会 Sketch 怎么办呢，学吧。你平日喜欢结交不同领域的朋友，正好几周前在一个活动上你认识一位朋友做设计的。她花一个下午的时间教你基本的 Sketch 的使用，并对你的 UI 设计给出了一些意见。你请她吃了顿晚饭表示感谢，然后立即回家根据她的一些建议重新调整了 UI ，这次你在 PS 里把 UI 画了出来，Icons 和 Logo 也顺道一起做了。</p>
<p>接下来的一周，你学习 HTML，CSS，以及 Javascript，并漂亮地把前端搞定。</p>
<h2 id="发布-App"><a href="#发布-App" class="headerlink" title="发布 App"></a>发布 App</h2><p>在朋友圈发了个状态，找人帮你做 Beta 测试。他们都首先问你是什么 App，一开始你简单回答一个天气的 App。但你发现，这不能提起他们的兴趣。你觉得你需要用语言，用故事包装一下。不光是作为别人「是什么 App」提问的回答，也是成为 Full stack Engineer 道路上的一个重要技能。</p>
<p>你去看了所有你喜欢的产品的主页，从他们的文案上获得一些灵感启发；你读了经典的 On Writing Well ，发现好的文案，好的设计，其实和好的代码很相似，都是重在交流，如何让他人毫不费劲地明白你要表达的内容。你的故事要吸引人，你的产品介绍要在1分钟内解释清楚，并确保你的父母可以毫无压力听明白。</p>
<p>一切就绪，产品上线了。反响不错，用户持续增加。很多用户希望有移动版本，于是你立即投入到iOS 版本的开发上。</p>
<h2 id="iOS-版及后台优化"><a href="#iOS-版及后台优化" class="headerlink" title="iOS 版及后台优化"></a>iOS 版及后台优化</h2><p>你花一周不到时间学习了基本的语法和工具使用便投入到 App 的开发中。你知道 Learn by Doing 是最好也是最快的。由于之前学习了设计的基础，UI ，Icons 很快搞定，不久 iOS 版本便发布了。iOS 的发布带来了更多的用户增长，后台服务器的压力颇大，你知道是时候优化后台了。</p>
<p>你在 AWS 上多开了 2 台服务器，并写了一个 Script 来自动化部署过程。<br>你改用 uWSGi 协议，用 uwsgi 作为 Application Server。<br>你使用 Nginx 来做并发，负载均衡 …<br>……<br>……</p>
<h2 id="成立公司"><a href="#成立公司" class="headerlink" title="成立公司"></a>成立公司</h2><p>用户持续增长，每天你都会收到十几二十封用户的邮件。你很感激这些愿意花时间给你写邮件的用户，你相信他们是你最重要的用户，是潜在的付费用户。如果你把他们像上帝一样对待，他们同样也会把你看作是上帝。所以除了睡觉时间的发来的邮件，每一封邮件，你都会在2小时内给予回复。</p>
<p>果然这样的付出是收获巨大的，他们不仅惊讶且非常感谢你的快速回复，他们会在app store里给你★★★★★的评价，他们在社交网站上分享你的app，他们甚至会主动提出捐款给你。</p>
<p>你从快速的用户增长中嗅到了商机，你开始思考如何赚钱。广告你是坚决不能允许的，你认为再精确的广告也会影响用户体验。你设计了 2 个不同的付费方案，你打算用 A/B 测试看哪个方案更好。你分别给 200 个用户发去邀请尝试付费的邮件，邮件内容你精心打磨过，并在最后写上：CEO &amp; Founder. 通过分析 2 种方案的用户行为，你决定将使用第一种方案。</p>
<p>接下来，你相信差不多是时候成立个公司了。为了省时间，你花 2000 块钱找了个园区挂靠并帮你注册公司。公司的名字让你头疼了很久，你不想只是简单的用这个 App 的名字作为公司名字，你知道公司将来还会做出其他优秀的产品。你希望这个名字简单易记，同时其含义也是你公司文化的象征。</p>
<p>公司注册下来了，但银行那边得自己跑。你联系了一些媒体编辑，邀请他们来试用你的产品；你重新设计了产品主页，并开始写产品的 Blog ；你在各大社交网络都给 App 注册了账号，即做社区客服也为宣传… 这些事大大压缩你写代码的时间。以往你都是以代码量作为衡量自己当天工作效率的指标，所以这些天你总感觉没做啥工作。</p>
<p>这样的发展早已超过你的预期，这个 App 从一个 Side Project 几乎变成了你生活的全部。你跟你女朋友半个月才出去约会一次，她抱怨不断；你1个月没跟朋友出去玩耍喝酒了；你 2 个月都没锻炼过身体… 你意识到, YOU CAN NOT DO THIS ALONE，你需要帮手，你需要找人一起把这个做下去。</p>
<p>但你不是要成为 Full Stack Engineer 么？你现在是了么？</p>
<h2 id="Full-Stack-Engineer"><a href="#Full-Stack-Engineer" class="headerlink" title="Full Stack Engineer"></a>Full Stack Engineer</h2><p>设计，后台开发，前端开发，移动开发，运营维护，PS，文案… 好像都会了，这算 Full Stack Engineer 了么？</p>
<p>不，这只是踏上成为 Full Stack Engineer 的第一步。你知道目前只是每个 stack 都懂一点，离senior 或者 expert 还差得远，而要每个 stack 都做到极致，需要大量的时间和精力。精力有限，产品开发紧迫，力不从心啊，这条道路也太孤独，因为你不需要与任何人进行协作。难道要把一些stack的任务交给别人做么？这样算是放弃成为 Full Stack Engineer 么？</p>
<p>不！这不是。</p>
<p>什么是 Engineer？「Engineers are versatile minds who create links between science, technology, and society」。</p>
<p>Engineer 的本质工作是设计，开发出应用于大众的产品。</p>
<p>一个真正的 Full Stack Engineer ，他从生活中发现问题，洞察需求，他设计解决方案，并开发出初始版本的产品。为了达到目标，他愿意去学习任何领域的技能和知识。同时他不追求一个人完成所有工作，如果有人可以比他在某方面做得更出色，便会十分热情的邀请他们加入。</p>
<p>最终他的职位也许不再是 Engineer ，他不再设计 UI ，不再写代码 … 他的工作不再是 design and building an app or product，因为他有更大更重要的任务要做 - design and building a team or a company which builds great products. </p>
<p>而这时，社会给了他们另一个称呼 - 创业者。尽管众人已忘记他们 Engineer 的身份，但在他们骨子里，内心深处，自己始终都是一个 Engineer 。当他们需要从头再来时，他们毫不犹豫从设计开发产品做起。Nikola Tesla，Ferdinand Porsche，Henry Ford，Jack Dorsey，Mark zuckerberg，Elon Musk … 细数那些改变了或正改变世界的创业者，他们大多数是 Engineer 背景，热衷于设计创造。他们学习技能和知识，不是为了成为某个领域的专家；而是因为那些 是完成自己目标所需要的。</p>
<p>以上，为我认可的 Full Stack Engineer 。</p>
]]></content>
      
        <categories>
            
            <category> 深度文摘 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> App </tag>
            
            <tag> 全栈工程师 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置 Gradle 构建]]></title>
      <url>http://linfuyan.com/configuring-gradle-builds/</url>
      <content type="html"><![CDATA[<p>本节基于<a href="http://www.linfuyan.com/android-build-system-overview" target="_blank" rel="noopener">Android 构建系统概览</a>和<a href="">从 Android Studio 构建并运行</a>来展示如何基于产品口味和构建类型来使用构建变种。</p>
<h2 id="构建配置基础"><a href="#构建配置基础" class="headerlink" title="构建配置基础"></a>构建配置基础</h2><p>Android Studio 项目包含一个顶级的构建文件以及每个模块下的一个构建文件。构建文件名为 <code>build.gradle</code>，他们是普通的文本文件，通过 Gradle 的 Android 插件提供的元素，使用 <a href="http://groovy.codehaus.org/" target="_blank" rel="noopener">Groovy</a> 语法来配置构建过程。大多数情况下，你只需要在模块层级上来编辑构建文件。例如在项目 <code>BuildSystemExample</code> 的 app 模块的构建文件看起来像这样：</p>
<a id="more"></a>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">19</span></span><br><span class="line">    buildToolsVersion <span class="string">"19.0.0"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">8</span></span><br><span class="line">        targetSdkVersion <span class="number">19</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">":lib"</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:19.0.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>apply plugin: &#39;com.android.application&#39;</code> 说明应用 Gradle 的 Android 插件来构建。这将为顶级的构建任务新增 Android 指定的构建任务，并添加 <code>android {...}</code> 元素为 Android 指定的构建选项。</p>
<p><code>android {...}</code> 则配置所有 Android 指定的构建选项：</p>
<ul>
<li><code>compileSdkVersion</code> 属性指定编译目标版本。</li>
<li><code>buildToolVersion</code> 属性指定采用那个版本的构建工具。想要安装不同版本的构建工具，可以使用 SDK 管理器。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 永远要使用版本号比你所用的编译目标或者目标 SDK 的主要修订号高的或者相等的构建工具。</p>
</blockquote>
<ul>
<li><code>defaultConfig</code> 元素动态地配置构建系统中的清单文件( <code>AndroidManifest.xml</code> )的核心设置和条目。 <code>defaultConfig</code> 中的值将覆盖清单文件中的对应值。<br><code>defaultConfig</code> 元素中的指定配置将被应用到所有构建变种，除非某个构建变种的配置覆盖了其中的一些值。</li>
<li><code>buildTypes</code> 元素控制如何构建和打包应用程序。 构建系统默认定义了两个构建类型： debug 和 release。 debug 构建类型包含调试标志，并使用 debug 密钥签名。 release 构建类型默认是为签名的。这个实例中构建文件配置了 release 版本使用混淆。</li>
</ul>
<p><code>dependencies</code> 元素位于 <code>android</code> 元素之外，在其后面。该元素申明这个模块的依赖。依赖将在后面的章节中说明。</p>
<blockquote>
<p><strong>注意：</strong> 当你修改了项目中的构建文件， Android Studio 需要一个项目同步来导入构建配置的改变。点击出现在 Android Studio 黄色通知栏上的 <strong>Sync Now</strong> 按钮来导入这些变化。</p>
</blockquote>
<p><img src="http://img.uprogrammer.cn/uprogrammer-as-gradlesync.png" alt="Sync the project in Andriod Studio"></p>
<h3 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h3><p>实例中的 app 模块声明了3个依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Module dependency</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">":lib"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remote binary dependency</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:19.0.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local binary dependency</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每种依赖将在下面描述。构建系统添加所有的 <code>compile</code> 依赖到编译类路径中，并在最终的安装包中包含他们。</p>
<h4 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h4><p><code>app</code> 模块依赖 <code>lib</code> 模块，因为如<a href="https://developer.android.com/intl/zh-cn/tools/building/configuring-gradle.html#openActFromLib" target="_blank" rel="noopener">从一个库模块中开启 Activity </a> 中 <code>MainActivity</code> 启动 <code>LibActivity1</code>。</p>
<p><code>compile project(&quot;:lib&quot;)</code> 声明对 <code>BuildSystemExample</code> 中 <code>lib</code> 模块的依赖。当你构建 <code>app</code> 模块时，构建系统将组装和包含 <code>lib</code> 模块。</p>
<h4 id="远程二进制依赖"><a href="#远程二进制依赖" class="headerlink" title="远程二进制依赖"></a>远程二进制依赖</h4><p><code>app</code> 和 <code>lib</code> 模块都使用 Android Support 库中的 <code>ActionBarActivity</code> 类，所以这些模块依赖于它。</p>
<p><code>compile &#39;com.android.support:appcompat-v7:19.0.1&#39;</code> 通过指定 Android Support 库的 Maven 坐标来声明对该库 19.0.1 版本的依赖。Android Support 库被打包在 Android SDK 的 Android 仓库中。如果你安装的 SDK 中不包含该安装包，可以通过 SDK 管理器来下载并安装。</p>
<p>Android Studio 默认配置项目使用 Maven 中央仓库。(该配置包含在项目的顶级构建文件中)。</p>
<h4 id="本地二进制依赖"><a href="#本地二进制依赖" class="headerlink" title="本地二进制依赖"></a>本地二进制依赖</h4><p>一些模块没有用到本地文件系统的任何二进制依赖。如果你拥有一些模块需要本地二进制依赖，复制这些依赖中的 JAR 文件 到你项目中的 <code>&lt;moduleName&gt;/libs</code> 目录下。</p>
<p><code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code> 告诉构建系统所有 <code>app/libs</code> 下的 JAR 文件都是依赖，将被包含在编译类路径和最终安装包中。</p>
<p>想了解 Gradle 的依赖更多信息，查看 Gradle 用户指南中的<a href="http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html" target="_blank" rel="noopener">以来管理基础</a>。</p>
<h3 id="运行混淆"><a href="#运行混淆" class="headerlink" title="运行混淆"></a>运行混淆</h3><p>构建系统可以在构建过程中运行 <a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">ProGuard</a> 来混淆类，通过修改 <code>app</code> 模块中的构建文件来为 release 构建运行 ProGuard：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">...</span></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>
<p><code>getDefaultProguardFile(&#39;proguard-android.txt&#39;)</code> 从 Android SDK 安装路径下获取默认的 ProGuard 设置。 Android Studio 在模块根目录下添加模块指定的规则文件 <code>proguard-rules.pro</code>， 这样你可以添加自定义的 ProGuard 规则。</p>
<h3 id="安装包标识：应用程序ID"><a href="#安装包标识：应用程序ID" class="headerlink" title="安装包标识：应用程序ID"></a>安装包标识：应用程序ID</h3><p>在 Android 构建系统中， applicationId 属性是用来唯一标识发布的应用程序包的。 applicationId 在 <code>build.gradle</code> 文件中的 android 部分设置。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apply</span> plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="attribute">compileSdkVersion</span> <span class="number">19</span></span><br><span class="line">    buildToolsVersion <span class="string">"19.1"</span></span><br><span class="line"></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    <span class="attribute">applicationId</span> <span class="string">"com.example.my.app"</span></span><br><span class="line">    minSdkVersion <span class="number">15</span></span><br><span class="line">    targetSdkVersion <span class="number">19</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line">    versionName <span class="string">"1.0"</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> applicationId 只能在 <code>build.gradle</code> 文件中指定，而不能在 AndroidManifest.xml 中。</p>
</blockquote>
<p>在使用构建变种时，构建系统允许为每个产品修饰和构建类型唯一的标识不同的安装包。 构建类型中的 applicationId 被添加为后缀，以便指定产品修饰。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">productFlavors</span> &#123;</span><br><span class="line">       <span class="section">pro</span> &#123;</span><br><span class="line">           <span class="attribute">applicationId</span> = <span class="string">"com.example.my.pkg.pro"</span></span><br><span class="line">       &#125;</span><br><span class="line">       free &#123;</span><br><span class="line">           <span class="attribute">applicationId</span> = <span class="string">"com.example.my.pkg.free"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   buildTypes &#123;</span><br><span class="line">       <span class="section">debug</span> &#123;</span><br><span class="line">           <span class="attribute">applicationIdSuffix</span> <span class="string">".debug"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>
<p>清单文件中依然要指定包名。它将用来在代码只能怪引用 R 类，并解决一些相对的 activity/service 的注册。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">package</span>=<span class="string">"com.example.app"</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 如果存在多个清单文件(例如一个产品修饰指定的清单和一个构建类型清单)，包名在这些清单中是可选的。如果在这些清单中指定包名，这些包名应该和 <code>src/main</code> 文件夹下的清单中的包名完全一样。</p>
</blockquote>
<p>想了解构建文件和过程的更多信息，查看<a href="http://www.linfuyan.com/android-build-system-overview" target="_blank" rel="noopener"> Android 构建系统概览</a>。</p>
<h3 id="配置签名设置"><a href="#配置签名设置" class="headerlink" title="配置签名设置"></a>配置签名设置</h3><p>debug 和 release 版本的应用区别在于是否应用程序能够在安全设备上被调试以及 APK 如何被签名。构建系统使用默认的密钥和已知证书的凭证来签名 debug 版本以避免在构建时密码提醒。构建系统不会签名 release 版本，除非为这次构建明确定义一个签名配置。如果你还没有 release 密钥，可以像<a href="https://developer.android.com/tools/publishing/app-signing.html" target="_blank" rel="noopener">签名应用程序</a>中一样，自己生成一个。</p>
<h2 id="使用构建变种工作"><a href="#使用构建变种工作" class="headerlink" title="使用构建变种工作"></a>使用构建变种工作</h2><p>这一章节描述构建系统如何从单一的项目来创建相同应用程序的不同版本。当你的应用程序存在一个 Demo 版本和一个付费版本，或者在 Google Play 上针对不同配置的设备发布多个 Apk 包时，这将变得非常有用。</p>
<p>构建系统使用产品口味来创建应用程序的不同产品版本。每个产品版本可以有不同的功能和设备要求。构建系统同时使用构建变形来应用不同的构建和打包设置到每个产品版本。每个产品口味和构建类型组合形成构建变种。构建系统则为应用程序的每个构建变种生成不同的 APK。</p>
<h3 id="构建变种"><a href="#构建变种" class="headerlink" title="构建变种"></a>构建变种</h3><p>这个实例项目包含两个默认的构建类型( debug 和 release )和两个对应应用类型( demo 和 full)的 产品口味。构建变种的更多高级用法，请查看<a href="http://www.linfuyan.com/android-build-system-overview" target="_blank" rel="noopener"> Android 构建系统概览</a>。</p>
<h4 id="产品口味"><a href="#产品口味" class="headerlink" title="产品口味"></a>产品口味</h4><p>创建应用程序的不同产品版本：</p>
<ol>
<li>在构建文件中定义产品口味。</li>
<li>为每种口味创建额外的源文件夹。</li>
<li>添加特定口味的源文件到应用程序中。</li>
</ol>
<p>接下来的部分使用 <code>BuildSystemExample</code> 项目来详细介绍这些过程。为 <code>BuildSystemExample</code> 应用创建两种口味，一个 demo 和一个 full。两种口味共享 <code>MainActivity</code>，在这个 Activity 中添加一个按钮来启动一个新的 <code>SecondActivity</code>。这个新的 Activity 则在不同变种中不同，因此你可以模拟这样的状态：让 full 口味的新 Activity 具有比 demo 口味更多的功能。在练习的最后，你将得到两个不同的 APK 包，每种口味一个。</p>
<h4 id="在构建中定义产品口味"><a href="#在构建中定义产品口味" class="headerlink" title="在构建中定义产品口味"></a>在构建中定义产品口味</h4><p>要定义两种产品口味，编辑 <code>app</code> 模块的构建文件来添加下面的配置。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    defaultConfig &#123; <span class="string">...</span> &#125;</span><br><span class="line">    signingConfigs &#123; <span class="string">...</span> &#125;</span><br><span class="line">    buildTypes &#123; <span class="string">...</span> &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            applicationId <span class="string">"com.buildsystemexample.app.demo"</span></span><br><span class="line">            <span class="keyword">version</span>Name <span class="string">"1.0-demo"</span></span><br><span class="line">        &#125;</span><br><span class="line">        full &#123;</span><br><span class="line">            applicationId <span class="string">"com.buildsystemexample.app.full"</span></span><br><span class="line">            <span class="keyword">version</span>Name <span class="string">"1.0-full"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>产品口味定义支持相同的属性，如 <code>defaultConfig</code> 元素。所有口味的基础配置在 <code>defaultConfig</code> 中指定，每种口味可以覆盖任何的默认值。这个构建文件使用 <code>applicationId</code> 属性为每种口味分配不同的包名：因为每种口味定义创建一个不同的应用程序，每个应用程序需要区分包名。</p>
<blockquote>
<p><strong>注意：</strong> 使用多 APK 支持在 Google Play 市场发布应用程序，需要为所有的变种分配相同的包名和不同的 <code>versionCode</code>。要发布不同变种为 Google Play 上的独立应用，则要为每个变种分配不同的包名。</p>
</blockquote>
<h4 id="为每个变种创建额外的源文件夹"><a href="#为每个变种创建额外的源文件夹" class="headerlink" title="为每个变种创建额外的源文件夹"></a>为每个变种创建额外的源文件夹</h4><p>创建源文件夹，并为每种口味添加 <code>SecondActivity</code>。为 demo 口味创建源文件夹结构：</p>
<ol>
<li>在 <code>Project</code> 面板，展开 <code>BuildSystemExample</code>，然后展开 <code>app</code> 目录。</li>
<li>右击 <code>app</code> 目录下的 <code>src</code> 文件夹并选择 <strong>New &gt; Direcory</strong>。</li>
<li>输入 “demo” 作为新文件夹名称，并点击 <strong>OK</strong>。</li>
<li>类似地步骤，创建下面的文件夹：<ul>
<li><code>app/src/demo/java</code></li>
<li><code>app/src/demo/res</code></li>
<li><code>app/src/demo/res/layout</code></li>
<li><code>app/src/demo/res/values</code></li>
</ul>
</li>
</ol>
<p>最终的目录结构如下图：</p>
<p><img src="http://img.uprogrammer.cn/uprogrammer-as-demoflavordirs.png" alt="demo 口味的新源文件夹"> </p>
<h4 id="为每种口味添加新的-Activity"><a href="#为每种口味添加新的-Activity" class="headerlink" title="为每种口味添加新的 Activity"></a>为每种口味添加新的 Activity</h4><p>添加 <code>SecondActivity</code> 到 demo 口味：</p>
<ol>
<li>在 <code>Project</code> 面板，右击 <code>app</code> 模块并选择 <strong>New &gt; Activity</strong>。</li>
<li>选择 <strong>Blank Activity</strong> 并点击 <strong>Next</strong>。</li>
<li>输入 “SecondActivity” 作为 Activity 名称。</li>
<li>输入 “com.buildsystemexample.app” 作为包名并点击 <strong>Finish</strong>。</li>
<li>右击 app/src/demo 下的 java 目录，并选择 <strong>New &gt; Package</strong>。</li>
<li>输入 “com.buildsystemexample.app” 作为包名并点击 <strong>OK</strong>。</li>
<li>拖动 SecondActivity，并将其放到 app/src/demo/java 下的新包中。</li>
<li>接受默认值并点击 <strong>Refactor</strong>。</li>
</ol>
<p>添加 SecondActivity 的布局和字符串资源到 demo 口味：</p>
<ol>
<li>从 app/src/main/res/layout 拖动 activity_second.xml 到 app/src/demo/res/layout 中。</li>
<li>接受窗口中出现的默认值并点击 <strong>OK</strong>。</li>
<li>从 app/src/main/res 复制 strings.xml 到 app/src/demo/res 中。</li>
<li>用下面的内容替换 strings.xml 新副本中的内容。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>Demo version only.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来通过复制 demo 口味来添加源文件夹和 <code>SecondActivity</code> 到 full 口味：</p>
<ol>
<li>在 <code>Project</code> 面板，右击 app/src 下的 demo 目录，并选择 <strong>Copy</strong>。</li>
<li>右击 app/ 下的 src/ 目录，并选择 <strong>Paste</strong>。</li>
<li>当窗口出现是，输入 full 作为新的名字，并 <strong>OK</strong>。</li>
<li>使用下面的内容替换 src/full/res/values 下的 strings.xml 的内容：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"hello_world"</span>&gt;</span>This is the full version!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>从现在开始，你可以在每种口味上独立的开发 <code>SecondActivity</code>。例如，你可以在 full 口味中为这个 Activity 添加更多的功能。</p>
</blockquote>
<p>想要在特定口味上的文件进行工作，点击 IDE 窗口左上角的 <strong>Build Variants</strong>，并在”构建变种”面板选择你想要修改的口味，如下图所示。 Android Studio 会为没有在构建变种面板上选中的口味的源文件中显示错误，但是这不影响构建输出。</p>
<p><img src="http://img.uprogrammer.cn/uprogrammer-as-buildvariants.png" alt="构建变种面板"> </p>
<h4 id="从主-Activity-启动特定口味的-Activity"><a href="#从主-Activity-启动特定口味的-Activity" class="headerlink" title="从主 Activity 启动特定口味的 Activity"></a>从主 Activity 启动特定口味的 Activity</h4><p>由于特定口味的 Activity (<code>SecondActivity</code>)在两种口味中拥有相同的包名和 activity 名称，可以从所有口味共同的主 Activity 中启动它。修改主 Activity 如下：</p>
<p>1、 编辑 <code>activity_main.xml</code>，并添加新的按钮到 <code>MainActivity</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/button2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"onButton2Clicked"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、 点击布局文件中标记为红色的区域并点击 <strong>Alt + Enter</strong>。按照 Android Studio 的提示添加一个值为 “Open Second Activity” 的字符串资源，以及 <code>onButton2Clicked</code> 方法到 <code>MainActivity</code>。<br>3、 添加下面的代码到 <code>MainActivity</code> 中的 <code>onButton2Clicked</code> 方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void onButton2Clicked(View view) &#123;</span><br><span class="line">    <span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(this, SecondActivity.<span class="keyword">class</span>);</span><br><span class="line">    startActivity(<span class="keyword">intent</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、 编辑应用的 manifest 文件来包含 <code>SecondActivity</code> 的引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.buildsystemexample.app.SecondActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"@string/title_activity_second"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="构建类型"><a href="#构建类型" class="headerlink" title="构建类型"></a>构建类型</h4><p>构建类型代表了为每个应用程序构建打包的版本。默认系统提供了 debug 和 release 的构建类型。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    signingConfigs &#123; ... &#125;</span><br><span class="line">    buildTypes &#123; ... &#125;</span><br><span class="line">    productFlavors <span class="meta">&#123;...&#125;</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</span><br><span class="line">        &#125;</span><br><span class="line">         debug &#123;</span><br><span class="line">            debuggable <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>虽然只有 release 的构建类型出现在默认的 build.gradle 文件中，但每个构建都提供了 release 和 debug 的构建类型。</p>
</blockquote>
<p>在这个实例中，产品口味和构建类型创建了下面的构建变种：</p>
<ul>
<li>demoDebug</li>
<li>demoRelease</li>
<li>fullDebug</li>
<li>fullRelease</li>
</ul>
<p>要构建这个实例，点击 Android Studio 上的 <strong>Build</strong> 选项按钮，或者从命令行调用 <code>assemble</code> 任务。</p>
<blockquote>
<p><strong>注意：</strong> <strong>Build &gt; Make Project</strong> 选项将编译整个项目中自从上一次编译之后所有被修改过的源文件。<strong>Build &gt; Rebuild Project</strong> 选项将重新编译项目中的所有源文件。</p>
</blockquote>
<p>每个构建变种将创建独立的输出文件夹。</p>
<p>原文链接：<a href="https://developer.android.com/intl/zh-cn/tools/building/configuring-gradle.html" target="_blank" rel="noopener">Build Configuration Basics</a></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> 构建系统 </tag>
            
            <tag> Android Studio </tag>
            
            <tag> 构建变种 </tag>
            
            <tag> 构建类型 </tag>
            
            <tag> 产品口味 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 构建系统概览]]></title>
      <url>http://linfuyan.com/android-build-system-overview/</url>
      <content type="html"><![CDATA[<p>Android 构建系统是一个用来构建、测试、运行和打包应用程序的工具箱。构建系统可以作为 Android Studio 菜单中的集成工具运行，也可以独立地从命令行运行。构建系统可以用来：</p>
<ul>
<li>对构建过程进行自定义，配置和扩展。</li>
<li>使用相同的项目和模块来为应用程序创建拥有不同特性的多个 APK。</li>
<li>跨源的集合来复用代码和资源。</li>
</ul>
<p>Android 构建系统的灵活性使得可以在不修改应用程序核心源文件的情况下实现这些目标。想要构建一个 Android Studio 项目，参见<a href="https://developer.android.com/tools/building/building-studio.html" target="_blank" rel="noopener">从 Android Studio 构建和运行</a>。想要在 Android Studio 项目中配置自定义的构建设置，参见<a href="http://www.linfuyan.com/configuring-gradle-builds" target="_blank" rel="noopener">配置 Gradle 构建</a>。</p>
<a id="more"></a>
<h2 id="构建进程详解"><a href="#构建进程详解" class="headerlink" title="构建进程详解"></a>构建进程详解</h2><p>整个构建过程包含有许多工具和过程产生中间文件，并最终生成一个 .apk 文件。如果你使用 Android Studio 进行开发，那么当你每次为项目或者模块运行 Gradle 构建任务时，完整的构建过程就完成了。由于许多的构建过程是可配置和扩展的，因此理解每个覆盖下发生了对于理解构建过程的灵活性是很有用的。下面的图标描述整个构建中包含的不同的工具和过程：</p>
<p><img src="http://img.uprogrammer.cn/uprogrammer-build.png" alt="Android 构建工具与过程"></p>
<p>一个典型构建的大概过程如下。构建系统从所有配置的产品修饰、构建类型和依赖中合并资源。如果不同文件夹包含有相同名字或设置的资源，将按照下面的优先级覆盖：依赖覆盖构建类型，构建类型覆盖产品修饰，产品修饰覆盖主源文件夹。</p>
<ul>
<li>Android 资源打包工具 (aapt) 处理应用程序的资源文件，例如 <code>AndroidManifest.xml</code> 文件以及 Activity 的 XML 文件等，并编译他们。最终生成 <code>R.java</code>，这样可以在 Java 代码中引用资源。</li>
<li>aidl 工具则转化所有的 <code>.aidl</code> 接口为 Java 接口。</li>
<li>所有的 Java 代码，包括 <code>R.java</code> 和 <code>.aidl</code> 文件被 Java 编译器所编译，并输出为 .class 文件。</li>
<li>dex 工具将 .class 文件转化为 Dalvik 字节码。在模块构建中所有包含的第三方库和 .class 文件也都转化为 <code>.dex</code> 文件，这样才能被打包进最终的 <code>.apk</code> 文件中。</li>
<li>所有未编译的资源(如图片)，已编译的资源以及 .dex 文件将通过 apkbuilder 工具来打包进 <code>.apk</code> 文件。</li>
<li>一旦 <code>.apk</code> 文件被构建，需要通过一个 debug 或者 release 的密钥来签名才能被安装到设备上。</li>
<li>最后，如果应用程序以 release 模式被签名，需要通过 zipalign 工具来对齐 <code>.apk</code> 文件。对齐最终的 <code>.apk</code> 能够在设备上运行应用程序时降低内存使用。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 应用程序有最多 64k 个方法引用的限制。如果你的应用程序达到这个限制，构建过程将输出下列的错误信息：</p>
</blockquote>
<pre><code>Unable to execute dex: method ID not in [0, 0xffff]: 65536.
</code></pre><p>要避免这个错误，查看<a href="https://developer.android.com/tools/building/multidex.html" target="_blank" rel="noopener">构建超过65k方法的应用程序</a></p>
<h2 id="构建输出"><a href="#构建输出" class="headerlink" title="构建输出"></a>构建输出</h2><p>构建过程为每个构建变量在 <code>app/build</code> 文件夹下生成一个 APK: <code>app/build/outputs/apk/</code> 文件夹包含名为 <code>app-&lt;flavor&gt;-&lt;buildtype&gt;.apk</code> 的安装包；例如 <code>app-full-release.apk</code> 和 <code>app-demo-debug.apk</code>。</p>
<p>原文链接：<a href="https://developer.android.com/intl/zh-cn/sdk/installing/studio-build.html" target="_blank" rel="noopener">Build System Overview</a></p>
]]></content>
      
        <categories>
            
            <category> 软件工具 </category>
            
            <category> Gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
            <tag> 构建系统 </tag>
            
            <tag> Android Studio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs 学习资源汇总]]></title>
      <url>http://linfuyan.com/nodejs/</url>
      <content type="html"><![CDATA[<p>待补充</p>
]]></content>
      
        <categories>
            
            <category> 导航 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 汇总 </tag>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 学习资源汇总]]></title>
      <url>http://linfuyan.com/ios/</url>
      <content type="html"><![CDATA[<p>待补充</p>
]]></content>
      
        <categories>
            
            <category> 导航 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 汇总 </tag>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 学习资源汇总]]></title>
      <url>http://linfuyan.com/android/</url>
      <content type="html"><![CDATA[<p>待补充</p>
]]></content>
      
        <categories>
            
            <category> 导航 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习 </tag>
            
            <tag> 资源 </tag>
            
            <tag> 汇总 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[技术站点导航]]></title>
      <url>http://linfuyan.com/navit/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>站点推荐</th>
<th>xx</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com" target="_blank" rel="noopener">GitHub</a></td>
<td><a href="https://stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 导航 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
