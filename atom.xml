<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[悠城札记 - 关注但不限于 Android/iOS/nodejs 的 hexo 博客]]></title>
  <subtitle><![CDATA[关注但不限于 Android、iOS、nodejs]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linfuyan.com/"/>
  <updated>2015-11-12T06:55:50.000Z</updated>
  <id>http://linfuyan.com/</id>
  
  <author>
    <name><![CDATA[linfuyan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android (Java) 编码惯例及最佳实践]]></title>
    <link href="http://linfuyan.com/android-or-java-style-guide-and-best-practice/"/>
    <id>http://linfuyan.com/android-or-java-style-guide-and-best-practice/</id>
    <published>2015-11-12T03:45:07.000Z</published>
    <updated>2015-11-12T06:55:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-_声明(Declaration)">1. 声明(Declaration)</h1><h2 id="1-1_每行声明变量的数量(Number_Per_Line)">1.1 每行声明变量的数量(Number Per Line)</h2><p>推荐一行一个声明，因为这样以利于写注释。亦即，</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> level; <span class="comment">// indentation level      </span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">size</span>; <span class="comment">// size of table</span></span><br></pre></td></tr></table></figure>
<p>要优于，</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> level, <span class="built_in">size</span>;</span><br></pre></td></tr></table></figure>
<p>不要将不同类型变量的声明放在同一行，例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo, fooarry[]; <span class="comment">// WRONG!</span></span><br></pre></td></tr></table></figure>
<p>注意：上面的例子中，在类型和标识之间放了一个空格，另一种被允许的替代方法是多行变量注释的对齐：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> level;                <span class="comment">// indentation level</span></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">size</span>;                 <span class="comment">// size of table  </span></span><br><span class="line"><span class="keyword">Object</span> currentEntry;      <span class="comment">// currently selected table entry</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2_初始化(Initialization)">1.2 初始化(Initialization)</h2><p>尽量在声明局部变量的同时进行初始化。唯一 不这么做理由是变量的初始值依赖于某些先前发生的计算。</p>
<h2 id="1-3_布局(Placement)">1.3 布局(Placement)</h2><p>建议只在代码块的开始处声明变量(一个块可以指任何被包含在大括号“{”和“}”中间的代码，也可以是逻辑上分块的代码)。通常不要在首次用于该变量时才声明之，这会把注意力不集中的程序员搞糊涂，同时会妨碍代码在该作用域内的可移植性。    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int1 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">int</span> int2 = <span class="number">0</span>;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该规则的一个例外是for循环的索引变量</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; maxLoops; i++) &#123; … &#125;</span></span><br></pre></td></tr></table></figure>
<p>避免声明的局部变量覆盖上一级声明的变量。例如，不要在内部代码块中声明相同的变量名：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">…</span><br><span class="line">myMethod() &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;    <span class="comment">// AVOID!</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4_类和接口的声明(Class_and_Interface_Declarations)">1.4 类和接口的声明(Class and Interface Declarations)</h2><p>当编写类和接口时，应该遵守以下格式规则：</p>
<ol>
<li>在方法名与其参数列表之前的左括号“(”间不要有空格。</li>
<li>左大括号“{”位于声明语句同行的末尾。</li>
<li>右大括号“}”另起一行，与相应的声明语句对齐，除非是一个空语句，“}”应紧跟在“{”之后。   </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    int ivar1;</span><br><span class="line">    int ivar2;</span><br><span class="line"></span><br><span class="line">    <span class="type">Sample</span>(int i, int j) &#123;</span><br><span class="line">        ivar1 = i;</span><br><span class="line">        ivar2 = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int emptyMethod() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-_注释(Comments)">2. 注释(Comments)</h1><p>Java 程序有两类注释：实现注释( implementation comments )和文档注释( document comments )。实现注释是那些在 C++ 中见过的，使用 <code>/*…*/</code> 和 <code>//</code> 界定的注释。文档注释(被称为“doc comments”)是 Java 独有的，并由 <code>/**…*/</code> 界定。文档注释可以通过 javadoc 工具转换成 HTML 文件。</p>
<p>实现注释用以注释代码或或者实现细节。文档注释从实现自由( implemtentation-free )的角度描述代码的规范。它可以被那些手头没有源码的开发人员读懂。</p>
<p>注释应被用来给出代码的总括，并提供代码自身没有提供的附加信息。注释应该仅包含与阅读和理解程序有关的信息。例如，相应的包如何被建立或位于哪个目录下之类的信息不应包括在注释中。</p>
<p>在注释里，对设计决策中重要的或者不是显而易见的地方进行说明是可以的，但应避免提供代码中已清晰表达出来的重复信息，多余的注释很容易过时。通常应避免那些代码更新就可能过时的注释。</p>
<p>注意：频繁的注释有时反映出代码的低质量。当你觉得被迫要加注释的时候，考虑一下重写代码使其更清晰。</p>
<p>注释不应写在用星号或字符画出来的大框里。注释不应包括诸如制表符和回退符之类的特殊字符。</p>
<h2 id="2-1_实现注释的格式(Implementation_Comment_Formats)">2.1 实现注释的格式(Implementation Comment Formats)</h2><p>程序可以有4种实现注释的风格：块(Block)，单行(single-line)，尾端(trailing)和行末(end-of-line)。</p>
<h3 id="2-1-1_块注释">2.1.1 块注释</h3><p>块注释通常用于提供对文件，方法，数据结构和算法的描述。块注释被置于每个文件的开始处以及每个方法之前。它们也可以被用于其他地方，比如方法的内部。在功能和方法内部的块注释应该和它们所描述的代码具有一样的缩进格式。</p>
<p>块注释之首应该有一个空行，用于把块注释和代码分割开来，比如：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Here is a block comment.</span><br><span class="line"> <span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2_单行注释(Single-Line_Comments)">2.1.2 单行注释(Single-Line Comments)</h3><p>短注释可以显示一行内，并与其后的代码具有一样的缩进层级。如果一个注释不能在一行内写完，就该块注释(参见“块注释”)。单行注释之前应该有一个空行。以下是一个Java代码中单行注释的例子：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> &#123;</span><br><span class="line">    <span class="comment">/* Handle the condition. */</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3_尾端注释(Trailing_Comments)">2.1.3 尾端注释(Trailing Comments)</h3><p>极短的注释可以与它们所要描述的代码位于同一行，但是应该有足够的空白（至少一个空格）来分开代码和注释。若有多个短注释出现于大段代码中，它们应该具有相同的缩进。</p>
<p>以下是一个Java代码中尾端注释的例子：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="operator">a</span> ==<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="constant">return</span> <span class="constant">TRUE</span>;            <span class="comment">/* special case */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="constant">return</span> isPrime(<span class="operator">a</span>);      <span class="comment">/* works only for odd a */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4_行末注释(End-Of-Line_Comments)">2.1.4 行末注释(End-Of-Line Comments)</h3><p>注释界定符//，可以注释掉整行或者一行中的一部分。它一般不用于连续多行的注释文本；然而，它可以用来注释掉多行的代码段。以下是所有三种风格的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Do a double-filp.</span></span><br><span class="line">    ……</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Expalin why here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (bar &gt; 1) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    // Do a triple-flip.</span></span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else &#123;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2_文档注释(Documentation_Comments)">2.2 文档注释(Documentation Comments)</h2><p>注意：此处描述的注释格式之范例，参见“ Java 源文件范例”<br>若想了解更多，参见“How to Write Doc Comments for Javadoc”，其中包含了有关文档注释标记的信息(@return，@param，@see)：</p>
<p><a href="http://java.sun.com/javadoc/writingdoccomments/index.html" target="_blank" rel="external">http://java.sun.com/javadoc/writingdoccomments/index.html</a></p>
<p>若想了解有关文档注释和 javadoc 的详细资料，参见 javadoc 的主页：</p>
<p><a href="http://java.sun.com/javadoc/index.html" target="_blank" rel="external">http://java.sun.com/javadoc/index.html</a></p>
<p>文档注释描述Java的类、接口、构造器、方法，以及字段(field)。每个文档注释都会被置于注释界定符 <code>/**…*/</code> 之中，一个注释对应一个类、接口或成员。该注释应位于声明之前：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> The Example class provides …</span><br><span class="line"> <span class="keyword">*</span> </span><br><span class="line"> <span class="keyword">*</span> <span class="comment">@author FirstName Lastname (account@sohu-inc.com)</span></span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">public class Example &#123; …</span><br></pre></td></tr></table></figure>
<p>注意：顶层(top-level)的类和接口是不缩进的，而其成员是缩进的。描述类和接口的文档注释的第一行会被置于注释的第一行(/ **)不需要缩进；随后的文档注释每行都缩进1格(使星号纵向对齐)。成员，包括构造函数在内，其文档注释的第一行缩进4格，随后每行都缩进5格。</p>
<p>若你想给出有关类、接口、变量或方法的信息，而这些信息又不适合写在文档中，则可使用实现块注释(见2.1.1)或紧跟在声明后面的单行注释(见2.1.2)。例如，有关一个类实现的细节应放入紧跟在类声明后面的实现块注释中，而不是放在文档注释中。</p>
<p>文档注释不能放在一个方法或构造器的定义块中，因为 Java 会将位于文档注释之后的第一个声明与其相关联。</p>
<h1 id="3-_编程实践">3. 编程实践</h1><h2 id="3-1_提供对实例以及类变量的访问控制(Providing_Access_to_Instance_and_Class_Variables)">3.1 提供对实例以及类变量的访问控制(Providing Access to Instance and Class Variables)</h2><p>若没有足够的理由，不要把实例或类类变量声明为 public。通常，实例变量无需显式的设置(set)和获取(gotten)，通常这作为方法调用的边缘效应(side effect)而产生。</p>
<p>一个具有public实例变量的恰当例子，是类仅作为数据结构，没有行为。亦即，若你要使用一个结构(struct)而非一个类(如果Java支持结构的话)，那么把类的实例变量声明为public是合适的。</p>
<p>Android 变量访问控制：Android 的开发通常允许公共的实例变量。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Common</span> practice <span class="type">in</span> Android development.</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClass &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> pulicField;  // <span class="keyword">public</span> field for <span class="keyword">direct</span> <span class="keyword">access</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2_引用类变量和类方法(Referring_to_Class_Variables_and_Methods)">3.2 引用类变量和类方法(Referring to Class Variables and Methods)</h2><p>避免用一个对象访问一个类的静态变量和方法。应该用类名替代。例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">classMethod</span>();         <span class="comment">// OK</span></span><br><span class="line">AClass<span class="class">.classMethod</span>();   <span class="comment">// OK</span></span><br><span class="line">anObject<span class="class">.classMethod</span>();  <span class="comment">// AVOID!</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3_常量(Constants)">3.3 常量(Constants)</h2><p>位于for循环中作为计数器值的数字常量，除了-1，0和1之外，不应被直接写入代码。</p>
<h2 id="3-4_变量赋值(Variable_Assignments)">3.4 变量赋值(Variable Assignments)</h2><p>避免在一个语句中给多个变量赋相同的值。它很难读懂。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooBar.fChar = barFoo.lchar = ‘<span class="built_in">c</span>’;  <span class="comment">// AVOID!</span></span><br></pre></td></tr></table></figure>
<p>不要将赋值运算符用在容易与相等关系运算符混淆的地方。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (c++ = d++) &#123;    <span class="comment">// AVOID! (Java disallows)</span></span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该写成</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">if</span> <span class="comment">((c</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">=</span> <span class="comment">d</span><span class="literal">+</span><span class="literal">+</span><span class="comment">)</span> <span class="comment">!</span> <span class="comment">=</span> <span class="comment">0)</span> <span class="comment">&#123;</span></span><br><span class="line">    <span class="comment">…</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不要使用内嵌(embedded)赋值运算符试图提高运行时效率，这是编译器的工作。例如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="comment">(a = b +c)</span> + r; <span class="comment">// AOVID!</span></span><br></pre></td></tr></table></figure>
<p>应该写成</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">a</span> = b + c<span class="comment">;</span></span><br><span class="line">d = <span class="literal">a</span> + r<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-5_其它惯例(Miscellaneous_Practices)">3.5 其它惯例(Miscellaneous Practices)</h2><h3 id="3-5-1_圆括号与运算符优先级(Parentheses_and_Operator_Precedence)">3.5.1 圆括号与运算符优先级(Parentheses and Operator Precedence)</h3><p>一般而言，在含有多种运算符的表达式中使用括号来避免运算符优先级问题，是个好方法。即便运算符的优先级对你而言可能很清楚，但对其他人未必如此。你不能假设别的程序员和你一样清楚运算符的优先级。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="tag">a</span> == <span class="tag">b</span> &amp;&amp; c ==d)     <span class="comment">// AVOID!</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="tag">a</span> == b) &amp;&amp; (c == d))  <span class="comment">// RIGHT</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-2_返回值(Returning_Values)">3.5.2 返回值(Returning Values)</h3><p>设法让你的程序结构符合目的。例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (booleanException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该代之以如下方法：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> booleanException;</span><br></pre></td></tr></table></figure>
<p>类似地：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br></pre></td></tr></table></figure>
<p>应该写为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">return</span> (<span class="tag">condition</span> ? <span class="rule"><span class="attribute">x </span>:<span class="value"> y)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-3_条件运算符“?”前的表达式_(Expressions_before_“?”_in_the_Conditional_Operator)">3.5.3 条件运算符“?”前的表达式 <code>(Expressions before “?” in the Conditional Operator)</code></h3><p>如果一个包含二元运算符表达式出现在三元运算符“<code>? :</code>”之前，那么应该给表达式添上一对圆括号。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &gt;= <span class="number">0</span>) ? x : -x;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4_特殊注释(Special_Comments)">3.5.4 特殊注释(Special Comments)</h3><p>使用 TODO 来注释一个临时的或者未完成的解决方案。TODO 必须包含详细的信息，例如，需要做什么，打算怎么做，为什么以后才做，等。要发布到生产环境的代码尽量减少 TODO。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO: Change this <span class="built_in">to</span> use <span class="operator">a</span> flag instead <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">constant</span>.</span><br></pre></td></tr></table></figure>
<p>如果有可能，尽量包含具体的开发者帐号，以及具体的修正日期。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO(tom, Fix <span class="keyword">by</span> Nov <span class="number">2005</span>): Change this <span class="built_in">to</span> use <span class="operator">a</span> flag.</span><br></pre></td></tr></table></figure>
<h2 id="3-6_所有对象的共有方法(Methods_Common_to_All_Objects)">3.6 所有对象的共有方法(Methods Common to All Objects)</h2><h3 id="3-6-1_覆盖equals时请遵守通用约定">3.6.1 覆盖equals时请遵守通用约定</h3><p>Item 8: Obey the general contract when overriding equals.</p>
<p>重写 equals 方法看起来很简单，实际上非常容易犯错误。在多数情况下我们不推荐重写equals方法。如果确实有必要，这里再强调一下 Object.equals 的约定：</p>
<ul>
<li>自反：对于任意 non-null 的引用值x，x.equals(x) 必须返回true。</li>
<li>对称：对于任意的 non-null 的值x和y，x.equals(y) 和 y.equals(x) 必须返回相同的值。</li>
<li>传递：对于任意 non-null 的值，x，y，z，如果 x.equals(y) 返回true以及 y.equals(z) 返回true，那么 x.equals(z) 也必须返回 true。</li>
<li>一致：如果 equals 实现中的辅助信息没有改变，对于任意的x和y，对  x.equals(y) 必须返回相同的值。</li>
</ul>
<p>对于所有的 non-null 的 x，x.equals(null) 必须返回false。</p>
<h3 id="3-6-2_覆盖equals时总要覆盖hashCode">3.6.2 覆盖equals时总要覆盖hashCode</h3><p>Item 9: Always override hashCode when you override equals.</p>
<p>对于每一个 equals 方法被重写的类，你必须重写 hashCode 方法。请仔细阅读 javadoc 中关于 Object.equals 的描述。相等的对象必须有相等的 hash 值。</p>
<p>这里是一个错误的例子：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> class PhoneNumber &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> areaCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> prefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> lineNumber;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PhoneNumber pn = (PhoneNumber)o;</span><br><span class="line">        <span class="keyword">return</span> pn.lineNumber == lineNumber</span><br><span class="line">                         &amp;&amp; pn.prefix  == prefix</span><br><span class="line">                         &amp;&amp; pn.areaCode  == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Broken - no hashCode method!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;PhoneNumber, <span class="keyword">String</span>&gt; m = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;PhoneNumber, <span class="keyword">String</span>&gt;();</span><br><span class="line">m.put(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>), <span class="string">"Jenny"</span>);</span><br><span class="line"><span class="comment">// null is returned instead of "Jenny"</span></span><br><span class="line">m.<span class="built_in">get</span>(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>));</span><br></pre></td></tr></table></figure>
<h2 id="3-7_泛型(Generics)">3.7 泛型(Generics)</h2><h3 id="3-7-1_请不要在新代码中使用原生态类型">3.7.1 请不要在新代码中使用原生态类型</h3><p>Item 23: Don’t use raw types in new code.</p>
<p>从1.5版本开始，java提供了泛型机制来保证类型的安全。除非为了向后兼容，不允许使用原生态类型，像List（而不是 <code>List&lt;String&gt;</code>)。</p>
<p>下面这段代码就很容易出问题：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Now</span> a raw collection <span class="keyword">type</span> - don't <span class="keyword">do</span> this!</span><br><span class="line">/**</span><br><span class="line"> * <span class="type">My</span> stamp collection. <span class="type">Contains</span> only <span class="type">Stamp</span> instances.</span><br><span class="line"> */</span><br><span class="line">private final <span class="type">Collection</span> stamps = ... ;</span><br><span class="line">        </span><br><span class="line">// <span class="type">Erroneous</span> insertion <span class="keyword">of</span> coin into stamp collection</span><br><span class="line">stamps.add(new <span class="type">Coin</span>( ... ));</span><br><span class="line">        </span><br><span class="line">// <span class="type">Now</span> a raw <span class="keyword">iterator</span> <span class="keyword">type</span> - don't <span class="keyword">do</span> this!</span><br><span class="line"><span class="keyword">for</span> (<span class="type">Iterator</span> i = stamps.<span class="keyword">iterator</span>(); i.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">Stamp</span> s = (<span class="type">Stamp</span>) i.next(); // <span class="type">Throws</span> <span class="type">ClassCastException</span></span><br><span class="line">    ... // <span class="type">Do</span> something <span class="keyword">with</span> the stamp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型能够很好地解决这个问题：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameterized collection type - typesafe</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Stamp&gt; stamps = ... ;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// for-each loop over a parameterized collection - typesafe</span></span><br><span class="line"><span class="keyword">for</span> (Stamp <span class="string">s :</span> stamps) &#123; <span class="comment">// No cast</span></span><br><span class="line">    ... <span class="comment">// Do something with the stamp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-2_消除非受检警告">3.7.2 消除非受检警告</h3><p>Item 24: Elimate unchecked warnings.</p>
<p>在使用泛型编程的时候，我们经常会看到编译警告：非受检的类型转换警告，非受检的函数调用警告等等。很多非受检的警告是非常容易消除的，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Set</span>&lt;Lark&gt; exaltation = <span class="keyword">new</span> HashSet();</span></span><br></pre></td></tr></table></figure>
<p>编译器会抛出警告：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Venery.<span class="string">java:</span><span class="number">4</span>: <span class="string">warning:</span> [unchecked] unchecked conversion</span><br><span class="line"><span class="string">found  :</span> HashSet, <span class="string">required:</span> Set&lt;Lark&gt;</span><br><span class="line">    Set&lt;Lark&gt; exaltation = <span class="keyword">new</span> HashSet();</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>
<p>我们很容易消除这个警告：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">Set</span>&lt;Lark&gt; exaltation = <span class="keyword">new</span> HashSet&lt;Lark&gt;();</span></span><br></pre></td></tr></table></figure>
<p>关于消除非受检的警告，有如下基本规则：</p>
<ul>
<li>尽可能地消除每个非受检的警告。</li>
<li>如果无法消除，必须能够证明这个警告不会引起类型安全问题，同时通过 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 来消除警告。</li>
<li>SuppressWarning必须作用在尽可能小的范围。</li>
<li>每一次使用 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 时，必须注释说明为什么这样做是安全的。</li>
</ul>
<h2 id="3-8_枚举和注解(Enums_and_Annotations)">3.8 枚举和注解(Enums and Annotations)</h2><h3 id="3-8-1_用_enum_代替_int_常量">3.8.1 用 enum 代替 int 常量</h3><p>Item 30: Use enums instead of int constants.</p>
<p>下面的代码利用了一种叫 int enum pattern 的技术，它有很多问题。它不能保证类型安全；它不能很好地转换为可读的字符串；如果数值变了的话，使用它的代码必须重新编译（严重！）。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The int enum pattern - severely deficient!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_NAVEL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_TEMPLE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORANGE_BLOOD = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>我们应该用enum来实现上面的代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Orange</span> &#123; <span class="title">NAVEL</span>, <span class="title">TEMPLE</span>, <span class="title">BLOOD</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意：出于效率考虑，Android 的开发允许使用 int 常量，但是使用时要非常小心。</p>
<h3 id="8-8-2_用实例域代替序数">8.8.2 用实例域代替序数</h3><p>Item 31: Use instance fields instead of ordinals.</p>
<p>所有的枚举类型都有一个ordinal方法，它能够返回每个枚举常量在类型中的位置。有时候，你可能会想从这个方法中直接得到一个整数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abuse of ordinal to derive an associated value - DON'T DO THIS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO, SEXTET, DUET, TRIO, QUARTET, QUINTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要从枚举的序数中得到一个整数值，如果需要，请创建一个整数字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.numberOfMusicians = size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-3_坚持使用Override注解">3.8.3 坚持使用Override注解</h3><p>Item 36: Consistently use the Override annotation.</p>
<p>你能发现下面代码的错误吗？</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Bigram &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">char</span> <span class="built_in">second</span>;</span><br><span class="line">    <span class="keyword">public</span> Bigram(<span class="built_in">char</span> first, <span class="built_in">char</span> <span class="built_in">second</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">second</span> = <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(Bigram b) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.first == first &amp;&amp; b.<span class="built_in">second</span> == <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + <span class="built_in">second</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们加入了 <code>@Override</code> 的标注，编译器就能告诉我们错误了。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Override</span> public boolean equals(<span class="type">Bigram</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b.first == first &amp;&amp; b.second == second;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="type">Bigram</span>.java:<span class="number">10</span>: <span class="keyword">method</span> does <span class="keyword">not</span> override <span class="keyword">or</span> implement a <span class="keyword">method</span></span><br><span class="line">        <span class="keyword">from</span> a supertype</span><br><span class="line">@<span class="type">Override</span> public boolean equals(<span class="type">Bigram</span> b) &#123;</span><br><span class="line">^</span><br></pre></td></tr></table></figure>
<h2 id="3-9_方法_(Methods)">3.9 方法 (Methods)</h2><h3 id="3-9-1_检查参数的有效性">3.9.1 检查参数的有效性</h3><p>Item 38: Check parameters for validaity.</p>
<p>大多数的方法对于传入参数的值有限制，例如，通常来说索引值必须是非负的，对象应用必须是非空的。一条总的规则是，在错误发生之前必须尽早地发现它、处理它。</p>
<p>如果我们能在方法执行主要逻辑之前检查到错误的参数，我们就能够及时退出，同时抛出一个合适的一场。如果错误的参数进入函数的主要执行逻辑，方法就可能抛出一个奇怪的异常。在更坏的情况下，方法可能成功返回，但是中间出现一些不可预知的结果。</p>
<p>对于公共方法，用 <code>@throws</code> 来注释异常。比如，这些异常可能是 <code>IllegalArgumentException</code> 或者是 <code>NullPointerException</code>。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@param</span> m the modulus, which must be positive</span><br><span class="line"> * <span class="doctag">@return</span> this mod m</span><br><span class="line"> * <span class="doctag">@throws</span> ArithmeticException if m is less than or equal to 0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.signum() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Modulus &lt;= 0: "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Do the computation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10_异常(Exceptions)">3.10 异常(Exceptions)</h2><h3 id="3-10-1_只针对异常的情况才使用异常">3.10.1 只针对异常的情况才使用异常</h3><p>Item 57: Use exceptions only for exceptional conditions.</p>
<p>异常，只应该被应用于异常的情况；不能被用于正常的控制流程。这一点在很多时候会被误用，下面是一个极端的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Horrible abuse of exceptions. Don't ever do this!</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        range[i++].climb();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-2_对可恢复的情况使用受检异常，对编程错误使用运行时异常">3.10.2 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><p>Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors.</p>
<p>受检异常在调用者能够合适处理并恢复程序执行的情况下使用。运行时异常用来表明程序自身的错误，大多数的运行时异常都是因为调用者违反了函数的预设条件。</p>
<p>应用程序所有非受检的异常应该派生自 RuntimeException ，作为惯例，Error 通常只被 JVM 使用。</p>
<h3 id="3-10-3_抛出与抽象相对应的异常">3.10.3 抛出与抽象相对应的异常</h3><p>Item 61: Throw exceptions appropriate to the abstraction.</p>
<p>抛出与当前方法明显无关的异常会让人十分迷惑，而且会暴露出实现的细节。这种情况通常是因为高一级的方法直接抛出底层调用的异常引起的。我们采用异常转换的方法来避免这一种情况。也就是说，高一级的方法应该捕获底层调用的异常，抛出一个更高抽象的异常。例如，下面是一段 AbstractSequentialList 实现代码，它需要实现 <code>List&lt;E&gt;#get</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the element at the specified position in this list.</span><br><span class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if the index is out of range</span><br><span class="line"> * (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;).</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> i.<span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NoSuchElementException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，不要滥用了异常转换。</p>
<h3 id="3-10-4_每个方法抛出的异常都要有文档">3.10.4 每个方法抛出的异常都要有文档</h3><p>Item 62: Document all exceptions thrown by each method.</p>
<p>关于异常的文档有以下要求：</p>
<p>必须单独地声明每个受检异常，同时准确地用 <code>@throws</code> 来说明异常条件。</p>
<p>用 Javadoc 的 <code>@throws</code> 来表明非受检的异常；但是不要用throws关键字在方法的声明中包括非受检的异常。</p>
<p>如果一个异常会被同一个类的很多方法抛出，在类的注释中表明这个异常是可以接受的。但是通常不推荐这么做。</p>
<h3 id="3-10-5_不要忽略异常">3.10.5 不要忽略异常</h3><p>Item 65: Don’t ignore exceptions.</p>
<p>我们不允许像下面的代码一样忽略异常：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span>(<span class="params">String <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(<span class="keyword">value</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至少，在 catch 语句里，应该有注释说明为什么忽略异常是合适的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** If value is not a valid number, original port number is used. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setServerPort</span>(<span class="params">String <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverPort = Integer.parseInt(<span class="keyword">value</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// Method is documented to just ignore invalid user input.</span></span><br><span class="line">        <span class="comment">// serverPort will just be unchanged.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-6_不要一次捕获所有异常">3.10.6 不要一次捕获所有异常</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    <span class="function">someComplicatedIOFunction</span>();        <span class="comment">// may throw IOException </span></span><br><span class="line">    <span class="function">someComplicatedParsingFunction</span>();   <span class="comment">// may throw ParsingException </span></span><br><span class="line">    <span class="function">someComplicatedSecurityFunction</span>();  <span class="comment">// may throw SecurityException </span></span><br><span class="line">    <span class="comment">// phew, made it all the way </span></span><br><span class="line">    &#125; catch (Exception e) &#123;                 <span class="comment">// I'll just catch all exceptions </span></span><br><span class="line">    <span class="function">handleError</span>();                      <span class="comment">// with one generic handler!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绝大多数情况下，捕获 Exception 或者是 Throwable 都是不对的。这个非常危险，你可能会捕获一些没有想到的异常，或者是稍后加入的异常。</p>
<h1 id="参考">参考</h1><p><a href="http://source.android.com/source/code-style.html" target="_blank" rel="external">Code Style Guidelines for Contributors</a></p>
<p><a href="http://linfuyan.com/google-java-style-guide/">Google Java 编程风格指南</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-_声明(Declaration)">1. 声明(Declaration)</h1><h2 id="1-1_每行声明变量的数量(Number_Per_Line)">1.1 每行声明变量的数量(Number Per Line)</h2><p>推荐一行一个声明，因为]]>
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Java" scheme="http://linfuyan.com/tags/Java/"/>
    
      <category term="代码" scheme="http://linfuyan.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="实践" scheme="http://linfuyan.com/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="规范" scheme="http://linfuyan.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Java 编程风格指南]]></title>
    <link href="http://linfuyan.com/google-java-style-guide/"/>
    <id>http://linfuyan.com/google-java-style-guide/</id>
    <published>2015-11-12T03:24:09.000Z</published>
    <updated>2015-11-12T07:04:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-_简介">1. 简介</h1><h2 id="1-1_术语说明">1.1 术语说明</h2><p>在本文档中，除非另有说明：</p>
<p>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</p>
<p>其他的术语说明会偶尔在后面的文档出现。</p>
<h2 id="1-2_指南说明">1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<h1 id="2-_源文件基础">2. 源文件基础</h1><h2 id="2-1_文件名">2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 .java。</p>
<h2 id="2-2_文件编码：UTF-8">2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p>
<h2 id="2-3_特殊字符">2.3 特殊字符</h2><h3 id="2-3-1_空白字符">2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="2-3-2_特殊转义序列">2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \“, \‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p>
<h3 id="2-3-3_非ASCII字符">2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。<br>例如：</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String unitAbbrev = “μs”;</td>
<td>赞，即使没有注释也非常清晰</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // “μs”</td>
<td>允许，但没有理由要这样做</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td>
<td>允许，但这样做显得笨拙还容易出错</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”;</td>
<td>很糟，读者根本看不出这是什么</td>
</tr>
<tr>
<td>return ‘\ufeff’ + content; // byte order mark</td>
<td>好，对于非打印字符，使用转义，并在必要时写上注释</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Tip: 永远不要由于害怕某些程序可能无法正确处理非 ASCII 字符而让你的代码可读性变差。当程序无法正确处理非 ASCII 字符时，它自然无法正确运行， 你就会去 fix 这些问题的了。(言下之意就是大胆去用非 ASCII 字符，如果真的有需要的话)</p>
</blockquote>
<h1 id="3-_源文件结构">3. 源文件结构</h1><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h2 id="3-1_许可证或版权信息">3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="3-2_package语句">3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="3-3_import语句">3.3 import语句</h2><h3 id="3-3-1_import不要使用通配符">3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：import java.util.*;</p>
<h3 id="3-3-2_不要换行">3.3.2 不要换行</h3><p>import 语句不换行，列限制(4.4节)并不适用于 import 语句。(每个 import 语句独立成行)</p>
<h3 id="3-3-3_顺序和间距">3.3.3 顺序和间距</h3><p>import 语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<ol>
<li>所有的静态导入独立成组</li>
<li><code>com.google</code> imports (仅当这个源文件是在 <code>com.google</code> 包下)</li>
<li>第三方的包。每个顶级包为一组，字典序。例如： android, com, junit, org, sun</li>
<li><code>java</code> imports</li>
<li><code>javax</code> imports</li>
</ol>
<p>组内不空行，按字典序排列。</p>
<blockquote>
<p>飞博团队要求：</p>
</blockquote>
<p>导入包的顺序为：静态导入，java基础包，javax基础包，android包，第三方包（每个顶级包为一组，字典序。例如：com, junit, org, sun, feibo包。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">import</span> <span class="tag">java</span><span class="class">.a</span><span class="class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">import</span> <span class="tag">javax</span><span class="class">.a</span><span class="class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">import</span> <span class="tag">android</span><span class="class">.a</span><span class="class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">import</span> <span class="tag">org</span><span class="class">.apache</span><span class="class">.a</span><span class="class">.B</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.feibo</span><span class="class">.a</span><span class="class">.B</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-4_类声明">3.4 类声明</h2><h3 id="3-4-1_只有一个顶级类声明">3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含 .java 后缀)。</p>
<h3 id="3-4-2_类成员顺序">3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 </p>
<p>最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h4 id="3-4-2-1_重载：永不分离">3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="4-_格式">4. 格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h2 id="4-1_大括号">4.1 大括号</h2><h3 id="4-1-1_使用大括号(即使是可选的)">4.1.1 使用大括号(即使是可选的)</h3><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h3 id="4-1-2_非空块：K_&amp;_R_风格">4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="external">Egyptian brackets</a>):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>实例：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> new <span class="type">MyClass</span>() &#123;</span><br><span class="line">    @<span class="type">Override</span> public <span class="type">void</span> <span class="keyword">method</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                something();</span><br><span class="line">            &#125; catch (<span class="type">ProblemException</span> e) &#123;</span><br><span class="line">                recover();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.8.1节给出了enum类的一些例外。</p>
<h3 id="4-1-3_空块：可以用简洁版本">4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(<code>if/else 或 try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</p>
<p>实例：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2_块缩进：4个空格">4.2 块缩进：4个空格</h2><p>每当开始一个新的块，缩进增加4个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h2 id="4-3_一行一个语句">4.3 一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="4-4_列限制：80或100">4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如， Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。</li>
<li>package 和 import 语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到 shell 中的命令行。</li>
</ol>
<h2 id="4-5_自动换行">4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
<h3 id="4-5-1_从哪里断开">4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li><p>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如C++和JavaScript)。 </p>
<ul>
<li>这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的 <code>&amp;（&lt;T extends Foo &amp; Bar&gt;)</code> ，catch块中的管道符号 <code>(catch (FooException | BarException e)</code> </li>
</ul>
</li>
<li><p>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。</p>
<ul>
<li>这条规则也适用于foreach语句中的分号。</li>
</ul>
</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<h3 id="4-5-2_自动换行时缩进至少+4个空格">4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>当一个表达式无法容纳在一行内时，可以依据如下一般规则断开之：</p>
<ul>
<li>在一个逗号后面断开。</li>
<li>在一个操作符前面断开。</li>
<li>宁可选择较高级别的(higher-level)的断开，而非较低级别(lower-level)的断开。</li>
<li>新的一行应该与上一行同一级别表达式的开头处对齐。</li>
<li>如果以上规则导致你的代码混乱或者使你的代码都堆挤在右边，那就代之以缩进8个空格。</li>
</ul>
<p>以下是断开方法的一些例子：</p>
<pre><code>someMethod<span class="list">(<span class="keyword">longExpression1</span>, longExpression2, longExpression3,
        longExpression4, longExpression5)</span><span class="comment">; // 8个空格</span>
var = someMethod1<span class="list">(<span class="keyword">Expression1</span>,
                  someMethod2<span class="list">(<span class="keyword">longExpression2</span>,
                              longExpression3)</span>)</span><span class="comment">;</span>
</code></pre><p>以下是两个断开算术表达式的例子。前者更好，因为断开处位于括号表达式的外边，这是个较高级别的断开。</p>
<pre><code>lo<span class="label">ngName1</span> = lo<span class="label">ngName2</span> * <span class="comment">(longName3 + longName4 - longName5)</span>
            + <span class="number">4</span> * lo<span class="label">ngname6</span>; <span class="comment">// PREFER</span>
lo<span class="label">ngName1</span> = lo<span class="label">ngName2</span> * <span class="comment">(longName3 + longName4
        - longName5)</span> + <span class="number">4</span> * lo<span class="label">ngName6</span>; <span class="comment">//AVOID</span>
</code></pre><p>以下是两个缩进方法声明的例子。前者是常规情形，后者若使用常规的缩进方式将会使第二行和第三行移得很靠右，所以代这以缩进8个空格。</p>
<pre><code><span class="comment">// CONVENTION INDENTATION</span>
someMethod(<span class="built_in">int</span> anArg, <span class="keyword">Object</span> anotherArg,
           <span class="keyword">String</span> yetAnotherArg,
           <span class="keyword">Object</span> andStillAnother) {
    ……
}

<span class="comment">// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> horkingLongMethodName(<span class="built_in">int</span> anArg,
        <span class="keyword">Object</span> anotherArg, <span class="keyword">String</span> yetAnotherArg,
        <span class="keyword">Object</span> andStillAnother) {
    ……
}
</code></pre><p>if语句的换行通常使用8个空格的规则，因为常规缩进(4个空格)会使语句看起来比较费劲。比如：</p>
<pre><code><span class="comment">//DON’T USE THIS INDENTATION</span>
<span class="keyword">if</span> <span class="params">(<span class="params">(condition1 &amp;&amp; condition2)</span>
    || <span class="params">(condition3 &amp;&amp; condition4)</span>
    || !<span class="params">(condition5 &amp;&amp; condition6)</span>)</span> { <span class="comment">//BAD WRAPS</span>
    doSomethingAboutIt<span class="params">()</span>; <span class="comment">// MAKE THIS LING EASY TO MISS</span>
}
<span class="comment">// USE THIS INDENTATION INSTEAD</span>
<span class="keyword">if</span> <span class="params">(<span class="params">(condition1 &amp;&amp; condition2)</span>
        || <span class="params">(condition3 &amp;&amp; condition4)</span>
        || !<span class="params">(condition5 &amp;&amp; condition6)</span>)</span> {
    doSomethingAboutIt<span class="params">()</span>;
}

<span class="comment">// OR USE THIS</span>
<span class="keyword">if</span> <span class="params">(<span class="params">(condition1 &amp;&amp; condition2)</span> || <span class="params">(condition3 &amp;&amp; condition4)</span>
        || !<span class="params">(condition5 &amp;&amp; condition6)</span>)</span> {
   doSomthingAoutIt<span class="params">()</span>;
}
</code></pre><p>这里有三种可行的方法用于处理三元运算表达式：</p>
<pre><code>alpha = (aLongBooleanExpression) ? <span class="built_in">beta</span> : <span class="built_in">gamma</span>;

alpha = (aLongBooleanExpression) ? <span class="built_in">beta</span>
                                 : <span class="built_in">gamma</span>;

alpha = (aLongBooleanExpression)
        ? <span class="built_in">beta</span>
        : <span class="built_in">gamma</span>;
</code></pre><h2 id="4-6_空白">4.6 空白</h2><h3 id="4-6-1_垂直空白">4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ol>
<p>空行将逻辑相关的代码段分隔开，以提高可读性。</p>
<p>下列情况应总是使用两个空行：</p>
<ul>
<li>一个源文件的两个片段(section)之间。</li>
<li>类声明和接口声明之间。</li>
</ul>
<p>下列情况应该总是使用一个空行：</p>
<ul>
<li>两个方法之间。方法与方法之间 以空行分隔。</li>
<li>方法内的局部变量和方法的第一条语句之间。</li>
<li>块注释(参见“5.1.1”)或单行注释(参见5.1.2)之前。</li>
<li>一个方法内的两个逻辑段之间，用以提高可读性。</li>
</ul>
<h3 id="4-6-2_水平空白">4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code> (不使用空格)。</li>
<li><code>String[][] x = foo;</code> (大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的<code>&amp;(&lt;T extends Foo &amp; Bar&gt;)</code>。</li>
<li>catch块中的管道符号<code>(catch (FooException | BarException e)</code>。</li>
<li>foreach语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则双斜杠(<code>//</code>)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：<code>List&lt;String&gt; list</code>。</li>
<li>数组初始化中，大括号内的空格是可选的，<ul>
<li><code>new int[] {5, 6}</code> 和 <code>new int[] { 5, 6 }</code> 都是可以的。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h3 id="4-6-3_水平对齐：不做要求">4.6.3 水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color <span class="built_in">color</span>;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了 reviewer 的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-6-4_空格(Blank_Spaces)">4.6.4 空格(Blank Spaces)</h3><p>下列情况应该使用空格：</p>
<p>1. 一个紧跟着括号的关键应该被空格分开，例如：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">while</span> (true) &#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：空格不应该置于方法名与其左括号之间，这将有助于区分关键字和方法调用。</p>
</blockquote>
<p>2. 空白应该位于参数列表中逗号的后面。</p>
<p>3. 所有的二元运算符，除了“.”，应该使用空格将之与操作数分开。一元操作符和操作数之间不应该加空格，比如：负号(“-”)，自增(“++”)和自减(“–”)。例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a += c + <span class="keyword">d</span>;</span><br><span class="line">a = (a + b) / (c * <span class="keyword">d</span>);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">d</span>++ = s++) &#123;</span><br><span class="line">    <span class="keyword">n</span>++;</span><br><span class="line">&#125;</span><br><span class="line">printSize(“size is ” + foo + “\<span class="keyword">n</span>”);</span><br></pre></td></tr></table></figure>
<p>4. for语句中的表达式应该被空格分开，例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (expr1; expr2; expr3)</span><br></pre></td></tr></table></figure>
<p>5. 强制转型后应该跟一个空格，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myMethod<span class="list">(<span class="list">(<span class="keyword">byte</span>)</span> aNum, <span class="list">(<span class="keyword">Object</span>)</span> x)</span><span class="comment">;</span></span><br><span class="line">myMethod<span class="list">(<span class="list">(<span class="keyword">int</span>)</span> <span class="list">(<span class="keyword">cp</span> + <span class="number">5</span>)</span>, <span class="list">(<span class="list">(<span class="keyword">int</span>)</span> <span class="list">(<span class="keyword">i</span> + <span class="number">3</span>)</span>)</span> + <span class="number">1</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-7_用小括号来限定组：推荐">4.7 用小括号来限定组：推荐</h2><p>除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h2 id="4-8_具体结构">4.8 具体结构</h2><h3 id="4-8-1_枚举类">4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> &#123; <span class="title">CLUBS</span>, <span class="title">HEARTS</span>, <span class="title">SPADES</span>, <span class="title">DIAMONDS</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="4-8-2_变量声明">4.8.2 变量声明</h3><h4 id="4-8-2-1_每次只声明一个变量">4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如 <code>int a, b;</code>。</p>
<h4 id="4-8-2-2_需要时才声明，并尽快进行初始化">4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="4-8-3_数组">4.8.3 数组</h3><h4 id="4-8-3-1_数组初始化：可写成块状结构">4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-2_非C风格的数组声明">4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[]</code> args， 而非 <code>String args[]</code>。</p>
<h3 id="4-8-4_switch语句">4.8.4 switch语句</h3><p>术语说明：switch 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签( case FOO: 或 default: )，后面跟着一条或多条语句。</p>
<h4 id="4-8-4-1_缩进">4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为4个空格。</p>
<p>每个switch标签后新起一行，再缩进4个空格，写下一条或多条语句。</p>
<h4 id="4-8-4-2_Fall-through：注释">4.8.4.2 Fall-through：注释</h4><p>在一个 switch 块内，每个语句组要么通过 <code>break, continue, return</code> 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是 OK 的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> 2:</span><br><span class="line">        prepareOneOrTwo();</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        handleOneTwoOrThree();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-4-3_default的情况要写出来">4.8.4.3 default的情况要写出来</h4><p>每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。</p>
<h3 id="4-8-5_注解(Annotations)">4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@Nullable</span></span><br><span class="line">public String <span class="function">getNameIfPresent</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Partial</span> <span class="variable">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="4-8-6_注释">4.8.6 注释</h3><h4 id="4-8-6-1_块注释风格">4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。以下示例注释都是OK的。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> This is          // <span class="keyword">And</span> so           /<span class="keyword">*</span> Or you can</span><br><span class="line"> <span class="keyword">*</span> okay.            // is this.          <span class="keyword">*</span> even do this. <span class="keyword">*</span>/</span><br><span class="line"> <span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 <code>/* ... */</code>。</p>
</blockquote>
<h3 id="4-8-7_Modifiers">4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-8_简单语句(Simple_Statement)">4.8.8 简单语句(Simple Statement)</h3><p>每行至多包含一条语句，例如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>           <span class="comment">//</span> <span class="comment">Correct</span></span><br><span class="line"><span class="comment">argv</span><span class="literal">+</span><span class="literal">+</span><span class="comment">;</span> <span class="comment">argc</span><span class="literal">-</span><span class="literal">-</span><span class="comment">;</span>    <span class="comment">//</span> <span class="comment">AVOID!</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-9_复合语句(Compound_Statements)">4.8.9 复合语句(Compound Statements)</h3><p>复合语句是包含在大括号中的语句序列，形如“{ statements }”。例如下面各段。</p>
<ul>
<li>被括其中的语句应该较之复合语句缩进一个层次。</li>
<li>左大括号“{”应位于复合语句起始行的行尾；右大括号“}”应另起一行并与复合语句首行对齐。</li>
<li>大括号可以被用于所有语句，包括单个语句，只要这些语句是诸如if–else或for控制结构的一部分。这样便于添加语句而无需担心由于忘了加括号而引入bug.</li>
</ul>
<h3 id="4-8-10_返回语句(return_Statements)s">4.8.10 返回语句(return Statements)s</h3><p>一个带返回值的return语句不使用小括号“()”，除非它们以某种方式使返回值更显见。例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> myDisk.<span class="built_in">size</span>();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">size</span> ? <span class="built_in">size</span> ; defaultSize);</span><br></pre></td></tr></table></figure>
<h3 id="4-8-11_if,_if-else,_if_else-if_else_语句(if,_if-else,_if_else-if_else_Statements)">4.8.11 <code>if, if-else, if else-if else</code> 语句(<code>if, if-else, if else-if else Statements</code>)</h3><p>if-else 语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：if 语句问题用 “{” 和 “}” 括起来，避免使用如下容易引起错误的格式：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">condition</span>)  <span class="comment">// AVOI! THIS OMITS THE BRACES &#123;&#125;!</span></span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-12_for语句(for_Statements)">4.8.12 for语句(for Statements)</h3><p>一个for语句应该具有如下格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; <span class="keyword">update</span>) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个空的for语句(所有工作都在初始化，条件判断，更新子句中完成)应该具有如下格式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">initialization</span>; condition; update);</span><br></pre></td></tr></table></figure>
<p>当在 for 语句的初始化或更新子句中使用逗号时，避免因使用三个以上变量，而导致复杂度提高。若需要，可以在 for 循环之前(为初始化子句)或 for 循环末尾(为更新子句)使用单独的语句。</p>
<h3 id="4-8-13_while语句(while_Statements)">4.8.13 while语句(while Statements)</h3><p>一个 while 语句应该具有如下格式：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    statements<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="escape">``</span><span class="escape">` </span>       </span><br><span class="line">     </span><br><span class="line">一个空的 <span class="keyword">while</span> 语句应该具有如下格式：</span><br></pre></td></tr></table></figure>
<pre><code><span class="keyword">while</span> <span class="comment">(condition)</span>;
</code></pre><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">4.8</span>.<span class="number">14</span> <span class="keyword">do</span>-<span class="keyword">while</span>语句(<span class="keyword">do</span>-<span class="keyword">while</span> Statements)</span><br><span class="line"></span><br><span class="line">一个 <span class="keyword">do</span>-<span class="keyword">while</span> 语句应该具有如下格式：</span><br></pre></td></tr></table></figure>
<p>do {<br>    statements;<br>} while (condition);<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### <span class="number">4.8</span><span class="number">.15</span> switch语句(switch Statements)</span></span><br><span class="line"></span><br><span class="line">一个 <span class="keyword">switch</span> 语句应该具有如下格式：</span><br></pre></td></tr></table></figure></p>
<p>switch (condition) {<br>case ABC:<br>    statements;<br>    /<em> falls through </em>/<br>case DEF: {<br>    statements;<br>    break;<br>}<br>case XYZ: {<br>    statements;<br>    break;<br>}<br>default:<br>    assert false : condition;  // Or throw error.<br>}<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每当一个 <span class="keyword">case</span> 顺着往下执行时(因为没有 <span class="keyword">break</span> 语句)，通常应在 <span class="keyword">break</span> 语句的位置添加注释。上面的示例代码中就包含注释 <span class="string">`/* falls through */`</span> 。</span><br><span class="line"></span><br><span class="line">每个 <span class="keyword">switch</span> 语句，必须有对应的 <span class="keyword">default</span> 语句。如果执行不到，可以加上  <span class="keyword">assert</span>语句。</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 语句后面需要使用 <span class="string">"&#123;"</span> , <span class="string">"&#125;"</span> 包含语句块。</span><br><span class="line"></span><br><span class="line">### <span class="number">4.8</span>.16 <span class="keyword">try</span>-<span class="keyword">catch</span>语句(<span class="keyword">try</span>-<span class="keyword">catch</span> Statements)</span><br><span class="line"></span><br><span class="line">一个 <span class="keyword">try</span>-<span class="keyword">catch</span> 语句应该具有如下格式：</span><br></pre></td></tr></table></figure></p>
<p>try {<br>    statements;<br>} catch (ExceptionClass e) {<br>    statements;<br>}<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个 <span class="keyword">try</span>-<span class="keyword">catch</span> 语句后面也可能跟着一个 <span class="keyword">finally</span> 语句，不论 <span class="keyword">try</span> 代码块是否顺利执行完，它都会被执行。</span><br></pre></td></tr></table></figure></p>
<p>try {<br>    statements;<br>} catch (ExceptionClass e) {<br>    statements;<br>} finally {<br>    statements;<br>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="number">5.</span> 命名规范(Naming)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## <span class="number">5.1</span> 对所有标识符都通用的规则</span></span><br><span class="line"></span><br><span class="line">标识符只能使用 ASCII 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 \w+。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## <span class="number">5.2</span> 标识符类型的规则</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### <span class="number">5.2</span><span class="number">.1</span> 包名</span></span><br><span class="line"></span><br><span class="line">一个唯一包名的前缀总是全部小写的 ASCⅡ 字母并且是一个顶级域名，通常是 com，gov，edu，mil，net，org，或<span class="number">1981</span>年ISO <span class="number">3166</span>标准所指定的标识的国家的英文双字符代码。包名的后续部分根据不同机构各自内部的命名规范而不尽相同。这类命名规范可能以特定目录名的组成来区分部门(department)，项目(project)，机器(machine)，或注册名(login names)。</span><br><span class="line"></span><br><span class="line">包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure></p>
<p>com.sun.eng<br>com.feibo.joke<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### <span class="number">5.2</span><span class="number">.2</span> 类名</span></span><br><span class="line"></span><br><span class="line">类名是一个名词，采用大小写混合方式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。使用完整单词，避免缩写词(除非该缩写词被广泛的使用，如 URL，HTML)。例如：</span><br><span class="line"></span><br><span class="line">类名都以 UpperCamelCase 风格编写。</span><br><span class="line"></span><br><span class="line">类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</span><br><span class="line"></span><br><span class="line">测试类的命名以它要测试的类的名称开始，以 Test 结束。例如， HashTest 或 HashIntegrationTest。</span><br></pre></td></tr></table></figure></p>
<p>class Raster</p>
<p>class ImageSprite<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">5.2</span>.<span class="number">3</span> 方法名</span><br><span class="line"></span><br><span class="line">方法名都以 lowerCamelCase 风格编写。</span><br><span class="line"></span><br><span class="line">方法名通常是动词或动词短语。</span><br><span class="line"></span><br><span class="line">下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是： <span class="escape">`t</span>est&lt;MethodUnderTest&gt;_&lt;state&gt;<span class="escape">` </span>，例如 <span class="escape">`t</span>estPop_emptyStack<span class="escape">`。</span> 并不存在唯一正确的方式来命名测试方法。</span><br><span class="line"></span><br><span class="line">### <span class="number">5.2</span>.<span class="number">4</span> 常量名</span><br><span class="line"></span><br><span class="line">常量名命名模式为 <span class="escape">`C</span>ONSTANT_CASE<span class="escape">` </span>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</span><br><span class="line"></span><br><span class="line">每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</span><br></pre></td></tr></table></figure></p>
<p>// Constants<br>static final int NUMBER = 5;<br>static final ImmutableList<string> NAMES = ImmutableList.of(“Ed”, “Ann”);<br>static final Joiner COMMA_JOINER = Joiner.on(‘,’);  // because Joiner is immutable<br>static final SomeMutableType[] EMPTY_ARRAY = {};<br>enum SomeEnum { ENUM_CONSTANT }</string></p>
<p>// Not constants<br>static String nonFinal = “non-final”;<br>final String nonStatic = “non-static”;<br>static final Set<string> mutableCollection = new HashSet<string>();<br>static final ImmutableSet<somemutabletype> mutableElements = ImmutableSet.of(mutable);<br>static final Logger logger = Logger.getLogger(MyClass.getName());<br>static final String[] nonEmptyArray = {“these”, “can”, “change”};<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这些名字通常是名词或名词短语。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5.2.5 非常量字段名</span></span><br><span class="line"></span><br><span class="line">非常量字段名以 lowerCamelCase 风格编写。</span><br><span class="line"></span><br><span class="line">这些名字通常是名词或名词短语。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5.2.6 参数名</span></span><br><span class="line"></span><br><span class="line">参数名以 lowerCamelCase 风格编写。</span><br><span class="line"></span><br><span class="line">参数应该避免用单个字符命名。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5.2.7 局部变量名</span></span><br><span class="line"></span><br><span class="line">局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</span><br><span class="line"></span><br><span class="line">虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</span><br><span class="line"></span><br><span class="line">即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 5.2.8 类型变量名</span></span><br><span class="line"></span><br><span class="line">类型变量可用以下两种风格之一进行命名：</span><br><span class="line"></span><br><span class="line">+ 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</span><br><span class="line">+ 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 5.3 驼峰式命名法(CamelCase)</span></span><br><span class="line"></span><br><span class="line">驼峰式命名法分大驼峰式命名法( UpperCamelCase )和小驼峰式命名法( lowerCamelCase )。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如<span class="string">"IPv6"</span>或<span class="string">"iOS"</span>)。 Google 指定了以下的转换方案。</span><br><span class="line"></span><br><span class="line">名字从散文形式(prose form)开始:</span><br><span class="line"></span><br><span class="line">1. 把短语转换为纯 ASCII 码，并且移除任何单引号。例如： <span class="string">"Müller’s algorithm"</span> 将变成 <span class="string">"Muellers algorithm"</span>。</span><br><span class="line">2. 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</span><br><span class="line">	+ 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<span class="string">"AdWords"</span>将分割成<span class="string">"ad words"</span>)。 需要注意的是<span class="string">"iOS"</span>并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</span><br><span class="line">3. 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</span><br><span class="line">	+ 每个单词的第一个字母都大写，来得到大驼峰式命名。</span><br><span class="line">	+ 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</span><br><span class="line">4. 最后将所有的单词连接起来得到一个标识符。</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|<span class="string">Prose form             </span>|<span class="string">   Correct         </span>|<span class="string">      Incorrect      </span>|</span><br><span class="line">|<span class="string">-----------------------------------------------------------------</span>|</span><br><span class="line">|<span class="string">"XML HTTP request"     </span>|<span class="string"> XmlHttpRequest    </span>|<span class="string">   XMLHTTPRequest    </span>|</span><br><span class="line">|<span class="string">"new customer ID"      </span>|<span class="string">  newCustomerId    </span>|<span class="string">     newCustomerID   </span>|</span><br><span class="line">|<span class="string">"inner stopwatch"      </span>|<span class="string">  innerStopwatch   </span>|<span class="string">     innerStopWatch  </span>|</span><br><span class="line">|<span class="string">"supports IPv6 on iOS?"</span>|<span class="string">  supportsIpv6OnIos</span>|<span class="string">     supportsIPv6OnIOS</span>|</span><br><span class="line">|<span class="string">"YouTube importer"     </span>|<span class="string">  YouTubeImporter  </span>|<span class="string">YoutubeImporter*</span>|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">加星号处表示可以，但不推荐。</span><br><span class="line"></span><br><span class="line">&gt; 注意：在英语中，某些带有连字符的单词形式不唯一。例如：<span class="string">"nonempty"</span>和<span class="string">"non-empty"</span>都是正确的，因此方法名 checkNonempty 和 checkNonEmpty 也都是正确的。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 编程实践</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 6.1 @Override： 能用则用</span></span><br><span class="line"></span><br><span class="line">只要是合法的，就把<span class="comment">@Override注解给用上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 6.2 捕获的异常：不能忽视</span></span><br><span class="line"></span><br><span class="line">除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。)</span><br><span class="line"></span><br><span class="line">如果它确实是不需要在 catch 块中做任何响应，需要做注释加以说明(如下面的例子)。</span><br></pre></td></tr></table></figure></somemutabletype></string></string></p>
<p>try {<br>    int i = Integer.parseInt(response);<br>    return handleNumericResponse(i);<br>} catch (NumberFormatException ok) {<br>    // it’s not numeric; that’s fine, just continue<br>}<br>return handleTextResponse(response);<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</span><br></pre></td></tr></table></figure></p>
<p>try {<br>    emptyStack.pop();<br>    fail();<br>} catch (NoSuchElementException expected) {<br>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## <span class="number">6.3</span> 静态成员：使用类进行调用</span></span><br><span class="line"></span><br><span class="line">使用类名调用静态的类成员，而不是具体某个对象或表达式。</span><br></pre></td></tr></table></figure></p>
<p>Foo aFoo = …;<br>Foo.aStaticMethod(); // good<br>aFoo.aStaticMethod(); // bad<br>somethingThatYieldsAFoo().aStaticMethod(); // very bad<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## <span class="number">6.4</span> Finalizers: 禁用</span></span><br><span class="line"></span><br><span class="line">极少会去重载 Object.finalize。</span><br><span class="line"></span><br><span class="line">&gt; Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第<span class="number">7</span>条款：“Avoid Finalizers”，然后不要使用它。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="number">7.</span> Javadoc</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## <span class="number">7.1</span> 格式</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### <span class="number">7.1</span><span class="number">.1</span> 一般形式</span></span><br><span class="line"></span><br><span class="line">Javadoc 块的基本格式如下所示：</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>Multiple lines of Javadoc text are written here,</li>
<li>wrapped normally…<br>*/<br>public int method(String p1) { … }<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者是以下单行形式：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/<em>* An especially short bit of Javadoc. </em>/<br>```</p>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="7-1-2_段落">7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="7-1-3_Javadoc_标记">7.1.3 Javadoc 标记</h3><p>标准的 Javadoc 标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="7-2_摘要片段">7.2 摘要片段</h2><p>每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 <code>A {@code Foo} is a...</code> 或 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record...</code> 。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的 Javadoc 写成 <code>/** @return the customer ID */</code> ，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="7-3_哪里需要使用_Javadoc">7.3 哪里需要使用 Javadoc</h2><p>至少在每个 public 类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p>
<h3 id="7-3-1_例外：不言自明的方法">7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如 getFoo，Javadoc 是可选的(即，是可以不写的)。这种情况下除了写 “Returns the foo” ，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p>
</blockquote>
<h3 id="7-3-2_例外：重载">7.3.2 例外：重载</h3><p>如果一个方法重载了超类中的方法，那么 Javadoc 并非必需的。</p>
<h3 id="7-3-3_可选的_Javadoc">7.3.3 可选的 Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。</p>
<h2 id="8-_参考">8. 参考</h2><p><a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Java StyleGuide 中文翻译</a></p>
<p><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="external">Google Java StyleGuide 官方英文</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-_简介">1. 简介</h1><h2 id="1-1_术语说明">1.1 术语说明</h2><p>在本文档中，除非另有说明：</p>
<p>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)<br>术语commen]]>
    </summary>
    
      <category term="Google" scheme="http://linfuyan.com/tags/Google/"/>
    
      <category term="Java" scheme="http://linfuyan.com/tags/Java/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="编码" scheme="http://linfuyan.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="规范" scheme="http://linfuyan.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 编码风格指南]]></title>
    <link href="http://linfuyan.com/objective-c-coding-style-guide/"/>
    <id>http://linfuyan.com/objective-c-coding-style-guide/</id>
    <published>2015-11-11T13:11:50.000Z</published>
    <updated>2015-11-12T06:45:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文件编码">文件编码</h2><p>源文件编码格式为 UTF-8</p>
<h2 id="语言">语言</h2><p>使用英语，变量的命名等已英语单词命名，不要使用汉语拼音。</p>
<h2 id="代码组织">代码组织</h2><p>使用 <code>#pragma mark</code> 来为方法分组。</p>
<h2 id="间距与空白">间距与空白</h2><ul>
<li>一个缩进使用 4 个空格，不要使用制表符。可以在 Xcode 中配置自动将 Tab 转化为空格。在 Xcode &gt; Preferences &gt; Text Editing 将 Tab 和自动缩进都设置为 4 个空格。</li>
<li>行尾不允许留有空格。</li>
<li>关键字及符号之间需要留有 1 个空格。</li>
<li>方法或者代码块之间留有一行空白。</li>
</ul>
<h2 id="大括号">大括号</h2><ul>
<li>方法和大括号及其他大括号( if / else / switch / while 等等)始终和声明在同一行开始，在新的一行结束。</li>
</ul>
<p>以下是正确的：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是不正确的：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">    //<span class="keyword">Do</span> something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    //<span class="keyword">Do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐">对齐</h2><ul>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为 Xcode 的对齐方式令它难以辨认。</li>
</ul>
<p>应该：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[UIView <span class="string">animateWithDuration:</span><span class="number">1.0</span> <span class="string">animations:</span>^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; <span class="string">completion:</span>^(BOOL finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="命名">命名</h2><ul>
<li>长的，描述性的方法和变量命名是好的。</li>
</ul>
<p>应该：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *<span class="built_in">set</span>But;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。</p>
</blockquote>
<ul>
<li>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</li>
</ul>
<p>应该：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSTimeInterval <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@synthesize语句，除非你有一个好的理由。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> varnm;</span><br></pre></td></tr></table></figure>
<h2 id="下划线">下划线</h2><p>当使用属性时，实例变量应该使用 <code>self.</code> 来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有 <code>self.</code> 。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免 <code>getters/setters</code> 潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h2 id="方法">方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合 Apple 的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像 initWithWidth:height 以下这个例子：</p>
<p>应该：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">setExampleText</span>:<span class="value">(NSString *)text image:(UIImage *)image</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">sendAction</span>:<span class="value">(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">viewWithTag</span>:<span class="value">(NSInteger)tag</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">instancetype</span>)<span class="rule"><span class="attribute">initWithWidth</span>:<span class="value">(CGFloat)width height:(CGFloat)height</span></span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(void)</span>setT:<span class="params">(<span class="variable">NSString</span> *)</span>text i:<span class="params">(<span class="variable">UIImage</span> *)</span>image;</span><br><span class="line">- <span class="params">(void)</span>sendAction:<span class="params">(<span class="variable">SEL</span>)</span>aSelector :<span class="params">(id)</span>anObject :<span class="params">(<span class="variable">BOOL</span>)</span>flag;</span><br><span class="line">- <span class="params">(id)</span>taggedView:<span class="params">(<span class="variable">NSInteger</span>)</span>tag;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithWidth:<span class="params">(<span class="variable">CGFloat</span>)</span>width andHeight:<span class="params">(<span class="variable">CGFloat</span>)</span>height;</span><br><span class="line">- <span class="params">(instancetype)</span>initWith:<span class="params">(int)</span>width and:<span class="params">(int)</span>height;  // Never do this</span>.</span><br></pre></td></tr></table></figure>
<h2 id="变量">变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p>私有变量应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性( _variable ，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法( init , initWithCoder: , 等…)， dealloc 方法和自定义的 setters 和 getters 。想了解关于如何在初始化方法和 dealloc 直接使用 Accessor 方法的更多信息，查看这里。</p>
<p>应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RWTTutorial </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString *tutorialName;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">RWTTutorial</span> : NSObject </span>&#123;</span><br><span class="line">    NSString *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性特性">属性特性</h2><ul>
<li>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是 storage、atomicity，与在 Interface Builder 连接 UI 元素时自动生成代码一致。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSString应该使用copy而不是strong的属性特性。</li>
</ul>
<blockquote>
<p>为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<h2 id="点符号语法">点符号语法</h2><ul>
<li>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用 getter 或 setter 方法，属性仍然被访问或修改。想了解更多，阅读<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="external">这里</a>。</li>
</ul>
<blockquote>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span><span class="variable">.array</span> count];</span><br><span class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span><span class="variable">.array</span><span class="variable">.count</span>;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span><span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure>
<h2 id="字面值">字面值</h2><ul>
<li>NSString、 NSDictionary、 NSArray 和 NSNumber 的字面值应该在创建这些类的不可变实例时被使用。请特别注意 nil 值不能传入 NSArray 和 NSDictionary 字面值，因为这样会导致 crash。</li>
</ul>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。</p>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine CompanyName @<span class="string">"RayWenderlich.com"</span></span><br><span class="line"><span class="hexcolor">#def</span>ine thumbnailHeight <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举类型">枚举类型</h2><ul>
<li>当使用 enum 时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在 SDK 有一个宏 NS_ENUM() 来帮助和鼓励你使用固定的基本类型。</li>
</ul>
<p>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">    RWTLeftMenuTopItemMain,</span><br><span class="line">    RWTLeftMenuTopItemShows,</span><br><span class="line">    RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123;</span><br><span class="line">    RWTP<span class="keyword">in</span>SizeM<span class="keyword">in</span> = <span class="number">1</span>,</span><br><span class="line">    RWTP<span class="keyword">in</span>SizeMax = <span class="number">5</span>,</span><br><span class="line">    RWTP<span class="keyword">in</span>CountM<span class="keyword">in</span> = <span class="number">100</span>,</span><br><span class="line">    RWTP<span class="keyword">in</span>CountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旧的 k-style 常量定义应该避免，除非编写 Core Foundation C 的代码。</p>
<p>不应该：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GlobalConstants</span> &#123;</span></span><br><span class="line">    kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">    kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Case语句">Case语句</h2><ul>
<li>大括号在 case 语句中必须的，不仅仅是 case 语句包含多行代码时，大括号都应该加上。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 这个是不应该的</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Multi-line example using braces</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// 应该的</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// ** fall-through! **</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当在switch使用枚举类型时，’default’是不需要的。例如：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemMain:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemShows:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">RWTLeftMenuTopItemSchedule:</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有属性">私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p>例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> RWTDetailViewController ()</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) GADBannerView *googleAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) ADBannerView *iAdView;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) UIWebView *adXWebView;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔值">布尔值</h2><ul>
<li>Objective-C 使用 YES 和 NO。因为 true 和 false 应该只在 CoreFoundation， C 或 C++ 代码使用。既然 nil 解析成 NO ，所以没有必要在条件语句比较。不要拿某样东西直接与 YES 比较，因为 YES 被定义为 1 而一个 BOOL 能被设置为8位。</li>
</ul>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p>应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(![anotherObject boolValue])</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(someObject == nil)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">([anotherObject boolValue] == NO)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == YES)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(isAwesome == true)</span> &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, getter=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>
<h2 id="条件语句">条件语句</h2><ul>
<li>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为 if 语句；还有，<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="external">even more dangerous defect</a> 可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</li>
</ul>
<p>应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) &#123;</span><br><span class="line"><span class="command">    return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>)</span><br><span class="line"><span class="command">    return</span> success;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">error</span>) <span class="constant">return</span> success;</span><br></pre></td></tr></table></figure>
<h2 id="三元操作符">三元操作符</h2><p>当需要提高代码的清晰性和简洁性时，三元操作符 ?: 才会使用。单个条件求值常常需要它。多个条件求值时，如果使用 if 语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean 的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是 boolean 类型，那么就不需要括号。</p>
<p>应该：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="literal">result</span> = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"><span class="type">BOOL</span> isHorizontal = <span class="type">YES</span>;</span><br><span class="line"><span class="literal">result</span> = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span> = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure>
<h2 id="Init方法">Init方法</h2><p>Init 方法应该遵循 Apple 生成代码模板的命名规则，返回类型应该使用 instancetype 而不是 id。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类构造方法">类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Airplane</span><br><span class="line">+ (instancetype)airplaneWithType:(RWTAirplaneType)<span class="class"><span class="keyword">type</span>;</span></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>关于更多 instancetype，请查看<a href="http://nshipster.com/instancetype/" target="_blank" rel="external">这里</a>。</p>
<h2 id="CGRect函数">CGRect函数</h2><p>当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry：</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p>应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="黄金路径">黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。</p>
<p>应该：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">someMethod</span> &#123;</span><br><span class="line">    <span class="tag">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">        <span class="comment">//Do something important</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理">错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p>应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="variable">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在成功的情况下，有些 Apple 的 APIs 记录垃圾值( garbage values )到错误参数(如果 non-NULL )，那么判断错误值会导致 false 负值和 crash。</p>
<h2 id="单例模式">单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以防止<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="external">有时可能产生的崩溃</a></p>
<h2 id="换行符">换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.productsRequest = <span class="comment">[<span class="comment">[SKProductsRequest alloc]</span> </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="导入">导入</h2><p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。<br>注：对于模块使用 @import 语法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Frameworks</span></span><br><span class="line">@<span class="keyword">import</span> QuartzCore;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Models</span></span><br><span class="line">#<span class="keyword">import</span> "NYTUser.h"</span><br><span class="line"></span><br><span class="line"><span class="comment">// Views</span></span><br><span class="line">#<span class="keyword">import</span> "NYTButton.h"</span><br><span class="line">#<span class="keyword">import</span> "NYTUserView.h"</span><br></pre></td></tr></table></figure>
<h2 id="飞博可接受的缩略词">飞博可接受的缩略词</h2><table>
<thead>
<tr>
<th>缩略词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>VC</td>
<td>ViewController</td>
</tr>
<tr>
<td>VM</td>
<td>ViewModel</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2><h3 id="中文版">中文版</h3><p><a href="http://www.iwangke.me/objc-style-guide/" target="_blank" rel="external">Google Objective-C Style Guide 中文版</a></p>
<p><a href="http://linfuyan.com/apple-cocoa-coding-style-guide/">Apple 官方 Cocoa 编码规范</a></p>
<p><a href="http://www.csdn.net/article/2015-06-01/2824818-objective-c-style-guide/1" target="_blank" rel="external">Objective-C编码规范：26个方面解决iOS开发问题</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide/blob/master/README_zh-Hans.md" target="_blank" rel="external">纽约时报 移动团队 Objective-C 规范指南</a></p>
<h3 id="英文版">英文版</h3><p><a href="https://google.github.io/styleguide/objcguide.xml" target="_blank" rel="external">Google Objective-C Style Guide</a></p>
<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Coding Guidelines for Cocoa</a></p>
<p><a href="https://github.com/raywenderlich/objective-c-style-guide" target="_blank" rel="external">Raywenderlich.com Objective-C style guide</a></p>
<p><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">NYTimes Objective-C Style Guide</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="文件编码">文件编码</h2><p>源文件编码格式为 UTF-8</p>
<h2 id="语言">语言</h2><p>使用英语，变量的命名等已英语单词命名，不要使用汉语拼音。</p>
<h2 id="代码组织">代码组织</h2><p>使用 <code>#prag]]>
    </summary>
    
      <category term="Objective-C" scheme="http://linfuyan.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/tags/iOS/"/>
    
      <category term="代码" scheme="http://linfuyan.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="规范" scheme="http://linfuyan.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apple 官方 Cocoa 编码规范]]></title>
    <link href="http://linfuyan.com/apple-cocoa-coding-style-guide/"/>
    <id>http://linfuyan.com/apple-cocoa-coding-style-guide/</id>
    <published>2015-11-10T08:06:39.000Z</published>
    <updated>2015-11-11T15:09:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="编码命名基础">编码命名基础</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH" target="_blank" rel="external">Code Naming Basics</a></p>
<h3 id="一般性原则">一般性原则</h3><h4 id="清晰性">清晰性</h4><ul>
<li>最好是既清晰又简短，但不要为简短而丧失清晰性</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insertObject:atIndex:</td>
<td>好</td>
</tr>
<tr>
<td>insert:at:</td>
<td>不清晰：要插入什么？”at”表示什么？</td>
</tr>
<tr>
<td>removeObjectAtIndex:</td>
<td>好</td>
</tr>
<tr>
<td>removeObject:</td>
<td>这样也不错，因为方法是移除作为参数的对象</td>
</tr>
<tr>
<td>remove</td>
<td>不清晰；要移除什么?</td>
</tr>
</tbody>
</table>
<ul>
<li>名称通常不缩写，即使名称很长，也要拼写完全</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>destinationSelection</td>
<td>好</td>
</tr>
<tr>
<td>destSel</td>
<td>不清晰</td>
</tr>
<tr>
<td>setBackgroundColor</td>
<td>好</td>
</tr>
<tr>
<td>setBkgdColor</td>
<td>不清晰</td>
</tr>
</tbody>
</table>
<p>你可能会认为某个缩写广为人知，但有可能并非如此，尤其是当你的代码被来自不同文化和语言背景的开<br>发人员所使用时。</p>
<ul>
<li><p>然而，你可以使用少数非常常见，历史悠久的缩写。请参考：”可接受的缩略名”一节</p>
</li>
<li><p>避免使用有歧义的 API 名称，如那些能被理解成多种意思的方法名称</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sendPort</td>
<td>是发送端口还是返回一个发送端口?</td>
</tr>
<tr>
<td>displayName</td>
<td>是显示一个名称还是返回用户界面中控件的标题?</td>
</tr>
</tbody>
</table>
<h4 id="一致性">一致性</h4><ul>
<li>尽可能使用与 Cocoa 编程接口命名保持一致的名称。如果你不太确定某个命名的一致性，请浏览一下头文件或参考文档中的范例</li>
<li>在使用多态方法的类中，命名的一致性非常重要。在不同类中实现相同功能的方法应该具有相同的名称</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (int) tag</td>
<td>在 NSView， NSCell， NSControl 中有定义</td>
</tr>
<tr>
<td>- (void) setStringValue:(NSString *)</td>
<td>在许多 Cocoa classes 中有定义</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请参考“方法参数”一节。</p>
</blockquote>
<h4 id="不要自我指涉">不要自我指涉</h4><ul>
<li>不要名称自我指涉</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString</td>
<td>好</td>
</tr>
<tr>
<td>NSStringObject</td>
<td>自我指涉</td>
</tr>
</tbody>
</table>
<ul>
<li>掩码(可使用位操作进行组合)和用作通知名称的常量不受该约定限制</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSUnderlineByWordMask</td>
<td>好</td>
</tr>
<tr>
<td>NSTableViewColumnDidMoveNotification</td>
<td>好</td>
</tr>
</tbody>
</table>
<h3 id="前缀">前缀</h3><p>前缀是名称的重要组成部分。它们可以区分软件的功能范畴。通常，软件会被打包成一个框架或多个紧密 相关的框架(如 Foundation 和 Application Kit 框架)。前缀可以防止第三方开发者与苹果公司之间的命 名冲突(同样也可防止苹果内部不同框架之间的命名冲突)</p>
<ul>
<li>前缀有规定的格式。它由两到三个大写字符组成，不能使用下划线与子前缀</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>Cocoa 框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>NS</td>
<td>Foundation</td>
</tr>
<tr>
<td>NS</td>
<td>Application Kit</td>
</tr>
<tr>
<td>AB</td>
<td>Address Book</td>
</tr>
<tr>
<td>IB</td>
<td>Interface Builder</td>
</tr>
</tbody>
</table>
<ul>
<li>命名 class， protocol， structure， 函数，常量时使用前缀；命名成员方法时不使用前缀，因为方法已经在它所在类的命名空间种；同理，命名结构体字段时也不使用前缀</li>
</ul>
<h3 id="书写约定">书写约定</h3><p>在为 API 元素命名时，请遵循如下一些简单的书写约定</p>
<ul>
<li><p>对于包含多个单词的名称，不要使用标点符号作为名称的一部分或作为分隔符(下划线，破折号等)； 此外，大写每个单词的首字符并将这些单词连续拼写在一起。请注意以下限制:</p>
<ul>
<li>方法名小写第一个单词的首字符，大写后续所有单词的首字符。方法名不使用前缀。如:  <code>fileExistsAtPath:isDirectory:</code> 如果方法名以一个广为人知的大写首字母缩略词开头，该规则不适用，如: <code>NSImage</code> 中的 <code>TIFFRepresentation</code></li>
<li>函数名和常量名使用与其关联类相同的前缀，并且要大写前缀后面所有单词的首字符。如: <code>NSRunAlertPanel</code> ， <code>NSCellDisabled</code></li>
<li>避免使用下划线来表示名称的私有属性。苹果公司保留该方式的使用。如果第三方这样使用可能会导致命名冲突，他们可能会在无意中用自己的方法覆盖掉已有的私有方法，这会导致严重的后果。请参考”私有方法”一节以了解私有 API 的命名约定的建议</li>
</ul>
</li>
</ul>
<h3 id="类与协议命名">类与协议命名</h3><p>类名应包含一个明确 述该类(或类的对象)是什么或做什么的名词。类名要有合适的前缀(请参考“前缀” 一节)。Foundation 及 Application Kit 有很多这样例子，如:NSString， NSData， NSScanner， NSApplication， NSButton 以及 NSEvent。</p>
<p>协议应该根据对方法的行为分组方式来命名。</p>
<ul>
<li>大多数协议仅组合一组相关的方法，而不关联任何类，这种协议的命名应该使用动名词(ing)，以不与 类名混淆。</li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSLocking</td>
<td>好</td>
</tr>
<tr>
<td>NSLock</td>
<td>不好，看起来像类名</td>
</tr>
</tbody>
</table>
<ul>
<li>有些协议组合一些彼此无关的方法(这样做是避免创建多个独立的小协议)。这样的协议倾向于与某 个类关联在一起，该类是协议的主要体现者。在这种情形，我们约定协议的名称与该类同名。NSObject 协议就是这样一个例子。这个协议组合一组彼此无关的方法，有用于查询对象在其类层次中位置的方 法，有使之能调用特殊方法的方法以及用于增减引用计数的方法。由于 NSObject 是这些方法的主要 体现者，所以我们用类的名称命名这个协议。</li>
</ul>
<h3 id="头文件">头文件</h3><p>头文件的命名方式很重要，我们可以根据其命名知晓头文件的内容。</p>
<ul>
<li>声明孤立的类或协议:将孤立的类或协议声明放置在单独的头文件中，该头文件名称与类或协议同名</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSApplication</td>
<td>NSApplication类</td>
</tr>
</tbody>
</table>
<ul>
<li>声明相关联的类或协议:将相关联的声明(类，类别及协议) 放置在一个头文件中，该头文件名称与主要的类/类别/协议的名字相同。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSString.h</td>
<td>NSString 和 NSMutableString 类</td>
</tr>
<tr>
<td>NSLock.h</td>
<td>NSLocking 协议和 NSLock， NSConditionLock， NSRecursiveLock 类</td>
</tr>
</tbody>
</table>
<ul>
<li>包含框架头文件:每个框架应该包含一个与框架同名的头文件，该头文件包含该框架所有公开的头文件。</li>
</ul>
<table>
<thead>
<tr>
<th>头文件</th>
<th>框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>Foundation.h</td>
<td>Foundation.framework</td>
</tr>
</tbody>
</table>
<ul>
<li><p>为已有框架中的某个类扩展 API:如果要在一个框架中声明属于另一个框架某个类的范畴类的方法， 该头文件的命名形式为:原类名+“Additions”。如 Application Kit 中的 NSBundleAdditions.h</p>
</li>
<li><p>相关联的函数与数据类型:将相联的函数，常量，结构体以及其他数据类型放置到一个头文件中，并以合适的名字命名。如 Application Kit 中的 NSGraphics.h </p>
</li>
</ul>
<h2 id="方法命名">方法命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF" target="_blank" rel="external">Naming Methods</a></p>
<h3 id="一般性规则">一般性规则</h3><p>为方法命名时，请考虑如下一些一般性规则:</p>
<ul>
<li>小写第一个单词的首字符，大写随后单词的首字符，不使用前缀。请参考“书写约定”一节。有两种例 外情况:1，方法名以广为人知的大写字母缩略词(如 TIFF or PDF)开头;2，私有方法可以使用统 一的前缀来分组和辨识，请参考“私有方法”一节</li>
<li>表示对象行为的方法，名称以动词开头:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>) <span class="string">invokeWithTarget:</span>(id)<span class="string">target:</span>- (<span class="typename">void</span>) <span class="string">selectTabViewItem:</span>(NSTableViewItem *)tableViewItem</span><br></pre></td></tr></table></figure>
<p>名称中不要出现 do 或 does，因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰</p>
<ul>
<li>如果方法返回方法接收者的某个属性，直接用属性名称命名。不要使用 get，除非是间接返回一个或 多个值。请参考“访问方法”一节。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (NSSize)cellSize</td>
<td>对</td>
</tr>
<tr>
<td>- (NSSize)calcCellSize</td>
<td>错</td>
</tr>
<tr>
<td>- (NSSize)getCellSize</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数要用 述该参数的关键字命名</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void) sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void) sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>参数前面的单词要能述该参数。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id) viewWithTag:(int)aTag;</td>
<td>对</td>
</tr>
<tr>
<td>- (id) taggedView:(int)aTag;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>细化基类中的已有方法:创建一个新方法，其名称是在被细化方法名称后面追加参数关键词</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (id) initWithFrame:(NSRect)frameRect;</td>
<td>NSView</td>
</tr>
<tr>
<td>- (id) initWithFrame:(NSRect)frameRect mode:(ind)aMode cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns:(int)colsWide;</td>
<td>NSMatrix - NSView 的子类</td>
</tr>
</tbody>
</table>
<ul>
<li>不要使用 and 来连接用属性作参数关键字</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (int) runModalForDirectory:(NSString *)path file:(NSString *)name types:(NSArray *)fileTypes;</code></td>
<td>对</td>
</tr>
<tr>
<td><code>- (int) runModalForDirectory:(NSString *)path addFile:(NSString *)name addTypes:(NSArray *)fileTypes;</code></td>
<td>错</td>
</tr>
</tbody>
</table>
<p>虽然上面的例子中使用 add 看起来也不错，但当你方法有太多参数关键字时就有问题。</p>
<ul>
<li>如果方法 述两种独立的行为，使用 and 来串接它们</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (BOOL) openFile:(NSString <em>)fullPath withApplication:(NSString </em>)appName andDeactivate:(BOOL)flag;</td>
<td>NSWorkspace</td>
</tr>
</tbody>
</table>
<h3 id="访问方法">访问方法</h3><p>访问方法是对象属性的读取与设置方法。其命名有特定的格式依赖于属性的 述内容。</p>
<ul>
<li>如果属性是用名词述的，则命名格式为:</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setNoun:(<span class="class"><span class="keyword">type</span>)<span class="title">aNoun</span>;</span>- (<span class="class"><span class="keyword">type</span>) <span class="title">noun</span>;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setgColor</span>:<span class="value">(NSColor *)aColor</span></span>; </span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSColor</span> *) <span class="tag">color</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用形容词述的，则命名格式为:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setAdjective</span>:<span class="value">(BOOL)flag</span></span>;<span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="tag">isAdjective</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setEditable</span>:<span class="value">(BOOL)flag</span></span>; </span><br><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="tag">isEditable</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果属性是用动词 述的，则命名格式为:(动词要用现在时时态)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setVerbObject</span>:<span class="value">(BOOL)flag</span></span>;<span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="tag">verbObject</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<pre><code><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setShowAlpha</span>:<span class="value">(BOOL)flag</span></span>; 
<span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="tag">showsAlpha</span>;
</code></pre><ul>
<li>不要使用动词的过去分词形式作形容词使用</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void) setAcceptsGlyphInfo:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL) acceptsGlyphInfo;</td>
<td>对</td>
</tr>
<tr>
<td>- (void) setGlyphInfoAccepted:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL) glyphInfoAccepted;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>可以使用情态动词(can， should， will 等)来 高清晰性，但不要使用 do 或 does</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- (void) setCanHide:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (BOOL) canHide;</td>
<td>对</td>
</tr>
<tr>
<td>- (void) setShouldCloseDocument:(BOOL)flag;</td>
<td>对</td>
</tr>
<tr>
<td>- (void) shouldCloseDocument;</td>
<td>对</td>
</tr>
<tr>
<td>- (void) setDoseAcceptGlyphInfo:(BOOL)flag;</td>
<td>错</td>
</tr>
<tr>
<td>- (BOOL) doseAcceptGlyphInfo;</td>
<td>错</td>
</tr>
</tbody>
</table>
<ul>
<li>只有在方法需要间接返回多个值的情况下，才使用 get</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>- (void) getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</code></td>
<td>NSBezierPath</td>
</tr>
</tbody>
</table>
<p>像上面这样的方法，在其实现里应允许接受 NULL 作为其 in/out 参数，以表示调用者对一个或多个返回 值不感兴趣。</p>
<h3 id="委托方法">委托方法</h3><p>委托方法是那些在特定事件发生时可被对象调用，并声明在对象的委托类中的方法。它们有独特的命名约<br>定，这些命名约定同样也适用于对象的数据源方法</p>
<ul>
<li>名称以标示发送消息的对象的类名开头，省略类名的前缀并小写类第一个字符</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="rule"><span class="attribute">tableView</span>:<span class="value">(NSTableView *)tableView shouldSelectRow:(int)row</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="rule"><span class="attribute">application</span>:<span class="value">(NSApplication *)sender openFile:(NSString *)filename</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的方法</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="rule"><span class="attribute">applicationOpenUntitledFile</span>:<span class="value">(NSApplication *)sender</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的那条规则也不适用于响应通知的方法。在这种情况下，方法的唯一参数表示通知对象</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">windowDidChangeScreen</span>:<span class="value">(NSNotification *)notification</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">browserDidScroll</span>:<span class="value">(NSBrowser *)sender</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSUndoManager</span> *) <span class="rule"><span class="attribute">windowWillReturnUndoManager</span>:<span class="value">(NSWindow *)window</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will，但最好使用 should</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="rule"><span class="attribute">windowShouldClose</span>:<span class="value">(id)sender</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="集合方法">集合方法</h3><p>管理对象(集合中的对象被称之为元素)的集合类，约定要具备如下形式的方法:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">addElement</span>:<span class="value">(elementType)adObj</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">removeElement</span>:<span class="value">(elementType)anObj</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span> *)<span class="tag">elements</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">addLayoutManager</span>:<span class="value">(NSLayoutManager *)adObj</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">removeLayoutManager</span>:<span class="value">(NSLayoutManager *)anObj</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span> *)<span class="tag">layoutManagers</span>;</span><br></pre></td></tr></table></figure>
<p>集合方法命名有如下一些限制和约定:</p>
<ul>
<li>如果集合中的元素无序，返回 NSSet，而不是 NSArray</li>
<li>如果将元素插入指定位置的功能很重要，则需具备如下方法:</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>) <span class="string">insertElement:</span>(elementType)anObj <span class="string">atIndex:</span>(<span class="typename">int</span>)index; </span><br><span class="line">- (<span class="typename">void</span>) <span class="string">removeElementAtIndex:</span>(<span class="typename">int</span>)index;</span><br></pre></td></tr></table></figure>
<p>集合方法的实现要考虑如下细节:</p>
<ul>
<li>以上集合类方法通常负责管理元素的所有者关系，在 add 或 insert 的实现代码里会 retain 元素，在 remove 的实现代码中会 release 元素</li>
<li>当被插入的对象需要持有指向集合对象的指针时，通常使用 set… 来命名其设置该指针的方法，且不 要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形，NSLayoutManager 类使 用如下方法:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setTextStorage</span>:<span class="value">(NSTextStorage *)textStorage</span></span>; </span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSTextStorage</span> *)<span class="tag">textStorage</span>;</span><br></pre></td></tr></table></figure>
<p>通常你不会直接调用 setTextStorage:，而是覆写它。</p>
<p>另一个关于集合约定的例子来自 NSWindow 类:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">addChildWindow</span>:<span class="value">(NSWindow *)childWin ordered:(NSWindowOrderingMode)place</span></span>; </span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">removeChildWindow</span>:<span class="value">(NSWindow *)childWin</span></span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span> *)<span class="tag">childWindows</span>;<span class="tag">-</span> (<span class="tag">NSWindow</span> *)<span class="tag">parentWindow</span>;</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>) <span class="rule"><span class="attribute">setParentWindow</span>:<span class="value">(NSWindow *)window</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="方法参数">方法参数</h3><p>命名方法参数时要考虑如下规则:</p>
<ul>
<li>如同方法名，参数名小写第一个单词的首字符，大写后继单词的首字符。如:removeObject:(id)anObject</li>
<li>不要在参数名中使用 pointer 或 ptr，让参数的类型来说明它是指针</li>
<li>避免使用 one， two，…，作为参数名</li>
<li>避免为节省几个字符而缩写</li>
</ul>
<p>按照 Cocoa 惯例，以下关键字与参数联合使用:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">..<span class="class">.action</span>:(SEL)aSelector</span><br><span class="line">..<span class="class">.alignment</span>:(int)mode</span><br><span class="line">..<span class="class">.atIndex</span>:(int)index</span><br><span class="line">..<span class="class">.content</span>:(NSRect)aRect</span><br><span class="line">..<span class="class">.doubleValue</span>:(double)aDouble</span><br><span class="line">..<span class="class">.floatValue</span>:(<span class="attribute">float</span>)aFloat</span><br><span class="line">..<span class="class">.font</span>:(NSFont *)fontObj</span><br><span class="line">..<span class="class">.frame</span>:(NSRect)frameRect</span><br><span class="line">..<span class="class">.intValue</span>:(int)anInt</span><br><span class="line">..<span class="class">.keyEquivalent</span>:(NSString *)charCode</span><br><span class="line">..<span class="class">.length</span>:(int)numBytes</span><br><span class="line">..<span class="class">.point</span>:(NSPoint)aPoint</span><br><span class="line">..<span class="class">.stringValue</span>:(NSString *)aString</span><br><span class="line">..<span class="class">.tag</span>:(int)anInt..<span class="class">.target</span>:(id)anObject..<span class="class">.title</span>:(NSString *)aString</span><br></pre></td></tr></table></figure>
<h3 id="私有方法">私有方法</h3><p>大多数情况下，私有方法命名相同与公共方法命名约定相同，但通常我们约定给私有方法添加前缀，以便 与公共方法区分开来。即使这样，私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时，你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。<br>Cocoa framework 的私有方法名称通常以下划线作为前缀(如:_fooData)，以标示其私有属性。基于这 样的事实，遵循以下两条建议：</p>
<ul>
<li>不要使用下划线作为你自己的私有方法名称的前缀，Apple 保留这种用法。</li>
<li>若要继承 Cocoa framework 中一个超大的类(如:NSView)，并且想要使你的私有方法名称与基类 中的区别开来，你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性，如基于你 公司的名称，或工程的名称，并以“XX_”形式给出。比如你的工程名为”Byte Flogger”，那么就可以是 “BF_addObject:”</li>
</ul>
<p>尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突，这里的意图有所不同:为了防止不<br>小心地覆盖基类中的私有方法。</p>
<h2 id="函数命名">函数命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingFunctions.html#//apple_ref/doc/uid/20001283-BAJGGCAD" target="_blank" rel="external">Naming Functions</a></p>
<p>Objective-C 允许通过函数(C 形式的函数) 述行为，就如成员方法一样。 你应当优先使用函数，而不 是类方法，如果隐含的类为单例或在处理函数子系统时。</p>
<p>函数命名应该遵循如下几条规则:</p>
<ul>
<li>函数命名与方法命名相似，但有两点不同:<ol>
<li>它们有前缀，其前缀与你使用的类和常量的前缀相同</li>
<li>大写前缀后紧跟的第一个单词首字符</li>
</ol>
</li>
<li>大多数函数名称以动词开头，这个动词 述该函数的行为</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHighlightRect</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span></span><br></pre></td></tr></table></figure>
<p>查询属性的函数有个更多的规则要遵循:</p>
<ul>
<li>查询第一个参数的属性的函数，省略动词</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">NSEventMaskFromType</span>(<span class="built_in">NSEventType</span> type) </span><br><span class="line"><span class="keyword">float</span> <span class="built_in">NSHeight</span>(<span class="built_in">NSRect</span> rect)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值为引用的方法，使用 Get</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">NSGetSizeAndAlignment</span>(<span class="keyword">const</span> <span class="keyword">char</span> *typePtr, <span class="keyword">unsigned</span> <span class="keyword">int</span>*sizep, <span class="keyword">unsigned</span> <span class="keyword">int</span> *alignp)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 boolean 值的函数，名称使用判断动词 is/does 开头</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecimalIsNotANumber</span>(<span class="keyword">const</span> <span class="built_in">NSDecimal</span> *decimal)</span><br></pre></td></tr></table></figure>
<h2 id="实例变量与数据类型命名">实例变量与数据类型命名</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="external">Naming Properties and Data Types</a></p>
<p>这一节 述实例变量，常量，异常以及通知的命名约定。</p>
<h3 id="实例变量">实例变量</h3><p>在为类添加实例变量是要注意:</p>
<ul>
<li>避免创建 public 实例变量</li>
<li>使用 @private，@protected 显式限定实例变量的访问权限</li>
<li>确保实例变量名简明扼要地述了它所代表的属性</li>
</ul>
<p>如果实例变量别设计为可被访问的，确保编写了访问方法</p>
<h3 id="常量">常量</h3><p>常量命名规则根据常量创建的方式不同而大不同。</p>
<h4 id="枚举常量">枚举常量</h4><ul>
<li>使用枚举来定义一组相关的整数常量</li>
<li>枚举常量与其 typedef 命名遵守函数命名规则。如来自 NSMatrix.h 中的例子：(本例中的 typedef tag (_NSMatrixMode) 不是必须的)</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_NSMatrixMode</span> &#123; </span></span><br><span class="line">	<span class="constant">NSRadioModeMatrix</span> = <span class="number">0</span>, </span><br><span class="line">	<span class="constant">NSHighlightModeMatrix</span> = <span class="number">1</span>,</span><br><span class="line">	<span class="constant">NSListModeMatrix</span> = <span class="number">2</span>, </span><br><span class="line">	<span class="constant">NSTrackModeMatrix</span> = <span class="number">3</span>&#125; <span class="constant">NSMatrixMode</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>位掩码常量可以使用不具名枚举。如:</li>
</ul>
<pre><code><span class="keyword">enum</span> {
    NSBorderlessWindowMask = <span class="number">0</span>,
    NSTitledWindowMask = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
    NSClosableWindowMask = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
    NSMiniaturizableWindowMask <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
    NSResizableWindowMask = <span class="number">1</span>&lt;&lt; <span class="number">3</span>
};
</code></pre><h4 id="常量-1">常量</h4><ul>
<li>使用 const 来修饰浮点常量或彼此没有关联的整数常量</li>
<li>枚举常量命名规则与函数命名规则相同。const 常量命名范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">NSLightGray</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他常量">其他常量</h4><ul>
<li>通常不使用 #define 来创建常量。如上面所述，整数常量请使用枚举，浮点数常量请使用 const</li>
<li>使用大写字母来定义预处理编译宏。如:#ifdef DEBUG</li>
<li>编译器定义的宏名首尾都有双下划线。如:<strong>MACH</strong></li>
<li>为 notification 名及 dictionary key 定义字符串常量，从而能够利用编译器的拼写检查，减少书写错误。Cocoa 框架供了很多这样的范例:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPKIT_EXTERN <span class="built_in">NSString</span> *<span class="built_in">NSPrintCopies</span>;</span><br></pre></td></tr></table></figure>
<p>实际的字符串值在实现文件中赋予。(注意:APPKIT_EXTERN 宏等价于 Objective-C 中 extern)</p>
<h3 id="异常与通知">异常与通知</h3><p>异常与通知的命名遵循相似的规则,但是它们有各自推荐的使用模式。</p>
<h4 id="异常">异常</h4><p>虽然你可以处于任何目的而使用异常(由 NSException 类及相关类实现)， Cocoa 通常不使用异常来处 理常规的， 可预料的错误。在这些情形下， 使用诸如 nil， NULL， NO 或错误代码之类的返回值。异常的典 型应用类似数组越界之类的编程错误。</p>
<p>异常由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[Prefix] + UniquePartOfName + Exception</p>
</blockquote>
<p>UniquePartOfName 部分是有连续的首字符大写的单词组成。例如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSColorListIOException</span></span><br><span class="line"><span class="built_in">NSColorListNotEditableException</span></span><br><span class="line"><span class="built_in">NSDraggingException</span></span><br><span class="line"><span class="built_in">NSFontUnavailableException</span></span><br><span class="line"><span class="built_in">NSIllegalSelectorException</span></span><br></pre></td></tr></table></figure>
<h4 id="通知">通知</h4><p>如果一个类有委托,那它的大部分通知可能由其委托的委托方法来处理。这些通知的名称应该能够反应其 响应的委托方法。比如,当应用程序 交 NSApplicationDidBecomeActiveNotification 通知时,全局 NSApplication 对象的委托会注册从而能够接收 applicaitonDidBecomeActive: 消息。</p>
<p>通知由具有如下形式的全局 NSString 对象标识:</p>
<blockquote>
<p>[相关联类的名称] + [Did 或 Will] + [UniquePartOfName] + Notification 例如: </p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSApplicationDidBecomeActiveNotification</span></span><br><span class="line"><span class="built_in">NSWindowDidMiniaturizeNotification</span></span><br><span class="line"><span class="built_in">NSTextViewDidChangeSelectionNotification</span></span><br><span class="line"><span class="built_in">NSColorPanelColorDidChangeNotification</span></span><br></pre></td></tr></table></figure>
<h2 id="可接受的缩略语">可接受的缩略语</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE" target="_blank" rel="external">Acceptable Abbreviations and Acronyms</a></p>
<p>在设计编程接口时，通常名称不要缩写。然而，下面列出的缩写要么是固定下来的要么是过去被广泛使用<br>的，所以你可以继续使用。关于缩写有一些额外的注意事项:</p>
<ul>
<li>标准 C 库中长期使用的缩写形式是可以接受的。如:”alloc”， “getc”</li>
<li>你可以在参数名中更自由地使用缩写。如:imageRep， col(column)， obj， otherWin</li>
</ul>
<h3 id="常见的缩写">常见的缩写</h3><table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc</td>
<td>Allocate</td>
<td>msg</td>
<td>Message</td>
</tr>
<tr>
<td>alt</td>
<td>Alternate</td>
<td>nib</td>
<td>Interface Builder archive</td>
</tr>
<tr>
<td>app</td>
<td>Application</td>
<td>pboard</td>
<td>Pasteboard</td>
</tr>
<tr>
<td>calc</td>
<td>Calculate</td>
<td>rect</td>
<td>Rectangle</td>
</tr>
<tr>
<td>dealloc</td>
<td>Deallocate</td>
<td>Rep</td>
<td>Representation</td>
</tr>
<tr>
<td>func</td>
<td>Function</td>
<td>temp</td>
<td>Temporary</td>
</tr>
<tr>
<td>horiz</td>
<td>Horizontal</td>
<td>vert</td>
<td>Vertical</td>
</tr>
<tr>
<td>info</td>
<td>Information</td>
<td>init</td>
<td>Initialize</td>
</tr>
<tr>
<td>max</td>
<td>Maximum</td>
</tr>
</tbody>
</table>
<h3 id="常见的略写">常见的略写</h3><p>ASCII， PDF， XML， HTML， URL， RTF， HTTP， TIFF， JPG， GIF， LZW， ROM， RGB， CMYK， MIDI， FTP</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="编码命名基础">编码命名基础</h2><p>原文：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/N]]>
    </summary>
    
      <category term="Cocoa" scheme="http://linfuyan.com/tags/Cocoa/"/>
    
      <category term="Ojbective-C" scheme="http://linfuyan.com/tags/Ojbective-C/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/tags/iOS/"/>
    
      <category term="代码" scheme="http://linfuyan.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="编程" scheme="http://linfuyan.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="规范" scheme="http://linfuyan.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="风格" scheme="http://linfuyan.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Task 与后退栈解析]]></title>
    <link href="http://linfuyan.com/task-and-back-stack/"/>
    <id>http://linfuyan.com/task-and-back-stack/</id>
    <published>2015-11-08T18:39:00.000Z</published>
    <updated>2015-11-09T10:19:03.000Z</updated>
    <content type="html"><![CDATA[<p>应用程序通常包含多个 Activity。每个 Activity 围绕用户能够执行的指定动作类型和启动其他 Activity 来设计。例如，一个邮件应用程序有一个用来显示新信息列表的 Activity ，当用户选择一条信息，一个新的 Activity 打开用来查看信息。</p>
<p>一个 Activity 可以打开存在设备上的其他应用程序。例如，你的应用想要发送邮件信息，你可以定义一个意图来执行”发送”动作，并包含一些如邮箱地址和信息的数据。其他应用程序的 Activity 声明自己能够处理这种类型的意图，并打开。这个例子中，意图是想要发送邮件，因此邮件应用的创作 Activity 启动(如果多个 Activity 支持相同的意图，系统将让用户来选择)。当邮件发送完成，这个 Activity 退出，看起来就像是自己应用程序的一部分， Android 通过将这些 Activity 保存在相同的 Task 中来维持一致的用户体验。</p>
<p>Task 是用户在执行特定工作时与之交互的一系列 Activity 集合。 Activity 被排列在后退栈中，以每个 Activity 被打开的顺序排列。</p>
<p>对于大部分 Task 而言，设备的主屏幕都是起始位置。当用户触摸应用程序启动器或者主屏幕上的快捷方式时，应用程序的 Task 进入前台。如果应用程序的 Task 不存在(即应用程序最近没有被使用)，那么新的 Task 将被创建，并且应用程序打开的主 Activity 将作为 Task 的根 Activity。</p>
<p>当当前 Activity 启动另外的 Activity ， 新的 Activity 将被推到栈顶并获取焦点。之前的 Activity 仍然在栈中，但是被停止的。当 Activity 被停止时，系统保持了它的用户界面的当前状态。当用户按下返回按钮，当前 Activity 被从栈顶弹出，之前的 Activity 则恢复为之前 UI 所保存下来的状态。 栈中的 Activity 不会被重新排列，只能够被推入到栈中或者从栈中弹出。当被当前 Activity 启动时推入栈中，用户按下后退键时从栈中弹出。后退栈的操作遵循后进先出的原则。下图可视化的展示了随着时间推移 Activity 与后退栈中的关系。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/diagram_backstack.png" alt=""></p>
<p>如果用户继续按返回键，每个 Activity 都会从栈中被弹出来展示上一个 Activity ，直到回到主屏幕(或者回到运行 Task 开始的 Activity )。当所有的 Activity 从栈中移出， Task 就不存在了。</p>
<p>Task 是一个相互结合的单元，当用户启动新的 Task 或者通过按下 Home 键来返回主屏幕时，原来的 Task 进入后台。一旦进入后台， Task 中的所有 Activity 被停止，但是 Task 的后退栈中是完整的，只是失去了焦点。一个 Task 可以重新回到前台以便用户打开。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/diagram_multitasking.png" alt=""></p>
<p>假设，当前的 Task A 包含 3 个 Activity 在它的栈中，即当前 Activity 下有另外两个。用户按下 Home 键，从应用程序启动器新的应用程序。当主屏幕显示， Task A 进入后台。当新的应用程序启动，系统为新的应用程序启动了 Task B (其中包含自己 Activity 的栈)。在新的应用程序中玩了不久，用户再次回到主屏幕，并选择了先前 Task A 中启动的应用程序。这是 Task A 进入前台，堆栈中的 3 个 Activity 都是完整的，栈顶的 Activity 被恢复。这种情况下，用户可以通过返回主屏幕，再点击应用程序图标来启动。这是 Android 上多任务的一个实例。</p>
<blockquote>
<p>注意：多个 Task 可以同时被维持在后台。但如果用户同时运行太多的后台任务，系统会为了回收内存而销毁后台的 Activity ，这会引起 Activity 状态的丢失。</p>
</blockquote>
<p>由于后退栈中的 Activity 永远不会被重排，如果你的应用程序允许用户从多个 Activity 中启动一个特殊的 Activity ，那么，新的 Activity 实例将被创建并推入栈中，而不是将之前的其他 Activity 实例放到顶部。这样，应用程序中的一个 Activity 可能被实例化多次，如下图所示。当用户使用返回键导航回去时，每个 Activity 的实例将按照被打开的顺序来展示。但是，如果你不想让一个 Activity 被实例化多次，你可以修改这些行为。具体怎么做，在下一节的[管理  Task] 中介绍。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/diagram_multiple_instances.png" alt=""></p>
<p>总结一下 Activity 和 Task 的默认行为：</p>
<ol>
<li>当 Activity A 启动 Activity B 时， Activity A 被停止，但系统保存了它的状态，包括滚动的位置和输入的文本等。如果用户在 Activity B 时按下返回键， Activity A 会返回到其原来保存的状态。</li>
<li>当用户按下 Home 键离开 Task ，当前的 Activity 及它所在的 Task 进入后台。系统保持 Task 中每个 Activity 的状态。如果用户通过选择启动图标再次启动 Task ， Task 进入前台，并且在栈顶部的 Activity 被恢复。</li>
<li>如果用户按下返回键，当前的 Activity 被从栈中弹出并销毁。栈中之前的 Activity 被恢复。当 Activity 被销毁，系统不在保持 Activity 的状态。</li>
<li>Activity 可以被实例化多次，即使是来自其他的 Task 。</li>
</ol>
<h2 id="保存_Activity_状态">保存 Activity 状态</h2><p>如上面所讨论的，当 Activity 被停止时，系统的默认行为会保留其状态。这样子，当用户导航回到之前的 Activity 时，将展示之前离开时留下的界面。尽管如此，当 Activity 即将被销毁或者必须要重建时，你依然可以使用回调方法来保持 Activity 的状态。</p>
<p>当系统停止某个 Activity 时，如果需要恢复系统的内存，系统将完全的销毁 Activity 。这种情况下， Activity 状态相关的信息便丢失了。但系统依然知道在后退栈中有 Activity 的一个位置，当 Activity 被带到前台时系统需要重建它，而不是恢复它。为了避免丢失用户以完成的工作，需要在 Activity 中通过实现 onSaveInstanceState() 方法来主动保持状态。</p>
<p>关于如何来保存 Activity 的状态的更多信息，可以查看 Activity 相关文档。</p>
<h2 id="管理_Task">管理 Task</h2><p>上面描述的 Android 管理 Task 和后退栈的方式-将所有成功打开的 Activity 放在同一个 Task 及后进先出的堆栈中-在大部分应用程序中工作正常，也不需要担心 Activity 如何与 Task 相关联，以及如何存在后退栈中。有的时候，你想要中断这种普通的行为。也许你想要应用程序中的一个 Activity 打开时开启一个新的 Task ，而不是被放在当前 Task 中。也许你启动一个 Activity 时，想要把已经存在的实例带到前台，而不是在顶上创建一个新的实例。也许你想当用户离开 Task 的时候，后退栈中除了根 Activity 之外的清空其他 Activity 。</p>
<p>通过清单文件中 <code>&lt;activity&gt;</code> 元素的属性以及传递给 startActivity() 的 Intent 中的 flag 可以完成上面的工作，甚至更多其他工作。</p>
<p>可以使用的 <code>&lt;activity&gt;</code> 元素主要属性包括：</p>
<ul>
<li>taskAffinity</li>
<li>launchMode</li>
<li>allowTaskReparenting</li>
<li>clearTaskOnLaunch</li>
<li>alwaysRetainTaskState</li>
<li>finishOnTaskLaunch</li>
</ul>
<p>可以使用的主要 Intent 的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>接下来的章节中，你将看到如何使用这些清单属性和 Intent 的 flag 来定义 Activity 如何与 Task 关联以及他们在后退栈中的行为。</p>
<blockquote>
<p><strong>警告：</strong> 大部分应用程序不应该干扰 Activity 和 Task 的默认行为。如果你觉得非常有必要修改这些默认行为，那么需要做出警告，并测试 Activity 启动以及通过返回键从其他 Activity 或 Task 返回的情况。测试导航是否会和用户所期待的行为冲突。</p>
</blockquote>
<h3 id="定义启动模式">定义启动模式</h3><p>启动模式用来定义一个新的 Activity 实例如何与当前的 Task 关联。可以通过两种方式来定义不同的启动模式：</p>
<ul>
<li>使用清单文件：当你在清单文件中声明一个 Activity 时，可以指定 Activity 在启动时如何关联 Task。</li>
<li>使用 Intent flag ：调用 startActivity() 时，可以在 Intent 中包含 flag 来声明新的 Activity 与当前 Task 如何关联。</li>
</ul>
<p>这样，如果 Activity A 启动 Activity B ， Activity B 可以在它的清单中定义如何与当前 Task 关联， Activity A 同样可以请求 Activity B 如何与当前 Task 关联。如果都定义了 Activity B 如何与 Task 关联， Activity A 中通过 Intent 定义的请求优先于 Activity 在清单中定义的请求。</p>
<blockquote>
<p><strong>注意</strong>：某些在清单文件中有效的启动模式，在 Intent 中的 flag 是无效的，同样，某些 Intent 中有效的启动模式在清单里定义是无效的。</p>
</blockquote>
<p><strong>使用清单文件</strong></p>
<p>在清单文件中申明 Activity 时，使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性可以指定 Activity 如何与 Task 关联：</p>
<ul>
<li>“standard”（默认模式）</li>
</ul>
<p>系统创建新的 Activity 实例，这个实例位于启动它的 Activity 相同的栈，并且将意图传递给它。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 也能有多个实例。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>如果 Activity 的实例已经存在于当前 Task 的顶部，系统通过调用实例的 onNewIntent() 方法来传递意图到实例，而不是为 Activity 创建一个新的实例。 Activity 可以被实例化多次，每个实例可以属于不同的 Task ，一个 Task 可以有多个实例(除非后退栈顶部的 Activity 不是一个已经存在的 Activity 实例)。</p>
<p>例如，假设一个 Task 的后退栈包含根 Activity A ， Activity B ， Activity C 以及 Activity D 在顶部。一个意图到达 Activity D 。如果 D 的启动模式为 “standard” ，新的类实例将被启动，堆栈变成 A-B-C-D-D 。如果 D 的启动模式为 “singleTop” ，已经存在的 D 实例将通过 onNewIntent() 接收意图，一次它还在栈顶，而栈依然是 A-B-C-D 。如果一个意图到达 B ，新的 B 的实例被添加到堆栈中，即使它的启动模式是 “singleTop” 。</p>
<blockquote>
<p><strong>注意</strong>：当新的 Activity 实例被创建，用户可以按下返回按钮来返回到之前的 Activity 。但是当已经存在的 Activity 实例处理了新的 Intent ，用户无法按下返回键返回到通过 onNewIntent() 到来新的 Intent 前的 Activity 状态。</p>
</blockquote>
<ul>
<li>“singleTask”</li>
</ul>
<p>系统创建新的 Task 并在新的 Task 的根实例化 Activity 。如果已经有 Activity 的实例存在于独立的 Task 中，系统通过调用 onNewIntent() 将 Intent 路由到已存在的实例，而不是创建一个新的实例。每次只能有一个 Activity 的实例存在。</p>
<blockquote>
<p><strong>注意</strong>：虽然 Activity 在新的 Task 中打开，后退按钮依然可以返回到用户之前的 Activity 。</p>
</blockquote>
<ul>
<li>“singleInstance”</li>
</ul>
<p>除了系统不再启动其他的 Activity 到持有实例的 Task 中，其他的和 “singleTask” 一样。 这个 Activity 是它的 Task 的唯一成员。任何由它打开的 Activity 在一个独立的 Task 。</p>
<p>另外一个实例， Android 浏览器应用程序声明网页浏览器的 Activity 需要永远在自己的 Task 中打开，即在 <code>&lt;activity&gt;</code> 元素中指定 singleTask 启动模式。这意味着，如果你的应用程序要打开 Android 浏览器，它的 Activity 与你的应用程序将在不同的 Task 中。不论新的 Task 启动浏览器，或者浏览器已经有一个运行在后台的 Task， Task 将被带到前台处理新的 Intent 。</p>
<p>不论 Activity 是在新的 Task 中启动还是在相同的 Task 中启动，返回按钮总是能让用户返回到之前的 Activity 。如果你启动了一个指定 singleTask 启动模式的 Activity ，恰好这时有个 Activity 的实例在后台 Task 中，整个 Task 将进入前台。这种情况下，后退栈中包含在 Task 中的所有 Activity 进入前台，在栈的顶部。下图展示了这个过程。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/diagram_backstack_singletask_multiactivity.png" alt=""></p>
<p>更多的在清单中使用启动模式的信息，可以查看 <a href=""><activity>元素</activity></a> 相关文档，这里讨论更多关于 launchMode 属性及可接受的值。</p>
<blockquote>
<p><strong>注意</strong>：Activity 中通过 launchMode 属性指定的行为，可以通过启动 Activity 的意图的 flag 来覆盖。 </p>
</blockquote>
<p><strong>使用意图 flag</strong></p>
<p>启动一个 Activity 时，可以通过在 startActivity() 中传递意图的 flag 来修改 Activity 与 Task 之间的默认关联。可以用来修改默认行为的 flag 包括：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK</li>
</ul>
<p>在新的 Task 中启动 Activity 。如果要启动的 Activity 已经有在运行的 Task ， Task 将带着最后被保存的状态到前台， Activity 在 onNewIntent() 中接收新的意图。</p>
<p>这产生的效果与上节讨论的 “singleTask” 启动模式一致。</p>
<ul>
<li>FLAG_ACTIVITY_SINGLE_TOP</li>
</ul>
<p>如果被启动的 Activity 是当前 Activity (即在后退栈的顶部)，已存在的实例调用 onNewIntent() ，而不是创建一个新的 Activity 实例。</p>
<p>这产生的效果与上节讨论的 “singleTop” 启动模式一致。 </p>
<ul>
<li>FLAG_ACTIVITY_CLEAR_TOP</li>
</ul>
<p>如果被启动的 Activity 已经在当前 Task 中，那么所有在其顶部的 Activity 将被销毁，意图将通过 onNewIntent() 传递到被恢复的 Activity 实例，而不是创建一个新的实例。</p>
<p>没有启动模式可以产生这种行为。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP 经常和 FLAG_ACTIVITY_NEW_TASK 结合使用。当在一起使用时，这些 flag 是一种在其他 Task 中定位已存在 Activity，并将其放入可以响应意图位置的方式。</p>
<h3 id="处理_affinities">处理 affinities</h3><p>Affinity 表明 Activity 优先属于哪个 Task 。默认情况下，来自同一个应用程序的 Activity 相互间拥有一个 Affinity 。因此，同一个应用程序的 Activity 优先在同一个 Task 中。尽管如此，你可以修改一个 Activity 的默认 Affinity 。不同应用程序中定义的 Activity 可以共享一个 Affinity ，同一个应用程序中定义的 Activity 也可以被分配在不同的 Task Affinity 中。</p>
<p>通过给定 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性可以修改 Activity 的 Affinity 。</p>
<p>taskAffinity 属性是一个字符串，必须与申明在 <code>&lt;manifest&gt;</code> 元素中的默认包名不同。因为系统使用这个名称来识别应用程序的默认 Task Affinity 。</p>
<p>两种情况下使用 Affinity：</p>
<ul>
<li>当启动 Activity 的意图包含 FLAG_ACTIVITY_NEW_TASK flag 时。</li>
</ul>
<p>默认情况下，新的 Activity 被启动在调用 startActivity() 方法的 Activity 所在 Task 。被推入到调用者相同的后退栈。但如果传递给 startActivity() 的意图中包含 FLAG_ACTIVITY_NEW_TASK flag ，系统寻找另外的 Task 来存放 Activity 。通常是一个新的 Task 。但也不是必须的。当已经存在存在一个 Task 拥有相同的 Affinity 时， Activity 被启动到这个 Task 中，没有时，才启动新的 Task 。</p>
<p>如果这个 flag 使得 Activity 启动到新的 Task 中，用户又按下 Home 键离开它，这里将有许多种方式来让用户导航回 Task 。某些入口（如通知管理器）总是在外部 Task 中启动 Activity ，而不是在自己内部，因此调用 startActivity() 总是在意图中传递 FLAG_ACTIVITY_NEW_ACTIVITY 。如果你需要一个 Activity 可以被外部的入口调用，则使用这个 flag ，需要注意的是用户有独立的方式来返回到启动的 Task ，如通过启动器图标。</p>
<ul>
<li>当一个 Activity 有 allowTaskReparenting 属性并设置为 true 。</li>
</ul>
<h3 id="清空后退栈">清空后退栈</h3><p>如果用户离开 Task 一段时间，系统将清空 Task 中除根 Activity 之外的所有 Activity 。当用户再次回到 Task ，只有根 Activity 将被回复。系统行为之所以如此，是因为在经历一段相对长的时间，用户将放弃之前所做的一些事情，而返回 Task 是为了开始其他新的事情。</p>
<p>这里有一些 Activity 的属性可以用来修改这个行为：</p>
<ul>
<li>alwaysRetainTaskState</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，上面提到的默认行为将不会发生。 即时经过很长一段时间， Task 也将在栈中保持所有的 Activity 。</p>
<ul>
<li>clearTaskOnLaunch</li>
</ul>
<p>如果在 Task 的根 Activity 中将这个属性设置为 true ，无论用户离开 Task 或是返回它，堆栈将被清空只剩下根 Activity。换句话说，这与 alwaysRetainTaskState 刚刚相反。即时在离开很短的时间，用户也将返回 Task 的初始状态。</p>
<ul>
<li>finishOnTaskLaunch</li>
</ul>
<p>这个属性类似 clearTaskOnLaunch ，但是这个仅作用于单个 Activity ，而不是整个 Task 。这能引起任何 Activity 消失，包括根 Activity 。当它被设置为 true ， Activity 仅仅为当前会话维持 Task 的部分。如果用户离开或者过会儿返回 Task 都不在了。</p>
<h3 id="启动_Task">启动 Task</h3><p>通过给定某个 Activity 包含 “android.intent.action.MAIN” 为指定动作， “android.intent.category.LAUNCHER” 为指定类别的意图过滤器，可以将 Activity 作为 Task 的入口。实例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种类型的意图过滤器在应用程序启动器上显示 Activity 的图标和标签。由于这种原因，”singleTask” 和 “singleInstance” 两种启动模式标记 Activity 初始化 Task 只能在 Activity 拥有 ACTION_MAIN 和 CATEGORY_LAUNCHER 过滤器时使用。想象一下如果没有这些过滤器将发生什么：一个意图启动了 “singleTask” 的 Activity ，初始化了 Task ，用户在这个 Task 上玩耍了一段时间，然后按下了 Home 键。Task 就进入了后台且不可见。现在用户无法再返回到 Task ，因为应用程序启动器上没有显示…</p>
<p>在那些不需要用户返回到 Activity 的情况，设置 <code>&lt;activity&gt;</code> 元素的 finishOnTaskLaunch 为 true 。</p>
<h2 id="参考">参考</h2><p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>应用程序通常包含多个 Activity。每个 Activity 围绕用户能够执行的指定动作类型和启动其他 Activity 来设计。例如，一个邮件应用程序有一个用来显示新信息列表的 Activity ，当用户选择一条信息，一个新的 Activity 打开用来查看信息。</p]]>
    </summary>
    
      <category term="Activity" scheme="http://linfuyan.com/tags/Activity/"/>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Task" scheme="http://linfuyan.com/tags/Task/"/>
    
      <category term="后退栈" scheme="http://linfuyan.com/tags/%E5%90%8E%E9%80%80%E6%A0%88/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Activity 详解]]></title>
    <link href="http://linfuyan.com/android-activity/"/>
    <id>http://linfuyan.com/android-activity/</id>
    <published>2015-11-04T10:05:39.000Z</published>
    <updated>2015-11-09T10:13:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><ol>
<li>Activity 是一个提供屏幕的应用程序组件，用户通过它与机器产生交互。</li>
<li>每个 Activity 包含一个窗口( window )，大部分情况下窗口是全屏的，也有可能窗口比屏幕小且在其他窗口的顶部。</li>
<li>一个应用程序由一个或者多个 Activity 组成，这些 Activity 之间是松散的组织在一起的。</li>
<li>每一个 Activity 可以启动其他的 Activity，不同的 Activity 可以执行不同的动作。</li>
<li>新的 Activity 启动以后，原来的 Activity 会被保留到后退栈中，后退栈遵循基本的后进先出的堆栈机制。在当前 Activity 中按返回键退出，当前 Activity 将被从堆栈中弹出、销毁，之前的 Activity 则被恢复。</li>
<li>当 Activity 被启动，或者被停止时，都会通过生命周期回调的方式来通知自己的状态变化。这些状态包括被创建、停止、恢复、销毁，每个回调都提供了在特定状态下执行特定任务的时机。</li>
</ol>
<h2 id="如何创建_Activity">如何创建 Activity</h2><ol>
<li>创建 Activity 可以通过创建 Activity 的子类，或者一个已经存在的 Activity 子类来实现。</li>
<li>在创建的子类中实现生命周期的回调方法。其中最重要的是 onCreate 和 onPause。<ul>
<li>必须实现 onCreate 方法，并且在其中调用 setContentView() 来定义用户布局。</li>
<li>在 onPause 中提交当前会话中需要被持久化的更改，以避免用户可能不再回来导致的数据丢失。</li>
</ul>
</li>
</ol>
<h3 id="实现用户界面">实现用户界面</h3><ol>
<li>Activity 的用户界面是由一系列的视图层级来提供的。</li>
<li>视图源自于 View 类的对象。每个视图控制 Activity 的窗口上的特定矩形空间，并响应用户交互。</li>
<li>用户提供了一系列内置的视图，包括”控件”和”布局”。<ul>
<li>控件指的是在屏幕上提供的可见、可交互的元素的视图。</li>
<li>布局源自 ViewGroup， 为它的子类提供唯一的布局模型。</li>
</ul>
</li>
<li>可以实现 View 或者 ViewGroup 的子类来创建自己的控件和布局。</li>
<li>常用的视图布局定义方式包括：<ul>
<li>通过资源文件中的 XML 布局，并在 setContentView() 方法中传递资源ID。可以使界面设计的维护和逻辑代码分离。</li>
<li>通过代码创建 View， 并插入到 ViewGroup 来构建视图层级，然后传递根 ViewGroup 给 setContentView()。</li>
</ul>
</li>
</ol>
<h3 id="在清单中声明_Activity">在清单中声明 Activity</h3><ol>
<li>使用 Activity 前，需要在应用清单文件中对其进行声明。在 <code>&lt;application&gt;</code> 元素中添加 <code>&lt;activity&gt;</code> 子元素。</li>
<li><code>&lt;activity&gt;</code> 元素中还有许多属性用来定义Activity 的标签、图标、主题等， <code>android:name</code> 是唯一必须的属性，用于定义 Activity 的名称。</li>
<li>Activity 的名称定义以后，不要随便改动。如果改动，可能造成某些功能无法正常使用。</li>
</ol>
<h3 id="使用意图过滤器">使用意图过滤器</h3><ol>
<li><code>&lt;activity&gt;</code> 元素通过 <code>&lt;intent-filter&gt;</code> 元素来定义不同的意图过滤器，用来声明其他应用程序如何激活它。</li>
<li>Android SDK 工具在创建应用程序时自动生成的 Activity 中包含的意图过滤器，声明了 Activity 响应 main 动作，并放在 launcher 类别中。<ul>
<li><code>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</code> 指定这是应用程序的主入口。</li>
<li><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</code> 指定 Activity 被列在系统的应用程序启动器中，这样用户可以启动它。</li>
</ul>
</li>
<li>如果不允许其他的应用程序来启动 Activity，则不要声明任何的意图过滤器。</li>
<li>在应用程序内部，可以通过显式的意图来启动想要的 Activity。</li>
<li>如果定义了意图过滤器，则可以让其他应用程序通过隐式意图来激活 Activity。</li>
<li><code>&lt;intent-filter&gt;</code> 元素中包含有 <code>&lt;action&gt;</code> 元素及可选的 <code>&lt;category&gt;</code> 或者 <code>&lt;data&gt;</code>，这些元素一同指定了 Activity 能响应的意图类型。</li>
</ol>
<h2 id="启动一个_Activity">启动一个 Activity</h2><ol>
<li>通过 startActivity() 方法来启动 Activity， 并传递一个 Intent 意图对象。</li>
<li>Intent 对象通过两种方式描述想要启动的 Activity：<ul>
<li>准确的 Activity 对象。</li>
<li>想要执行的动作类型。系统会自动选择合适的 Activity， 可能来自其他的应用程序。</li>
</ul>
</li>
<li>Intent 还可以传递少量的数据给即将启动的 Activity。</li>
<li>使用类名来启动已知的 Activity：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(this, SignInActivity.<span class="keyword">class</span>);</span><br><span class="line">startActivity(<span class="type">intent</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 Intent 来描述要执行的动作，系统从其他应用程序中选择打开合适的 Activity， 如果有多个 Activity， 则由用户来选择：</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(<span class="type">Intent</span>.ACTION_SEND);</span><br><span class="line"><span class="type">intent</span>.putExtra(<span class="type">Intent</span>.EXTRA_EMAIL, recipientArray);</span><br><span class="line">startActivity(<span class="type">intent</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为结果启动_Activity">为结果启动 Activity</h3><ol>
<li>如果启动一个 Activity， 并期望从新的 Activity 上接收一个结果，则使用 startActivityForResult()。</li>
<li>要接收新 Activity 上的结果，需要在原 Activity 上实现 onActivityResult() 方法，从其中的 Intent 参数中获取返回结果。</li>
<li>onActivityResult() 方法处理 Activity 返回结果：<ul>
<li>处理成功，则 resultCode 为 RESULT_OK。</li>
<li>需要检查 requestCode 是否与 startActivityForResult() 的第二个参数匹配。</li>
<li>返回的结果以 Intent 带回。</li>
</ul>
</li>
</ol>
<h2 id="关闭_Activity">关闭 Activity</h2><p>通过 finish() 和 finishActivity() 来关闭 Activity。实际上由于 Android 系统自己管理 Activity 的生命，你不应该显示的调用这些方法。</p>
<h2 id="管理_Activity_生命周期">管理 Activity 生命周期</h2><ol>
<li>通过实现回调方法来管理 Activity 的生命周期，可以开发一个健壮且灵活的应用程序。 Activity 的生命周期则直接影响到它所关联的其他 Activity， 任务以及后退栈。</li>
<li>Activity 的主要状态：<ul>
<li>Resumed： Activity 处于前台屏幕，且拥有用户焦点。</li>
<li>Paused：其他 Activity 位于前台，但这个 Activity 还是可见的。其他 Activity 位于顶部且没有覆盖整个屏幕。这时候， Activity 还在内存中，<strong>与窗口管理器关联</strong>，但在内存极低的情况下将被系统杀掉。</li>
<li>Stopped： Activity 被其他 Activity 完全覆盖，位于后台。这时候， Activity 还在内存中，<strong>与窗口管理器分离</strong>，当需要内存时将被系统杀掉。</li>
</ul>
</li>
<li>当 Activity 被暂停或者被停止，系统可以通过调用 finish() 或者直接删掉进程的方式丢弃它。重新打开时需要重建。</li>
</ol>
<h3 id="基础的生命周期方法">基础的生命周期方法</h3><table>
<thead>
<tr>
<th>生命周期方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>Activity 将被创建。</td>
</tr>
<tr>
<td>onStart()</td>
<td>Activity 即将可见。</td>
</tr>
<tr>
<td>onResume()</td>
<td>Activity 已经可见，处于 resumed 状态。</td>
</tr>
<tr>
<td>onPause()</td>
<td>其他 Activity 可见，自己则即将处于 paused 状态。</td>
</tr>
<tr>
<td>onStop()</td>
<td>Activity 不在可见，处于 stopped 状态。</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>Activity 即将被销毁。</td>
</tr>
</tbody>
</table>
<ol>
<li>在实现生命周期方法时，需要调用父类的实现。</li>
<li>实现这些生命周期方法，你可以监控 3 个嵌套的循环。<ul>
<li>完整生命：从 onCreate() 到 onDestroy() 。在 onCreate() 中建立全局状态，并在 onDestroy() 中释放资源。</li>
<li>可见生命：从 onStart() 到 onStop() 。这个过程中，用户可以看到 Activity 并与之交互。</li>
<li>前台生命：从 onResume() 到 onPause()。</li>
</ul>
</li>
</ol>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/activity_lifecycle.png" alt="Activity 生命周期"></p>
<h3 id="保存_Activity_状态">保存 Activity 状态</h3><ol>
<li>Activity 处于 paused， stopped 时依然存在内存中，所有的数据及状态都存在，因此当被恢复时依然保持退出时的状态。</li>
<li>但处于 paused， stopped 状态的 Activity 可能会被系统杀掉，从而用户重新打开时，与当时提出时不一样了。为了保证能够还原现场，则需要实现 onSaveInstanceState() 回调方法。</li>
<li>系统在 Activity 被销毁之前调用 onSaveInstance() ，通过将需要记住的状态通过键值对的形式保存到 Bundle 参数中。当应用程序被系统杀死，并再次被启动时，会将保存的 Bundle 传递到 onCreate() 和 onRestoreInstanceState() 。从这些方法的 Bundle 参数中，就可以获取到 Activity 被销毁前的状态，并据此恢复 Activity。</li>
</ol>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/restore_instance.png" alt="Activity 恢复实例"></p>
<ol>
<li>onSaveInstanceState() 并不是在 Activity 被销毁之前一定会被调用。该方法在 onStop() 之前被调用，是否在 onPause() 前则不确定。</li>
<li>即使你没有实现 onSaveInstanceState() ，在 Activity 的 onSaveInstanceState() 的默认实现中也可以恢复一些状态。由于 onSaveInstanceState() 的默认实现中保存了 UI 的状态，因此，在自己实现 onSaveInstanceState() 时，需要调用父类的 onSaveInstanceState()。</li>
<li>由于 onSaveInstanceState() 不保证一定会被调用，因此不能在这个回调中记录 Activity 状态的变换，也不应该使用它来持久化数据，而应该使用 onPause()。</li>
<li>一个好的，用来测试应用程序恢复状态能力的方法是简单地旋转设备的屏幕方向。</li>
</ol>
<h3 id="处理配置改变">处理配置改变</h3><p>某些设备配置在运行时会发生改变，如屏幕方向、键盘可用性和语言。当这些改变发生时， Android 重建运行中的 Activity (系统调用 onDestroy() 后马上调用 onCreate() )。这个行为被设计用来帮助应用程序适应新的配置，自动为应用程序重新加载已提供的可替换资源，如为不同屏幕方向和尺寸使用的不同布局。</p>
<p>处理重启的最好方法是使用 onSaveInstanceState() 和 onRestoreInstanceState() (或者 onCreate()) 来保存和恢复 Activity 的状态。</p>
<h3 id="协调多个_Activity">协调多个 Activity</h3><p>当一个 Activity 启动另外一个时，两个 Activity 都会经历生命周期的变换。当另一个 Activity 被创建时，第一个 Activity 将暂停，乃至停止(如果它在后台且可见，则不会停止)。如果两个 Activity 之间共享保存在磁盘上的数据，对于理解在第二个 Activity 创建完成之前，第一个 Activity 不会完全停止是非常重要的。第二个 Activity 的启动过程和第一个 Activity 的停止过程重叠。</p>
<p>生命周期回调的顺序是被良好定义的，特别是当两个 Activity 在相同的进程中，且一个启动另外一个。下面是当 Activity A 启动 Activity B 时的操作顺序：</p>
<ol>
<li>执行 Activity A 的 onPause() 方法。</li>
<li>Activity B 的 onCreate() ， onStart() 和 onResume() 方法按顺序执行。(这是 Activity 获取了用户焦点)。</li>
<li>如果 Activity A 不再屏幕上可见， onStop() 方法被执行。</li>
</ol>
<p>可预期的生命周期回调顺序使得你可以管理一个 Activity 到另一个的变换信息。例如，你必须在第一个 Activity 停止时对数据库进行写入，这样接下来的 Activity 可以读取，那么你需要在 onPause() 中写入数据库，而不是在 onStop() 中。</p>
<h2 id="参考">参考</h2><p><a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="external">https://developer.android.com/guide/components/activities.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概览">概览</h2><ol>
<li>Activity 是一个提供屏幕的应用程序组件，用户通过它与机器产生交互。</li>
<li>每个 Activity 包含一个窗口( window )，大部分情况下窗口是全屏的，也有可能窗口比屏幕小且在其他窗口的顶部。</l]]>
    </summary>
    
      <category term="Activity" scheme="http://linfuyan.com/tags/Activity/"/>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 上 sublime text 通过命令行打开文件]]></title>
    <link href="http://linfuyan.com/faq/open-files-via-cmdline-using-sublime-text/"/>
    <id>http://linfuyan.com/faq/open-files-via-cmdline-using-sublime-text/</id>
    <published>2015-11-03T10:28:00.000Z</published>
    <updated>2015-11-03T10:39:01.000Z</updated>
    <content type="html"><![CDATA[<p>在 Mac 上让 sublime text 通过命令行打开文件，可以提升比较高的效率。</p>
<p>具体过程如下：</p>
<p>1. 首先，在主用户目录下新建 .bash_alias 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.bash_<span class="built_in">alias</span></span><br></pre></td></tr></table></figure>
<p>2. 在其中添加如下代码</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">subl</span>=<span class="comment">'open -a /Applications/"Sublime Text 2.app"'</span></span><br><span class="line"><span class="keyword">alias</span> <span class="title">st</span>=subl</span><br></pre></td></tr></table></figure>
<p>3. 使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_<span class="built_in">alias</span></span><br></pre></td></tr></table></figure>
<p>4. 可以将上面的命令，添加到 <code>~/.bash_profile</code> 中，这样每次启动就自动使上面的配置生效了。</p>
<p>5. 完成上面步骤，就可以通过如下命令，打开目标文件/目录了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">st</span> path/<span class="keyword">to</span>/dest/dir_or_file</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他的应用也是可以通过类似的方式配置，来提高操作的效率，如下面添加了 mou 来打开文件。</p>
</blockquote>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">mou</span>=<span class="comment">'open -a /Applications/Mou.app'</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>在 Mac 上让 sublime text 通过命令行打开文件，可以提升比较高的效率。</p>
<p>具体过程如下：</p>
<p>1. 首先，在主用户目录下新建 .bash_alias 文件</p>
<figure class="highlight bash"><tabl]]>
    </summary>
    
      <category term="Mac" scheme="http://linfuyan.com/tags/Mac/"/>
    
      <category term="sublime text" scheme="http://linfuyan.com/tags/sublime-text/"/>
    
      <category term="使用" scheme="http://linfuyan.com/tags/%E4%BD%BF%E7%94%A8/"/>
    
      <category term="技巧" scheme="http://linfuyan.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决 The same input jar is specified twice 问题]]></title>
    <link href="http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/"/>
    <id>http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/</id>
    <published>2015-11-02T13:06:00.000Z</published>
    <updated>2015-11-02T13:18:19.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> <span class="keyword">task</span> <span class="string">':joke:proguardRelease'</span>.</span><br><span class="line">&gt; java.io.IOException: The same input jar [<span class="regexp">/Users/</span>lfy<span class="regexp">/Develop/gi</span>ts<span class="regexp">/joke-android/</span>joke<span class="regexp">/libs/</span>eventbus.jar] is specified twice.</span><br></pre></td></tr></table></figure>
<p>今天在打混淆包时，遇到这个错误，刚开始以为是因为有多个项目都引用了 eventbus.jar 库，但当我对项目中的 eventbus.jar 的依赖进行排除时，同样出错。这次报的则是没有 eventbus.jar。 所以打消了我的第一个猜测。</p>
<p>后来发现，是因为以前在用 eclipse 开发时，混淆配置文件中包含有 <code>-libraryjars libs/eventbus.jar</code> 的配置，用来保持 eventbus.jar 不被混淆。在 Android Studio 中， build.gradle 中声明了对这个 jar 包的依赖，则不需要在混淆配置文件中继续声明。</p>
<p>在将所有的 <code>-libraryjars libs/*.jar</code> 注释掉以后，项目可以正常混淆了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td]]>
    </summary>
    
      <category term="Android Studio" scheme="http://linfuyan.com/tags/Android-Studio/"/>
    
      <category term="proguard" scheme="http://linfuyan.com/tags/proguard/"/>
    
      <category term="混淆" scheme="http://linfuyan.com/tags/%E6%B7%B7%E6%B7%86/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 使用多说评论框]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/"/>
    <id>http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/</id>
    <published>2015-11-01T01:37:28.000Z</published>
    <updated>2015-11-01T02:59:05.000Z</updated>
    <content type="html"><![CDATA[<p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>
<a id="more"></a>
<p>既然如此，我们以 hueman 主题下在文章末尾配置多说评论框为例作一下说明。</p>
<p>首先，你需要注册一个<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>账号并新建一个站点。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-create-site.png" alt="多说创建站点"></p>
<p>站点创建完成以后，会跳出代码模板的页面，如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-comment-template.png" alt="多说代码模板"></p>
<p>左侧选择”获取代码”的这栏，然后选中”通用代码”。这就是我们评论框的代码模板，后面我们需要找到合适的地方，将其插入到 hueman 主题中的文章模板里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/hueman-article.png" alt="hueman 文章代码"></p>
<p>在 hueman 主题中，文章的模板在 <code>hueman -&gt; layout -&gt; _partial -&gt; post -&gt; article.ejs</code>  下面。看到上图中，第一个红框圈住的部分，是主题自带的 disqus 评论框的配置。当然我们没有在<strong>项目目录</strong>下的 <code>_config.yml</code> 中配置 disqus_shortname，所以它是不生效的，在咱们的文章页面中看不到。</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (post.comments &amp;&amp; config.disqus_shortname)&#123; </span>%&gt;<span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"disqus_thread"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"></span>&lt;%<span class="ruby"> &#125; </span>%&gt;<span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>找到上面这个文章末尾的位置，仿照上面的逻辑判断代码，把多说评论框模板代码添加进来，如上图中的第二个红框圈住的部分。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (!<span class="attribute">index</span> &amp;&amp; <span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">theme.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%= page.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 end --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="keyword">var</span> duoshuoQuery = &#123;short_name:<span class="string">'&lt;%= theme.duoshuo_shortname %&gt;'</span>&#125;;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</span><br><span class="line">        ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</span><br><span class="line">        ds.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">        (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</span><br><span class="line">         || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span><br><span class="line">      &#125;)();</span><br><span class="line">      </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 end --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里大家注意一下：</p>
<p>1. 第一行中判断 !index 代表是非主页的文章。我们是要在主页之外的文章正文下添加评论，所以添加了这个判断。</p>
<p>2. <code>theme.duoshuo_shortname</code>，这里需要我们在主题下面的 <code>_config.yml</code> 中添加 <code>duoshuo_shortname</code> 字段配置才能生效。这里和上面讲到的 <code>config.disqus_shortname</code> 的区别就在于 <code>theme._</code> 开头的是在主题中的 <code>_config.yml</code> 配置， <code>config._</code> 开头是在项目目录下的 <code>_config.yml</code> 配置。</p>
<p>Ok，到这里，打开 <code>hueman -&gt; _config.yml</code> 在其中添加如下代码：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># comments 配置多说评论</span></span><br><span class="line"><span class="label">duoshuo_shortname:</span> 这里就是你在创建站点时填的多说域名</span><br></pre></td></tr></table></figure>
<p>如果多说域名是 <a href="http://abc.duoshuo.com" target="_blank" rel="external">http://abc.duoshuo.com</a> ， 那这里 <code>duoshuo_shortname</code> 就是 abc。</p>
<p>3. 多说评论框模板中的变量，我们需要进行替换。原来如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"ds-thread"</span> data-thread-key=<span class="string">"请将此处替换成文章在你的站点中的ID"</span> data-title=<span class="string">"请替换成文章的标题"</span> data-url=<span class="string">"请替换成文章的网址"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> post.layout </span>%&gt;<span class="xml"><span class="tag"><span class="value">-</span></span></span>&lt;%=<span class="ruby"> post.slug </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">data-title</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> post.title </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">data-url</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> page.permalink </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>其中， <code>post.layout</code>， <code>post.slug</code>， <code>post.title</code>， <code>page.permalink</code> 都是 Hexo 的内置变量。具体可以查看<a href="https://hexo.io/zh-cn/docs/variables.html" target="_blank" rel="external">这里</a>。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-article-management.png" alt="多说文章管理"></p>
<p>这样就为 Hexo 站点添加上多说评论框啦，如果还需要在其他的位置添加，过程类似。总结下步骤：</p>
<ol>
<li>注册多说账号，创建新站点。</li>
<li>找到需要添加多说评论框的位置，粘贴多说评论框的模板代码，并作必要的修改。</li>
<li>如果将多说评论框作为配置项，合适的地方，添加配置。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="多说" scheme="http://linfuyan.com/tags/%E5%A4%9A%E8%AF%B4/"/>
    
      <category term="评论框" scheme="http://linfuyan.com/tags/%E8%AF%84%E8%AE%BA%E6%A1%86/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo Symbol not found _usdt_create_provider 错误处理]]></title>
    <link href="http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/"/>
    <id>http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/</id>
    <published>2015-10-30T23:13:12.000Z</published>
    <updated>2015-10-31T11:26:55.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>
<a id="more"></a>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> lazy symbol binding <span class="string">failed:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"><span class="label"></span><br><span class="line">dyld:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"></span><br><span class="line">Trace/BPT <span class="string">trap:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>最终，我是通过多次的 <code>npm install hexo --no-optional</code> 解决的，至于原因是什么，我不太清楚。其他手段也试过，没有成功。</p>
<p>以下是参考过的资料：</p>
<p><a href="https://github.com/trentm/node-bunyan/issues/216" target="_blank" rel="external">Still getting lots of DtraceProviderBindings errors on OS X</a></p>
<p><a href="https://github.com/hexojs/hexo/issues/1398" target="_blank" rel="external">node.js v0.12.7 install hexo-cli error on mac os x 10.10.4</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="错误" scheme="http://linfuyan.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 使用七牛云同步插件 hexo-qiniu-sync 出错]]></title>
    <link href="http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/"/>
    <id>http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/</id>
    <published>2015-10-30T22:45:20.000Z</published>
    <updated>2015-10-31T11:23:12.000Z</updated>
    <content type="html"><![CDATA[<p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something<span class="comment">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line">TypeError: Arguments <span class="keyword">to</span> path.<span class="keyword">join</span> must be strings</span><br><span class="line">    at <span class="built_in">Object</span>.posix.<span class="keyword">join</span> (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    at <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    at Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Hexo.ret (eval at &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    at /Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="keyword">new</span> Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    at Hexo.<span class="keyword">call</span> (/Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    at runHexoCommand (/usr/local/<span class="keyword">lib</span>/node_modules/hexo/node_modules/hexo-cli/<span class="keyword">lib</span>/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    at Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    at Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    at Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    at Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    at Immediate.Async.drainQueues [<span class="keyword">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate [<span class="keyword">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>找到关键的部分：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Arguments to path<span class="class">.join</span> must be strings</span><br><span class="line">    at Object<span class="class">.posix</span><span class="class">.join</span> (path<span class="class">.js</span>:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync<span class="class">.js</span>:<span class="number">110</span>:<span class="number">26</span>)</span><br></pre></td></tr></table></figure>
<p>查看源代码中的 sync.js，发现其中的 sync() 方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">file</span> <span class="keyword">in</span> files) &#123;</span><br><span class="line">       <span class="keyword">var</span> fname = path.join(local_dir, <span class="keyword">dir</span>, files[i]); <span class="comment">// 这部分出错</span></span><br><span class="line">       <span class="keyword">var</span> stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == true) &#123;</span><br><span class="line">           sync(path.join(<span class="keyword">dir</span>, files[i]));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="keyword">var</span> name = path.join(dirPrefix, fname.<span class="keyword">replace</span>(local_dir, '')).<span class="keyword">replace</span>(/\\/<span class="keyword">g</span>, '/').<span class="keyword">replace</span>(/^\<span class="comment">//g, '');</span></span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面注释部分似乎是传递的参数类型出错了。</p>
<p>查看了官方最新的代码，发现确实不一样。于是将上面的内容替换成下面：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">files.forEach(function(<span class="keyword">file</span>)  &#123;</span><br><span class="line">       var fname = path.<span class="keyword">join</span>(local_dir + <span class="string">''</span>, dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>);</span><br><span class="line">       var stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == <span class="keyword">true</span>) &#123;</span><br><span class="line">           sync(path.<span class="keyword">join</span>(dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           var name = path.<span class="keyword">join</span>(dirPrefix, fname.replace(local_dir, <span class="string">''</span>)).replace(<span class="regexp">/\\/g</span>, <span class="string">'/'</span>).replace(<span class="regexp">/^\//g</span>, <span class="string">''</span>);</span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>问题解决了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something<span class="comment">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line">TypeError: Arguments <span class="keyword">to</span> path.<span class="keyword">join</span> must be strings</span><br><span class="line">    at <span class="built_in">Object</span>.posix.<span class="keyword">join</span> (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    at <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    at Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Hexo.ret (eval at &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    at /Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="keyword">new</span> Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    at Hexo.<span class="keyword">call</span> (/Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    at runHexoCommand (/usr/local/<span class="keyword">lib</span>/node_modules/hexo/node_modules/hexo-cli/<span class="keyword">lib</span>/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    at Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    at Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    at Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    at Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    at Immediate.Async.drainQueues [<span class="keyword">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate [<span class="keyword">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="七牛" scheme="http://linfuyan.com/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="同步" scheme="http://linfuyan.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[保持兼容性]]></title>
    <link href="http://linfuyan.com/material-design-training/maintaining-compatibility/"/>
    <id>http://linfuyan.com/material-design-training/maintaining-compatibility/</id>
    <published>2015-10-24T07:00:35.000Z</published>
    <updated>2015-11-03T09:17:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>某些 material design 特性如 material 主题以及自定义活动转场效果等只在 Android 5.0 ( API 21) 上可用。尽管如此，你依然可以设计的应用程序来使用这些特性，使之运行在支持 material design 的设备上时，能够兼容的在其他较早的 Android 发布版上运行。</p>
<a id="more"></a>
<h2 id="定义可替代的风格">定义可替代的风格</h2><p>你可以配置应用程序在支持 material design 的设备上使用 material 主题，在运行较早期版本的 Android 设备上恢复为旧的主题：</p>
<ol>
<li>在 <code>res/values/styles.xml</code> 中定义一个主题继承自旧的主题，如 Holo。</li>
<li>在 <code>res/values-v21/styles.xml</code> 中定义相同名称的主题继承自 material 主题。</li>
<li>在清单文件中设置这个主题为应用程序的主题。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果你的应用程序使用 material 主题，但没有按照这种方式提供一个替代的主题，你的应用程序在早于 Android 5.0 版本上无法运行。</p>
</blockquote>
<h2 id="提供替代的布局">提供替代的布局</h2><p>如果你所涉及的布局是按照 material design 指南，并且没有使用任何在 Android 5.0 (API 21) 上引入的新 XML 属性，那么在之前的 Android 版本也可以正常工作。否则，你需要提供一个可替换的布局。你可以提供可替代的布局来在早先的 Android 版本上自定义应用程序外观。</p>
<p>在 <code>res/layout-v21</code> 里为 Android 5.0 (API 21) 创建布局文件，在 <code>res/layout</code> 里为早先的 Android 版本创建替代的布局文件。例如： <code>res/layout/my_activity.xml</code> 是 <code>res/layout-v21/my_activity.xml</code> 的替代布局。</p>
<p>为了避免重复代码，在 <code>res/values</code> 中定义风格，为新的 API 修改 <code>res/values-v21</code> 中的风格。使用风格继承，在 <code>res/values/</code> 定义基础风格，并在 <code>res/values-v21</code> 中继承它。</p>
<h2 id="使用_Support_Library">使用 Support Library</h2><p><a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Support v7 兼容库</a> r21 及以上包含下面的 material design 特性：</p>
<ul>
<li>当你应用其中一个 <code>Theme.AppCompat</code> 主题时，某些系统组件具有 <a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="external">Material design 风格</a>。</li>
<li><code>Theme.AppCompat</code> 主题中的 <a href="https://developer.android.com/training/material/theme.html#ColorPalette" target="_blank" rel="external">色彩调色板主题属性</a>。</li>
<li>使用 RecyclerView 控件来显示数据集。</li>
<li>使用 CardView 控件来创建卡片。</li>
<li>使用 Palette 类来从图片中抽取主色彩。</li>
</ul>
<h3 id="系统控件">系统控件</h3><p><code>Theme.AppCompat</code> 主题为以下控件提供了 material design 风格：</p>
<ul>
<li>EditText</li>
<li>Spinner</li>
<li>CheckBox</li>
<li>RadioButton</li>
<li>SwitchCompat</li>
<li>CheckedTextView</li>
</ul>
<h3 id="调色板">调色板</h3><p>通过 Android Support V7 兼容库来获取 material design 风格和自定义调色板，需要应用一个 <code>Theme.AppCompat</code> 主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- extend one of the Theme.AppCompat themes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"Theme.MyTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light"</span>&gt;</span><span class="css"></span><br><span class="line">  &lt;!<span class="tag">--</span> <span class="tag">customize</span> <span class="tag">the</span> <span class="tag">color</span> <span class="tag">palette</span> <span class="tag">--</span>&gt;</span><br><span class="line">  &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/material_blue_500&lt;/item&gt;</span></span><br><span class="line">  &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/material_blue_700&lt;/item&gt;</span><br><span class="line">  &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/material_green_A200&lt;/item&gt;</span><br><span class="line"></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表和卡片">列表和卡片</h3><p>通过 Android Supprot V7 兼容库，RecyclerView 和 CardView 控件在早先的 Android 版本上是可用的，但具有如下局限：</p>
<ul>
<li>CardView 上的阴影需要使用额外的内边距来编程实现。</li>
<li>具有圆角的 CardView 无法裁剪其子视图。</li>
</ul>
<h3 id="依赖">依赖</h3><p>在早于 Android 5.0 (API 21) 版本上使用这些特性需要在项目中通过 Gradle 依赖引入 Android Support V7 兼容库。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查系统版本">检查系统版本</h3><p>以下特性在 Android 5.0 (API 21) 以上可用：</p>
<ul>
<li>活动转场效果</li>
<li>触摸反馈</li>
<li>显示动画</li>
<li>基于路径的动画</li>
<li>矢量图片</li>
<li>图片着色</li>
</ul>
<p>为了在早先 Android 版本上保持兼容性，需要中调用包含这些特性的 API 前检查系统版本。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否运行在 Android 5.0 以上版本</span></span><br><span class="line"><span class="tag">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="comment">// 在这里调用 material design API</span></span><br><span class="line">&#125; <span class="tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// 实现不包含 material design 的特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在清单文件中使用 <code>android:minSdkVersion</code> 和 <code>android:targetSdkVersion</code> 属性来指定 Android 应用程序支持哪些版本。在 Android 5.0 上使用 material design 特性，需要设置 <code>android:targetSdkVersion</code> 属性为 <code>21</code>。更多信息，可以查看<a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html" target="_blank" rel="external"><uses-sdk> API 指南</uses-sdk></a>。</p>
</blockquote>
<p>原文：<a href="https://developer.android.com/training/material/compatibility.html" target="_blank" rel="external">Maintaining Compatibility</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>某些 material design 特性如 material 主题以及自定义活动转场效果等只在 Android 5.0 ( API 21) 上可用。尽管如此，你依然可以设计的应用程序来使用这些特性，使之运行在支持 material design 的设备上时，能够兼容的在其他较早的 Android 发布版上运行。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="兼容" scheme="http://linfuyan.com/tags/%E5%85%BC%E5%AE%B9/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义自定义动画]]></title>
    <link href="http://linfuyan.com/material-design-training/defining-custom-animations/"/>
    <id>http://linfuyan.com/material-design-training/defining-custom-animations/</id>
    <published>2015-10-24T06:00:00.000Z</published>
    <updated>2015-11-03T09:16:28.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 中的动画能够让应用程序给予用户对于动作的反馈，提供用户交互的视觉持续性。 Material 主题为按钮和活动转场效果提供默认的动画， Android 5.0 (API 21) 以上版本可以定制这些动画，并创建新的：</p>
<ul>
<li>触摸反馈</li>
<li>圆形波纹</li>
<li>活动转场效果</li>
<li>曲线移动</li>
<li>视图状态改变</li>
</ul>
<a id="more"></a>
<h2 id="自定义触摸反馈">自定义触摸反馈</h2><p>Material design 中的触摸反馈可以为用户与 UI 元素的交互提供持续的视觉确认。按钮上的默认的触摸反馈动画使用新的 RippleDrawable 类，该类在不同的状态切换中使用波纹效果。</p>
<p>大部分情况下，你需要在视图的 XML 中指定视图背景来应用这个功能：</p>
<ul>
<li><code>?android:attr/selectableItemBackground</code> : 实现有边界的波纹。</li>
<li><code>?android:attr/selectableItemBackgroundBorderless</code> : 在视图之上的波纹。它将被绘制在最近的背景不为空的父视图内。</li>
</ul>
<blockquote>
<p><strong>注意</strong>： <code>selectableItemBackgroundBorderless</code> 是在 API 21 中引入的新属性。</p>
</blockquote>
<p>你也可以使用 <code>ripple</code> 元素在 XML 资源中定义 RippleDrawable 。</p>
<p>可以为 RippleDrawable 对象设置颜色。要改变默认的触摸反馈的颜色，使用主题中的 <code>android:colorControlHighlight</code> 属性。</p>
<p>更多信息，可以查看类 RippleDrawable 的 API 参考。</p>
<h2 id="使用显示效果">使用显示效果</h2><p>当显示或者隐藏一组 UI 元素时，显示动画能提供用户视觉连续性。 ViewAnimationUtils.createCircularReveal() 方法来使用裁剪为圆形动画来显示或隐藏视图。</p>
<p>要实现一个之前不可见的视图使用这种效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前不可见的视图</span></span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的最终半径</span></span><br><span class="line"><span class="keyword">int</span> finalRadius = Math.max(myView.getWidth(), myView.getHeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为视图创建动画发生器(起始半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使视图可见并启动动画</span></span><br><span class="line">myView.setVisibility(View.VISIBLE);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<p>要隐藏之前可见的视图使用这种效果：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前可见的视图</span></span><br><span class="line"><span class="keyword">final</span> View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的厨师半径</span></span><br><span class="line"><span class="keyword">int</span> initialRadius = myView.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动画(最终半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当动画结束时是视图不可见</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<h2 id="自定义活动转场效果">自定义活动转场效果</h2><p>在 Material design 特性的应用程序中，活动转场效果提供公共元素在移动和转换上不同状态下的视觉连接。你可以指定自定义的进场/退场效果及活动间的共享元素转场。</p>
<ul>
<li>进场效果决定活动中的视图如何进入场景。例如，在 <em>explode</em> 进场效果中，视图从外部飞入到屏幕的中心。</li>
<li>退场效果决定活动中的驶入如何退出场景。例如，在 <em>explode</em> 退场效果中，视图从中心退出场景。</li>
<li>共享元素转场效果决定活动之间共享视图在两个活动间的转场。例如，在两个活动中同一个图片在不同的位置且尺寸不同， <em>changeImageTransform</em> 共享元素转场在活动之间平滑的平移和缩放这些图片。</li>
</ul>
<p>Android 5.0 (API 21) 支持下面这些进场和退场效果：</p>
<ul>
<li>explode - 从场景中间移入或移出视图。</li>
<li>slide - 从场景的一边移入或移出视图。</li>
<li>fade - 通过修改透明度在场景中添加或者移除视图。</li>
</ul>
<p>所有继承自 Visibility 类的转场支持进场/退场效果。更多信息，查看 API 参考的 Transition 类。</p>
<p>Android 5.0 (API 21) 同时支持共享元素的转场效果：</p>
<ul>
<li>changeBounds - 动画改变目标视图的布局边界。</li>
<li>changeClipBounds - 动画改变目标视图的裁剪边界。</li>
<li>changeTransform - 动画改变目标视图的缩放和旋转。</li>
<li>changeImageTransform - 动画改变图片的尺寸和缩放。</li>
</ul>
<p>如果应用程序中开启了活动转场效果，进入或退出活动时默认的 cross-fading 转场效果将被激活。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/SceneTransition.png" alt="带有共享元素的转场效果"></p>
<h3 id="指定自定义转场效果">指定自定义转场效果</h3><p>首先，定义一个风格继承自 material 主题，并设置 <code>android:windowContentTransitions</code> 属性来开启窗口内容转场。你也可以在风格定义中指定进场，退场和共享元素转场效果。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"BaseAppTheme"</span> parent=<span class="string">"android:Theme.Material"</span>&gt;</span><br><span class="line"> &lt;!<span class="comment">-- 开启窗口内容转场 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowContentTransitions"</span>&gt;<span class="constant">true</span>&lt;/<span class="property">item</span>&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!<span class="comment">-- 指定进场/退场效果 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;@transition/explode&lt;/<span class="property">item</span>&gt;</span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;@transition/explode&lt;/<span class="property">item</span>&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!<span class="comment">-- 指定共享元素转场 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span><br><span class="line">   @transition/change_image_transform&lt;/<span class="property">item</span>&gt;</span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span><br><span class="line">   @transition/change_image_transform&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这个例子中 <code>change_image_transform</code> 转场效果定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/transition/change_image_transform.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- (see also Shared Transitions below) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">transitionSet</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">changeImageTransform</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>change_image_transform</code> 元素与 ChangeImageTransform 类相对应。更多信息，可以查看 API 参考 <a href="">Transition</a>。</p>
<p>在代码中，可以通过调用 Window.requestFeature() 方法来开启窗口内容转场。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line"><span class="function">getWindow</span>()<span class="class">.requestFeature</span>(Window<span class="class">.FEATURE_CONTENT_TRANSITIONS</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set an exit transition</span></span><br><span class="line"><span class="function">getWindow</span>()<span class="class">.setExitTransition</span>(new <span class="function">Explode</span>());</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过调用下面的方法，并传递 Transtion 对象来确定转场效果：</p>
<ul>
<li>Window.setEnterTransition()</li>
<li>Window.setExitTransition()</li>
<li>Window.setSharedElementEnterTransition()</li>
<li>Window.setSharedElementExitTransition()</li>
</ul>
<p>setExitTransition() 和 setSharedElementExitTransition() 定义了调用该方法的活动的退场效果。setEnterTransition() 和 setSharedElementEnterTransition() 则定义调用该方法的活动的进场效果。</p>
<p>要获取转场的完整效果，你取药开启调用与被调用活动的窗口内容转场功能。否则，调用活动可以开始退场效果，但是你最后只能看到一个窗口转场(缩放或者淡入)。</p>
<p>在被调用的活动中使用 Window.setAllowEnterTransitionOverlap() 方法来尽快启动一个进场效果，这能让你拥有很炫酷的进场效果。</p>
<h3 id="使用转场效果启动活动">使用转场效果启动活动</h3><p>如果你开启转场效果并为活动设置了退场效果，当你启动另一个活动时，转场效果将被激活，如下所示：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity<span class="list">(<span class="keyword">intent</span>,</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation<span class="list">(<span class="keyword">this</span>)</span>.toBundle<span class="list">()</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果你为第二个活动设置了进场效果，当活动开始时转场效果将被激活。要在启动另一个活动时禁用转场效果，提供一个为 <code>null</code> 的可选 bundle。</p>
<h3 id="启动带有共享元素的活动">启动带有共享元素的活动</h3><p>创建带有共享元素的两个活动的屏幕转场需要：</p>
<ol>
<li>在主题中开启窗口内容转场。</li>
<li>在风格中指定共享元素转场。</li>
<li>将转场效果定义为 XML 资源。</li>
<li>在布局中的共享元素通过 <code>android:transitionName</code> 属性来分配一样的名字。</li>
<li>使用 ActivityOptions.makeSceneTransitionAnimation() 方法。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取接收点击事件的元素</span></span><br><span class="line"><span class="keyword">final</span> View imgContainerView = findViewById(R.id.img_container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活动中进行转场的公共元素</span></span><br><span class="line"><span class="keyword">final</span> View androidRobotView = findViewById(R.id.image_small);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点击监听</span></span><br><span class="line">imgContainerView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, Activity2.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// 创建转场动画，两个活动布局中的图片使用android:transitionName="robot"进行定义</span></span><br><span class="line">        ActivityOptions <span class="keyword">options</span> = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(<span class="keyword">this</span>, androidRobotView, <span class="string">"robot"</span>);</span><br><span class="line">        <span class="comment">// 启动新的活动</span></span><br><span class="line">        startActivity(intent, <span class="keyword">options</span>.toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过在两个活动中使用 View.setTransitionName() 方法来指定公共元素名称来共享动态视图。</p>
<p>当你结束第二个活动，想要反转转场动画时，调用 Activity.finishAfterTransition() 代替 Activity.finish() 。</p>
<h3 id="启动带多个共享元素的活动">启动带多个共享元素的活动</h3><p>创建带有多个共享元素的活动转场，在布局中使用 <code>android:transitionName</code> 属性来定义共享元素，或者在活动代码中用 View.setTransitionName() 方法。然后创建 ActivityOptions 对象：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions <span class="keyword">options</span> = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>,</span><br><span class="line">        Pair.create(view1, <span class="string">"agreedName1"</span>),</span><br><span class="line">        Pair.create(view2, <span class="string">"agreedName2"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="使用曲线移动">使用曲线移动</h2><p>Material design 中的动画依赖于时间插值曲线并运动收空间所限。<br>Animations in material design rely on curves for time interpolation and spatial movement patterns. With Android 5.0 (API level 21) and above, you can define custom timing curves and curved motion patterns for animations.</p>
<p>PathInterpolator 类是基于贝塞尔曲线和一个 Path 对象的新的插值器。这个插值器指定在 1x1 方形上的运动曲线，拥有 (0,0) 和 (1,1) 两个锚点，并且使用构造器参数为指定的控制点。也可以在 XML 资源中定义路径插值器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">pathInterpolator</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:controlX1</span>=<span class="value">"0.4"</span></span><br><span class="line">    <span class="attribute">android:controlY1</span>=<span class="value">"0"</span></span><br><span class="line">    <span class="attribute">android:controlX2</span>=<span class="value">"1"</span></span><br><span class="line">    <span class="attribute">android:controlY2</span>=<span class="value">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 material design 规范中系统为 3 种基本曲线提供了 XML 资源。</p>
<ul>
<li><code>@interpolator/fast_out_linear_in.xml</code></li>
<li><code>@interpolator/fast_out_slow_in.xml</code></li>
<li><code>@interpolator/linear_out_slow_in.xml</code></li>
</ul>
<p>可以传递一个 PathInterpolator 对象到 Animator.setInterpolator() 方法。</p>
<p>ObjectAnimator 类有新的构造器来支持一次性使用2个或多个属性，与路径一起来推动坐标。例如，下面的动画会之气使用一个 Path 对象来推动视图的 X 和 Y 属性：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator mAnimator<span class="comment">;</span></span><br><span class="line">mAnimator = ObjectAnimator.ofFloat(view, View.X, View.Y, path)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">mAnimator.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画视图状态改变">动画视图状态改变</h2><p>StateListAnimator 类定义视图状态改变时运行的动画。下面的实例展示如何在 XML 资源中定义一个 StateListAnimator 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- animate the translationZ property of a view when pressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">selector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:state_pressed</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">objectAnimator</span> <span class="attribute">android:propertyName</span>=<span class="value">"translationZ"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"@android:integer/config_shortAnimTime"</span></span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"2dp"</span></span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- you could have other objectAnimator elements</span><br><span class="line">             here for "x" and "y", or other properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:state_enabled</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:state_pressed</span>=<span class="value">"false"</span></span><br><span class="line">    <span class="attribute">android:state_focused</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">objectAnimator</span> <span class="attribute">android:propertyName</span>=<span class="value">"translationZ"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"100"</span></span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"0"</span></span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要为视图关联自定义视图状态动画，需要在 XML 资源文件中使用 <code>selector</code> 元素来定义动画绘制器，并将它分配到视图的 <code>android:stateListAnimator</code> 属性。通过代码来分配一个状态列表动画绘制器到视图，则使用 AnimationInflater.loadStateListAnimator() 方法，分配动画绘制器到视图使用 View.setStateListAnimator() 方法。</p>
<p>当你的主题继承自 material 主题，按钮默认由 Z 动画。要禁用按钮的行为，需要设置 <code>android:stateListAnimatro</code> 属性为 <code>@null</code>。</p>
<p>AnimatedStateListDrawable 类可以创建图片用来显示关联视图的状态变化的动画。某些 Android 5.0 上的系统组件默认使用这些动画。下面的实例展示如何使用 XML 资源定义一个 AnimatedStateListDrawable 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animated-selector</span></span><br><span class="line">  <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 为每种状态提供不同的图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@+id/pressed"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableP"</span></span><br><span class="line">      <span class="attribute">android:state_pressed</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@+id/focused"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableF"</span></span><br><span class="line">      <span class="attribute">android:state_focused</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@id/default"</span></span><br><span class="line">      <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableD"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 指定转场效果 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">transition</span> <span class="attribute">android:fromId</span>=<span class="value">"@+id/default"</span> <span class="attribute">android:toId</span>=<span class="value">"@+id/pressed"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">animation-list</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:duration</span>=<span class="value">"15"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/dt1"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:duration</span>=<span class="value">"15"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/dt2"</span>/&gt;</span></span><br><span class="line">          ...</span><br><span class="line">      <span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">transition</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画矢量图片">动画矢量图片</h2><p>矢量图片在缩放过程中不会丢失清晰度。 AnimatedVectorDrawable 类定义了矢量图片的属性。</p>
<p>通常可以在三个 XML 文件中定义动画矢量图片：</p>
<ul>
<li>在 <code>res/drawable/</code> 中的使用 <code>&lt;vector&gt;</code> 元素定义矢量图片。</li>
<li>在 <code>res/drawable/</code> 中使用 <code>&lt;animated-vector&gt;</code> 元素来定义动画矢量图片。</li>
<li>在 <code>res/anim/</code> 中使用 <code>&lt;objectAnimator&gt;</code> 元素定义一个或多个对象的动画绘制器。</li>
</ul>
<p>动画矢量图片可以推动 <code>&lt;group&gt;</code> 和 <code>&lt;path&gt;</code> 元素的属性。 <code>&lt;group&gt;</code> 元素定义路径或者子组的集合， <code>&lt;path&gt;</code> 元素定义需要绘制的路径。</p>
<p>当你定义一个你需要动画的矢量图片时，使用 <code>android:name</code> 属性来为组和路径分配唯一的名称，这样就可以从动画器的定义中应用他们。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- res/drawable/vectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:height</span>=<span class="value">"64dp"</span></span><br><span class="line">    <span class="attribute">android:width</span>=<span class="value">"64dp"</span></span><br><span class="line">    <span class="attribute">android:viewportHeight</span>=<span class="value">"600"</span></span><br><span class="line">    <span class="attribute">android:viewportWidth</span>=<span class="value">"600"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">group</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"rotationGroup"</span></span><br><span class="line">        <span class="attribute">android:pivotX</span>=<span class="value">"300.0"</span></span><br><span class="line">        <span class="attribute">android:pivotY</span>=<span class="value">"300.0"</span></span><br><span class="line">        <span class="attribute">android:rotation</span>=<span class="value">"45.0"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">path</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"v"</span></span><br><span class="line">            <span class="attribute">android:fillColor</span>=<span class="value">"#000000"</span></span><br><span class="line">            <span class="attribute">android:pathData</span>=<span class="value">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在矢量图片中，动画矢量图片定义通过名称与组和路径相关联：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/animvectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animated-vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"><span class="attribute">android:drawable</span>=<span class="value">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">target</span></span><br><span class="line">      <span class="attribute">android:name</span>=<span class="value">"rotationGroup"</span></span><br><span class="line">      <span class="attribute">android:animation</span>=<span class="value">"@anim/rotation"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">target</span></span><br><span class="line">      <span class="attribute">android:name</span>=<span class="value">"v"</span></span><br><span class="line">      <span class="attribute">android:animation</span>=<span class="value">"@anim/path_morph"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动画定义为 ObjectAnimator 或者 AnimatorSet 对象。这个实例中的第一个动画绘制器将目标组旋转 360 度：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/rotation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">  <span class="attribute">android:duration</span>=<span class="value">"6000"</span></span><br><span class="line">  <span class="attribute">android:propertyName</span>=<span class="value">"rotation"</span></span><br><span class="line">  <span class="attribute">android:valueFrom</span>=<span class="value">"0"</span></span><br><span class="line">  <span class="attribute">android:valueTo</span>=<span class="value">"360"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第二个动画绘制器改变矢量图片的路径从一种形状到另一种。两条路径需要匹配改变：他们需要相同数量的命名，并且每个命令要有相同数量的参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/path_morph.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">      <span class="attribute">android:duration</span>=<span class="value">"3000"</span></span><br><span class="line">      <span class="attribute">android:propertyName</span>=<span class="value">"pathData"</span></span><br><span class="line">      <span class="attribute">android:valueFrom</span>=<span class="value">"M300,70 l 0,-70 70,70 0,0   -70,70z"</span></span><br><span class="line">      <span class="attribute">android:valueTo</span>=<span class="value">"M300,70 l 0,-70 70,0  0,140 -70,0 z"</span></span><br><span class="line">      <span class="attribute">android:valueType</span>=<span class="value">"pathType"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 AnimatedVectorDrawable 的 API 参考文档。</p>
<p>原文：<a href="https://developer.android.com/training/material/animations.html" target="_blank" rel="external">Defining Custom Animations</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 中的动画能够让应用程序给予用户对于动作的反馈，提供用户交互的视觉持续性。 Material 主题为按钮和活动转场效果提供默认的动画， Android 5.0 (API 21) 以上版本可以定制这些动画，并创建新的：</p>
<ul>
<li>触摸反馈</li>
<li>圆形波纹</li>
<li>活动转场效果</li>
<li>曲线移动</li>
<li>视图状态改变</li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="动画" scheme="http://linfuyan.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用图片]]></title>
    <link href="http://linfuyan.com/material-design-training/working-with-drawables/"/>
    <id>http://linfuyan.com/material-design-training/working-with-drawables/</id>
    <published>2015-10-24T05:00:00.000Z</published>
    <updated>2015-11-03T09:21:09.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>图片所具有的下面能力可以帮助你在应用程序中实现 material design。</p>
<ul>
<li>图片着色。</li>
<li>抽取主色彩。</li>
<li>矢量图片。</li>
</ul>
<p>这节课程教你如何在应用程序中使用这些特性。</p>
<a id="more"></a>
<h2 id="对图片资源进行着色">对图片资源进行着色</h2><p>在 Android 5.0 ( API 21) 及以上，你可以定义透明度对位图和 9 patch 图片进行着色。你可以使用颜色资源或者对应颜色资源的主题属性(如 <code>?android:attr/colorPrimary</code> )对他们进行着色。通常，你只需要一次创建这些资源并对他们自动着色来适应你的主题。</p>
<p>通过 setTint() 方法可以对 BitmapDrawable， NinePatchDrawable 或 VectorDrawable 对象应用着色。也可以在布局中使用 <code>android:tint</code> 和 <code>android:tintMode</code> 属性来设置着色的颜色和模式。</p>
<h2 id="从图片中抽取主色彩">从图片中抽取主色彩</h2><p>在 Android Support 库 r21 及以上版本中包含有 Palette 类，可以从一张图片中抽取主色彩。这个类可以抽取下面的突出色彩：</p>
<ul>
<li></li>
<li></li>
</ul>
<p>要抽取这些色彩，当你在加载图片时在后台线程里面传递 Bitmap 对象到 Palette.generate() 静态方法中。如果你没有使用线程，那边调用 Palette.generateAsync() 方法并提供一个监听器。</p>
<p>在 Palette 类中，使用获取方法来从图片获取主要色彩，如 <code>Palette.getVibrantColor</code> 。</p>
<p>在项目中使用 Palette 类时，需要添加下面的 Gradle 依赖到应用程序模块：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:palette-v7:21.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 API 参考中的 Palette 类。</p>
<h2 id="创建矢量图片">创建矢量图片</h2><p>在 Android 5.0 (API 21) 及以上，你可以定义矢量图片，这些图片在缩放过程中不会丢失清晰度。对应于每种屏幕密度需要一个位图文件，所有的屏幕密度仅需要一个矢量文件。要创建矢量图片，你需要在 XML 文件中的 <code>&lt;vector&gt;</code> 元素中定义形状细节。</p>
<p>下面的实例定义了一个心形的矢量图片：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- res/drawable/heart.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">  &lt;!<span class="attribute">--</span> <span class="attribute">intrinsic</span> <span class="attribute">size</span> <span class="attribute">of</span> <span class="attribute">the</span> <span class="attribute">drawable</span> <span class="attribute">--</span>&gt;</span></span><br><span class="line">  android:height="256dp"</span><br><span class="line">  android:width="256dp"</span><br><span class="line">  <span class="comment">&lt;!-- size of the virtual canvas --&gt;</span></span><br><span class="line">  android:viewportWidth="32"</span><br><span class="line">  android:viewportHeight="32"&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- draw a path --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">path</span> <span class="attribute">android:fillColor</span>=<span class="value">"#8fff"</span></span><br><span class="line">    <span class="attribute">android:pathData</span>=<span class="value">"M20.5,9.5</span><br><span class="line">                      c-1.955,0,-3.83,1.268,-4.5,3</span><br><span class="line">                      c-0.67,-1.732,-2.547,-3,-4.5,-3</span><br><span class="line">                      C8.957,9.5,7,11.432,7,14</span><br><span class="line">                      c0,3.53,3.793,6.257,9,11.5</span><br><span class="line">                      c5.207,-5.242,9,-7.97,9,-11.5</span><br><span class="line">                      C25,11.432,23.043,9.5,20.5,9.5z"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">vector</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>矢量图片在 Android 中表现为 VectorDrawable 对象。关于 <code>pathData</code> 语法的更多信息，可以查看 <a href="http://www.w3.org/TR/SVG11/paths.html#PathData" target="_blank" rel="external">SVG 路径</a>。矢量图片中动画属性相关的更多信息，可以查看<a href="">动画矢量图片</a>。</p>
<p>原文：<a href="https://developer.android.com/training/material/drawables.html" target="_blank" rel="external">Working with Drawables</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>图片所具有的下面能力可以帮助你在应用程序中实现 material design。</p>
<ul>
<li>图片着色。</li>
<li>抽取主色彩。</li>
<li>矢量图片。</li>
</ul>
<p>这节课程教你如何在应用程序中使用这些特性。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="图片" scheme="http://linfuyan.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义阴影与裁剪视图]]></title>
    <link href="http://linfuyan.com/material-design-training/defining-shadows-and-clipping-views/"/>
    <id>http://linfuyan.com/material-design-training/defining-shadows-and-clipping-views/</id>
    <published>2015-10-24T04:00:00.000Z</published>
    <updated>2015-11-03T09:13:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 为 UI 元素引入了海拔的概念。海拔能够帮助用户理解每个元素的相对重要程度，并关注正在运行的任务。</p>
<p>视图的海拔有 Z 属性来表示，决定它的阴影的视觉展示：拥有更高 Z 值的视图打造更大，更软的阴影。拥有更高 Z 值的视图会挡住低 Z 值的视图，视图的 Z 值多少并不影响视图的尺寸。</p>
<p>阴影由被抬起视图的父视图来绘制，并默认由父视图进行视图裁剪。</p>
<p>在某些动作中，当控件临时上升到其他普通视图之上时。海拔对于创建动画非常有用。</p>
<p>Material design 中海拔相关的更多信息，可以查看 <a href="http://www.google.com/design/spec/what-is-material/objects-in-3d-space.html" target="_blank" rel="external">3D 空间中的物体</a>。</p>
<a id="more"></a>
<h2 id="为视图设置海拔">为视图设置海拔</h2><p>视图的 Z 值有两个组件：</p>
<ul>
<li>海拔：静态组件。</li>
<li>变换：用于动画的动态组件。</li>
</ul>
<blockquote>
<p>Z = elevation + translationZ</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/shadows-depth.png" alt="不同视图海拔的阴影"></p>
<p>在布局定义中设置视图的海拔，使用 <code>android:elevation</code> 属性。在活动的代码中设置视图的海拔，使用 View.setElevation() 方法。</p>
<p>设置视图的变换使用 View.setTranslationZ() 方法。</p>
<p>新的 ViewPropertyAnimator.z() 和 ViewPropertyAnimator.translationZ() 方法使得视图海拔的动画变得简单。更多信息可以查看开发者指南中的 ViewPropertyAnimator 和 Property Animation。</p>
<p>你可以使用 StateListAnimator 来以声明的方式指定这些动画。当在状态的变化中出发动画时，这将非常有用，例如当用户按下按钮时。更多信息，可以查看 <a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="external">动画视图状态改变</a>。</p>
<p>测量 Z 值的单位是 dp。</p>
<h2 id="自定义视图阴影和轮廓">自定义视图阴影和轮廓</h2><p>视图背景图片的边沿决定了它的阴影的默认形状。轮廓代表了图形对象的外围形状并定义了触摸反馈的波纹区域。</p>
<p>假设下面的视图，定义了背景图片：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="property">id</span>=<span class="string">"@+id/myview"</span></span><br><span class="line">    ...</span><br><span class="line">    android:elevation=<span class="string">"2dp"</span></span><br><span class="line">    android:background=<span class="string">"@drawable/myrect"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>背景图片定义为具有圆角的矩形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myrect.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">shape</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">     <span class="attribute">android:shape</span>=<span class="value">"rectangle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">solid</span> <span class="attribute">android:color</span>=<span class="value">"#42000000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">corners</span> <span class="attribute">android:radius</span>=<span class="value">"5dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>视图打造了具有圆角的阴影，背景图片定义了视图的轮廓。</p>
<p>提供自定义的轮廓来覆盖视图阴影的默认形状。</p>
<p>在代码中为视图定义自定义的轮廓：</p>
<ol>
<li>继承 ViewOutlineProvider 类。</li>
<li>覆盖 getOutline() 方法。</li>
<li>通过 View.setOutlineProvider() 方法为视图设置新的轮廓提供者。</li>
</ol>
<p>使用 Outline 类中的方法可以来创建椭圆形或者带有圆角的矩形轮廓。视图默认的轮廓提供者从视图的背景中获取轮廓。要阻止视图生成阴影，只要将它的轮廓提供者设置为 <code>null</code> 就可以了。</p>
<h2 id="裁剪视图">裁剪视图</h2><p>裁剪视图让改变视图的形状变得简单。你可以通过裁剪视图让其与其他设计元素之间保持一致，也可以改变视图的形状来反应用户输入。通过 View.setClipToOutline() 方法或者 <code>android:clipToOutline</code> 属性来对视图的轮廓区域进行裁剪。只有矩形，圆形和圆角矩形轮廓支持裁剪，能否裁剪是由 Outline.canClip() 方法决定的。</p>
<p>要裁剪视图中图片的形状，需要将图片设置为视图的背景，并调用 View.setClipToOutline() 方法。</p>
<p>裁剪视图是一个代价昂贵的操作，因此不要对用于裁剪视图的形状做动画。要达到这样的效果，可以使用<br> <a href="https://developer.android.com/training/material/animations.html#Reveal" target="_blank" rel="external">Reveal Effect</a> 动画。</p>
<p> 原文：<a href="https://developer.android.com/training/material/shadows-clipping.html" target="_blank" rel="external">Defining Shadows and Clipping Views</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 为 UI 元素引入了海拔的概念。海拔能够帮助用户理解每个元素的相对重要程度，并关注正在运行的任务。</p>
<p>视图的海拔有 Z 属性来表示，决定它的阴影的视觉展示：拥有更高 Z 值的视图打造更大，更软的阴影。拥有更高 Z 值的视图会挡住低 Z 值的视图，视图的 Z 值多少并不影响视图的尺寸。</p>
<p>阴影由被抬起视图的父视图来绘制，并默认由父视图进行视图裁剪。</p>
<p>在某些动作中，当控件临时上升到其他普通视图之上时。海拔对于创建动画非常有用。</p>
<p>Material design 中海拔相关的更多信息，可以查看 <a href="http://www.google.com/design/spec/what-is-material/objects-in-3d-space.html">3D 空间中的物体</a>。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="视图" scheme="http://linfuyan.com/tags/%E8%A7%86%E5%9B%BE/"/>
    
      <category term="阴影" scheme="http://linfuyan.com/tags/%E9%98%B4%E5%BD%B1/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建列表和卡片]]></title>
    <link href="http://linfuyan.com/material-design-training/creating-lists-and-cards/"/>
    <id>http://linfuyan.com/material-design-training/creating-lists-and-cards/</id>
    <published>2015-10-24T03:00:00.000Z</published>
    <updated>2015-11-03T09:20:03.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>在应用程序中要创建具备 material design 风格的复杂列表和卡片，可以使用 RecyclerView 和 CardView 组件。</p>
<a id="more"></a>
<h2 id="创建列表">创建列表</h2><p>RecyclerView 组件是一个更加高级，更加灵活的 ListView 版本。这个组件是这样一个容器，可以用来显示大量的数据集，并且通过维护有限数量的视图来非常高效的滚动。当你拥有大量的数据集，且其中的元素基于用户操作或者网络数据而在运行时改变时，使用 RecyclerView。</p>
<p>RecyclerView 通过提供以下两点来简化显示并处理大数据集：</p>
<ul>
<li>布局管理器来定位数据项</li>
<li>为公共数据项的操作定义默认动画，如删除或者新增数据项</li>
</ul>
<p>你可以灵活地为 RecyclerView 组件定义自定义的布局管理器和动画。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/RecyclerView.png" alt="RecyclerView 组件"></p>
<p>使用 RecyclerView 组件时，需要制定一个适配器和布局管理器。继承 <code>RecyclerView.Adapter</code> 类来创建一个适配器。具体的实现则依赖于特定的数据集和视图的类型。更多信息，可以查看下面的实例。</p>
<p><strong>布局管理器</strong>在 RecyclerView 中定位项的视图，并决定当项的视图对用户不可见后何时被复用。要复用(或者回收)一个视图，布局管理器会要求适配从数据集中用一个不同的元素来替换视图的内容。用这种方式来复用视图可以避免由于不必要的视图创建和执行昂贵的 <code>findViewById()</code> 操作，从而提升性能。</p>
<p>RecyclerView 内置了下面的布局管理器：</p>
<ul>
<li>LinearLayoutManager：在垂直或者水平滚动列表中显示项。</li>
<li>GridLayoutManager：通过网格显示项。</li>
<li>StaggeredGridLayout：在错落的网格中显示项。</li>
</ul>
<p>继承 RecyclerView.LayoutManager 类来创建自定义的布局管理器。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/list_mail.png" alt="Lists with RecyclerView"></p>
<h3 id="动画">动画</h3><p>在 RecyclerView 中添加和移除项的动画是默认支持的。要自定义这些动画，继承 RecyclerView.ItemAnimator 类并使用 RecyclerView.setItemAnimator() 方法。</p>
<h3 id="实例">实例</h3><p>下面的代码实例展示如何添加 RecyclerView 到布局：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A RecyclerView with some commonly used attributes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">  <span class="attribute">android:id</span>=<span class="value">"@+id/my_recycler_view"</span></span><br><span class="line">  <span class="attribute">android:scrollbars</span>=<span class="value">"vertical"</span></span><br><span class="line">  <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">  <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦添加一个 RecyclerView 组件到布局中，获得一个对象的句柄，并连接到布局管理器，然后关联一个需要显示的数据的适配器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span> mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">Adapter</span> mAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">LayoutManager</span> mLayoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.my_activity);</span><br><span class="line">        mRecyclerView = (<span class="type">RecyclerView</span>) findViewById(<span class="type">R</span>.id.my_recycler_view);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果你已知 RecyclerView 的内容改变不会改变布局尺寸，使用这个设置可以提升效率。</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线性布局管理器</span></span><br><span class="line">        mLayoutManager = <span class="keyword">new</span> <span class="type">LinearLayoutManager</span>(<span class="keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 制定适配器</span></span><br><span class="line">        mAdapter = <span class="keyword">new</span> <span class="type">MyAdapter</span>(myDataset);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适配器提供对数据集中数据项的访问，为数据项创建视图，并且当原始数据项不再可见时使用新的数据项来替换这些视图的内容。下面的代码实例展示一个有字符串数组组成且使用 TextView 控件显示的简单数据集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mDataset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个数据项的视图提供一个引用。复杂的数据项可能需要多余一个视图，并且在一个 view holder中为每个数据项的所有视图进行访问。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个实例中，每个数据项是仅仅是一个字符串</span></span><br><span class="line">        <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">            mTextView = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供一个合适的构造方法(这取决于数据集类型)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(String[] myDataset)</span> </span>&#123;</span><br><span class="line">        mDataset = myDataset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的视图(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyAdapter.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,</span><br><span class="line">                                                   <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建视图</span></span><br><span class="line">        View v = LayoutInflater.from(parent.getContext())</span><br><span class="line">                               .inflate(R.layout.my_text_view, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置视图的尺寸，外边距，内边距和布局参数</span></span><br><span class="line">        ...</span><br><span class="line">        ViewHolder vh = <span class="keyword">new</span> ViewHolder(v);</span><br><span class="line">        <span class="keyword">return</span> vh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换视图的内容(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// - 从数据集中获取当前位置的元素</span></span><br><span class="line">        <span class="comment">// - 用该元素替换视图的内容</span></span><br><span class="line">        holder.mTextView.setText(mDataset[position]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据集的大小(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDataset.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建卡片">创建卡片</h2><p>CardView 集成自 FrameLayout 类，能够使显示在卡片中的信息在多个平台上拥有一致的外观。 CardView 控件可以拥有阴影和圆角。</p>
<p>使用 <code>card_view:cardElevation</code> 属性来创建带圆角的卡片。 CardView 在 Android 5.0 ( API 21) 及以上版本使用真正的海拔和动态阴影，在早先的版本中则使用可编程的阴影实现。更多信息，查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
<p>使用下面的属性来自定义 CardView 组件的外观：</p>
<ul>
<li>在布局中使用 <code>card_view:cardCornerRadius</code> 属性来设置圆角半径。</li>
<li>在代码中使用 <code>CardView.setRadius</code> 方法来设置圆角半径。</li>
<li>使用 <code>card_view:cardBackgroundColor</code> 属性来设置卡片的背景色。</li>
</ul>
<p>下面的代码实例展示如何在布局中包含 CardView 控件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">xmlns:card_view</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- A CardView that contains a TextView --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v7.widget.CardView</span></span><br><span class="line">        <span class="attribute">xmlns:card_view</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/card_view"</span></span><br><span class="line">        <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"200dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"200dp"</span></span><br><span class="line">        <span class="attribute">card_view:cardCornerRadius</span>=<span class="value">"4dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/info_text"</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，查看 CardView 的 API 引用。</p>
<h2 id="添加依赖">添加依赖</h2><p>RecyclerView 和 CardView 控件是 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Supprot V7 兼容包</a>中的一部分。要在项目中使用这些组件，需要添加下面的 Gradle 依赖到应用模块中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>在应用程序中要创建具备 material design 风格的复杂列表和卡片，可以使用 RecyclerView 和 CardView 组件。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="CardView" scheme="http://linfuyan.com/tags/CardView/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="RecyclerView" scheme="http://linfuyan.com/tags/RecyclerView/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Material 主题]]></title>
    <link href="http://linfuyan.com/material-design-training/using-the-material-theme/"/>
    <id>http://linfuyan.com/material-design-training/using-the-material-theme/</id>
    <published>2015-10-24T02:00:35.000Z</published>
    <updated>2015-11-03T09:26:29.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>新的 material 主题提供：</p>
<ul>
<li>可以设置调色板的系统组件。</li>
<li>系统组件的触摸反馈动画。</li>
<li>活动转场效果动画。</li>
</ul>
<a id="more"></a>
<p>使用调色板，你可以根据自己的品牌标识来自定义 material 主题的外观。可以通过主题属性来为状态栏和 action bar 着色，如下图所示。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/ThemeColors.png" alt="自定义 material 主题"></p>
<p>系统组件拥有新的设计以及触摸反馈动画。你可以自定义应用程序的调色板，触摸反馈动画以及活动转场效果。</p>
<p>Material 主题定义如下：</p>
<ul>
<li><code>@android:style/Theme.Material</code>: 深色版本</li>
<li><code>@android:style/Theme.Material.Light</code>: 浅色版本</li>
<li><code>@android:style/Theme.Material.Light.DarkActionBar</code></li>
</ul>
<p>可使用的 material 风格列表，可以查看 R.style 的 API 引用。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/MaterialDark.png" alt="图1 深色 material 主题"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/MaterialLight.png" alt="图2 浅色 material 主题"></p>
<blockquote>
<p><strong>注意：</strong> Material 主题仅仅在 Android 5.0 (API 21) 及以上系统版本可用。 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Support V7 兼容包</a> 为一些组件提供了具备 material 设计风格的主题，以及自定义调色板的支持。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
</blockquote>
<h2 id="自定义调色板">自定义调色板</h2><p>为了自定义主题的基本颜色来适应自己的品牌，需要继承 material 主题，并使用主题属性来定义自己的自定义颜色。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  &lt;!<span class="comment">-- inherit from the material theme --&gt;</span></span><br><span class="line">  &lt;style <span class="property">name</span>=<span class="string">"AppTheme"</span> parent=<span class="string">"android:Theme.Material"</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">-- Main theme colors --&gt;</span></span><br><span class="line">    &lt;!<span class="comment">--   your app branding color for the app bar --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorPrimary"</span>&gt;@color/primary&lt;/<span class="property">item</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">--   darker variant for the status bar and contextual app bars --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;@color/primary_dark&lt;/<span class="property">item</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">--   theme UI controls like checkboxes and text fields --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorAccent"</span>&gt;@color/accent&lt;/<span class="property">item</span>&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<h2 id="自定义状态栏">自定义状态栏</h2><p>Material 主题可以很方便的自定义状态栏，因此你可以指定一个颜色来适应自己的品牌并提供足够的对比来显示白色的状态栏图标。继承 material 主题，并且使用 <code>android:statusBarColr</code> 属性来为状态来设置自定义颜色。默认情况下， <code>android:statusBarColor</code> 继承 <code>android:colorPrimaryDark</code> 的值。</p>
<p>你也可以自己在状态栏上进行绘制。例如，你想要在一张照片上显示透明的状态栏，并且使用微薄的深色渐变来确保白色的状态栏图标可见。要实现这个功能，将 <code>android.statusBarColor</code> 属性设置为 <code>@android:color/transparent</code> 并且根据要求设置窗口标识。可以使用 Window.setStatusBarColor() 方法来设置动画或者淡出。</p>
<blockquote>
<p><strong>注意</strong>：状态栏大部分情况下应该有区别于主要工具栏的明显轮廓，除非你需要在工具栏后显示丰富的意象或者媒体内容，并且所使用的渐变需要保证图标依然可见。</p>
</blockquote>
<p>当你自定义导航栏和状态栏时，你可以使两者都是透明的或者仅仅修改状态栏。其他情况下导航栏需要保持黑色。</p>
<h2 id="主题个性视图">主题个性视图</h2><p>定义在 XML 布局中的元素可以指定 <code>android:theme</code> 属性，用来引用一个主题资源。这个属性为元素和其子元素修改主题，当要替换界面的某个部分的主题调色板时，这是很有用的。</p>
<p>原文：<a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="external">Using the Material Theme</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>新的 material 主题提供：</p>
<ul>
<li>可以设置调色板的系统组件。</li>
<li>系统组件的触摸反馈动画。</li>
<li>活动转场效果动画。</li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="主题" scheme="http://linfuyan.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[准备开始]]></title>
    <link href="http://linfuyan.com/material-design-training/get-started/"/>
    <id>http://linfuyan.com/material-design-training/get-started/</id>
    <published>2015-10-24T01:00:01.000Z</published>
    <updated>2015-11-03T09:09:23.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>创建具有 material design 特性的应用程序，步骤如下：</p>
<ol>
<li>审查 <a href="">material design 规范</a>。</li>
<li>应用 material <strong>主题</strong>到应用程序。</li>
<li>根据 material design 指南创建<strong>布局</strong>。</li>
<li>确定视图的<strong>海拔</strong>来打造阴影。</li>
<li>为列表和卡片使用系统<strong>组件</strong>。</li>
<li>在应用程序中自定义<strong>动画</strong>。</li>
</ol>
<a id="more"></a>
<h3 id="维持向后兼容">维持向后兼容</h3><p>你可以为应用程序添加许多 material design 特性，同时对低于 Android 5.0 的版本保持兼容。更多信息，可以查看 <a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
<h3 id="升级应用程序使之具备_material_design">升级应用程序使之具备 material design</h3><p>要升级已经存在的应用程序来包含 material design，根据 material design 指南来升级布局。同时确保包含深度，触摸反馈和动画。</p>
<h3 id="创建具备_material_design_的新应用程序">创建具备 material design 的新应用程序</h3><p>如果要创建一个具备 material design 特性的应用程序，<a href="http://www.google.com/design/spec" target="_blank" rel="external">material design 指南</a> 提供了一个紧密结合的设计框架。按照这些指南，使用 Android 框架中的新特性来设计和开发应用程序。</p>
<h2 id="应用_material_主题">应用 material 主题</h2><p>要应用 material 主要到应用程序中，需要指定一种风格继承自 <code>android:Theme.Material</code> :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/values/styles.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- your theme inherits from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"android:Theme.Material"</span>&gt;</span><span class="css"></span><br><span class="line">    &lt;!<span class="tag">--</span> <span class="tag">theme</span> <span class="tag">customizations</span> <span class="tag">--</span>&gt;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Material 主题提供了升级过的系统组件来为触摸反馈和活动的转场效果设置调色和默认动画。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="external">使用 Material 主题</a>。</p>
<h2 id="设计布局">设计布局</h2><p>除了应用和自定义 material 主题之外，布局需要与 material design 指南保持一致。在设计布局时，需要注意下面几点：</p>
<ul>
<li>基线表格</li>
<li>注解行</li>
<li>空白</li>
<li>触摸目标尺寸</li>
<li>布局结构</li>
</ul>
<h2 id="指定视图的海拔">指定视图的海拔</h2><p>视图可以打造阴影，视图的海拔值决定它的阴影尺寸以及它的绘制顺序。在布局中使用 <code>android:elevation</code> 属性来设置视图的海拔。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="property">id</span>=<span class="string">"@+id/my_textview"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="type">text</span>=<span class="string">"@string/next"</span></span><br><span class="line">    android:background=<span class="string">"@color/white"</span></span><br><span class="line">    android:elevation=<span class="string">"5dp"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>新的 <code>translationZ</code> 属性可以用来创建动画来反映视图海拔的临时变化。当<a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="external">响应触摸事件</a>时，海拔的改变会非常有用。</p>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="external">定义阴影及裁剪视图</a>。</p>
<h2 id="创建列表和卡片">创建列表和卡片</h2><p>RecyclerView 是一个更加具有可插拔性的 ListView 版本，支持不同的布局类型，提供性能改进。 CardView 可以为不同的应用程序中在卡片内显示的信息提供一致的外观。下面的实例代码展示如何在布局中包含 CardView 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.CardView</span></span><br><span class="line">    android:id=<span class="string">"@+id/card_view"</span></span><br><span class="line">    android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"200dp"</span></span><br><span class="line">    card_view:cardCornerRadius=<span class="string">"3dp"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.CardView</span>&gt;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="external">创建列表和卡片</a>。</p>
<h2 id="自定义动画">自定义动画</h2><p>Android 5.0 (API 21) 包含用来在应用程序中创建自定义动画的新的 API 。例如，你可以在一个活动中启用活动的转场效果并定义一个退出的转场效果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// enable transitions</span></span><br><span class="line">        getWindow().requestFeature(<span class="type">Window</span>.<span class="type">FEATURE_CONTENT_TRANSITIONS</span>);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_my);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onSomeButtonClicked(<span class="type">View</span> view) &#123;</span><br><span class="line">        getWindow().setExitTransition(<span class="keyword">new</span> <span class="type">Explode</span>());</span><br><span class="line">        <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="keyword">this</span>, <span class="type">MyOtherActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">        startActivity(intent,</span><br><span class="line">                      <span class="type">ActivityOptions</span></span><br><span class="line">                          .makeSceneTransitionAnimation(<span class="keyword">this</span>).toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你从这个活动启动另外一个活动时，退场效果将会被激活。</p>
<p>可以查看<a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="external">定义自定义动画</a>来学些更多新的动画 API 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>创建具有 material design 特性的应用程序，步骤如下：</p>
<ol>
<li>审查 <a href="">material design 规范</a>。</li>
<li>应用 material <strong>主题</strong>到应用程序。</li>
<li>根据 material design 指南创建<strong>布局</strong>。</li>
<li>确定视图的<strong>海拔</strong>来打造阴影。</li>
<li>为列表和卡片使用系统<strong>组件</strong>。</li>
<li>在应用程序中自定义<strong>动画</strong>。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Material Design 概览]]></title>
    <link href="http://linfuyan.com/material-design-training/training-index/"/>
    <id>http://linfuyan.com/material-design-training/training-index/</id>
    <published>2015-10-24T00:00:35.000Z</published>
    <updated>2015-11-03T09:18:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 是一种为视觉，动作和交互而设计的规范，易于理解，跨平台、跨设备。要在 Android 应用程序中使用 material design，需要参照 [material design 规范] 中描述的指南，并使用 Android 5.0 ( API 21) 上的新组件和功能。</p>
<a id="more"></a>
<p>这个课程展示如何通过下面的元素来创建具备 material design 的应用程序。</p>
<ul>
<li>Material 主题</li>
<li>列表及卡片组件</li>
<li>自定义阴影和视图裁剪</li>
<li>矢量图片</li>
<li>自定义动画</li>
</ul>
<p>这个课程同时讲授在你的应用中使用 material design 时如何对低于 Android 5.0 (API 21) 版本进行兼容。</p>
<h2 id="课程">课程</h2><h3 id="准备开始"><a href="http://www.linfuyan.com/material-design-training/get-started/" target="_blank" rel="external">准备开始</a></h3><p>学习如何将应用程序升级到使用 material design。</p>
<h3 id="使用_Material_主题"><a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="external">使用 Material 主题</a></h3><p>学习如何应用 material design 样式到应用程序。</p>
<h3 id="创建列表和卡片"><a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="external">创建列表和卡片</a></h3><p>学习如何使用系统组件来创建具有统一观感的列表和卡片。</p>
<h3 id="定义阴影和裁剪视图"><a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="external">定义阴影和裁剪视图</a></h3><p>学习如何设置视图的海拔来创建自定义阴影及如何裁剪视图。</p>
<h3 id="使用图片"><a href="http://www.linfuyan.com/material-design-training/working-with-drawables/" target="_blank" rel="external">使用图片</a></h3><p>学习如何创建矢量图片及如何给图片资源着色。</p>
<h3 id="定义自定义动画"><a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="external">定义自定义动画</a></h3><p>学习如何创建视图的自定义动画以及具有共享元素的活动转场效果。</p>
<h3 id="保持兼容性"><a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a></h3><p>学习如何对低于 Android 5.0 的系统维持兼容性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 是一种为视觉，动作和交互而设计的规范，易于理解，跨平台、跨设备。要在 Android 应用程序中使用 material design，需要参照 [material design 规范] 中描述的指南，并使用 Android 5.0 ( API 21) 上的新组件和功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="概览" scheme="http://linfuyan.com/tags/%E6%A6%82%E8%A7%88/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用 Git 命令使用教程]]></title>
    <link href="http://linfuyan.com/git-cmd-user-guide/"/>
    <id>http://linfuyan.com/git-cmd-user-guide/</id>
    <published>2015-10-14T02:00:00.000Z</published>
    <updated>2015-10-16T04:01:02.000Z</updated>
    <content type="html"><![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>
<a id="more"></a>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-cmd-user-guide.png" alt="常用 Git 命令使用教程"></p>
<h2 id="Git_配置">Git 配置</h2><p>1. 在安装完成 Git 后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱。</p>
<p>设置的主要命令是 <code>git config</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"your name"</span>  	<span class="comment">// 设置全局用户名</span></span><br><span class="line">git config --global user<span class="class">.email</span> <span class="string">"your email"</span>	<span class="comment">// 设置邮箱</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>--global</code> 指定为全局配置，不使用该参数，则为当前所在仓库配置。</p>
<p>2. 除了用户名、邮箱之外，还有很多的配置可以用来自定义 Git，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="attribute">color</span><span class="class">.ui</span> true		<span class="comment">// 让 Git 显示不同的颜色</span></span><br><span class="line">git config core<span class="class">.ignorecase</span> true			<span class="comment">// 让 Git 对仓库中的文件大小写敏感</span></span><br></pre></td></tr></table></figure>
<p>3. 查看所有的已经做出的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-config.gif" alt="git config"></p>
<h2 id="基础操作">基础操作</h2><h3 id="创建_Git_版本库">创建 Git 版本库</h3><p>在本地创建 Git 版本库，需要使用 <code>git init</code> 命令。</p>
<p>首先，你需要新建一个存放版本库的目录，然后进入到该目录所在路径，然后执行：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> init</span><br></pre></td></tr></table></figure>
<p>然后查看目录结构中，就可以看到包含有 <code>.git</code> 子目录，这就说明创建版本库成功了。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-init.gif" alt="git init"></p>
<h3 id="将文件添加到版本库">将文件添加到版本库</h3><p>要将一个文件纳入到版本库管理，首先要将其添加到暂存区(这里不做深入介绍)，然后才能提交到仓库中。</p>
<p>1. 将文件添加到暂存区，使用的是 <code>git add</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> Readme.md	<span class="comment">	// 添加单个文件到暂存区</span></span><br><span class="line">git <span class="built_in">add</span> .			<span class="comment">	// 将当前目录下所有修改添加到暂存区，除按照规则忽略的之外</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边空文件夹是不会被添加到暂存区中的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-add.gif" alt="git add"></p>
<p>2. 将暂存区中的文件，提交到仓库中。需要使用 <code>git commit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">commit</span>		// 如果暂存区有文件，则将其中的文件提交到仓库</span><br><span class="line">git <span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">'your comments'</span> 		// 带评论提交，用于说明提交内容、变更、作用等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边直接用 <code>git commit</code> 提交，会先弹出添加评论的页面。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-commit.gif" alt="git commit"></p>
<h3 id="查看仓库的状态">查看仓库的状态</h3><p>不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">status</span></span><br></pre></td></tr></table></figure>
<p>来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，我使用最多的一个命令。</p>
<h3 id="查看仓库中的具体修改">查看仓库中的具体修改</h3><p>很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code> 来查看具体的修改内容。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff	<span class="comment">// 查看版本库中所有的改动</span></span><br><span class="line">git diff Readme<span class="class">.md</span>		<span class="comment">// 查看具体文件的改动</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-diff.gif" alt="git diff"></p>
<h3 id="查看提交历史记录">查看提交历史记录</h3><p>有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">	// 显示所有提交的历史记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline	// 单行显示提交历史记录的内容</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-log.gif" alt="git log"></p>
<h3 id="版本回退">版本回退</h3><p>有了 <code>git log</code> 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard HEAD^		// 回退到上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD^^		// 回退到上上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 'commit_id'	// 会退到 commit_id 指定的提交版本</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-1.gif" alt="git reset --hard"></p>
<h3 id="回到未来的某个提交">回到未来的某个提交</h3><p>当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。</p>
<p>因此，想要回到未来的某个提交，先通过 <code>git reflog</code> 从历史命令中找到想要回到的提交版本的 ID，然后通过 <code>git reset --hard</code> 来切换。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git <span class="keyword">reset</span> --hard <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reflog.gif" alt="git reflog"></p>
<h3 id="撤销修改">撤销修改</h3><p>撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。</p>
<p>1. 丢弃工作区中文件的修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Readme<span class="class">.md</span>	<span class="comment">// 如果 Readme.md 文件在工作区，则丢弃其修改</span></span><br><span class="line">git checkout -- .			<span class="comment">// 丢弃当前目录下所有工作区中文件的修改</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-checkout-1.gif" alt="git checkout --"></p>
<p>2. 丢弃已经进入暂存区的修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="keyword">HEAD</span> Readme.md 	// 将 Readme.md 恢复到 <span class="keyword">HEAD</span> 提交版本的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-head.gif" alt="git reset HEAD"></p>
<h3 id="删除文件">删除文件</h3><p>在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Readme<span class="class">.md</span> 	<span class="comment">// 删除已经被提交过的 Readme.md</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-rm.gif" alt="git rm"></p>
<p><strong><code>git rm</code> 与 先 rm 然后 <code>git add</code> 的区别</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/rm-and-git-add.gif" alt="rm and git add"></p>
<p>更详细的可以参考：<a href="http://yang3wei.github.io/blog/2013/02/03/git-rm-he-rm-de-qu-bie/" target="_blank" rel="external">“git rm” 和 “rm” 的区别</a></p>
<blockquote>
<p>注意：上图中的结果是在 git 1.9.1 版本上的操作。在 git 2.0 以上两者没有区别了。</p>
</blockquote>
<h2 id="分支管理">分支管理</h2><p>分支是版本控制系统中很重要的一个概念，在 Git 中新建、合并等分支的操作非常轻量便捷，因此我们会很经常的用到。</p>
<h3 id="查看分支">查看分支</h3><p>查看分支使用 <code>git branch</code>：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch		<span class="comment">// 查看本地分支信息</span></span><br><span class="line">git branch -v 	<span class="comment">// 查看相对详细的本地分支信息</span></span><br><span class="line">git branch -av 	<span class="comment">// 查看包括远程仓库在内的分支信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 <code>git branch</code> 的输出内容中，有一个分支，前面带有 <code>*</code> 号，这标识我们当前所在的分支。</p>
</blockquote>
<h3 id="创建分支">创建分支</h3><p>当我们要修复一个 Bug，或者开发一个新特性，甚至是在初学的时候怕打乱原来的代码，都可以新建一个分支来避免对原来代码的影响。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">dev</span>	<span class="comment">// 新建一个名称为 dev 的分支</span></span><br></pre></td></tr></table></figure>
<h3 id="切换分支">切换分支</h3><p>当我们创建完分支以后，我们需要切换到新建的分支，否则，所有的修改，还是在原来的分支上。事实上，所有的改动，只能影响到当前所在的分支。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">dev</span>	<span class="comment">// 新建完 dev 分支以后，通过该命令切换到 dev 分支</span></span><br></pre></td></tr></table></figure>
<h3 id="创建并切换分支">创建并切换分支</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="tag">b</span> dev		<span class="comment">// 新建 dev 分支，并切换到该分支上</span></span><br></pre></td></tr></table></figure>
<p>这个命令合并了前两个独立的命令，平常使用中一般这样使用。</p>
<h3 id="合并分支">合并分支</h3><p>当我们修复完成一个 Bug，或者开发完成一个新特性，我们就会把相关的 Bug 或者 特性的上修改合并回原来的主分支上，这时候就需要 <code>git merge</code> 来做分支的合并。</p>
<p>首先需要切换回最终要合并到的分支，如 <code>master</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master	<span class="comment">	// 切换回 master 分支</span></span><br><span class="line">git <span class="built_in">merge</span> dev		<span class="comment">	// 将 dev 分钟中的修改合并回 master 分支</span></span><br></pre></td></tr></table></figure>
<p>合并回主分支的时候，后面可能会面临到冲突的问题。冲突的解决暂不在这里说明。</p>
<h3 id="删除分支">删除分支</h3><p>当之前创建的分支，完成了它的使命，如 Bug 修复完，分支合并以后，这个分支就不在需要了，就可以删除它。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">dev</span>		<span class="comment">// 删除 dev 分支</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库">远程仓库</h2><p>上面的所有命令都是针对本地仓库的操作。当我们希望多个人来协作时，会将代码发布到一个统一的远程仓库，然后多个人在本地操作以后，在推送到远程仓库。其他人协作时，需要先同步远程仓库的内容，再推送自己的修改。</p>
<h3 id="从远程仓库克隆">从远程仓库克隆</h3><p>如果你本地没有仓库，希望从已有的远程仓库上复制一份代码，那么你需要 <code>git clone</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/git/git.git 	// 通过 https 协议，克隆 Github 上 git 仓库的源码</span></span><br><span class="line">git clone linfuyan<span class="annotation">@github</span>.com<span class="regexp">/git/</span>git.git	<span class="comment">// 通过 ssh 协议，克隆 Github 上 git 仓库的源码</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git clone</code> 后面的仓库地址，可以支持多种协议，如 https， ssh 等。</p>
</blockquote>
<h3 id="添加远程仓库">添加远程仓库</h3><p>如果你已经有了一个本地仓库，如之前创建的 <code>git-guide</code>，然后你打算将它发布到远程，供其他人协作。那么使用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin your_remote_git_repo	<span class="comment">	// 为本地仓库添加远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="推送本地的内容到远程仓库">推送本地的内容到远程仓库</h3><p>当本地仓库中，代码完成提交，就需要将代码等推送到远程仓库，这样其他协作人员可以从远程仓库同步内容。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> -u origin master <span class="comment">// 第一次推送时使用，可以简化后面的推送或者拉取命令使用</span></span><br><span class="line">git <span class="keyword">push</span> origin master	<span class="comment">// 将本地 master 分支推送到 origin 远程分支</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code> 参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。</p>
</blockquote>
<h3 id="从远程仓库获取最新内容">从远程仓库获取最新内容</h3><p>在多人协作过程中，当自己完成了本地仓库中的提交，想要向远程仓库推送前，需要先获取到远程仓库的最新内容。</p>
<p>可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> fetch origin master	</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p><code>git fetch</code> 和 <code>git pull</code> 之间的区别：</p>
<ol>
<li><code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li><code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
</ol>
<blockquote>
<p>注意：建议多使用 <code>git fetch</code>。</p>
</blockquote>
<h3 id="查看远程仓库信息">查看远程仓库信息</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="attr_selector">[-v]</span>		<span class="comment">// 显示远程仓库信息</span></span><br></pre></td></tr></table></figure>
<h3 id="建立本地分支和远程分支的关联">建立本地分支和远程分支的关联</h3><p>在本地仓库中的分支和远程仓库中的分支是对应的。一般情况下，远程仓库中的分支名称和本地仓库中的分支名称是一致的。</p>
<p>有的时候，我们会需要指定本地分支与远程分支的关联。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream <span class="string">'local_branch'</span> origin/remote_branch</span><br></pre></td></tr></table></figure>
<h3 id="修改本地仓库对应的远程仓库地址">修改本地仓库对应的远程仓库地址</h3><p>当远程的仓库地址发生变化时，需要修改本地仓库对应的远程仓库的地址。主要应用在<a href="http://blog.csdn.net/hongshan50/article/details/23663043" target="_blank" rel="external">工程迁移</a>过程中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="operator"><span class="keyword">set</span>-<span class="keyword">url</span> origin <span class="keyword">url</span></span></span><br></pre></td></tr></table></figure>
<h2 id="标签管理">标签管理</h2><p>在项目开发过程中，当一个版本发布完成时，是需要对代码打上标签，便于后续检索。获取处于其他的原因，需要对某个提交打上特定的标签。</p>
<h3 id="创建标签">创建标签</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="tag">a</span> <span class="string">'tagname'</span> -m <span class="string">'comment'</span> <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 参数指定标签名， <code>-m</code> 添加备注信息， ‘commit_id’ 指定打标签的提交。</p>
<h3 id="查看所有标签">查看所有标签</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">tag</span>		<span class="comment">// 查看本地仓库中的所有标签</span></span><br></pre></td></tr></table></figure>
<h3 id="查看具体标签信息">查看具体标签信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> shwo tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除本地标签">删除本地标签</h3><p>如果打的标签出错，或者不在需要某个标签，则可以删除它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="operator">-d</span> tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除远程标签">删除远程标签</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/tagname</span></span><br></pre></td></tr></table></figure>
<h3 id="推送标签到远程仓库">推送标签到远程仓库</h3><p>打完标签以后，有需要推送到远程仓库。</p>
<p>1. 推送单个标签到远程仓库</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">git</span> <span class="keyword">push </span>origin tagname</span><br></pre></td></tr></table></figure>
<p>2. 一次性推送所有标签到远程仓库。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="comment">--tags</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶操作">进阶操作</h2><h3 id="临时保存修改">临时保存修改</h3><p>在执行很多的 Git 操作的时候，是需要保持当前操作的仓库/分支处于 clean 状态，及没有未提交的修改。如 <code>git pull</code>， <code>git merge</code> 等等，如果有未提交的修改，这些将无法操作。</p>
<p>但是做这些事情的时候，你可能修改了比较多的代码，却又不想丢弃它。那么，你需要把这些修改临时保存起来，这就需要用到 <code>git stash</code>。</p>
<p>1. <strong>临时保存修改</strong>，这样仓库就可以回到 clean 状态。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  stash		<span class="comment">// 保存本地仓库中的临时修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以多次的 <code>git stash</code> 来保存不同的临时修改。</p>
</blockquote>
<p>2. <strong>查看临时保存</strong>。当你临时保存以后，后面还是要取回来的，那它们在哪里呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">list</span>	<span class="comment">// 显示所有临时修改</span></span><br></pre></td></tr></table></figure>
<p>3. 当我们处理完其他操作时，想要恢复临时保存的修改。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash apply		<span class="comment">// 恢复所有保存的临时修改</span></span><br><span class="line">git stash <span class="keyword">pop</span>		<span class="comment">// 恢复最近一次保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>4. 或者，我们后面觉得临时保存不想要了，那可以丢弃它。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">clear</span>	<span class="comment">	// 丢弃所有保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>这些是我目前在项目中经常会用到的操作，这里整理下来，可以作为一个手册。对于 Git 的理解或者更多的解释，并不在这里体现。大家可以参考其他更多的资料。</p>
<p>更多阅读：</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a><br><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="external">Git Community Book 中文版</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4233881.html" target="_blank" rel="external">Git 对象模型</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4235448.html" target="_blank" rel="external">探索 .git 目录</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://linfuyan.com/tags/Git/"/>
    
      <category term="命令" scheme="http://linfuyan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Git/"/>
    
  </entry>
  
</feed>
