<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[悠城札记 - 关注但不限于 Android/iOS/nodejs 的 hexo 博客]]></title>
  <subtitle><![CDATA[关注但不限于 Android、iOS、nodejs]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linfuyan.com/"/>
  <updated>2015-10-16T04:01:02.000Z</updated>
  <id>http://linfuyan.com/</id>
  
  <author>
    <name><![CDATA[linfuyan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常用 Git 命令使用教程]]></title>
    <link href="http://linfuyan.com/git-cmd-user-guide/"/>
    <id>http://linfuyan.com/git-cmd-user-guide/</id>
    <published>2015-10-14T02:00:00.000Z</published>
    <updated>2015-10-16T04:01:02.000Z</updated>
    <content type="html"><![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>
<a id="more"></a>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-cmd-user-guide.png" alt="常用 Git 命令使用教程"></p>
<h2 id="Git_配置">Git 配置</h2><p>1. 在安装完成 Git 后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱。</p>
<p>设置的主要命令是 <code>git config</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"your name"</span>  	<span class="comment">// 设置全局用户名</span></span><br><span class="line">git config --global user<span class="class">.email</span> <span class="string">"your email"</span>	<span class="comment">// 设置邮箱</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>--global</code> 指定为全局配置，不使用该参数，则为当前所在仓库配置。</p>
<p>2. 除了用户名、邮箱之外，还有很多的配置可以用来自定义 Git，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="attribute">color</span><span class="class">.ui</span> true		<span class="comment">// 让 Git 显示不同的颜色</span></span><br><span class="line">git config core<span class="class">.ignorecase</span> true			<span class="comment">// 让 Git 对仓库中的文件大小写敏感</span></span><br></pre></td></tr></table></figure>
<p>3. 查看所有的已经做出的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-config.gif" alt="git config"></p>
<h2 id="基础操作">基础操作</h2><h3 id="创建_Git_版本库">创建 Git 版本库</h3><p>在本地创建 Git 版本库，需要使用 <code>git init</code> 命令。</p>
<p>首先，你需要新建一个存放版本库的目录，然后进入到该目录所在路径，然后执行：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> init</span><br></pre></td></tr></table></figure>
<p>然后查看目录结构中，就可以看到包含有 <code>.git</code> 子目录，这就说明创建版本库成功了。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-init.gif" alt="git init"></p>
<h3 id="将文件添加到版本库">将文件添加到版本库</h3><p>要将一个文件纳入到版本库管理，首先要将其添加到暂存区(这里不做深入介绍)，然后才能提交到仓库中。</p>
<p>1. 将文件添加到暂存区，使用的是 <code>git add</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> Readme.md	<span class="comment">	// 添加单个文件到暂存区</span></span><br><span class="line">git <span class="built_in">add</span> .			<span class="comment">	// 将当前目录下所有修改添加到暂存区，除按照规则忽略的之外</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边空文件夹是不会被添加到暂存区中的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-add.gif" alt="git add"></p>
<p>2. 将暂存区中的文件，提交到仓库中。需要使用 <code>git commit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">commit</span>		// 如果暂存区有文件，则将其中的文件提交到仓库</span><br><span class="line">git <span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">'your comments'</span> 		// 带评论提交，用于说明提交内容、变更、作用等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边直接用 <code>git commit</code> 提交，会先弹出添加评论的页面。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-commit.gif" alt="git commit"></p>
<h3 id="查看仓库的状态">查看仓库的状态</h3><p>不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">status</span></span><br></pre></td></tr></table></figure>
<p>来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，我使用最多的一个命令。</p>
<h3 id="查看仓库中的具体修改">查看仓库中的具体修改</h3><p>很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code> 来查看具体的修改内容。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff	<span class="comment">// 查看版本库中所有的改动</span></span><br><span class="line">git diff Readme<span class="class">.md</span>		<span class="comment">// 查看具体文件的改动</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-diff.gif" alt="git diff"></p>
<h3 id="查看提交历史记录">查看提交历史记录</h3><p>有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">	// 显示所有提交的历史记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline	// 单行显示提交历史记录的内容</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-log.gif" alt="git log"></p>
<h3 id="版本回退">版本回退</h3><p>有了 <code>git log</code> 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard HEAD^		// 回退到上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD^^		// 回退到上上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 'commit_id'	// 会退到 commit_id 指定的提交版本</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-1.gif" alt="git reset --hard"></p>
<h3 id="回到未来的某个提交">回到未来的某个提交</h3><p>当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。</p>
<p>因此，想要回到未来的某个提交，先通过 <code>git reflog</code> 从历史命令中找到想要回到的提交版本的 ID，然后通过 <code>git reset --hard</code> 来切换。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git <span class="keyword">reset</span> --hard <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reflog.gif" alt="git reflog"></p>
<h3 id="撤销修改">撤销修改</h3><p>撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。</p>
<p>1. 丢弃工作区中文件的修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Readme<span class="class">.md</span>	<span class="comment">// 如果 Readme.md 文件在工作区，则丢弃其修改</span></span><br><span class="line">git checkout -- .			<span class="comment">// 丢弃当前目录下所有工作区中文件的修改</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-checkout-1.gif" alt="git checkout --"></p>
<p>2. 丢弃已经进入暂存区的修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="keyword">HEAD</span> Readme.md 	// 将 Readme.md 恢复到 <span class="keyword">HEAD</span> 提交版本的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-head.gif" alt="git reset HEAD"></p>
<h3 id="删除文件">删除文件</h3><p>在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Readme<span class="class">.md</span> 	<span class="comment">// 删除已经被提交过的 Readme.md</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-rm.gif" alt="git rm"></p>
<p><strong><code>git rm</code> 与 先 rm 然后 <code>git add</code> 的区别</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/rm-and-git-add.gif" alt="rm and git add"></p>
<p>更详细的可以参考：<a href="http://yang3wei.github.io/blog/2013/02/03/git-rm-he-rm-de-qu-bie/" target="_blank" rel="external">“git rm” 和 “rm” 的区别</a></p>
<blockquote>
<p>注意：上图中的结果是在 git 1.9.1 版本上的操作。在 git 2.0 以上两者没有区别了。</p>
</blockquote>
<h2 id="分支管理">分支管理</h2><p>分支是版本控制系统中很重要的一个概念，在 Git 中新建、合并等分支的操作非常轻量便捷，因此我们会很经常的用到。</p>
<h3 id="查看分支">查看分支</h3><p>查看分支使用 <code>git branch</code>：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch		<span class="comment">// 查看本地分支信息</span></span><br><span class="line">git branch -v 	<span class="comment">// 查看相对详细的本地分支信息</span></span><br><span class="line">git branch -av 	<span class="comment">// 查看包括远程仓库在内的分支信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 <code>git branch</code> 的输出内容中，有一个分支，前面带有 <code>*</code> 号，这标识我们当前所在的分支。</p>
</blockquote>
<h3 id="创建分支">创建分支</h3><p>当我们要修复一个 Bug，或者开发一个新特性，甚至是在初学的时候怕打乱原来的代码，都可以新建一个分支来避免对原来代码的影响。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">dev</span>	<span class="comment">// 新建一个名称为 dev 的分支</span></span><br></pre></td></tr></table></figure>
<h3 id="切换分支">切换分支</h3><p>当我们创建完分支以后，我们需要切换到新建的分支，否则，所有的修改，还是在原来的分支上。事实上，所有的改动，只能影响到当前所在的分支。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">dev</span>	<span class="comment">// 新建完 dev 分支以后，通过该命令切换到 dev 分支</span></span><br></pre></td></tr></table></figure>
<h3 id="创建并切换分支">创建并切换分支</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="tag">b</span> dev		<span class="comment">// 新建 dev 分支，并切换到该分支上</span></span><br></pre></td></tr></table></figure>
<p>这个命令合并了前两个独立的命令，平常使用中一般这样使用。</p>
<h3 id="合并分支">合并分支</h3><p>当我们修复完成一个 Bug，或者开发完成一个新特性，我们就会把相关的 Bug 或者 特性的上修改合并回原来的主分支上，这时候就需要 <code>git merge</code> 来做分支的合并。</p>
<p>首先需要切换回最终要合并到的分支，如 <code>master</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master	<span class="comment">	// 切换回 master 分支</span></span><br><span class="line">git <span class="built_in">merge</span> dev		<span class="comment">	// 将 dev 分钟中的修改合并回 master 分支</span></span><br></pre></td></tr></table></figure>
<p>合并回主分支的时候，后面可能会面临到冲突的问题。冲突的解决暂不在这里说明。</p>
<h3 id="删除分支">删除分支</h3><p>当之前创建的分支，完成了它的使命，如 Bug 修复完，分支合并以后，这个分支就不在需要了，就可以删除它。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">dev</span>		<span class="comment">// 删除 dev 分支</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库">远程仓库</h2><p>上面的所有命令都是针对本地仓库的操作。当我们希望多个人来协作时，会将代码发布到一个统一的远程仓库，然后多个人在本地操作以后，在推送到远程仓库。其他人协作时，需要先同步远程仓库的内容，再推送自己的修改。</p>
<h3 id="从远程仓库克隆">从远程仓库克隆</h3><p>如果你本地没有仓库，希望从已有的远程仓库上复制一份代码，那么你需要 <code>git clone</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/git/git.git 	// 通过 https 协议，克隆 Github 上 git 仓库的源码</span></span><br><span class="line">git clone linfuyan<span class="annotation">@github</span>.com<span class="regexp">/git/</span>git.git	<span class="comment">// 通过 ssh 协议，克隆 Github 上 git 仓库的源码</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git clone</code> 后面的仓库地址，可以支持多种协议，如 https， ssh 等。</p>
</blockquote>
<h3 id="添加远程仓库">添加远程仓库</h3><p>如果你已经有了一个本地仓库，如之前创建的 <code>git-guide</code>，然后你打算将它发布到远程，供其他人协作。那么使用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin your_remote_git_repo	<span class="comment">	// 为本地仓库添加远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="推送本地的内容到远程仓库">推送本地的内容到远程仓库</h3><p>当本地仓库中，代码完成提交，就需要将代码等推送到远程仓库，这样其他协作人员可以从远程仓库同步内容。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> -u origin master <span class="comment">// 第一次推送时使用，可以简化后面的推送或者拉取命令使用</span></span><br><span class="line">git <span class="keyword">push</span> origin master	<span class="comment">// 将本地 master 分支推送到 origin 远程分支</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code> 参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。</p>
</blockquote>
<h3 id="从远程仓库获取最新内容">从远程仓库获取最新内容</h3><p>在多人协作过程中，当自己完成了本地仓库中的提交，想要向远程仓库推送前，需要先获取到远程仓库的最新内容。</p>
<p>可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> fetch origin master	</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p><code>git fetch</code> 和 <code>git pull</code> 之间的区别：</p>
<ol>
<li><code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li><code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
</ol>
<blockquote>
<p>注意：建议多使用 <code>git fetch</code>。</p>
</blockquote>
<h3 id="查看远程仓库信息">查看远程仓库信息</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="attr_selector">[-v]</span>		<span class="comment">// 显示远程仓库信息</span></span><br></pre></td></tr></table></figure>
<h3 id="建立本地分支和远程分支的关联">建立本地分支和远程分支的关联</h3><p>在本地仓库中的分支和远程仓库中的分支是对应的。一般情况下，远程仓库中的分支名称和本地仓库中的分支名称是一致的。</p>
<p>有的时候，我们会需要指定本地分支与远程分支的关联。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream <span class="string">'local_branch'</span> origin/remote_branch</span><br></pre></td></tr></table></figure>
<h3 id="修改本地仓库对应的远程仓库地址">修改本地仓库对应的远程仓库地址</h3><p>当远程的仓库地址发生变化时，需要修改本地仓库对应的远程仓库的地址。主要应用在<a href="http://blog.csdn.net/hongshan50/article/details/23663043" target="_blank" rel="external">工程迁移</a>过程中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="operator"><span class="keyword">set</span>-<span class="keyword">url</span> origin <span class="keyword">url</span></span></span><br></pre></td></tr></table></figure>
<h2 id="标签管理">标签管理</h2><p>在项目开发过程中，当一个版本发布完成时，是需要对代码打上标签，便于后续检索。获取处于其他的原因，需要对某个提交打上特定的标签。</p>
<h3 id="创建标签">创建标签</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="tag">a</span> <span class="string">'tagname'</span> -m <span class="string">'comment'</span> <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 参数指定标签名， <code>-m</code> 添加备注信息， ‘commit_id’ 指定打标签的提交。</p>
<h3 id="查看所有标签">查看所有标签</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">tag</span>		<span class="comment">// 查看本地仓库中的所有标签</span></span><br></pre></td></tr></table></figure>
<h3 id="查看具体标签信息">查看具体标签信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> shwo tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除本地标签">删除本地标签</h3><p>如果打的标签出错，或者不在需要某个标签，则可以删除它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="operator">-d</span> tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除远程标签">删除远程标签</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/tagname</span></span><br></pre></td></tr></table></figure>
<h3 id="推送标签到远程仓库">推送标签到远程仓库</h3><p>打完标签以后，有需要推送到远程仓库。</p>
<p>1. 推送单个标签到远程仓库</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">git</span> <span class="keyword">push </span>origin tagname</span><br></pre></td></tr></table></figure>
<p>2. 一次性推送所有标签到远程仓库。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="comment">--tags</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶操作">进阶操作</h2><h3 id="临时保存修改">临时保存修改</h3><p>在执行很多的 Git 操作的时候，是需要保持当前操作的仓库/分支处于 clean 状态，及没有未提交的修改。如 <code>git pull</code>， <code>git merge</code> 等等，如果有未提交的修改，这些将无法操作。</p>
<p>但是做这些事情的时候，你可能修改了比较多的代码，却又不想丢弃它。那么，你需要把这些修改临时保存起来，这就需要用到 <code>git stash</code>。</p>
<p>1. <strong>临时保存修改</strong>，这样仓库就可以回到 clean 状态。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  stash		<span class="comment">// 保存本地仓库中的临时修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以多次的 <code>git stash</code> 来保存不同的临时修改。</p>
</blockquote>
<p>2. <strong>查看临时保存</strong>。当你临时保存以后，后面还是要取回来的，那它们在哪里呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">list</span>	<span class="comment">// 显示所有临时修改</span></span><br></pre></td></tr></table></figure>
<p>3. 当我们处理完其他操作时，想要恢复临时保存的修改。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash apply		<span class="comment">// 恢复所有保存的临时修改</span></span><br><span class="line">git stash <span class="keyword">pop</span>		<span class="comment">// 恢复最近一次保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>4. 或者，我们后面觉得临时保存不想要了，那可以丢弃它。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">clear</span>	<span class="comment">	// 丢弃所有保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>这些是我目前在项目中经常会用到的操作，这里整理下来，可以作为一个手册。对于 Git 的理解或者更多的解释，并不在这里体现。大家可以参考其他更多的资料。</p>
<p>更多阅读：</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a><br><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="external">Git Community Book 中文版</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4233881.html" target="_blank" rel="external">Git 对象模型</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4235448.html" target="_blank" rel="external">探索 .git 目录</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://linfuyan.com/tags/Git/"/>
    
      <category term="命令" scheme="http://linfuyan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不懂技术的人不要对懂技术的人说这很容易实现]]></title>
    <link href="http://linfuyan.com/im-sure-it-will-only-take-you-a-few-days-to-code/"/>
    <id>http://linfuyan.com/im-sure-it-will-only-take-you-a-few-days-to-code/</id>
    <published>2015-10-11T10:36:09.000Z</published>
    <updated>2015-10-11T10:56:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/non-technical-people-cant-estimate-developmen.jpg" alt=""></p>
<p>“这个网站相当简单，所有你需要做的就是完成 X，Y，Z。你看起来应该是技术很好，所以，我相信，你不需要花费太多时间就能把它搭建起来。”</p>
<p>我时不时的就会收到这样的 Email 。写这些邮件的人几乎都是跟技术不沾边的人，或正在研究他们的第一个产品。起初，当听到人们这样的话，我总是十分的恼怒。他们在跟谁辩论软件开发所需要的时间？但后来我意识到，即使我自己对自己的项目预测要花去多少开发时间,我也是一筹莫展。如果连我自己都做不好，我何必对那些人恼怒呢？</p>
<a id="more"></a>
<p>真正让我郁闷的不是他们预估的错误。问题在于他们竟然认为自己可以做出正确的估计。作为开发人员，我们经常会发现，在软件开发的问题上，一个外行人会很自然的把复杂的事情估计的很简单。</p>
<p>这并不是为我们的愤怒找借口。但这引起了另外一个有趣的问题：为什么我们天生的预测复杂性的能力在遇到编程问题时会失灵？</p>
<p>为了回答这个问题，让我们来认识一下我们的大脑如何估计事情的。有些事情对于一些没有经验的人也很容易预估正确，但有些事情则不然。</p>
<p>我们来想想观看一个人弹吉他。即使你从来没有弹过吉他，在观看了一场弹奏《玛丽有只小羊羔( Mary had a Little Lamb )》的吉他表演后，你也能大概推测出这很简单，一个人不需要太高的技术就能演奏出来。同样，当观看了有人演奏 D 大调的《卡农( Pachabel’s Canon )》后，你也很容易推测出，这很复杂，需要很长时间的练习才能演奏的出来。</p>
<p>为什么我们能够很迅速准确的预估这两首曲子的复杂性呢？这是跟我们用来判断一个事情简单和还是复杂的方法有关的。我们的大脑有一些现成的模式来完成这些事情，首先一个就是根据速度。这种情况下，大脑会辨别每秒钟演奏的东西。根据每秒钟演奏了多少东西，我们很容易有一个直观的判断曲子的复杂度。因为用吉他演奏一首歌是一种物理过程，一种感官上的活动，我们的大脑很容易依此来推测速度，继而转换成复杂度。</p>
<p>我们还有另外一个天生的推测依据：体积。想想把一个帐篷和一栋公寓放在一起对比。即使一个人从来没有学过建筑学，他也能告诉你通常设计和建造一个帐篷会比设计和建造一栋公寓要简单。为什么？因为我们天生的会使用物理体积作为事物复杂性的一个指标。</p>
<p>当然。上面说的这两种逻辑分析并不是总是100%的有效。但大多数情况下，人们就是这样干，而且很成功。大多数情况中，我们在对物理过程评估时，我们的大脑会对物理事物进行有效的关联，不需要依赖之前的经验。</p>
<p>现在让我们来谈谈软件。当一个不懂技术的人试图对软件开发时间进行评估时，有两个很基本的直观指标在辅助他们：以体积为指标的复杂度和以速度为指标的复杂度。但他们没有意识到，软件跟他们想象的不一样。软件本质上不是有形物质。没有体积和速度。它的极小的组成部分可能会时不时的在电脑屏幕上闪现。正因为如此，当面对开发一个 web 应用时(或任何类型的软件)，我们的基本直观感觉失效了。</p>
<p>这第一点，速度，很显然根本不可能被外行人拿来对软件进行评估。于是很自然的，他们倾向于使用体积指标进行评估。要么是根据描述文档的页数，要么是根据软件的功能用例数或特征数。</p>
<p>有时候，这种评估手段确实有效！当面对一个静态网站，没有特别的设计要求，外行人很容易用这种方法估计出开发时间。但是，通常情况下，对于软件开发，体积并不能真实有效的反映复杂度。</p>
<p>不幸的是，对于软件的复杂度，唯一有效的推测方法是依据经验。而且还不是时时都好用。作为一个程序员，我知道，根据我之前开发过的相似的功能特征，我可以估计出现在的这些功能特征各自要多少开发时间。然后，我把总时间加起来，这就得到了完成整个项目需要的大致时间。然而，事实情况中，每个项目在开发过程中都遇到二、三个瓶颈。这些瓶颈会肆意的消耗程序员的大量时间，你在遇到它们之前根本不会有所预见。它们会拖住整个项目，致使工期延后数周甚至数月。</p>
<p>这些是没有经验的人在评估复杂度时不会理解的。他们不明白在其他事情上都很灵的方法，为什么放到软件开发上就不灵了。所以，下一次当你听到有人说”我想你几天时间就能把它开发出来”时，不管是谁说的，都不要懊恼。深呼吸一下，告诉他这篇文章的地址，自己该干什么还干什么。</p>
<p>译文来自：<a href="http://www.vaikan.com/im-sure-it-will-only-take-you-a-few-days-to-code/" target="_blank" rel="external">不懂技术的人不要对懂技术的人说这很容易实现</a><br>英文原文：<a href="http://danshipper.com/non-technical-people-cant-estimate-developmen" target="_blank" rel="external">I’m Sure It Will Only Take You A Few Days To Code</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/non-technical-people-cant-estimate-developmen.jpg" alt=""></p>
<p>“这个网站相当简单，所有你需要做的就是完成 X，Y，Z。你看起来应该是技术很好，所以，我相信，你不需要花费太多时间就能把它搭建起来。”</p>
<p>我时不时的就会收到这样的 Email 。写这些邮件的人几乎都是跟技术不沾边的人，或正在研究他们的第一个产品。起初，当听到人们这样的话，我总是十分的恼怒。他们在跟谁辩论软件开发所需要的时间？但后来我意识到，即使我自己对自己的项目预测要花去多少开发时间,我也是一筹莫展。如果连我自己都做不好，我何必对那些人恼怒呢？</p>]]>
    
    </summary>
    
      <category term="周期" scheme="http://linfuyan.com/tags/%E5%91%A8%E6%9C%9F/"/>
    
      <category term="开发" scheme="http://linfuyan.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="程序员" scheme="http://linfuyan.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="评估" scheme="http://linfuyan.com/tags/%E8%AF%84%E4%BC%B0/"/>
    
      <category term="软件" scheme="http://linfuyan.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="深度文摘" scheme="http://linfuyan.com/categories/%E6%B7%B1%E5%BA%A6%E6%96%87%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 如何保持页面文件不被渲染]]></title>
    <link href="http://linfuyan.com/keep-pages-at-your-hexo-blog/"/>
    <id>http://linfuyan.com/keep-pages-at-your-hexo-blog/</id>
    <published>2015-10-10T16:35:14.000Z</published>
    <updated>2015-10-10T16:50:54.000Z</updated>
    <content type="html"><![CDATA[<p>假设要保持 keep.html 文件原样输出，不被渲染：</p>
<p>1. 将 keep.html 文件放在 <code>source</code> 目录下。</p>
<p>2. 打开 <code>_confi.yml</code> 配置文件，添加 <code>skip_render:</code>，并声明 keep.html 文件如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">skip_render</span>: <span class="string">keep.html</span></span><br></pre></td></tr></table></figure>
<p>3. 如果需要保持多个文件，可以按照如下声明：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">skip_render</span>: <span class="string">[file1, files, ...]</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>假设要保持 keep.html 文件原样输出，不被渲染：</p>
<p>1. 将 keep.html 文件放在 <code>source</code> 目录下。</p>
<p>2. 打开 <code>_confi.yml</code> 配置文件，添加 <code>skip_]]>
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="skip render" scheme="http://linfuyan.com/tags/skip-render/"/>
    
      <category term="渲染" scheme="http://linfuyan.com/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="页面" scheme="http://linfuyan.com/tags/%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 6.0 特性及主要 API 变更]]></title>
    <link href="http://linfuyan.com/android-m-changes/"/>
    <id>http://linfuyan.com/android-m-changes/</id>
    <published>2015-10-10T03:52:00.000Z</published>
    <updated>2015-10-10T14:49:19.000Z</updated>
    <content type="html"><![CDATA[<p>伴随着新的特性和功能， Android 6.0 (API 级别 23)带来了一系列系统和 API 行为的变更。这篇文章中将介绍一些在应用程序中需要理解和注意的主要变更点。</p>
<blockquote>
<p>如果你之前已经发布过 Android 应用程序，要意识到这些变更对应用程序的影响。</p>
</blockquote>
<a id="more"></a>
<h2 id="运行时权限">运行时权限</h2><p>这个版本中引入了新的权限模型，现在用户可以在运行时直接管理应用程序的权限。这个模型基于用户对权限控制的更多可见性，同时为应用程序的开发者提供更流畅的应用安装和自动升级。用户可以为已安装的每个应用程序独立的授予或者取消权限。</p>
<p>在运行于目标版本 Android 6.0 (API 级别 23) 及以上的应用程序中，必须在运行时检查并请求权限。通过新的 <code>checkSelfPermission()</code> 方法来确定你的应用程序是否已经被授权。通过新的 <code>requestPermissions()</code> 方法来请求权限。即使你的应用程序运行的目标版本不是 Android 6.0 (API 级别 23)，你也应该在新的授权模型下来测试应用程序。</p>
<p>在应用程序中支持新的权限模型的更多详细信息，可以查看<a href="https://developer.android.com/training/permissions/index.html" target="_blank" rel="external">使用系统权限</a>。如何在应用程序中使用权限，相关提示可以查看<a href="https://developer.android.com/training/permissions/best-practices.html#testing" target="_blank" rel="external">权限最佳实践</a>。</p>
<h2 id="休眠与应用挂起(_Doze_and_App_Standby_)">休眠与应用挂起( Doze and App Standby )</h2><p>这个版本为空闲的设备和应用程序引入了电源节能优化。这个特性将影响所有应用程序，故确保自己的应用程序在这些新模式下进行测试。</p>
<ul>
<li><p><strong>休眠</strong>：如果用户将设备拔下，并将其静置，关闭屏幕，经过一段时间，设备将进入休眠模式。这时候，设备试图让系统保持在一个睡眠的状态。这种模式下，设备周期性的恢复平常的操作，以便应用程序同步，系统则可以处理一些延时的操作。</p>
</li>
<li><p><strong>应用挂起</strong>：应用挂起则允许系统当用户不再使用应用程序时，将其定义为空闲。当用户经过一段时间没有触摸应用程序时，系统可以做这个决定。设备被拔线时，系统禁用网络访问，停止应用程序的同步及操作，则被认为是空闲。</p>
</li>
</ul>
<p>学习更多关于电源节能的变更，查看<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对休眠与应用挂起的优化</a>。</p>
<h2 id="移除_Apache_HTTP_客户端">移除 Apache HTTP 客户端</h2><p>Android 6.0 发布版移除了对 Apache HTTP 客户端的支持。如果你的应用程序使用该客户端，并且目标运行版本为 Android 2.3 (API 级别9) 及以上，需要使用 <code>HttpURLConnection</code> 类来代替。这个 API 更加的高效，因为它通过对用户透明的压缩、响应缓存来减少网络开销，并最小化电量消耗。要继续使用 Apache HTTP 的 API，你需要在 <code>build.gradle</code> 文件中声明下面的编译期依赖：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">useLibrary</span> <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BoringSSL">BoringSSL</h2><p>Android 从 OpenSSL 转移到了 <a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="external">BoringSSL</a> 库。如果你在应用程序中使用 Android NDK，千万不要将加密库链接到除 NDK API 之外的任何库，如 <code>libcrypto.so</code> 和 <code>libssl.so</code>。这些库不是公开 API，有可能在没有收到通知的情况下在发布版和设备间发生变更或中断。这种情况你将把自己暴露在安全威胁下。你应该修改自己的本地代码来通过 JNI 调用 Java 加密 API 或者静态链接你选择的一个加密库。</p>
<h2 id="访问硬件标识符">访问硬件标识符</h2><p>为了给用户更多的数据保护，从这个版本开始， Android 移除了通过 WiFi 和蓝牙 API 来在应用程序中可编程的访问本地硬件标示符。现在 <code>WifiInfo.getMacAddress()</code> 和 <code>BluetoothAdapter.getAddress()</code> 方法都将返回 <code>02:00:00:00:00:00</code> 常量。</p>
<p>要通过蓝牙和 WiFi 扫描来访问附近外部设备的硬件标示符，应用程序需要 <code>ACCESS_FINE_LOCATION</code> 和 <code>ACCESS_COARSE_LOCATION</code> 权限：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/net/wifi/WifiManager.html#getScanResults\(\" target="_blank" rel="external"><code>WifiManager.getScanResults()</code></a>)</li>
<li><a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#ACTION_FOUND" target="_blank" rel="external"><code>BluetoothDevice.ACTION_FOUND</code></a></li>
<li><a href="https://developer.android.com/reference/android/bluetooth/le/BluetoothLeScanner.html#startScan\(android.bluetooth.le.ScanCallback\" target="_blank" rel="external"><code>BluetoothLeScanner.startScan()</code></a>)</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在一个运行 Android 6.0 (API 级别 23) 的设备初始化后台的 WiFi 或蓝牙扫描时，操作对于外部设备是可见的，且被赋予一个随机的 MAC 地址。</p>
</blockquote>
<h2 id="通知">通知</h2><p>这个版本移除了 <code>Notification.setLatestEventInfo()</code> 方法。使用 Notification.Builder 类来代替构造方法。要重复的更新通知，要重用 Notification.Builder 实例。调用 build() 方法来获取更新过的 Notification 实例。</p>
<p><code>adb shell dumpsys nnotification</code> 命令不在答应通知文本。使用 <code>adb shell dumpsys notification --noredcat</code> 命令来在同志对象中打印文本。</p>
<h2 id="AudioManager_变更">AudioManager 变更</h2><p>通过 AudioManager 类来直接设置音量或者使流静音已经不再支持。 setStreamSolo() 方法被弃用，你需要调用 requestAudioFocus() 来代替。类似的， setStreamMute() 方法被弃用，替换为 adjustStreamVolume() 方法并传递方向值 ADJUST_MUTE 或 ADJUST_UNMUTE。</p>
<h2 id="文本选择">文本选择</h2><p>当用户在应用程序中选择文本时，你可以在<a href="http://www.google.com/design/spec/patterns/selection.html#selection-text-selection" target="_blank" rel="external">悬浮工具栏</a>中显示文本选择工作，如剪切、复制、粘贴。用户交互实现与<a href="https://developer.android.com/guide/topics/ui/menus.html#CABforViews" target="_blank" rel="external">为独立视图启动上下文动作模式</a>中描述的上下文动作栏类似。</p>
<p>为文本选择实现悬浮工具栏，需要在已存在的应用程序中做如下修改：</p>
<ol>
<li><p>在 View 或者 Activity 对象中，通过修改 <code>startActionMode(Callback)</code> 为 <code>startActionMode(Callback, ActionMode.TYPE_FLOATING)</code> 来改变 ActionMode。 </p>
</li>
<li><p>使已经存在的 <code>ActionMode.Callback</code> 的实现继承自 ActionMode.Callback2 。</p>
</li>
<li><p>重载 onGetContentRect() 方法来提供内容 Rect 对象(如文本选择矩形)在视图中的坐标。</p>
</li>
<li><p>如果矩形位置不在有效，并且这是需要刷新的唯一元素，则调用 invalidateContentRect() 方法。</p>
</li>
</ol>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/text-selection.gif" alt="文本选择"></p>
<p>如果你在使用 Android 22.2 修订版的兼容包，悬浮工具栏不是向后兼容的，且使用默认的 ActionMode 对象。这导致悬浮工具栏无法显示。在 AppCompatActivity 中启用 ActionMode，首先调用 getDelegate() ，然后在返回的 AppCompatDelegate 对象中调用 setHandleNativeActionModesEnabled()，并设置输入参数为 <code>false</code>。这个调用为框架返回可控的 ActionMode 对象。在运行 Android 6.0 (API 级别 23) 的设备上，这允许框架支持 ActionBar 或悬浮工具栏模式。在 Android 5.1 (API 级别 22) 或更低版本，只有 ActionBar 是支持的。</p>
<h2 id="浏览器书签变更">浏览器书签变更</h2><p>这个版本移除了对全局书签的支持。 <code>android.provider.Browser.getAllBookmark()</code> 和 <code>android.provider.Browser.saveBookmark()</code> 方法被移除。同样的， <code>READ_HISTORY_BOOKMARKS</code> 和 <code>WRITE_HISTORY_BOOKMARKS</code> 权限被移除。如果你的应用程序的目标运行版本为 Android 6.0 (API 级别 23) 或者更高，不要从全局提供者访问书签或者使用书签权限。现在，你的应用程序需要内部保存书签数据。</p>
<h2 id="Android_Keystore_变更">Android Keystore 变更</h2><p>在这个版本中， <a href="https://developer.android.com/training/articles/keystore.html" target="_blank" rel="external">Android Keystore 提供器</a> 不在支持 DSA。 ECDSA 则仍然被支持。</p>
<p>当安全锁屏被禁用或重置时，不要求加密的 key 将不再被删除。要求加密的 key 则会在这些事件中被删除。</p>
<h2 id="Wi-Fi_和_网络变更">Wi-Fi 和 网络变更</h2><p>这个版本为 Wi-Fi 和 网络 API 引入了下面的行为变更：</p>
<ul>
<li>应用程序只有在创建了 WifiConfiguration 对象以后，才能更变这些对象的状态。当 WifiConfiguration 被用户或者其他应用程序创建时，你将不允许修改和删除这些 WifiConfiguration 对象。</li>
<li>在之前的版本中，如果应用程序使用 enableNetwork() ，并设置 <code>disableAllOthers=true</code> 来强制设备连接到指定的 Wi-Fi 网络，设备将和其他网络断开。这个版本中，这些设备将不再和其他网络断开。如果应用程序的 <code>targetSdkVersion</code> 是 20 或者更低，则会连接被选中的 Wi-Fi 网络。如果应用程序的 <code>targetSdkVersion</code> 是 21 或者更高，使用多网络 API (如 openConnection()， bindSocket() 及新的 bindProcessToNetwork() 方法)来确保它的网络通信是发给被选中的网络。</li>
</ul>
<h2 id="摄像头服务变更">摄像头服务变更</h2><p>在这个版本中，在摄像头服务中访问共享资源的模式发生了变更，不再是以前的”先到先得”，而是具备高优先级的将优先处理。服务行为的变更包括：</p>
<ul>
<li><p>访问摄像头子系统的资源，包括打开和配置摄像设备，依赖于客户端应用进程的优先级。用户可见或者在前台活动的应用程序进程往往具备更高的优先级，使得摄像资源更易获得，也更加可靠。</p>
</li>
<li><p>当更高优先级的应用程序视图使用摄像头时，具有低权限的活动摄像头客户端应用程序可能被中断。在被弃用的 Camera API 中，错误会在被中断客户端的 onError() 中被调用。在 Camera2 API 中，错误结果则在 onDisconnected() 中被调用。</p>
</li>
<li><p>在具备适合摄像头硬件的设备上，不同的应用进程可以同时独立地打开和使用独立的摄像头设备。虽然如此，多进程使用时，同时访问摄像头会造成设备性能的急剧下降，这将被摄像头服务所检测到并不被允许。这个变更使得由于较低优先级而被中断的客户端，即使当没有其他应用直接访问时，也会试图访问一样的设备。</p>
</li>
<li><p>改变当前用户会导致之前用户账号的应用程序中活动那个的摄像头客户端被中断。对摄像头的访问是被当前设备用户所限制的。实际上，这意味着当用户切换到不同的账户下时，原来的”访客”账号所使用的摄像头子系统是不可能继续运行的。</p>
</li>
</ul>
<h2 id="运行时">运行时</h2><p>通过 newInstance() 方法 ART 运行时现在正确的实现了访问规则。这个变更修复了之前版本中 Dalvik 检查访问规则时的错误。如果你的应用程序使用 newInstance() 方法，且你想要覆盖访问检查，调用 setAccessible() 方便，并设置参数为 <code>true</code>。如果你的应用程序使用 <a href="https://developer.android.com/tools/support-library/features.html#v7-appcompat" target="_blank" rel="external">v7 兼容库</a> 和 <a href="https://developer.android.com/tools/support-library/features.html#v7-recyclerview" target="_blank" rel="external">v7 recyclerview 库</a>。你需要升级应用程序中的相关库到最新版本。否则，需要确保 XML 中所引用的自定义类已经被升级，其构造方法是可访问的。</p>
<p>这个版本升级了动态链接器的行为。动态连接器现在可以理解库的 <code>soname</code> 和 它的路径之间的区别，且实现了通过 <code>soname</code> 来搜索。在加载时，之前可用的应用程序可能会被提示具有不可用的 <code>DT_NEEDED</code> 条目(通常是在构建机器文件系统中的绝对路径)。</p>
<p><code>dlopen(3) RTLD_LOCAL</code> 标志现在被正确实现了。 <code>RTLD_LOCAL</code> 是默认的，因此调用 <code>dlopen(3)</code> 是不明确使用 <code>RTLD_LOCAL</code> 是有效的(除非应用之前有明确使用 <code>RTLD_GLOBAL</code> )。使用 <code>RTLD_LOCAL</code> ，标记在调用 <code>dlopen(3)</code> 加载库之前是不可用的(这与被 <code>DT_NEEDED</code> 条目引用恰恰相反)。</p>
<p>在之前版本的 Android，如果你的应用请求系统来加载包含文本重定位段的动态链接库，系统会显示警告，但允许继续加载库。从这个版本开始，如果你的目标运行 SDK 版本为 23 或以上，系统会拒绝这个库。为了辅助检测库是否被成功加载，应用程序需要为 <code>dlopen(3)</code> 失败添加日志，并在 <code>dlerror(3)</code> 返回值中包含问题的描述文本。学习更多关于如何处理文本重定位段，可以查看这个<a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide" target="_blank" rel="external">指南</a>。</p>
<h2 id="APK_验证">APK 验证</h2><p>Android 平台现在执行更加严格的 APK 验证。如果一个文件在清单文件中被声明，但在 APK 中却没有，那么这个 APK 被认为是无效的。如果任意的内容被移除， APK 需要重新签名。</p>
<h2 id="USB_连接">USB 连接</h2><p>通过 USB 端口的设备连接现在默认被设置为充电模式。想要通过 USB 连接来访问设备和它的内容，用户需要为这些交互提供明确的授权。如果你的应用程序支持用户通过 USB 端口与设备交互，需要确保这些交互被明确启用。</p>
<h2 id="Android_for_Work_变更">Android for Work 变更</h2><p>这个版本包括下面的 Android for Work 行为变更：</p>
<ul>
<li><p><strong>个人上下文中的联系人</strong>。Google 拨号器通话记录现在可以在用户查看已通话记录时显示当前联系人。在 Google 拨号器中通过设置 <code>setCrossProfileCallerIdDisabled()</code> 为 <code>true</code> 来隐藏当前联系人。当设置 <code>setBluetoothContactSharingDisabled()</code> 为 <code>false</code> 时，当前联系人能通过蓝牙显示在设备联系人中。默认情况下，其设置为 <code>true</code>。</p>
</li>
<li><p><strong>移除 Wi-Fi 配置</strong>：由外部拥有者添加(如通过 addNetworkd() 方法)的 Wi-Fi 配置现在在当前 profile 被删除时也将被移除。</p>
</li>
<li><p><strong>紧闭 Wi-Fi 配置</strong>：如果 <code>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</code> 为非空时，任何由活动的设备拥有者创建的 Wi-Fi 配置将不能用户被修改和删除。用户可以创建和修改自己的 Wi-Fi 配置。活动的设备拥有者拥有编辑和移除任意 Wi-Fi 配置的特权，包括不是由他们创建的配置。</p>
</li>
<li><p><strong>通过 Google 账号下载使用策略控制器</strong>：当一个要求 WPC 应用程序来管理的 Google 账号被添加到管理上下文之外的设备中时，添加账号流程会提示用户安装合适的 WPC。这些行为也可以应用到通过在初始设备创建向导中 <strong>设置 &gt; 账号</strong> 添加的账号。</p>
</li>
<li><p><strong>制定 DevicePolicyManager API 行为变更</strong>：</p>
<ul>
<li>调用 <code>setCameraDisabled()</code> 方法来影响当前调用用户的摄像头。</li>
<li>此外， <code>setKeyguardDisabledFeatures()</code> 方法对 Profile 用户是可用的，与设备拥有者一样。</li>
<li>Profile 拥有者可以设置键盘守卫的约束：<ul>
<li>KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT 将影响到 profile 父用户的键盘守卫设置。</li>
<li>KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS 只会影响在 profile 中由应用程序生成的通知。</li>
</ul>
</li>
<li>createAndInitializeUser() 和 createUser() 方法已经被弃用。</li>
<li>当给定用户的应用程序在前台运行时， setScreenCaptureDisabled() 方法将阻塞辅助结构。</li>
<li>SHA-256 的默认值为 EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 。为保持兼容性， SHA-1 仍然被支持，但在将来会被移除。 EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM 则仅接受 SHA-256。</li>
<li>原来存在的设备初始化 API 在 Android 6.0 (API 级别 23) 中被移除了。</li>
<li>EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 被移除，因此 NFC bump provisioning 无法通过编程的方式解锁重置被保护的设备。</li>
<li>现在在被管理的设备中通过 NFC 可以使用 EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE 来传递数据给设备拥有者的应用程序。</li>
<li>Android M 上的 Android for Work API 是经过优化的，包括 Work 配置，辅助层及其他。新的 DevicePolicyManager 权限 API 不会影响 Android 之前版本的应用程序。</li>
<li>当用户通过 ACTION_PROVISION_MANAGED_PROFILE 或者 ACTION_PROVISION_MANAGED_DEVICE 意图，从创建流程中的同步部分返回时，系统将返回 RESULT_CANCELED 结果码。</li>
</ul>
</li>
<li><p><strong>其他 API 变更</strong>：</p>
<ul>
<li>数据用法： <code>android.app.usage.NetworkUsageStates</code> 类重命名为 NetworkStats。</li>
</ul>
</li>
<li><strong>全局设置变更</strong>：<ul>
<li>下面的设置不能继续通过 setGlobalSettings() 方法设置：<ul>
<li><code>BLUETOOTH_ON</code></li>
<li><code>DEVELOPMENT_SETTINGS_ENABLED</code></li>
<li><code>MODE_RINGER</code></li>
<li><code>NETWORK_PREFERENCE</code></li>
<li><code>WIFI_ON</code></li>
</ul>
</li>
<li>下面全局设置可以通过 setGlobalSettings() 方法设置：<ul>
<li>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原文：<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 Changes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>伴随着新的特性和功能， Android 6.0 (API 级别 23)带来了一系列系统和 API 行为的变更。这篇文章中将介绍一些在应用程序中需要理解和注意的主要变更点。</p>
<blockquote>
<p>如果你之前已经发布过 Android 应用程序，要意识到这些变更对应用程序的影响。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="6" scheme="http://linfuyan.com/tags/6/"/>
    
      <category term="API" scheme="http://linfuyan.com/tags/API/"/>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Marshmallow" scheme="http://linfuyan.com/tags/Marshmallow/"/>
    
      <category term="变更" scheme="http://linfuyan.com/tags/%E5%8F%98%E6%9B%B4/"/>
    
      <category term="更新" scheme="http://linfuyan.com/tags/%E6%9B%B4%E6%96%B0/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[响应式编程2分钟简介]]></title>
    <link href="http://linfuyan.com/2-minute-introduction-to-rx/"/>
    <id>http://linfuyan.com/2-minute-introduction-to-rx/</id>
    <published>2015-09-28T03:40:00.000Z</published>
    <updated>2015-09-28T03:44:52.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877" target="_blank" rel="external">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>
<a id="more"></a>
<p>现在来考虑包含鼠标位置信息的点击事件。如果你把这些事件画在一条时间轴上，则看起来像这样：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<p>这是个事件流( <em>stream</em> of <em>event</em> )，或者叫” <strong>Observable</strong> “。</p>
<p>这些点击事件来自于鼠标，因此整个事件流是不可变的，这种情况下，当它被定义，你无法从中添加或者删除。</p>
<p>但是，如果我们仅仅对 <code>x &lt; 250</code> 的点击事件感兴趣呢？我们能否通过过滤来建立一个新的流，就像我们之前对数组所做的那样呢？</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<blockquote>
<p>filter((event) -&gt; event.x &lt; 250)</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_2.png" alt="click event after filter"></p>
<p>既然这样，不可变数组与 <strong>Obserable</strong> 有什么不同呢？不仅仅这样，你可以应用 map、 filter、 reduce 等操作到这两者上。对于 <strong>Obserable</strong> ，你还可以应用这些操作： <code>merge</code>,  <code>delay</code>,  <code>concat</code>,  <code>buffer</code>,  <code>distinct</code>,  <code>first</code>,  <code>last</code>,  <code>zip</code>,  <code>startWith</code>,  <code>window</code>,  <code>takeUntil</code>,  <code>skip</code>,  <code>scan</code>,  <code>sample</code>,  <code>amb</code>,  <code>join</code>,  <code>flatMap</code> 等。</p>
<p><strong>把它想象成异步的不可变数组。</strong></p>
<p>在 underscore.js 中 Rx 被认为是事件。但想一想，到底什么是事件呢？你的应用中的大部分东西能否是个事件呢？</p>
<p>“应用启动”事件，”接口数据返回”事件，”按键按下”事件，”界面刷新”事件，”设备休眠”事件，等等。</p>
<p>实际上，几乎所有的东西都可以看做是事件的流。问题只在于如何以合适的方式来组合它们。</p>
<p>这就是响应式编程的2分钟介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>]]>
    
    </summary>
    
      <category term="rx" scheme="http://linfuyan.com/tags/rx/"/>
    
      <category term="响应式" scheme="http://linfuyan.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://linfuyan.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="响应式编程" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Ubuntu 14.04 上通过 apt-get 安装 Apache Tomcat 7]]></title>
    <link href="http://linfuyan.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/"/>
    <id>http://linfuyan.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/</id>
    <published>2015-09-26T15:32:00.000Z</published>
    <updated>2015-09-26T15:46:19.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>
<a id="more"></a>
<h3 id="步骤一_-_先决条件">步骤一 - 先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照 Ubuntu 14.04 上搭建服务器中的 1-4 步来学习完成它。我们这里使用创建的 <code>demo</code> 用户来完成后续的教程。</p>
<h3 id="步骤二_-_安装_Tomcat">步骤二 - 安装 Tomcat</h3><p>首先，你需要升级 apt-get 软件包列表：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<p>现在你已经准备好安装 Tomcat。运行以下命令，开始安装：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install tomcat7</span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装 Tomcat 。这将同时安装 Tomcat 和它的依赖，例如 Java，同时，它将创建一个 <code>tomcat7</code> 用户，并以默认设置启动 Tomcat 。</p>
<p>这时候， Tomcat 并没有完全安装完成，但你可以通过在浏览器中输入本地域名或IP地址之后加 <code>:8080</code> 的方法来访问默认页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你会看到一个闪屏页面，显示 “It works” ，和其他附加信息。现在，我们要深入到 Tomcat 的安装过程。</p>
<h3 id="步骤三_-_安装额外软件包">步骤三 - 安装额外软件包</h3><p><em>注意：</em>如果你对 Tomcat 足够了解，且不需要 Web 管理接口，文档和示例，那这个章节不是必须的。如果你是第一次接触 Tomcat ，请继续。</p>
<p>通过以下代码，你将安装 Tomcat 的在线文档， Web接 口（管理 Web 应用），以及一些示例应用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> tomcat7-docs tomcat7-<span class="keyword">admin</span> tomcat7-examples</span></span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装这些软件包。后面我们会讲到这些工具的用法和配置。接下来，我们要安装 JDK 。</p>
<h3 id="步骤四_-_安装_JDK_(可选)">步骤四 - 安装 JDK (可选)</h3><p>如果你打算在服务器上开发应用，你需要安装本章节中提到的软件。</p>
<p>JDK 确保我们可以开发运行在 Tomcat 服务器上的 Java 应用。运行以下命令来安装 <code>openjdk-7-jdk</code>:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure>
<p>作为 JDK 的附件， Tomcat 文档上建议同时安装用来构建 Java 应用 Apache Ant 工具及包括 Git 在内的源码控制系统。通过下面的命令来安装它们：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install ant git</span><br></pre></td></tr></table></figure>
<p>Apache Ant 的更多信息，可查阅其<a href="http://ant.apache.org/manual/index.html" target="_blank" rel="external">官方文档</a>。 Git 使用教程可以参考<a href="https://www.digitalocean.com/community/articles/how-to-use-git-effectively" target="_blank" rel="external">这里</a>。</p>
<h3 id="步骤五_-_配置_Tomcat_Web_管理器">步骤五 - 配置 Tomcat Web 管理器</h3><p>想要使用步骤三中安装的 Web 应用管理器，需要先登录到 Tomcat 服务器。首先需要编辑修改 <code>tomcat-users.xml</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>tomcat7<span class="regexp">/tomcat-users.xml</span></span><br></pre></td></tr></table></figure>
<p>该文件充满了用于说明如何配置的注释。你需要删除下面两行之间的所有注释。如需要用作参考，则保留。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;tomcat-users&gt;</span></span><br><span class="line"><span class="tag">&lt;/tomcat-users&gt;</span></span><br></pre></td></tr></table></figure>
<p>你需要添加一个用户，可以访问 <code>manager-gui</code> 和 <code>admin-gui</code> （我们在步骤三种安装的管理界面）。你可以通过如下的配置来定义一个用户。如果需要，确保修改用户名和密码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tomcat-users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">user</span> <span class="attribute">username</span>=<span class="value">"admin"</span> <span class="attribute">password</span>=<span class="value">"password"</span> <span class="attribute">roles</span>=<span class="value">"manager-gui,admin-gui"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存并退出 <code>tomcat-users.xml</code> 文件。重启 Tomcat 服务，以便修改配置生效。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> service tomcat7 restart</span><br></pre></td></tr></table></figure>
<h3 id="步骤六_-_访问_Web_界面">步骤六 - 访问 Web 界面</h3><p>现在，我们已经配置了一个管理员用户，从 Web 浏览器访问 Web 管理器页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your-ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你可以看到的页面如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_3.png" alt="image"></p>
<p>从上面可以看到，里面有四个链接到步骤三中安装的软件包：</p>
<ul>
<li>tomcat7-docs: Tomcat 的在线文档。通过 <code>http://your_ip_address:8080/docs/</code> 来访问</li>
<li>tomcat7-examples: Tomcat 7 Servlet 和 JSP 示例。你可以点击这些示例 Web 应用来了解它们是怎么工作的（通过源码可以了解它们是怎么实现的）。通过 <code>http://your_ip_address:8080/examples/</code> 来访问</li>
<li>tomcat7-admin ( Web 应用管理器): Tomcat Web 应用管理器。通过这里来管理你的 Java 应用。</li>
<li>tomcat7-admin (主机管理器): Tomcat 虚拟主机管理器。</li>
</ul>
<p>通过打开链接 <code>http://your_ip_address:8080/manager/html</code> ，来查看 Web 应用管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_1.png" alt="image"></p>
<p>这个Web应用管理器使用来管理Java应用的。你可以在这里执行应用的启动，停止，重新加载，部署，下架等操作。还可以对应用做一些诊断（如内存泄露）。最后，你服务器的相关信息被显示在页面的最底部。</p>
<p>通过打开链接 <code>http://your_ip_address:8080/host-manager/html</code> ，来查看虚拟主机管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_2.png" alt="image"></p>
<p>在虚拟主机管理页面，你可以为应用程序添加虚拟主机。</p>
<h3 id="结束">结束</h3><p>Tomcat 的安装到此结束。你现在就可以免费得来部署自己的 Web 应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>]]>
    
    </summary>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="tomcat" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是 Jenkins?]]></title>
    <link href="http://linfuyan.com/what-is-jenkins/"/>
    <id>http://linfuyan.com/what-is-jenkins/</id>
    <published>2015-09-26T15:13:09.000Z</published>
    <updated>2015-09-26T15:26:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
<ul>
<li><strong>持续构建/测试软件项目</strong>，类似于 <code>CruiseControl</code> 或者 <code>DamageControl</code> 。简而言之， Jenkins 提供一个使用简单地持续集成系统，使得开发人员更方便的集成项目修改，让用户更容易地获取较新的构建版本。自动化持续构建极大提高了生产力。</li>
<li><strong>监控外部运行任务的执行</strong>，比如配置在本地或者远程的 <code>cron</code> 或 <code>procmail</code> 任务。拿 <code>cron</code> 举个例子，你将收到的是一些包含输出结果的常规电子邮件，提醒你勤快地处理它们，当它们出错时，也可以第一时间提醒你。 Jenkins 保存这些输出，并使得出现问题时的通知变得简单。</li>
</ul>
<h3 id="特性">特性</h3><p>Jenkins 所提供(拥有)的特性如下：</p>
<ol>
<li><strong>易于安装</strong>：只需要一个名为 jenkins.war 的 Java jar 包，或者将它发布到 servlet 容器。不需要其他附件安装，不需要数据库。</li>
<li><strong>易于配置</strong>：整个 Jenkins 的配置都可以通过它友好的 Web 界面来完成。不在需要别扭的 XML 手动配置，如果你依然愿意，可以继续使用。</li>
<li><strong>修改设置的支持</strong>： Jenkins 可以从 <code>Subversion/CVS</code> 生成一系列的修改列表来完成构建。这种方式也非常的前卫，因为减少了从存储库加载资源的步骤。</li>
<li><strong>永久的链接地址</strong>： Jenkins 为大部分的页面提供了简洁可读的 URL ，包括诸如” <code>latest build/latest successful build</code> “这样的永久性链接，可以很轻易的从其他地方链接过来。</li>
<li><strong>RSS/邮件/即时通行集成</strong>：通过 RSS 或者邮件来获取失败时的实时通知，轻而易举地监控构建结果。</li>
<li><strong>标记构建过程</strong>：当构建完成以后，可以对其进行标记存储。</li>
<li><strong>JUnit/TestNG 测试报告</strong>： JUnit 的测试报告及历史信息，可以表格形式总结与展示，比如构建在什么时候开始出错等等。历史趋势以图表形式绘制出来。</li>
<li><strong>分布式构建</strong>： Jenkins 可以分配构建/测试到多台电脑商。</li>
<li><strong>文件指纹</strong>： Jenkins 可以跟踪那次构建生成了哪些 jar 包，哪些构建使用了哪个版本的 jar 包等等。这些对不是 Jenkins 内部产生的 jar 包也有效，非常适合于项目中的依赖跟踪。</li>
<li><strong>插件支持</strong>： Jenkins 可以轻易地通过第三方插件进行扩展。你甚至可以为自己的团队使用编写合适的 Jenkins 插件。</li>
</ol>
<h3 id="Jenkins_由来">Jenkins 由来</h3><p>目前持续集成（ CI ）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，只在缓和和稳固软件的构建过程，并且能够帮助你的开发团队应对如下挑战：</p>
<ul>
<li>软件构建自动化：配置完成后， CI 系统会依照预先定制的时间表，或者针对某一特定事件，对目标软件进行构建。</li>
<li>构建可持续的自动化检查： CI 系统能持续地获取新增或者修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时， CI 系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力。</li>
<li>构建可持续的自动化测试：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知给相关的当事人。</li>
<li>生成后后续过程的自动化：当自动化检查和测试成功完成以后，软件构建的周期中可能需要一些额外的任务，诸如生成文档，打包软件，部署构建到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。</li>
</ul>
<p>部署一个 CI 系统需要的最低要求是，一个可获取的源代码仓库，一个包含构建脚本的项目。</p>
<p>CI 系统的基本结构，如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/jenkins-basic-structure.jpg" alt="image"></p>
<p>该系统的各个组成部分是按如下顺序发挥作用的：</p>
<ol>
<li>开发这检入代码到源代码仓库。</li>
<li>CI 系统会为每一个项目创建一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</li>
<li>CI 系统会在对应的工作区内执行构建过程。</li>
<li>如果配置存在，构建完成后， CI 系统会在一个新的构建中执行定义的一套测试。完成后出发通知（RSS，邮箱等等）给相关的当事人。</li>
<li>如果配置存在，在构建成功后，这个构建会被打包并转移到一个部署目标（如应用服务器）或存储为软件仓库中的一个新版本。软件仓库可以是 CI 系统的一部分，也可以是一个外部的仓库，诸如一个文件或者服务器或者像 Java.net 、 SourceForge 之类的网站。</li>
<li>CI 系统通常会根据请求发起相应地操作，诸如及时构建、生成报告，或者检索一些构建好的构件。</li>
</ol>
<p>Jenkins 就是这样的一个 CI 系统。它的主要目标在于监控软件开发流程，快速显示问题。所以能保证开发人员以及相关人员省时省力提高开发效率。</p>
<p>在整个开发过程中， CI 的作用主要是控制：当系统在代码库中探测到修改是，它将运行构建的任务委托给构建过程本身。如果构建失败了，那么 CI 将通知相关人员，然后继续监视存储库。</p>
<h4 id="参考">参考</h4><ol>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins01.html" target="_blank" rel="external">Jenkins是什么</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins" target="_blank" rel="external">Meet Jenkins</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
]]>
    </summary>
    
      <category term="CI" scheme="http://linfuyan.com/tags/CI/"/>
    
      <category term="jenkins" scheme="http://linfuyan.com/tags/jenkins/"/>
    
      <category term="持续集成" scheme="http://linfuyan.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="构建" scheme="http://linfuyan.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="测试" scheme="http://linfuyan.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化" scheme="http://linfuyan.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jenkins" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/jenkins/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Hueman 主题添加侧边栏添加微信公众号二维码]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/add-weixin-qrcode-to-hueman-sidebar/"/>
    <id>http://linfuyan.com/hexo-your-blog/add-weixin-qrcode-to-hueman-sidebar/</id>
    <published>2015-09-26T14:38:53.000Z</published>
    <updated>2015-09-26T14:57:45.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章中，我们来在 Hueman 主题的侧边栏中添加微信公众号的二维码。</p>
<p>1. 找到 themes/hueman 下的配置文件 _config.yml，添加 weixin 变量配置为二维码地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置关注微信公众号</span></span><br><span class="line">weixin: http://<span class="number">7</span>sbydj.com1.z0.glb.clouddn.com/static/images/qrcode_<span class="keyword">for</span>_gh_3ad92a8<span class="built_in">fc</span>23c_860.jpg</span><br></pre></td></tr></table></figure>
<p>2. 在 themes/huema/layout/_widget 目录下新建 weixin.ejs 文件，添加如下代码</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (theme.weixin)&#123; </span>%&gt;<span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"widget-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> theme.weixin </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">width</span>=<span class="value">"100%"</span> <span class="attribute">height</span>=<span class="value">"100%"</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span>&lt;%<span class="ruby"> &#125; </span>%&gt;<span class="xml"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里根据是否存在1中的微信二维码链接来控制这个模块的显示。可以根据实际需要设置样式。</p>
</blockquote>
<p>3. 修改 themes/hueman/_config.yml , 在 widgets 添加 weixin。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">-<span class="ruby"> weixin</span><br><span class="line"></span>-<span class="ruby"> recent_posts</span><br><span class="line"></span>-<span class="ruby"> tagcloud</span><br><span class="line"></span>-<span class="ruby"> category</span><br><span class="line"></span>-<span class="ruby"> archive</span><br><span class="line"></span>-<span class="ruby"> tag</span><br><span class="line"></span>-<span class="ruby"> links</span></span><br></pre></td></tr></table></figure>
<h4 id="总结：">总结：</h4><p>本节中通过将微信公众账号的二维码作为一个组件( weixin.ejs )，利用 hueman 主题已有的侧边栏配置，非常方便的实现了微信公众账号二维码的添加。</p>
<p>同时也欢迎大家关注：非典型程序员</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/qrcode_for_gh_3ad92a8fc23c_860.jpg" alt="非典型程序员"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章中，我们来在 Hueman 主题的侧边栏中添加微信公众号的二维码。</p>
<p>1. 找到 themes/hueman 下的配置文件 _config.yml，添加 weixin 变量配置为二维码地址。</p>
<figure class="highlight ba]]>
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="Hueman" scheme="http://linfuyan.com/tags/Hueman/"/>
    
      <category term="二维码" scheme="http://linfuyan.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="微信公众号" scheme="http://linfuyan.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[声明式编程范式初探]]></title>
    <link href="http://linfuyan.com/declarative-programming-intro/"/>
    <id>http://linfuyan.com/declarative-programming-intro/</id>
    <published>2015-09-26T14:03:09.000Z</published>
    <updated>2015-09-26T14:10:51.000Z</updated>
    <content type="html"><![CDATA[<p>语言编程语言可以分成两类：</p>
<ul>
<li>命令式</li>
<li>声明式</li>
</ul>
<p>事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/categaries-of-programming-paradigm.jpg" alt="编程范式的简单分类"></p>
<p>与命令式编程相对的声明式编程（ declarative programming ）。顾名思义，声明式编程由若干规范（ specification ）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。</p>
<a id="more"></a>
<h4 id="声明式编程的发源">声明式编程的发源</h4><p>声明式编程发轫于人工智能的研究，主要包括函数式编程（ functional programming ，简称 FP ）和逻辑式编程（ logic programming ，简称 LP ）。其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。</p>
<p>其实支持它们的语言出现得并不比命令式的晚多少——最早的函数式语言 Lisp （ <strong>LIS</strong>t <strong>P</strong>rocessor ）已有半个世纪的历史，最早之一的逻辑式语言 Prolog （ <strong>PRO</strong>gramming in <strong>LOG</strong>ic ）也与 C 同龄。只是由于大多数更多地用于学术研究而非商业应用，颇有些‘养在深闺人未识’的味道。</p>
<p>起源的不同决定了这两大类范式代表着迥然不同的编程理念和风格：命令式编程是行动导向（ Action-Oriented ）的，因而算法是显性而目标是隐性的；声明式编程是目标驱动（ Goal-Driven ）的，因而目标是显性而算法是隐性的。为便于说明，我们分别用三种代表性的语言来实现阶乘（ factorial ）运算。</p>
<h4 id="阶乘的三种编程实现">阶乘的三种编程实现</h4><p>C(命令式) –</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; n &gt; <span class="number">0</span>; --n) f *= n;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Liap(函数式) –</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun factorial(<span class="keyword">n</span>)</span><br><span class="line">  (<span class="keyword">if</span> (= <span class="keyword">n</span> 0)</span><br><span class="line">	1                               <span class="comment">//  若n等于0，则n!等于1</span></span><br><span class="line">	(* <span class="keyword">n</span> (factorial(- <span class="keyword">n</span> 1)))))      <span class="comment">//  否则n!等于n* (n-1)</span></span><br></pre></td></tr></table></figure>
<p>Prolog(逻辑式) –</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0! 等于1</span></span><br><span class="line">factorial(0,1).</span><br><span class="line"><span class="comment">// 若M等于N-1且 M!等于Fm且F等于N*Fm，则N! 等于F</span></span><br><span class="line">factorial(<span class="keyword">N</span>,F) :-   <span class="keyword">M</span> is <span class="keyword">N</span>-1, factorial(<span class="keyword">M</span>,Fm), F is <span class="keyword">N</span> * Fm.</span><br></pre></td></tr></table></figure>
<p>以上三段代码区别在哪里？ C 明确给出了阶乘的迭代算法，而 Lisp 仅描述了阶乘的递归定义， Prolog 则陈述了两个关于阶乘的断言。</p>
<h4 id="声明式编程的本质">声明式编程的本质</h4><p>我们最早接触的变量是代数方程中的 x、y、z 等，本质上是抽象化的符号，变量值是该符号在给定约束条件下的允许值。而命令式编程中的变量本质上是抽象化的内存，变量值是该内存的储存内容。通俗地说，前者好比姓名，所指之人是固定的；后者好比住址，所住之人是变化的。此外，等号在代数中是一种约束，而在许多命令式语言中则表示赋值。因此 i = i + 1 可以在命令式编程中出现，但绝不可能在数学推理中出现 —— 除非在反证法中。</p>
<p>声明式编程让我们重回数学思维：函数式编程类似代数中的表达式变换和计算，逻辑式编程则类似数理逻辑推理。其中的变量也如数学中的一样，是抽象符号而非内存地址，因此没有赋值运算，不会产生变量被改写的副作用（ side-effect ），也不存在内存分配和释放的问题。这既简化了代码，也减少了调试——不妨想一想，有多少bug是由于某个变量被意外改写或内存管理不慎而造成的？</p>
<p><strong>声明式语言与命令式语言的相通之处</strong></p>
<ul>
<li>首先，所有高级语言都建立于低级语言之上，最终转化为机器语言，声明式语言也不例外。</li>
<li>其次，声明式语言与命令式语言并非泾渭分明，而是互相交叉渗透的。一些‘非纯粹’ 的声明式语言也提供变量赋值和流程控制，而一些命令式语言也在逐渐发展，通过利用其他程序或增加新的语言特征来实现声明式编程。</li>
</ul>
<p>总的说来，在命令式语言中融入声明式的元素应当是一种趋势。尤其是函数式，它的一些特征已经在许多命令式语言中得到了支持。比较而言，声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简洁清晰、易于修改和维护。从这种意义上说，声明式语言天然地就比命令式语言更高级。</p>
<blockquote>
<p>既然声明式编程有这么多好处，为什么命令式语言不仅占大多数，而且流行程度也不减呢？</p>
<p>编程语言的流行程度与其擅长的领域关系密切。声明式语言——尤其是函数式语言和逻辑式语言——擅长基于数理逻辑的应用，如人工智能、符号处理、数据库、编译器等，对基于业务逻辑的、尤其是交互式或事件驱动型的应用就不那么得心应手了。而大多数软件是面向用户的，交互性强、多为事件驱动、业务逻辑千差万别，显然命令式语言在此更有用武之地。</p>
</blockquote>
<p>值得指出的是，声明式编程并不仅仅局限于函数式和逻辑式。比方说， C# 中的 attribute 、 Java 中的 annotation 和 XDoclet 库等采用的也是具有声明式特征的属性导向式编程（ Attribute-Oriented Programming ，简称 @OP ）。再比如， Prograph 、 SISAL 等数据流语言（ dataflow language ）采用的数据流式编程（ Dataflow Programming ）与函数式编程有不少共同点，同样属于声明式的范畴。还有一些语言如 Oz 、 CHIP 等支持与逻辑式编程相交的约束式编程（ Constraint Programming ）。此外，大家熟悉的数据库语言 SQL ，样式语言 XSLT、 CSS，标记语言 HTML 、 XML 、 SVG ，规范语言 IDL （ Interface Description Language ）等等都是声明式的。算上它们，声明式语言所占的比例也是非常可观的。此前之所以没有提及，一方面，不少声明式语言采用的范式并没有专门的名称；另一方面，这些语言大多是领域特定语言，并且不少并非图灵完备的，有的连运算都没有。毕竟，目前我们的重点还是放在通用编程语言上。</p>
<p>其实用 Lisp 实现阶乘的方法也可以用在 C 上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : <span class="function">n * <span class="title">factorial</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 C 的递归实现。除了细微的语法差别外，二者的确很相似，这说明用命令式语言也可以讲出声明式的味道。实际上，命令式语言提倡迭代而不鼓励递归，早期的 Fortran 甚至都不支持递归。一则迭代比递归更符合命令式的思维模式，因为前者贴近机器语言而后者贴近数学语言；二则除尾递归（ tail recursion ）外，一般递归比迭代的开销（ overhead ）大。相反，声明式语言提倡递归而不支持迭代。就语法而言，它不允许迭代中的循环变量；就视角而言，迭代着眼微观过程而递归着眼宏观规律。</p>
<p>归根结底，<strong>编程是寻求一种机制，将指定的输入转化为指定的输出。</strong>三种范式对此提供了截然不同的解决方案：</p>
<ul>
<li>命令式把程序看作一个自动机，输入是初始状态，输出是最终状态，编程就是设计一系列指令，通过自动机执行以完成状态转变；</li>
<li>函数式把程序看作一个数学函数，输入是自变量，输出是因变量，编程就是设计一系列函数，通过表达式变换以完成计算；</li>
<li>逻辑式把程序看作一个逻辑证明，输入是题设，输出是结论，编程就是设计一系列命题，通过逻辑推理以完成证明。</li>
</ul>
<p>绘成表格如下：</p>
<table>
<thead>
<tr>
<th>范式</th>
<th>程序</th>
<th>输入</th>
<th>输出</th>
<th>程序设计</th>
<th>程序运行</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令式</td>
<td>自动机</td>
<td>初始状态</td>
<td>最终状态</td>
<td>设计指令</td>
<td>命令执行</td>
</tr>
<tr>
<td>函数式</td>
<td>数学函数</td>
<td>自变量</td>
<td>因变量</td>
<td>设计函数</td>
<td>表达式变换</td>
</tr>
<tr>
<td>逻辑式</td>
<td>逻辑证明</td>
<td>题设</td>
<td>结论</td>
<td>设计命题</td>
<td>逻辑推理</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>语言编程语言可以分成两类：</p>
<ul>
<li>命令式</li>
<li>声明式</li>
</ul>
<p>事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/categaries-of-programming-paradigm.jpg" alt="编程范式的简单分类"></p>
<p>与命令式编程相对的声明式编程（ declarative programming ）。顾名思义，声明式编程由若干规范（ specification ）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。</p>]]>
    
    </summary>
    
      <category term="命令式" scheme="http://linfuyan.com/tags/%E5%91%BD%E4%BB%A4%E5%BC%8F/"/>
    
      <category term="声明式" scheme="http://linfuyan.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://linfuyan.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="范式" scheme="http://linfuyan.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
      <category term="语言" scheme="http://linfuyan.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="基础理论" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Ubuntu 14.04 上安装Linux, Apache, MySQL, PHP (LAMP)组件]]></title>
    <link href="http://linfuyan.com/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04/"/>
    <id>http://linfuyan.com/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04/</id>
    <published>2015-09-26T13:29:00.000Z</published>
    <updated>2015-09-26T13:52:05.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04</a></p>
<h4 id="介绍">介绍</h4><p>“ LAMP “组件是一组典型的安装在一起的开源软件，用于服务器搭建动态网站和 Web 应用。实际上，这是一个首字母缩写的组合，代表了 Linux 操作系统安装 <strong>A</strong>pache Web 服务器。网站的数据存储在 <strong>M</strong>ySQL 数据库中，并由 <strong>P</strong>HP 提供动态内容。</p>
<a id="more"></a>
<p>在这篇向导中，我们将在 Ubuntu 14.04 Droplet 上搭建 LAMP 。 Ubuntu 提供了我们的第一个需求：一个 <strong>L</strong>inux 操作系统。</p>
<h3 id="先决条件">先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照<a href="https://www.digitalocean.com/community/articles/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="external">Ubuntu 14.04上搭建服务器</a>中的1-4步来学习完成它。</p>
<h3 id="步骤一_-_安装Apache">步骤一 - 安装<strong>A</strong>pache</h3><p>Apache web 服务器是目前世界上最流行的 web 服务器，是挂载站点的最佳默认选择。</p>
<p>我们将通过 Ubuntu 的包管理器 <code>apt</code> 来便捷地安装 Apache。这个包管理器让我们可以毫无痛苦的从 Ubuntu 维护的存储库中来安装大多数的软件。更多关于 <code>apt</code> 的信息，可以看这里<a href="https://www.digitalocean.com/community/articles/how-to-manage-packages-in-ubuntu-and-debian-with-apt-get-apt-cache" target="_blank" rel="external">如何使用 apt</a>。</p>
<p>为了我们的目标，我们可以从输入这些命令开始：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install apache2</span><br></pre></td></tr></table></figure>
<p>由于我们使用 <code>sudo</code> 命令，这些操作在 root 权限下执行。这将要求你输入常规用户的密码来验证你的意图。</p>
<p>在此之后，你的 web 服务器就安装好了。</p>
<p>你可以马上做一些验证来确定一起如预期进行。在浏览器中输入你服务器的公网IP地址：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_server_IP_address</span></span><br></pre></td></tr></table></figure>
<p>你将看到默认的 Ubuntu 14.04 Apache 页面，这个页面展示的目的是出于测试及显示信息。看起来他是这样的：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/default_apache.png" alt="image"></p>
<p>如果你看到这个页面，说明你的 web 服务器正确安装了。</p>
<h4 id="如何找到你的服务器的公网_IP_地址">如何找到你的服务器的公网 IP 地址</h4><p>如果你不知道服务器的公网IP地址是什么，可以有多重方式来找到。通常，这个地址是你用来通过SSH来连接你的服务器的。</p>
<p>在命令行下，有一些方法来找到。首先，你可以使用 <code>iproute2</code> 工具来获取地址，输入以下命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ip</span> addr show eth0 | grep inet | awk <span class="string">'&#123; print <span class="variable">$2</span>; &#125;'</span> | sed <span class="string">'s/\/.*$//'</span></span><br></pre></td></tr></table></figure>
<p>这个将返回一行或两行输出。这两个都是正确地地址，但是你的电脑只能用其中之一，因此放松地尝试每一个。</p>
<p>另一种方法是通过外部的第三方工具来查看你的服务器。你可以通过访问一个确定的服务器来查看自己的IP地址。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">http:</span><span class="comment">//icanhazip.com</span></span><br></pre></td></tr></table></figure>
<p>不论你用哪种方法获取到了自己的IP地址，你可以在浏览器的地址栏中来访问服务器。</p>
<h3 id="步骤二_-_安装_MySQL">步骤二 - 安装 <strong>M</strong>ySQL</h3><p>现在我们已经安装了 web 服务器，并正常运行，是时候安装 MySQL 了。 MySQL 是一个数据库管理系统。最基本的，它用来组织和访问用来存储我们站点信息的数据库。</p>
<p>我们再次用 <code>apt</code> 工具来获取和安装软件。这次，我们还需要安装一些其他的辅助工具包，来让安装的组件相互通信:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> mysql-<span class="keyword">server</span> php5-mysql</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在这里，你不需要在执行这个命令之前，执行 <code>sudo apt-get update</code> 。因为我们在之前安装 Apache 的时候已经执行过了。你电脑上的包索引已经是最新的了。</p>
<p>在安装过程中，你的服务器会让你为 MySQL 的 root 用户选择并设置密码。这在 MySQL 中是一个具有管理员权限的账号。这个有点类似于操作系统中的 root 账号（尽管如此，你目前所配置的账号仅针对 MySQL ）。</p>
<p>当安装结束，我们需要运行一些额外的命令，来保证我们的 MySQL 环境足够安全。</p>
<p>首先，我们需要告诉 MySQL 来创建它用于存储信息的数据库目录结构。你需要输入：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mysql_install_db</span><br></pre></td></tr></table></figure>
<p>然后我们要运行一些简单地安全脚本来消除默认的危险配置，并锁定数据的访问。通过输入如下命令，来开始使用交互脚本：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>你会被要求输入所设置的 MySQL 的 root 账号密码。接下来，会被问到是否想要修改密码，如果你对现有的密码满意，输入 <code>n</code> 代表 <code>no</code> 并提交。</p>
<p>接下来的问题中，你只需简单地回车来使用默认配置。这样做会移除一些测试用户和数据库，禁止 root 用户远程登录，加载这些新的配置，以便我们的修改在 MySQL 中立即生效。</p>
<p>到这里，你的数据库系统已经建立，可以继续下一步。</p>
<h3 id="步骤三_-_安装_PHP">步骤三 - 安装 <strong>P</strong>HP</h3><p>PHP 是我们安装的一个组件，用于处理代码以显示动态内容。它可以运行脚本，连接到 MySQL 数据库来获取信息，并传输处理好的内容到web服务器来显示。</p>
<p>我们可以再次利用 <code>apt</code> 工具来安装我们的组件。同样，我们会包含一些辅助包：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install php5 libapache2-<span class="keyword">mod</span>-php5 php5-mcrypt</span><br></pre></td></tr></table></figure>
<p>这样安装 PHP 将不会有任何问题，我们将马上测试。</p>
<p>在大部分情况下，当请求文件夹时，我们需要修改 Apache 服务器上处理文件的方式。现在，如果一个用户向服务器请求目录， Apache 会首先寻找名为 <code>index.html</code> 的文件。我们需要告诉我们的 web 服务器优先处理 PHP 文件，因此我们让 Apache 首先寻找 <code>index.php</code> 。</p>
<p>要完成这个，输入以下命令来在文本编辑器中打开 <code>dir.conf</code> 文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apache2<span class="regexp">/mods-enabled/</span>dir.conf</span><br></pre></td></tr></table></figure>
<p>找到如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">    DirectoryIndex index<span class="class">.html</span> index<span class="class">.cgi</span> index<span class="class">.pl</span> index<span class="class">.php</span> index<span class="class">.xhtml</span> index<span class="class">.htm</span></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>我们将其中的 <code>index.php</code> 移到第一项的位置，在 <code>DirectoryIndex</code> 之后，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_dir.c&gt;</span><br><span class="line">	DirectoryIndex index<span class="class">.php</span> index<span class="class">.html</span> index<span class="class">.cgi</span> index<span class="class">.pl</span> index<span class="class">.xhtml</span> index<span class="class">.htm</span></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>当操作完成，按下 <code>CTRL-X</code> 保存并退出文件。你需要输入 <code>Y</code> 来确认保存，并点击回车来确认文件保存位置。</p>
<p>在这之后，我们需要重启 Apache web 服务器来使配置修改生效。输入以下命令来完成：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> service apache2 restart</span><br></pre></td></tr></table></figure>
<h4 id="安装_PHP_模块">安装 PHP 模块</h4><p>为了扩展 PHP 的功能，我们可以选择安装一些额外的模块。</p>
<p>查看可选的 PHP 模块和库，可以在系统中输入如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">search</span> php5-</span></span><br></pre></td></tr></table></figure>
<p>结果是所有你可以安装的可选组件，并给出每项的简短介绍。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php5-cgi - server-side, HTML-embedded scripting <span class="keyword">language</span> (CGI binary)</span><br><span class="line">php5-cli - <span class="keyword">command</span>-<span class="built_in">line</span> interpreter <span class="keyword">for</span> the php5 scripting <span class="keyword">language</span></span><br><span class="line">php5-common - Common <span class="keyword">files</span> <span class="keyword">for</span> packages built from the php5 <span class="keyword">source</span></span><br><span class="line">php5-curl - CURL module <span class="keyword">for</span> php5</span><br><span class="line">php5-dbg - Debug symbols <span class="keyword">for</span> PHP5</span><br><span class="line">php5-dev - Files <span class="keyword">for</span> PHP5 module development</span><br><span class="line">php5-gd - GD module <span class="keyword">for</span> php5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>如果想要获取每个模块更多的信息，你可以在互联网上搜索或者通过如下命令查看包内的详细介绍：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">show</span> package_name</span></span><br></pre></td></tr></table></figure>
<p>这将会有许多输出，其中有个名为 <code>Description-en</code> 的区域对模块所提供的功能有详细的解释。</p>
<p>比如说，想要知道 <code>php5-cli</code> 模块的用处，我们可以输入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">show</span> php5-cli</span></span><br></pre></td></tr></table></figure>
<p>从大片的输出信息中，你会看到与如下类似的的内容：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line">SHA256: <span class="number">91</span>cfdbda65df65c9a4a5bd3478d6e7d3e92c53efcddf3436bbe9bbe27eca409d</span><br><span class="line">Description-en: <span class="command"><span class="keyword">command</span>-line <span class="title">interpreter</span> <span class="title">for</span> <span class="title">the</span> <span class="title">php5</span> <span class="title">scripting</span> <span class="title">language</span></span></span><br><span class="line">This package provides <span class="operator">the</span> /usr/bin/php5 <span class="command"><span class="keyword">command</span> <span class="title">interpreter</span>, <span class="title">useful</span> <span class="title">for</span></span></span><br><span class="line">testing PHP scripts <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">shell</span> <span class="operator">or</span> performing general <span class="built_in">shell</span> scripting tasks.</span><br><span class="line">.</span><br><span class="line">The following extensions are built <span class="operator">in</span>: bcmath bz2 calendar Core ctype <span class="built_in">date</span></span><br><span class="line">dba dom ereg exif fileinfo <span class="built_in">filter</span> <span class="keyword">ftp</span> gettext hash iconv libxml mbstring</span><br><span class="line">mhash openssl pcntl pcre Phar posix Reflection session shmop SimpleXML soap</span><br><span class="line">sockets SPL standard sysvmsg sysvsem sysvshm tokenizer wddx xml xmlreader</span><br><span class="line">xmlwriter zip zlib.</span><br><span class="line">.</span><br><span class="line">PHP (recursive acronym <span class="keyword">for</span> PHP: Hypertext Preprocessor) is <span class="operator">a</span> widely-used</span><br><span class="line"><span class="built_in">open</span> source general-purpose scripting language that is especially suited</span><br><span class="line"><span class="keyword">for</span> web development <span class="operator">and</span> can be embedded <span class="keyword">into</span> HTML.</span><br><span class="line">Description-md5: f8450d3b28653dcf1a4615f3b1d4e347</span><br><span class="line">Homepage: <span class="keyword">http</span>://www.php.net/</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>搜索之后，如果你决定要安装某些包，你可以像之前安装软件一样，使用 <code>apt-get</code> 命令来安装这些包。</p>
<p>假设我们想要安装所需的 <code>php5-cli</code> 包，我们输入：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install php5-cli</span><br></pre></td></tr></table></figure>
<p>如果你想要安装多个模块，你可以在 <code>apt-get install</code> 命令之后，列出每个包名，包名之间以空格隔开。像这样：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install <span class="keyword">package</span><span class="number">1</span> <span class="keyword">package</span><span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>到此，我们的组件安装并配置完毕。接下来，我们要测试 PHP。</p>
<h3 id="步骤四_-_在_Web_服务器上测试_PHP">步骤四 - 在 Web 服务器上测试 PHP</h3><p>为了测试我们的系统已经正确配置 PHP ，我们可以新建一个基本的 PHP 脚本。</p>
<p>这个脚本命名为 <code>inifo.php</code> 。为了 Apache 可以正确找到并处理它，它将被保存在名为 <code>web root</code> 的确定目录中。</p>
<p>在 Ubuntu 14.04中，这个目录是 <code>/var/www/html/</code> 。通过以下命令在目标位置新建文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>这将打开一个空文件，我们需要在文件中输入如下有效的PHP代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line">	phpinfo();</span><br><span class="line"><span class="preprocessor">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>操作完成，保存并关闭文件。</p>
<p>现在要测试我们的服务器是否可以正确显示由 PHP 脚本生成的内容。在 web 浏览器中访问这个页面，这时，你需要服务器的公网 IP 地址。</p>
<p>你需要访问的地址如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_server_IP_address/info.php</span></span><br></pre></td></tr></table></figure>
<p>你看到的页面显示如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/default_php.png" alt="image"></p>
<p>这个页面给出了你 web 服务器上的 PHP 信息。这对于你调试，并确保配置信息正确非常有用。</p>
<p>如果这个成功，那么 PHP 已经可以正常运行。</p>
<p>测试完毕，你需要删除这个文件。因为，这会向未授权用户泄露你服务器的信息。输入以下命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>nfo.php</span><br></pre></td></tr></table></figure>
<p>如果你需要查看配置信息，可以再次建立这个文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04</a></p>
<h4 id="介绍">介绍</h4><p>“ LAMP “组件是一组典型的安装在一起的开源软件，用于服务器搭建动态网站和 Web 应用。实际上，这是一个首字母缩写的组合，代表了 Linux 操作系统安装 <strong>A</strong>pache Web 服务器。网站的数据存储在 <strong>M</strong>ySQL 数据库中，并由 <strong>P</strong>HP 提供动态内容。</p>]]>
    
    </summary>
    
      <category term="14.04" scheme="http://linfuyan.com/tags/14-04/"/>
    
      <category term="Apache" scheme="http://linfuyan.com/tags/Apache/"/>
    
      <category term="LAMP" scheme="http://linfuyan.com/tags/LAMP/"/>
    
      <category term="Linux" scheme="http://linfuyan.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://linfuyan.com/tags/MySQL/"/>
    
      <category term="PHP" scheme="http://linfuyan.com/tags/PHP/"/>
    
      <category term="Ubuntu" scheme="http://linfuyan.com/tags/Ubuntu/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="LAMP" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/LAMP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么预期的软件开发周期总是不够?]]></title>
    <link href="http://linfuyan.com/why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/"/>
    <id>http://linfuyan.com/why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/</id>
    <published>2015-09-23T03:56:57.000Z</published>
    <updated>2015-09-23T04:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>有国外开发者在 Quora 提了这个问题：“为什么软件开发周期通常是预期的两三倍？” 并补充问：“这是开发人员的错误？ 是管理失误？ 是因为做事方法不对， 或者说缺乏好的方法？还是说这就是软件开发流程的特点？” Michael Wolfe 在2012年1月28日给的回复，非常经典，截至我们发布时已有8016个赞。以下是译文。</p>
<p>让我们先沿着海岸线，从旧金山（SF）走路去洛杉矶（LA），去拜访我们住在Newport Beach的朋友，我拿出地图在上面画出了行进路线。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl01.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>全程大约有400英里，如果我们每天走10小时每小时4公里的话，只用10天就可以到达目的地。立刻打电话给我们的朋友预定下周六的晚餐，告诉他们下周六晚上六点我们一定会准时出现，朋友们已经等不及了！</p>
<p>第二天清晨，我们带着准备冒险的兴奋起床，背起行囊，拿出地图，准备计划我们冒险的第一天，看一眼地图，噢，不！</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl02.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>哇，海岸线上有这么多迂回曲折的线路。每天行进40英里的话，10天后只能勉强到达Half Moon Bay（半月湾？）。这趟旅行至少有500英里，而不是400。赶紧打电话给我们的朋友，将晚餐顺延至下下周周二。人还是应该现实一点。朋友们有点失望，不过仍然盼望见到我们，况且花 12 天从 SF 到 LA 也不赖。</p>
<p>把不开心的事丢到一边，准备出发。两小时过后，我们才刚刚走出动物园。出了什么事？我们低头看了一下脚下的路：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcg03.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天哪，这样走路也太慢了！有沙子、海水、阶梯、溪流，还有海边愤怒的海狮！这样我们只能按每小时2公里的速度前进，只有我们预估一般的速度。要么我们现在每天走20小时，要么再把晚餐推迟一个星期。好吧，让我们各退一步：每天走12个小时，把晚餐安排到下下周的周末。只好再打电话给朋友告诉他们这个情况。朋友们有些不高兴，但还是表示可以，到时候见。</p>
<p>在辛苦走了12小时后，我们准备在 Moss Beach 扎营休息。靠，要把帐篷在风中立起来根本不可能。直到半夜才开始休息。不过没什么大不了：明天在加快点速度就可以了。</p>
<p>第二天早上睡过头了，早上10点才醒，起来浑身酸痛精疲力尽。艹，今天没法走12个小时了，先走10个小时，明天可以走14个小时。收拾东西出发。</p>
<p>再缓慢行进了几个小时之后，我发现伙伴脚有点跛。妈的，是水泡。必须现在解决它，在这些问题开始减慢我们的速度前，必须将它们扼杀在萌芽状态。我慢跑了45分钟到达内陆3英里远的Pescadero，买了一些创可贴再快速跑回去给朋友包扎了一下。我快累坏了，太阳也快下山了，又浪费了一天的时间。到我们准备休息前今天只走了6英里。但是我们确实需要补充一下供给。一切都很好，明天我们就能赶上。</p>
<p>第二天醒来，扎紧脚上的绷带准备出发。转角之后突然发现，靠！这是个啥？</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl04.jpg" alt="为什么预期的软件开发周期总是不够？"></p>
<p>你妹的地图上怎么没标出它！现在我们只能往内陆走3英里，绕过这些被联邦政府用栅栏保护起来的区域，中途迷路了两次，在中午前才好不容易又回到了海岸线。今天的时间过了一大半，而我们才前进了差不多1英里。好吧，不过我们不会再打电话给朋友推迟了，今天我们会一直走到午夜试着赶上进度。</p>
<p>晚上在大雾里断断续续地睡了一夜。一大早被我的伙伴叫醒，他一阵阵的头疼，还有点发烧，我问他能不能坚持一下。“你在想什么呢，混蛋，我已经连续三天在这么冷的雾中赶路，没有休息过了。“好吧，今天看来只能黄了，只能在原地好好恢复了。现在我们已经有经验了，今天好好休息明天再走14个小时，还有几天的时间，我们一定能够做到！</p>
<p>第二天我们昏昏沉沉地起来了。我看了一眼随身的地图：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/gcgl05.png" alt="为什么预期的软件开发周期总是不够？"></p>
<p>天啊！我们已经走了10天旅程里的第5天还没有离开海湾区域！太荒唐了！我们要重新估计一下准确的时间再打给朋友，搞不好会被骂，但至少得找一个现实一点的目标。</p>
<p>同伴说，我们在四天里走了40英里，这趟旅程至少又600英里，那就至少要60天，安全一点的说法说不定要70天，“没门…是，以前我是没走路从SF去过LA，但肯定不会要70天的时间，如果告诉他们我们要到复活节才能到，那要被他们笑死的“，我说。</p>
<p>我接着说，“如果你能保证每天走16个小时，我们就能把落下的时间补回来！我知道很困难，但现在是最关键的时刻，别抱怨了！”伙伴对我吼道 “一开始又不是我告诉别人下周日我们就能到的！因为你犯的这个错差点要我的命！”</p>
<p>两个人就这样不说话了。我还是没打出电话，等我的伙伴明天冷静一点我再决定，我也愿意做一些更合理的承诺。</p>
<p>第二天上午，我们一直待在各自的帐篷中直到一场暴风雨袭来。我们赶紧收拾好东西直到10点才摆脱危险。浑身酸痛，又长了好多新水泡。之前发生的事谁也没提，直到发现我那愚蠢的伙伴把水壶落下了，又被我指责了一顿，我们不得不再花30分钟回去取它。</p>
<p>我心里记得我们的厕纸已经快用完了，下次到一个小镇的时候应该囤一点。在我们又转个弯后，才发现一条湍急的河流挡住了去路，这时我突然感到肚子一阵难受……</p>
<p>本文来自伯乐在线：<a href="http://blog.jobbole.com/45756/" target="_blank" rel="external">趣文：为什么软件开发周期通常是预期的两三倍？</a>，译者：</p>
<p>英文出处：<a href="http://www.quora.com/Engineering-Management/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3" target="_blank" rel="external">Engineering Management: Why are software development task estimations regularly off by a factor of 2-3?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有国外开发者在 Quora 提了这个问题：“为什么软件开发周期通常是预期的两三倍？” 并补充问：“这是开发人员的错误？ 是管理失误？ 是因为做事方法不对， 或者说缺乏好的方法？还是说这就是软件开发流程的特点？” Michael Wolfe 在2012年1月28日给的回复，非]]>
    </summary>
    
      <category term="估计" scheme="http://linfuyan.com/tags/%E4%BC%B0%E8%AE%A1/"/>
    
      <category term="周期" scheme="http://linfuyan.com/tags/%E5%91%A8%E6%9C%9F/"/>
    
      <category term="开发" scheme="http://linfuyan.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="管理" scheme="http://linfuyan.com/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="软件" scheme="http://linfuyan.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="项目" scheme="http://linfuyan.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="深度文摘" scheme="http://linfuyan.com/categories/%E6%B7%B1%E5%BA%A6%E6%96%87%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 安装出现 Cannot find module 错误]]></title>
    <link href="http://linfuyan.com/faq/install-hexo-occur-connot-find-module-error/"/>
    <id>http://linfuyan.com/faq/install-hexo-occur-connot-find-module-error/</id>
    <published>2015-09-19T06:46:57.000Z</published>
    <updated>2015-09-19T06:59:38.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Hexo 的过程中，有时会遇到下面的错误：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Release/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/default/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Debug/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>从提示上看，问题的原因是缺少某些库，估计是由于天朝网络的问题，导致某些库没有完成下载就停止了。</p>
<p>可以换一个<a href="http://www.linfuyan.com/faq/npm-taobao-registry/" target="_blank" rel="external">国内的 npm 源</a>，然后重新安装 Hexo：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install hexo —<span class="literal">no</span>-optional</span><br></pre></td></tr></table></figure>
<p>原文：<a href="http://segmentfault.com/a/1190000002979092#articleHeader5" target="_blank" rel="external">http://segmentfault.com/a/1190000002979092#articleHeader5</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装 Hexo 的过程中，有时会遇到下面的错误：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span cl]]>
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="安装" scheme="http://linfuyan.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="解决方案" scheme="http://linfuyan.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="错误" scheme="http://linfuyan.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[npm 官网镜像无法连接怎么办?]]></title>
    <link href="http://linfuyan.com/faq/npm-taobao-registry/"/>
    <id>http://linfuyan.com/faq/npm-taobao-registry/</id>
    <published>2015-09-19T03:34:29.000Z</published>
    <updated>2015-09-19T03:45:14.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Hexo 是需要先安装 Node.js，这个过程中会因为 npm 无法连接到官方 registry 而导致失败。</p>
<p>后来在网上搜到有淘宝的镜像，具体的配置方法有如下几种：</p>
<p>1. 通过 config 命令</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> https://<span class="keyword">registry</span>.npm.taobao.org </span><br><span class="line">npm <span class="keyword">info</span> underscore //如果上面配置正确这个命令会有字符串response</span><br></pre></td></tr></table></figure>
<p>2. 命令行指定</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">npm</span> --registry <span class="url">https://registry.npm.taobao.org</span> <span class="built_in">info</span> underscore</span><br></pre></td></tr></table></figure>
<p>3. 编辑 ~/.npmrc 加入下面内容</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>第三种方案只需配置一次。</p>
<p>原文：<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank" rel="external">使用npm安装一些包失败了的看过来（npm国内镜像介绍）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装 Hexo 是需要先安装 Node.js，这个过程中会因为 npm 无法连接到官方 registry 而导致失败。</p>
<p>后来在网上搜到有淘宝的镜像，具体的配置方法有如下几种：</p>
<p>1. 通过 config 命令</p>
<figure class=]]>
    </summary>
    
      <category term="npm" scheme="http://linfuyan.com/tags/npm/"/>
    
      <category term="registry" scheme="http://linfuyan.com/tags/registry/"/>
    
      <category term="taobao" scheme="http://linfuyan.com/tags/taobao/"/>
    
      <category term="镜像" scheme="http://linfuyan.com/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 技能树]]></title>
    <link href="http://linfuyan.com/iOS-skills/"/>
    <id>http://linfuyan.com/iOS-skills/</id>
    <published>2015-09-17T01:36:00.000Z</published>
    <updated>2015-09-17T01:41:59.000Z</updated>
    <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 iOS 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="external">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/Android-skills" target="_blank" rel="external">Android 技能</a>请猛戳这里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/iOS-skills.png" alt="iOS 技能树"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是和团队小伙伴们一起整理的 iOS 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blan]]>
    </summary>
    
      <category term="iOS" scheme="http://linfuyan.com/tags/iOS/"/>
    
      <category term="基础" scheme="http://linfuyan.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习路线" scheme="http://linfuyan.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="技能" scheme="http://linfuyan.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="进阶" scheme="http://linfuyan.com/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 技能树]]></title>
    <link href="http://linfuyan.com/Android-skills/"/>
    <id>http://linfuyan.com/Android-skills/</id>
    <published>2015-09-17T01:25:00.000Z</published>
    <updated>2015-09-17T01:51:47.000Z</updated>
    <content type="html"><![CDATA[<p>以下是和团队小伙伴们一起整理的 Android 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_blank" rel="external">我们公司</a>一试的同学，欢迎投简历。</p>
<p>同时，<a href="http://www.linfuyan.com/iOS-skills" target="_blank" rel="external">iOS 技能</a>请猛戳这里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/Android-skills.png" alt="Android 技能树"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是和团队小伙伴们一起整理的 Android 开发中涉及到技能。贴出来，一方面希望能够获取更多的建议，用来完善目前团队的技术组成；另一方面，比对这些技能，有感兴趣的同学，且觉得能够胜任，愿意来<a href="http://www.feibo.cn/" target="_]]>
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="基础" scheme="http://linfuyan.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习路线" scheme="http://linfuyan.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
      <category term="技能" scheme="http://linfuyan.com/tags/%E6%8A%80%E8%83%BD/"/>
    
      <category term="进阶" scheme="http://linfuyan.com/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Are you trying to connect to a TLS-enabled daemon without TLS？]]></title>
    <link href="http://linfuyan.com/faq/docker-trying-to-connect-to-a-tls-enabled-daemon-without-tls/"/>
    <id>http://linfuyan.com/faq/docker-trying-to-connect-to-a-tls-enabled-daemon-without-tls/</id>
    <published>2015-09-16T08:34:00.000Z</published>
    <updated>2015-09-16T09:54:26.000Z</updated>
    <content type="html"><![CDATA[<p>在 Mac 上通过 boot2docker 启动 docker 时，运行 docker 命令出现下面的提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post http:///var/run/docker.sock/v1.19/containers/<span class="operator"><span class="keyword">create</span>: dial unix /<span class="keyword">var</span>/run/docker.sock: <span class="keyword">no</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span>. </span><br><span class="line"><span class="keyword">Are</span> you trying <span class="keyword">to</span> <span class="keyword">connect</span> <span class="keyword">to</span> a TLS-enabled daemon <span class="keyword">without</span> TLS?</span></span><br></pre></td></tr></table></figure>
<p>这时候需要重启 boot2docker：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">boot2docker </span>stop</span><br><span class="line">$ <span class="keyword">boot2docker </span>start</span><br></pre></td></tr></table></figure>
<p>然后根据提示设置变量，如下图：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/mac-docker-tls.png" alt="在 Mac 上通过 boot2docker 启动 docker 时异常"></p>
<p>OK，最后在终端中输入：<code>docker version</code> 验证是否成功。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Mac 上通过 boot2docker 启动 docker 时，运行 docker 命令出现下面的提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="]]>
    </summary>
    
      <category term="Docker" scheme="http://linfuyan.com/tags/Docker/"/>
    
      <category term="Mac" scheme="http://linfuyan.com/tags/Mac/"/>
    
      <category term="TLS" scheme="http://linfuyan.com/tags/TLS/"/>
    
      <category term="boot2docker" scheme="http://linfuyan.com/tags/boot2docker/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X 上 使用 Docker 安装 Hexo]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/dockerize-hexo-on-mac/"/>
    <id>http://linfuyan.com/hexo-your-blog/dockerize-hexo-on-mac/</id>
    <published>2015-09-10T06:57:42.000Z</published>
    <updated>2015-09-16T09:54:01.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇中介绍如何在 Mac OS X 上使用 Docker 来安装 Hexo。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇中介绍如何在 Mac OS X 上使用 Docker 来安装 Hexo。</p>
</blockquote>
]]>
    </summary>
    
      <category term="Docker" scheme="http://linfuyan.com/tags/Docker/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="Mac" scheme="http://linfuyan.com/tags/Mac/"/>
    
      <category term="个人" scheme="http://linfuyan.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="安装" scheme="http://linfuyan.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X 上 Hexo 安装]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/install-hexo-on-mac/"/>
    <id>http://linfuyan.com/hexo-your-blog/install-hexo-on-mac/</id>
    <published>2015-09-10T06:38:20.000Z</published>
    <updated>2015-09-19T07:34:14.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章描述 Mac OS X 环境下的 Hexo 安装，其他的系统环境安装略有不同。可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<h2 id="安装前提">安装前提</h2><p>Hexo 依赖于 Node.js 及 Git，故在安装 Hexo 前必须检查并安装 Node.js 及 Git。</p>
<h3 id="安装_Git">安装 Git</h3><p>安装 Git 的方法也是多种多样，这边简单提一下，大家可以寻着这些思路来自己完成 Git 的安装。</p>
<p><strong>方案一、</strong>通过 Xcode 来安装 Git</p>
<ol>
<li>从 AppStore 下载 Xcode。</li>
<li>打开 Xcode -&gt; Preferences 点击下载选项，下载 Command Line Tools 安装。</li>
</ol>
<p><strong>方案二、</strong>安装 SourceTree 等客户端。</p>
<p><strong>方案三、</strong>通过 <a href="http://code.google.com/p/git-osx-installer/" target="_blank" rel="external">git-osx-installer</a> 安装。</p>
<p>安装完成以后，在终端中输入 <code>git --version</code> 查看 Git 版本，来确认是否安装成功。</p>
<blockquote>
<p>在开始 Git 的使用之前，需要有一些公共的参数配置，如 username， email 等。这些不在本文讨论范围。</p>
</blockquote>
<h3 id="安装_Node-js">安装 Node.js</h3><p>node.js 的安装也是方法多样，这里简单提下思路。</p>
<p><strong>方案一、</strong><a href="https://nodejs.org/en/download/" target="_blank" rel="external">官方</a>的 .pkg 文件安装，个人觉得是最方便的。</p>
<p><strong>方案二、</strong>下载 <a href="https://github.com/nodejs/node" target="_blank" rel="external">node.js 源码</a>，自己编译。</p>
<p><strong>方案三、</strong>通过 Homebrew 安装。</p>
<p><strong>方案四、</strong>通过 nvm 安装。</p>
<h3 id="安装_Hexo">安装 Hexo</h3><p>所有必备的应用程序安装完以后，就可用 npm 安装 Hexo 了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -<span class="keyword">g</span> hexo-<span class="keyword">cli</span>		<span class="comment">// 安装 Hexo 程序</span></span><br><span class="line">$ <span class="keyword">mkdir</span> blog					<span class="comment">// 新建博客目录</span></span><br><span class="line">$ <span class="keyword">cd</span> blog						<span class="comment">// 到博客目录下</span></span><br><span class="line">$ hexo init						<span class="comment">// 初始化 Hexo 博客目录</span></span><br><span class="line">$ npm install 					<span class="comment">// 安装依赖和插件</span></span><br><span class="line">$ hexo s						<span class="comment">// 启动服务器在本地进行预览</span></span><br></pre></td></tr></table></figure>
<p>在浏览器中打开 <code>http://localhost:4000</code>，看到博客首页的话，至此安装就完成了。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/hexo-preview.png" alt="hexo 预览"></p>
<blockquote>
<p>为了说明问题，上面的截图是后面补的。 </p>
</blockquote>
<p>这节也比较简单，也可以查看<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官网</a>的对应章节。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇文章描述 Mac OS X 环境下的 Hexo 安装，其他的系统环境安装略有不同。可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a>]]>
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="Mac" scheme="http://linfuyan.com/tags/Mac/"/>
    
      <category term="个人" scheme="http://linfuyan.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="安装" scheme="http://linfuyan.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 简介]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/hexo-introduce/"/>
    <id>http://linfuyan.com/hexo-your-blog/hexo-introduce/</id>
    <published>2015-09-10T03:10:20.000Z</published>
    <updated>2015-09-10T06:26:31.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章是<a href="http://www.linfuyan.com/hexo-your-blog" target="_blank" rel="external">《一步一步打造自己的 Hexo 博客》</a>系列的开篇，为了让这篇《 Hexo 简介》看上去足够充实，当然会有许多的内容来源于网络，甚至有的我也以找不到出处或者考证其真实性。这里想稍稍补充一下自己寻找博客，并最终落脚 Hexo 之旅。</p>
<p>我想很多技术人员都会有写一些博客的想法，而最初我曾尝试过在 CSDN，JavaEye(现在已经是 ItEye 了，不小心暴露年龄)，但实在难以忍受的是上面的排版，当然还有网络时快时慢等等，写文章之外需要忍受其他许许多多的不痛快。虽然这也只是我没有写技术博客的原因之一，但没有坚持下来却是实实在在的事情了。</p>
<p>后来继续开始写一些东西，是在我发现了 Markdown 这个好东西，10分钟内入门，不用再手动选择插入图片、链接，不用再选中斜体、加粗，不用选字号… 我想我是一个极懒的人。现在，我只需要打开 Mou，一路写下来，轻巧方便，再也不用担心烦杂的操作，不用担心联网的问题了。</p>
<p>有了 Markdown，我便开始寻找能够支持 Markdown 的博客， Wordpress、Typecho… Markdown 是支持的，但却要么庞大、要么不尽如人意(写完文章以后，需要手动再复制粘贴到内容编辑器里面保存等)。直到 Github Pages，再到现在的 Hexo，当 Hexo 搭建，并配置完成以后，再写文章、发布，就是本地的一条命令了，简直再方便不过。</p>
<a id="more"></a>
<p>说了这么多，回到 Hexo 介绍上来，这些摘自 <a href="https://hexo.io" target="_blank" rel="external">Hexo 官网</a>。</p>
<h2 id="什么是_Hexo？">什么是 Hexo？</h2><blockquote>
<h3 id="快速、简洁且高效的博客框架">快速、简洁且高效的博客框架</h3></blockquote>
<h2 id="Hexo_有什么优势？">Hexo 有什么优势？</h2><blockquote>
<h4 id="超快速度">超快速度</h4><p>Node.js 所带来的超快生成速度，让上百个页面在几秒瞬间完成渲染。</p>
<h4 id="支持_Markdown">支持 Markdown</h4><p>Hexo 支持 Github Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
<h4 id="一键部署">一键部署</h4><p>只需一条指令即可部署到 Github Pages，Heroku 或者其他网站。</p>
<h4 id="丰富的插件">丰富的插件</h4><p>Hexo 用用强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。</p>
</blockquote>
<h2 id="Hexo_适合谁？">Hexo 适合谁？</h2><p>这是一个免费开源的博客程序，任何人都可以使用和修改。但是不同于 Wordpress，Hexo 由于需要使用Github, Git, Markdown, Node.js 这样的工具，好多插件、widget 都需要自己安装、设置。所以适合那些有一定计算机基础，喜欢折腾的人。但是，不要恐惧，只要跟着本教程走，就能很方便地让自己的博客飞起来。<a href="http://zipperary.com/2013/05/28/Hexo-guide-1/" target="_blank" rel="external">摘自：Hexo系列教程：（一）Hexo介绍</a></p>
<p>好吧，这篇就写到这里。想了解关于 Hexo 的更多，不方便找谷歌，就度娘就是啦。后面我们将开始自己的 Hexo 博客打造之旅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章是<a href="http://www.linfuyan.com/hexo-your-blog">《一步一步打造自己的 Hexo 博客》</a>系列的开篇，为了让这篇《 Hexo 简介》看上去足够充实，当然会有许多的内容来源于网络，甚至有的我也以找不到出处或者考证其真实性。这里想稍稍补充一下自己寻找博客，并最终落脚 Hexo 之旅。</p>
<p>我想很多技术人员都会有写一些博客的想法，而最初我曾尝试过在 CSDN，JavaEye(现在已经是 ItEye 了，不小心暴露年龄)，但实在难以忍受的是上面的排版，当然还有网络时快时慢等等，写文章之外需要忍受其他许许多多的不痛快。虽然这也只是我没有写技术博客的原因之一，但没有坚持下来却是实实在在的事情了。</p>
<p>后来继续开始写一些东西，是在我发现了 Markdown 这个好东西，10分钟内入门，不用再手动选择插入图片、链接，不用再选中斜体、加粗，不用选字号… 我想我是一个极懒的人。现在，我只需要打开 Mou，一路写下来，轻巧方便，再也不用担心烦杂的操作，不用担心联网的问题了。</p>
<p>有了 Markdown，我便开始寻找能够支持 Markdown 的博客， Wordpress、Typecho… Markdown 是支持的，但却要么庞大、要么不尽如人意(写完文章以后，需要手动再复制粘贴到内容编辑器里面保存等)。直到 Github Pages，再到现在的 Hexo，当 Hexo 搭建，并配置完成以后，再写文章、发布，就是本地的一条命令了，简直再方便不过。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="markdown" scheme="http://linfuyan.com/tags/markdown/"/>
    
      <category term="个人" scheme="http://linfuyan.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 开发者证书制作、App ID 与推送配置及 Provisioning Profiles 创建]]></title>
    <link href="http://linfuyan.com/ios-cer-appid-push-profile/"/>
    <id>http://linfuyan.com/ios-cer-appid-push-profile/</id>
    <published>2015-09-08T13:59:00.000Z</published>
    <updated>2015-09-08T14:10:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>1. <strong>开发者证书</strong></p>
<p>分为开发和发布两种，类型为 <code>iPhone Development</code>， <code>iPhone Distribution</code>。这个是最基础的，开发证书用于真机调试，发布证书则用于上传到 AppStore，是一个基础证书，用来证明开发者身份。</p>
<p>2. <strong>App ID</strong></p>
<p>这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了 PassBook，GameCenter，以及更为场景的 push 服务。如果选中了 push 服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的 App ID。</p>
<p>3. <strong>推送证书</strong></p>
<p>分为开发和发布两种，类型分别为 <code>Apple Development iOS Push Services</code>， <code>Apple Production iOS Push Services</code>，该证书在 App ID 配置中创建生成，和开发者证书一样，放在服务端程序上。</p>
<p>4. <strong>Provisioning Porfiles</strong></p>
<p>在后续部分中，简称为 profile 文件。该文件将 App ID，开发者证书，硬件绑定在一起。在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在 profile 文件中添加真机的 <code>udid</code>，是真机调试和上架 AppStore 所必需的。</p>
<a id="more"></a>
<p>平常我们的制作流程一般都是按照这样的顺序：</p>
<ol>
<li>利用开发者账号登录开发者中心</li>
<li>创建开发者证书、App ID</li>
<li>在 App ID 中开通推送服务</li>
<li>在开通推送服务的选项下面创建推送证书</li>
<li>之后在 profile 文件中绑定所有的证书ID，添加调试真机等</li>
</ol>
<h2 id="制作开发者证书">制作开发者证书</h2><p>要制作开发者证书，首先登录开发者中心，找到证书配置版块，点击证书，显示如下页面：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS_cer_list.png" alt="开发者证书列表"></p>
<p>点击右上角加号，进入创建页面：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/iOS_cer_create.png" alt="开发者证书创建"></p>
<p>创建开发证书和发布证书步骤是一样的，开发证书用于真机调试，发布证书用于提交到 AppStore，这里以开发证书的制作为例。</p>
<p>选择 “iOS App Development” 选项，点击下方的继续按钮，提示需要创建证书签名请求( CSR )。</p>
<h3 id="手动创建证书签名请求(_CSR_)">手动创建证书签名请求( CSR )</h3><p>在 Mac 上的应用程序文件夹中，打开钥匙串访问。</p>
<p>在钥匙串访问的下拉菜单中，选择 “钥匙串访问” &gt; “证书助理” &gt; “从证书颁发机构请求证书…”。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_1.png" alt="创建 CSR"></p>
<ul>
<li><p>在”证书助理”窗口，输入如下信息：</p>
<ul>
<li>在用户邮箱地址中，输入邮箱地址。</li>
<li>常用名称中，输入私钥的名称。</li>
<li>保留 CA 点子邮件地址为空。</li>
<li>在请求选项组中，选中”存储到磁盘”</li>
</ul>
</li>
<li><p>点击”继续”完成 CSR 的创建。</p>
</li>
</ul>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_2.png" alt="创建 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_3.png" alt="创建 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_4.png" alt="创建 CSR"></p>
<blockquote>
<p>CSR 文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字，之后在开发者中心将该 CSR 文件提交。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_5.png" alt="上传 CSR"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_csr_6.png" alt="生成 cer"></p>
<p>上传 CSR 到开发者中心，就会生成开发者证书。将开发者证书下载保存，双击安装。可以在钥匙串访问的登录证书中可以查看，其中专用密钥的名字即为 CSR 请求文件中的常用名称。同样的方法可以配置发布证书。</p>
<blockquote>
<p>在生成不同的证书的时候可以上传同一个 CSR 文件。(这边似乎不会有什么影响?)</p>
</blockquote>
<h2 id="App_ID_与推送证书配置">App ID 与推送证书配置</h2><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/app_id.png" alt="App ID 版块"></p>
<p>进入 App ID 版块，点击右上角的加号，添加新的应用：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_1.png" alt="创建 App ID"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_2.png" alt="创建 App ID"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_3.png" alt="创建 App ID"></p>
<p>新建 App ID 时，勾选 push 可选项，为该 App ID 所对应的应用添加推送功能，。</p>
<p>新应用添加完毕，选择该应用进行编辑，此时其中的 <code>Push Notifications</code> 为可配置的。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_app_id_4.png" alt="创建 App ID"></p>
<p>根据上一节中”制作开发者证书”的步骤，完成上图中证书的创建，然后下载保存，并双击安装。</p>
<blockquote>
<p>虽然在创建证书版块也可以直接创建推送证书，但是还是建议在 App ID 中勾选 push 服务后再在此处创建，这样可以避免因为忘了开通 push 服务而导致推送不可用的情况发生。</p>
</blockquote>
<h2 id="创建_profile_文件">创建 profile 文件</h2><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_1.png" alt="创建 profiles"></p>
<p>打开 provisioning profiles 版块，点击右上角加号创建 profile 文件。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_2.png" alt="创建 profiles"></p>
<p>可以选择开发、发布及 Ad Hoc 三种 profile 文件。开发 profile 文件用于真机测试，发布 profile 文件则用于提交发布。Ad Hoc 这里暂不讨论。</p>
<p>会自动选择匹配的 App ID。另外下拉项中还可以选择 wildCard 格式，该格式为自动生成，使用 * 通配符，适用于批量的，没有推送，PassCard 等服务的应用；我们选择我们刚刚创建的 App ID, 之后下一步选择证书：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_3.png" alt="创建 profiles"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_4.png" alt="创建 profiles"></p>
<p>继续，这里有一个区别，因为开发 profile 文件用于真机调试，所以我们需要绑定真机。由于之前已经有添加过设备，所以这里直接全选添加。如果没有的话，需要将真机的 udid 复制出来在此添加。发布 profile 文件则没有这一步。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_5.png" alt="创建 profiles"></p>
<p>填写 profile 文件名称，点击生成：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_6.png" alt="创建 profiles"></p>
<p>最终生成 .mobileprovision 文件，可以点击下载保存。双击安装。</p>
<p>在 Xcode 中可以看到效果如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/create_profiles_7.png" alt="创建 profiles"></p>
<p>到这里为止，iOS 开发者证书的制作，配置 App ID 和推送证书，以及 profile 文件的创建就都完成了。</p>
<p>本文根据 <a href="http://blog.csdn.net/holydancer/article/details/9219333" target="_blank" rel="external">《苹果所有常用证书，appID,Provisioning Profiles配置说明及制作图文教程（精）》</a> 进行整理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>1. <strong>开发者证书</strong></p>
<p>分为开发和发布两种，类型为 <code>iPhone Development</code>， <code>iPhone Distribution</code>。这个是最基础的，开发证书用于真机调试，发布证书则用于上传到 AppStore，是一个基础证书，用来证明开发者身份。</p>
<p>2. <strong>App ID</strong></p>
<p>这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了 PassBook，GameCenter，以及更为场景的 push 服务。如果选中了 push 服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的 App ID。</p>
<p>3. <strong>推送证书</strong></p>
<p>分为开发和发布两种，类型分别为 <code>Apple Development iOS Push Services</code>， <code>Apple Production iOS Push Services</code>，该证书在 App ID 配置中创建生成，和开发者证书一样，放在服务端程序上。</p>
<p>4. <strong>Provisioning Porfiles</strong></p>
<p>在后续部分中，简称为 profile 文件。该文件将 App ID，开发者证书，硬件绑定在一起。在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在 profile 文件中添加真机的 <code>udid</code>，是真机调试和上架 AppStore 所必需的。</p>]]>
    
    </summary>
    
      <category term="App ID" scheme="http://linfuyan.com/tags/App-ID/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/tags/iOS/"/>
    
      <category term="profile" scheme="http://linfuyan.com/tags/profile/"/>
    
      <category term="provision" scheme="http://linfuyan.com/tags/provision/"/>
    
      <category term="push" scheme="http://linfuyan.com/tags/push/"/>
    
      <category term="图文教程" scheme="http://linfuyan.com/tags/%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/"/>
    
      <category term="开发者证书" scheme="http://linfuyan.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6/"/>
    
      <category term="配置" scheme="http://linfuyan.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
</feed>
