<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[悠城札记 - 关注但不限于 Android/iOS/nodejs 的 hexo 博客]]></title>
  <subtitle><![CDATA[关注但不限于 Android、iOS、nodejs]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linfuyan.com/"/>
  <updated>2015-11-02T13:18:19.000Z</updated>
  <id>http://linfuyan.com/</id>
  
  <author>
    <name><![CDATA[linfuyan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[解决 The same input jar is specified twice 问题]]></title>
    <link href="http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/"/>
    <id>http://linfuyan.com/faq/resolve-the-same-input-jar-is-specified-twice-issue/</id>
    <published>2015-11-02T13:06:00.000Z</published>
    <updated>2015-11-02T13:18:19.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> <span class="keyword">task</span> <span class="string">':joke:proguardRelease'</span>.</span><br><span class="line">&gt; java.io.IOException: The same input jar [<span class="regexp">/Users/</span>lfy<span class="regexp">/Develop/gi</span>ts<span class="regexp">/joke-android/</span>joke<span class="regexp">/libs/</span>eventbus.jar] is specified twice.</span><br></pre></td></tr></table></figure>
<p>今天在打混淆包时，遇到这个错误，刚开始以为是因为有多个项目都引用了 eventbus.jar 库，但当我对项目中的 eventbus.jar 的依赖进行排除时，同样出错。这次报的则是没有 eventbus.jar。 所以打消了我的第一个猜测。</p>
<p>后来发现，是因为以前在用 eclipse 开发时，混淆配置文件中包含有 <code>-libraryjars libs/eventbus.jar</code> 的配置，用来保持 eventbus.jar 不被混淆。在 Android Studio 中， build.gradle 中声明了对这个 jar 包的依赖，则不需要在混淆配置文件中继续声明。</p>
<p>在将所有的 <code>-libraryjars libs/*.jar</code> 注释掉以后，项目可以正常混淆了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td]]>
    </summary>
    
      <category term="Android Studio" scheme="http://linfuyan.com/tags/Android-Studio/"/>
    
      <category term="proguard" scheme="http://linfuyan.com/tags/proguard/"/>
    
      <category term="混淆" scheme="http://linfuyan.com/tags/%E6%B7%B7%E6%B7%86/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 使用多说评论框]]></title>
    <link href="http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/"/>
    <id>http://linfuyan.com/hexo-your-blog/hexo-with-duoshuo/</id>
    <published>2015-11-01T01:37:28.000Z</published>
    <updated>2015-11-01T02:59:05.000Z</updated>
    <content type="html"><![CDATA[<p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>
<a id="more"></a>
<p>既然如此，我们以 hueman 主题下在文章末尾配置多说评论框为例作一下说明。</p>
<p>首先，你需要注册一个<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>账号并新建一个站点。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-create-site.png" alt="多说创建站点"></p>
<p>站点创建完成以后，会跳出代码模板的页面，如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-comment-template.png" alt="多说代码模板"></p>
<p>左侧选择”获取代码”的这栏，然后选中”通用代码”。这就是我们评论框的代码模板，后面我们需要找到合适的地方，将其插入到 hueman 主题中的文章模板里。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/hueman-article.png" alt="hueman 文章代码"></p>
<p>在 hueman 主题中，文章的模板在 <code>hueman -&gt; layout -&gt; _partial -&gt; post -&gt; article.ejs</code>  下面。看到上图中，第一个红框圈住的部分，是主题自带的 disqus 评论框的配置。当然我们没有在<strong>项目目录</strong>下的 <code>_config.yml</code> 中配置 disqus_shortname，所以它是不生效的，在咱们的文章页面中看不到。</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (post.comments &amp;&amp; config.disqus_shortname)&#123; </span>%&gt;<span class="xml"></span><br><span class="line">  <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"disqus_thread"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"></span>&lt;%<span class="ruby"> &#125; </span>%&gt;<span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>找到上面这个文章末尾的位置，仿照上面的逻辑判断代码，把多说评论框模板代码添加进来，如上图中的第二个红框圈住的部分。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (!<span class="attribute">index</span> &amp;&amp; <span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">theme.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 start --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%= page.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说评论框 end --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="keyword">var</span> duoshuoQuery = &#123;short_name:<span class="string">'&lt;%= theme.duoshuo_shortname %&gt;'</span>&#125;;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</span><br><span class="line">        ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</span><br><span class="line">        ds.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">        (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</span><br><span class="line">         || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span><br><span class="line">      &#125;)();</span><br><span class="line">      </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多说公共JS代码 end --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里大家注意一下：</p>
<p>1. 第一行中判断 !index 代表是非主页的文章。我们是要在主页之外的文章正文下添加评论，所以添加了这个判断。</p>
<p>2. <code>theme.duoshuo_shortname</code>，这里需要我们在主题下面的 <code>_config.yml</code> 中添加 <code>duoshuo_shortname</code> 字段配置才能生效。这里和上面讲到的 <code>config.disqus_shortname</code> 的区别就在于 <code>theme._</code> 开头的是在主题中的 <code>_config.yml</code> 配置， <code>config._</code> 开头是在项目目录下的 <code>_config.yml</code> 配置。</p>
<p>Ok，到这里，打开 <code>hueman -&gt; _config.yml</code> 在其中添加如下代码：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># comments 配置多说评论</span></span><br><span class="line"><span class="label">duoshuo_shortname:</span> 这里就是你在创建站点时填的多说域名</span><br></pre></td></tr></table></figure>
<p>如果多说域名是 <a href="http://abc.duoshuo.com" target="_blank" rel="external">http://abc.duoshuo.com</a> ， 那这里 <code>duoshuo_shortname</code> 就是 abc。</p>
<p>3. 多说评论框模板中的变量，我们需要进行替换。原来如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"ds-thread"</span> data-thread-key=<span class="string">"请将此处替换成文章在你的站点中的ID"</span> data-title=<span class="string">"请替换成文章的标题"</span> data-url=<span class="string">"请替换成文章的网址"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> post.layout </span>%&gt;<span class="xml"><span class="tag"><span class="value">-</span></span></span>&lt;%=<span class="ruby"> post.slug </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">data-title</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> post.title </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">data-url</span>=<span class="value">"</span></span></span>&lt;%=<span class="ruby"> page.permalink </span>%&gt;<span class="xml"><span class="tag"><span class="value">"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>其中， <code>post.layout</code>， <code>post.slug</code>， <code>post.title</code>， <code>page.permalink</code> 都是 Hexo 的内置变量。具体可以查看<a href="https://hexo.io/zh-cn/docs/variables.html" target="_blank" rel="external">这里</a>。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/duoshuo-article-management.png" alt="多说文章管理"></p>
<p>这样就为 Hexo 站点添加上多说评论框啦，如果还需要在其他的位置添加，过程类似。总结下步骤：</p>
<ol>
<li>注册多说账号，创建新站点。</li>
<li>找到需要添加多说评论框的位置，粘贴多说评论框的模板代码，并作必要的修改。</li>
<li>如果将多说评论框作为配置项，合适的地方，添加配置。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们看到很多的博客的文章下面有评论。在 Hexo 上使用这个评论系统，主要有两种，一种是 disqus，另一种是多说。具体使用哪种评论系统，一般是在具体的主题中配置的，也就是在主题下的 <code>_config.yml</code> 文件中。大部分多外的主题都自动集成了 disqus， disqus 也大多在国外使用，它的评论框颜值还是很高的。但是在国内，因为网络访问国外服务比较慢的问题，使用多说会相对好一点。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="多说" scheme="http://linfuyan.com/tags/%E5%A4%9A%E8%AF%B4/"/>
    
      <category term="评论框" scheme="http://linfuyan.com/tags/%E8%AF%84%E8%AE%BA%E6%A1%86/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo Symbol not found _usdt_create_provider 错误处理]]></title>
    <link href="http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/"/>
    <id>http://linfuyan.com/faq/hexo-symbol-not-found_usdt_create_provider/</id>
    <published>2015-10-30T23:13:12.000Z</published>
    <updated>2015-10-31T11:26:55.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>
<a id="more"></a>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dyld:</span> lazy symbol binding <span class="string">failed:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"><span class="label"></span><br><span class="line">dyld:</span> Symbol not <span class="string">found:</span> _usdt_create_provider</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>lfy<span class="regexp">/ihaowu/</span>node_modules<span class="regexp">/hexo/</span>node_modules<span class="regexp">/bunyan/</span>node_modules<span class="regexp">/dtrace-provider/</span>build<span class="regexp">/Release/</span>DTraceProviderBindings.node</span><br><span class="line">  Expected <span class="string">in:</span> dynamic lookup</span><br><span class="line"></span><br><span class="line">Trace/BPT <span class="string">trap:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>最终，我是通过多次的 <code>npm install hexo --no-optional</code> 解决的，至于原因是什么，我不太清楚。其他手段也试过，没有成功。</p>
<p>以下是参考过的资料：</p>
<p><a href="https://github.com/trentm/node-bunyan/issues/216" target="_blank" rel="external">Still getting lots of DtraceProviderBindings errors on OS X</a></p>
<p><a href="https://github.com/hexojs/hexo/issues/1398" target="_blank" rel="external">node.js v0.12.7 install hexo-cli error on mac os x 10.10.4</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚新建一个 Hexo 博客，准备启动测试，出现了下面的问题。在我第一次搭建博客时，也遇到了，当时的解决方案是重新用 docker 配置了一份。一直以为是 Mac OSX 上不支持，但后来在 Mac OSX 上可以用了。所以这次再遇到，就要想方法解决。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="错误" scheme="http://linfuyan.com/tags/%E9%94%99%E8%AF%AF/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 使用七牛云同步插件 hexo-qiniu-sync 出错]]></title>
    <link href="http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/"/>
    <id>http://linfuyan.com/faq/hexo-qiniu-sync-typeerror-arguments-to-path-join-must-be-strings/</id>
    <published>2015-10-30T22:45:20.000Z</published>
    <updated>2015-10-31T11:23:12.000Z</updated>
    <content type="html"><![CDATA[<p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something<span class="comment">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line">TypeError: Arguments <span class="keyword">to</span> path.<span class="keyword">join</span> must be strings</span><br><span class="line">    at <span class="built_in">Object</span>.posix.<span class="keyword">join</span> (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    at <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    at Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Hexo.ret (eval at &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    at /Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="keyword">new</span> Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    at Hexo.<span class="keyword">call</span> (/Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    at runHexoCommand (/usr/local/<span class="keyword">lib</span>/node_modules/hexo/node_modules/hexo-cli/<span class="keyword">lib</span>/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    at Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    at Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    at Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    at Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    at Immediate.Async.drainQueues [<span class="keyword">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate [<span class="keyword">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>找到关键的部分：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Arguments to path<span class="class">.join</span> must be strings</span><br><span class="line">    at Object<span class="class">.posix</span><span class="class">.join</span> (path<span class="class">.js</span>:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync<span class="class">.js</span>:<span class="number">110</span>:<span class="number">26</span>)</span><br></pre></td></tr></table></figure>
<p>查看源代码中的 sync.js，发现其中的 sync() 方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">file</span> <span class="keyword">in</span> files) &#123;</span><br><span class="line">       <span class="keyword">var</span> fname = path.join(local_dir, <span class="keyword">dir</span>, files[i]); <span class="comment">// 这部分出错</span></span><br><span class="line">       <span class="keyword">var</span> stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == true) &#123;</span><br><span class="line">           sync(path.join(<span class="keyword">dir</span>, files[i]));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="keyword">var</span> name = path.join(dirPrefix, fname.<span class="keyword">replace</span>(local_dir, '')).<span class="keyword">replace</span>(/\\/<span class="keyword">g</span>, '/').<span class="keyword">replace</span>(/^\<span class="comment">//g, '');</span></span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面注释部分似乎是传递的参数类型出错了。</p>
<p>查看了官方最新的代码，发现确实不一样。于是将上面的内容替换成下面：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">files.forEach(function(<span class="keyword">file</span>)  &#123;</span><br><span class="line">       var fname = path.<span class="keyword">join</span>(local_dir + <span class="string">''</span>, dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>);</span><br><span class="line">       var stat = fs.lstatSync(fname);</span><br><span class="line">       <span class="keyword">if</span>(stat.isDirectory() == <span class="keyword">true</span>) &#123;</span><br><span class="line">           sync(path.<span class="keyword">join</span>(dir + <span class="string">''</span>, <span class="keyword">file</span> + <span class="string">''</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           var name = path.<span class="keyword">join</span>(dirPrefix, fname.replace(local_dir, <span class="string">''</span>)).replace(<span class="regexp">/\\/g</span>, <span class="string">'/'</span>).replace(<span class="regexp">/^\//g</span>, <span class="string">''</span>);</span><br><span class="line">           check_upload(fname,name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>问题解决了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>安装完 hexo-qiniu-sync 插件，运行出现以下错误：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO  Now start qiniu sync.</span><br><span class="line">FATAL Something<span class="comment">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line">TypeError: Arguments <span class="keyword">to</span> path.<span class="keyword">join</span> must be strings</span><br><span class="line">    at <span class="built_in">Object</span>.posix.<span class="keyword">join</span> (path.js:<span class="number">488</span>:<span class="number">13</span>)</span><br><span class="line">    at sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">110</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/sync.js:<span class="number">113</span>:<span class="number">13</span>)</span><br><span class="line">    at <span class="keyword">Function</span>.commands.sync (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/cmd.js:<span class="number">28</span>:<span class="number">14</span>)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo-qiniu-sync/index.js:<span class="number">122</span>:<span class="number">11</span>)</span><br><span class="line">    at Hexo.tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Hexo.ret (eval at &lt;anonymous&gt; (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promisify.js:<span class="number">163</span>:<span class="number">12</span>), &lt;anonymous&gt;:<span class="number">13</span>:<span class="number">39</span>)</span><br><span class="line">    at /Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">192</span>:<span class="number">9</span></span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._resolveFromResolver (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">480</span>:<span class="number">31</span>)</span><br><span class="line">    at <span class="keyword">new</span> Promise (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">70</span>:<span class="number">37</span>)</span><br><span class="line">    at Hexo.<span class="keyword">call</span> (/Users/lfy/ihaowu/node_modules/hexo/<span class="keyword">lib</span>/hexo/index.js:<span class="number">188</span>:<span class="number">10</span>)</span><br><span class="line">    at runHexoCommand (/usr/local/<span class="keyword">lib</span>/node_modules/hexo/node_modules/hexo-cli/<span class="keyword">lib</span>/index.js:<span class="number">58</span>:<span class="number">17</span>)</span><br><span class="line">    at tryCatcher (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/util.js:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">507</span>:<span class="number">31</span>)</span><br><span class="line">    at Promise._settlePromiseAt (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">581</span>:<span class="number">18</span>)</span><br><span class="line">    at Promise._settlePromises (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/promise.js:<span class="number">697</span>:<span class="number">14</span>)</span><br><span class="line">    at Async._drainQueue (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">123</span>:<span class="number">16</span>)</span><br><span class="line">    at Async._drainQueues (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">    at Immediate.Async.drainQueues [<span class="keyword">as</span> _onImmediate] (/Users/lfy/ihaowu/node_modules/hexo/node_modules/bluebird/js/main/async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    at processImmediate [<span class="keyword">as</span> _immediateCallback] (timers.js:<span class="number">367</span>:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="七牛" scheme="http://linfuyan.com/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="博客" scheme="http://linfuyan.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="同步" scheme="http://linfuyan.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[保持兼容性]]></title>
    <link href="http://linfuyan.com/material-design-training/maintaining-compatibility/"/>
    <id>http://linfuyan.com/material-design-training/maintaining-compatibility/</id>
    <published>2015-10-24T07:00:35.000Z</published>
    <updated>2015-11-03T09:17:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>某些 material design 特性如 material 主题以及自定义活动转场效果等只在 Android 5.0 ( API 21) 上可用。尽管如此，你依然可以设计的应用程序来使用这些特性，使之运行在支持 material design 的设备上时，能够兼容的在其他较早的 Android 发布版上运行。</p>
<a id="more"></a>
<h2 id="定义可替代的风格">定义可替代的风格</h2><p>你可以配置应用程序在支持 material design 的设备上使用 material 主题，在运行较早期版本的 Android 设备上恢复为旧的主题：</p>
<ol>
<li>在 <code>res/values/styles.xml</code> 中定义一个主题继承自旧的主题，如 Holo。</li>
<li>在 <code>res/values-v21/styles.xml</code> 中定义相同名称的主题继承自 material 主题。</li>
<li>在清单文件中设置这个主题为应用程序的主题。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果你的应用程序使用 material 主题，但没有按照这种方式提供一个替代的主题，你的应用程序在早于 Android 5.0 版本上无法运行。</p>
</blockquote>
<h2 id="提供替代的布局">提供替代的布局</h2><p>如果你所涉及的布局是按照 material design 指南，并且没有使用任何在 Android 5.0 (API 21) 上引入的新 XML 属性，那么在之前的 Android 版本也可以正常工作。否则，你需要提供一个可替换的布局。你可以提供可替代的布局来在早先的 Android 版本上自定义应用程序外观。</p>
<p>在 <code>res/layout-v21</code> 里为 Android 5.0 (API 21) 创建布局文件，在 <code>res/layout</code> 里为早先的 Android 版本创建替代的布局文件。例如： <code>res/layout/my_activity.xml</code> 是 <code>res/layout-v21/my_activity.xml</code> 的替代布局。</p>
<p>为了避免重复代码，在 <code>res/values</code> 中定义风格，为新的 API 修改 <code>res/values-v21</code> 中的风格。使用风格继承，在 <code>res/values/</code> 定义基础风格，并在 <code>res/values-v21</code> 中继承它。</p>
<h2 id="使用_Support_Library">使用 Support Library</h2><p><a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Support v7 兼容库</a> r21 及以上包含下面的 material design 特性：</p>
<ul>
<li>当你应用其中一个 <code>Theme.AppCompat</code> 主题时，某些系统组件具有 <a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="external">Material design 风格</a>。</li>
<li><code>Theme.AppCompat</code> 主题中的 <a href="https://developer.android.com/training/material/theme.html#ColorPalette" target="_blank" rel="external">色彩调色板主题属性</a>。</li>
<li>使用 RecyclerView 控件来显示数据集。</li>
<li>使用 CardView 控件来创建卡片。</li>
<li>使用 Palette 类来从图片中抽取主色彩。</li>
</ul>
<h3 id="系统控件">系统控件</h3><p><code>Theme.AppCompat</code> 主题为以下控件提供了 material design 风格：</p>
<ul>
<li>EditText</li>
<li>Spinner</li>
<li>CheckBox</li>
<li>RadioButton</li>
<li>SwitchCompat</li>
<li>CheckedTextView</li>
</ul>
<h3 id="调色板">调色板</h3><p>通过 Android Support V7 兼容库来获取 material design 风格和自定义调色板，需要应用一个 <code>Theme.AppCompat</code> 主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- extend one of the Theme.AppCompat themes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"Theme.MyTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light"</span>&gt;</span><span class="css"></span><br><span class="line">  &lt;!<span class="tag">--</span> <span class="tag">customize</span> <span class="tag">the</span> <span class="tag">color</span> <span class="tag">palette</span> <span class="tag">--</span>&gt;</span><br><span class="line">  &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/material_blue_500&lt;/item&gt;</span></span><br><span class="line">  &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/material_blue_700&lt;/item&gt;</span><br><span class="line">  &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/material_green_A200&lt;/item&gt;</span><br><span class="line"></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表和卡片">列表和卡片</h3><p>通过 Android Supprot V7 兼容库，RecyclerView 和 CardView 控件在早先的 Android 版本上是可用的，但具有如下局限：</p>
<ul>
<li>CardView 上的阴影需要使用额外的内边距来编程实现。</li>
<li>具有圆角的 CardView 无法裁剪其子视图。</li>
</ul>
<h3 id="依赖">依赖</h3><p>在早于 Android 5.0 (API 21) 版本上使用这些特性需要在项目中通过 Gradle 依赖引入 Android Support V7 兼容库。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查系统版本">检查系统版本</h3><p>以下特性在 Android 5.0 (API 21) 以上可用：</p>
<ul>
<li>活动转场效果</li>
<li>触摸反馈</li>
<li>显示动画</li>
<li>基于路径的动画</li>
<li>矢量图片</li>
<li>图片着色</li>
</ul>
<p>为了在早先 Android 版本上保持兼容性，需要中调用包含这些特性的 API 前检查系统版本。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否运行在 Android 5.0 以上版本</span></span><br><span class="line"><span class="tag">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="comment">// 在这里调用 material design API</span></span><br><span class="line">&#125; <span class="tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// 实现不包含 material design 的特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在清单文件中使用 <code>android:minSdkVersion</code> 和 <code>android:targetSdkVersion</code> 属性来指定 Android 应用程序支持哪些版本。在 Android 5.0 上使用 material design 特性，需要设置 <code>android:targetSdkVersion</code> 属性为 <code>21</code>。更多信息，可以查看<a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html" target="_blank" rel="external"><uses-sdk> API 指南</uses-sdk></a>。</p>
</blockquote>
<p>原文：<a href="https://developer.android.com/training/material/compatibility.html" target="_blank" rel="external">Maintaining Compatibility</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>某些 material design 特性如 material 主题以及自定义活动转场效果等只在 Android 5.0 ( API 21) 上可用。尽管如此，你依然可以设计的应用程序来使用这些特性，使之运行在支持 material design 的设备上时，能够兼容的在其他较早的 Android 发布版上运行。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="兼容" scheme="http://linfuyan.com/tags/%E5%85%BC%E5%AE%B9/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义自定义动画]]></title>
    <link href="http://linfuyan.com/material-design-training/defining-custom-animations/"/>
    <id>http://linfuyan.com/material-design-training/defining-custom-animations/</id>
    <published>2015-10-24T06:00:00.000Z</published>
    <updated>2015-11-03T09:16:28.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 中的动画能够让应用程序给予用户对于动作的反馈，提供用户交互的视觉持续性。 Material 主题为按钮和活动转场效果提供默认的动画， Android 5.0 (API 21) 以上版本可以定制这些动画，并创建新的：</p>
<ul>
<li>触摸反馈</li>
<li>圆形波纹</li>
<li>活动转场效果</li>
<li>曲线移动</li>
<li>视图状态改变</li>
</ul>
<a id="more"></a>
<h2 id="自定义触摸反馈">自定义触摸反馈</h2><p>Material design 中的触摸反馈可以为用户与 UI 元素的交互提供持续的视觉确认。按钮上的默认的触摸反馈动画使用新的 RippleDrawable 类，该类在不同的状态切换中使用波纹效果。</p>
<p>大部分情况下，你需要在视图的 XML 中指定视图背景来应用这个功能：</p>
<ul>
<li><code>?android:attr/selectableItemBackground</code> : 实现有边界的波纹。</li>
<li><code>?android:attr/selectableItemBackgroundBorderless</code> : 在视图之上的波纹。它将被绘制在最近的背景不为空的父视图内。</li>
</ul>
<blockquote>
<p><strong>注意</strong>： <code>selectableItemBackgroundBorderless</code> 是在 API 21 中引入的新属性。</p>
</blockquote>
<p>你也可以使用 <code>ripple</code> 元素在 XML 资源中定义 RippleDrawable 。</p>
<p>可以为 RippleDrawable 对象设置颜色。要改变默认的触摸反馈的颜色，使用主题中的 <code>android:colorControlHighlight</code> 属性。</p>
<p>更多信息，可以查看类 RippleDrawable 的 API 参考。</p>
<h2 id="使用显示效果">使用显示效果</h2><p>当显示或者隐藏一组 UI 元素时，显示动画能提供用户视觉连续性。 ViewAnimationUtils.createCircularReveal() 方法来使用裁剪为圆形动画来显示或隐藏视图。</p>
<p>要实现一个之前不可见的视图使用这种效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前不可见的视图</span></span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的最终半径</span></span><br><span class="line"><span class="keyword">int</span> finalRadius = Math.max(myView.getWidth(), myView.getHeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为视图创建动画发生器(起始半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, <span class="number">0</span>, finalRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使视图可见并启动动画</span></span><br><span class="line">myView.setVisibility(View.VISIBLE);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<p>要隐藏之前可见的视图使用这种效果：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前可见的视图</span></span><br><span class="line"><span class="keyword">final</span> View myView = findViewById(R.id.my_view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的中心</span></span><br><span class="line"><span class="keyword">int</span> cx = myView.getWidth() / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = myView.getHeight() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取裁剪圆形的厨师半径</span></span><br><span class="line"><span class="keyword">int</span> initialRadius = myView.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动画(最终半径为0)</span></span><br><span class="line">Animator anim =</span><br><span class="line">    ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当动画结束时是视图不可见</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">        myView.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<h2 id="自定义活动转场效果">自定义活动转场效果</h2><p>在 Material design 特性的应用程序中，活动转场效果提供公共元素在移动和转换上不同状态下的视觉连接。你可以指定自定义的进场/退场效果及活动间的共享元素转场。</p>
<ul>
<li>进场效果决定活动中的视图如何进入场景。例如，在 <em>explode</em> 进场效果中，视图从外部飞入到屏幕的中心。</li>
<li>退场效果决定活动中的驶入如何退出场景。例如，在 <em>explode</em> 退场效果中，视图从中心退出场景。</li>
<li>共享元素转场效果决定活动之间共享视图在两个活动间的转场。例如，在两个活动中同一个图片在不同的位置且尺寸不同， <em>changeImageTransform</em> 共享元素转场在活动之间平滑的平移和缩放这些图片。</li>
</ul>
<p>Android 5.0 (API 21) 支持下面这些进场和退场效果：</p>
<ul>
<li>explode - 从场景中间移入或移出视图。</li>
<li>slide - 从场景的一边移入或移出视图。</li>
<li>fade - 通过修改透明度在场景中添加或者移除视图。</li>
</ul>
<p>所有继承自 Visibility 类的转场支持进场/退场效果。更多信息，查看 API 参考的 Transition 类。</p>
<p>Android 5.0 (API 21) 同时支持共享元素的转场效果：</p>
<ul>
<li>changeBounds - 动画改变目标视图的布局边界。</li>
<li>changeClipBounds - 动画改变目标视图的裁剪边界。</li>
<li>changeTransform - 动画改变目标视图的缩放和旋转。</li>
<li>changeImageTransform - 动画改变图片的尺寸和缩放。</li>
</ul>
<p>如果应用程序中开启了活动转场效果，进入或退出活动时默认的 cross-fading 转场效果将被激活。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/SceneTransition.png" alt="带有共享元素的转场效果"></p>
<h3 id="指定自定义转场效果">指定自定义转场效果</h3><p>首先，定义一个风格继承自 material 主题，并设置 <code>android:windowContentTransitions</code> 属性来开启窗口内容转场。你也可以在风格定义中指定进场，退场和共享元素转场效果。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"BaseAppTheme"</span> parent=<span class="string">"android:Theme.Material"</span>&gt;</span><br><span class="line"> &lt;!<span class="comment">-- 开启窗口内容转场 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowContentTransitions"</span>&gt;<span class="constant">true</span>&lt;/<span class="property">item</span>&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!<span class="comment">-- 指定进场/退场效果 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;@transition/explode&lt;/<span class="property">item</span>&gt;</span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;@transition/explode&lt;/<span class="property">item</span>&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!<span class="comment">-- 指定共享元素转场 --&gt;</span></span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span><br><span class="line">   @transition/change_image_transform&lt;/<span class="property">item</span>&gt;</span><br><span class="line"> &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span><br><span class="line">   @transition/change_image_transform&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这个例子中 <code>change_image_transform</code> 转场效果定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/transition/change_image_transform.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- (see also Shared Transitions below) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">transitionSet</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">changeImageTransform</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>change_image_transform</code> 元素与 ChangeImageTransform 类相对应。更多信息，可以查看 API 参考 <a href="">Transition</a>。</p>
<p>在代码中，可以通过调用 Window.requestFeature() 方法来开启窗口内容转场。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside your activity (if you did not enable transitions in your theme)</span></span><br><span class="line"><span class="function">getWindow</span>()<span class="class">.requestFeature</span>(Window<span class="class">.FEATURE_CONTENT_TRANSITIONS</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set an exit transition</span></span><br><span class="line"><span class="function">getWindow</span>()<span class="class">.setExitTransition</span>(new <span class="function">Explode</span>());</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过调用下面的方法，并传递 Transtion 对象来确定转场效果：</p>
<ul>
<li>Window.setEnterTransition()</li>
<li>Window.setExitTransition()</li>
<li>Window.setSharedElementEnterTransition()</li>
<li>Window.setSharedElementExitTransition()</li>
</ul>
<p>setExitTransition() 和 setSharedElementExitTransition() 定义了调用该方法的活动的退场效果。setEnterTransition() 和 setSharedElementEnterTransition() 则定义调用该方法的活动的进场效果。</p>
<p>要获取转场的完整效果，你取药开启调用与被调用活动的窗口内容转场功能。否则，调用活动可以开始退场效果，但是你最后只能看到一个窗口转场(缩放或者淡入)。</p>
<p>在被调用的活动中使用 Window.setAllowEnterTransitionOverlap() 方法来尽快启动一个进场效果，这能让你拥有很炫酷的进场效果。</p>
<h3 id="使用转场效果启动活动">使用转场效果启动活动</h3><p>如果你开启转场效果并为活动设置了退场效果，当你启动另一个活动时，转场效果将被激活，如下所示：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startActivity<span class="list">(<span class="keyword">intent</span>,</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation<span class="list">(<span class="keyword">this</span>)</span>.toBundle<span class="list">()</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果你为第二个活动设置了进场效果，当活动开始时转场效果将被激活。要在启动另一个活动时禁用转场效果，提供一个为 <code>null</code> 的可选 bundle。</p>
<h3 id="启动带有共享元素的活动">启动带有共享元素的活动</h3><p>创建带有共享元素的两个活动的屏幕转场需要：</p>
<ol>
<li>在主题中开启窗口内容转场。</li>
<li>在风格中指定共享元素转场。</li>
<li>将转场效果定义为 XML 资源。</li>
<li>在布局中的共享元素通过 <code>android:transitionName</code> 属性来分配一样的名字。</li>
<li>使用 ActivityOptions.makeSceneTransitionAnimation() 方法。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取接收点击事件的元素</span></span><br><span class="line"><span class="keyword">final</span> View imgContainerView = findViewById(R.id.img_container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活动中进行转场的公共元素</span></span><br><span class="line"><span class="keyword">final</span> View androidRobotView = findViewById(R.id.image_small);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点击监听</span></span><br><span class="line">imgContainerView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, Activity2.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// 创建转场动画，两个活动布局中的图片使用android:transitionName="robot"进行定义</span></span><br><span class="line">        ActivityOptions <span class="keyword">options</span> = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(<span class="keyword">this</span>, androidRobotView, <span class="string">"robot"</span>);</span><br><span class="line">        <span class="comment">// 启动新的活动</span></span><br><span class="line">        startActivity(intent, <span class="keyword">options</span>.toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在代码中，可以通过在两个活动中使用 View.setTransitionName() 方法来指定公共元素名称来共享动态视图。</p>
<p>当你结束第二个活动，想要反转转场动画时，调用 Activity.finishAfterTransition() 代替 Activity.finish() 。</p>
<h3 id="启动带多个共享元素的活动">启动带多个共享元素的活动</h3><p>创建带有多个共享元素的活动转场，在布局中使用 <code>android:transitionName</code> 属性来定义共享元素，或者在活动代码中用 View.setTransitionName() 方法。然后创建 ActivityOptions 对象：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions <span class="keyword">options</span> = ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>,</span><br><span class="line">        Pair.create(view1, <span class="string">"agreedName1"</span>),</span><br><span class="line">        Pair.create(view2, <span class="string">"agreedName2"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="使用曲线移动">使用曲线移动</h2><p>Material design 中的动画依赖于时间插值曲线并运动收空间所限。<br>Animations in material design rely on curves for time interpolation and spatial movement patterns. With Android 5.0 (API level 21) and above, you can define custom timing curves and curved motion patterns for animations.</p>
<p>PathInterpolator 类是基于贝塞尔曲线和一个 Path 对象的新的插值器。这个插值器指定在 1x1 方形上的运动曲线，拥有 (0,0) 和 (1,1) 两个锚点，并且使用构造器参数为指定的控制点。也可以在 XML 资源中定义路径插值器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">pathInterpolator</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:controlX1</span>=<span class="value">"0.4"</span></span><br><span class="line">    <span class="attribute">android:controlY1</span>=<span class="value">"0"</span></span><br><span class="line">    <span class="attribute">android:controlX2</span>=<span class="value">"1"</span></span><br><span class="line">    <span class="attribute">android:controlY2</span>=<span class="value">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 material design 规范中系统为 3 种基本曲线提供了 XML 资源。</p>
<ul>
<li><code>@interpolator/fast_out_linear_in.xml</code></li>
<li><code>@interpolator/fast_out_slow_in.xml</code></li>
<li><code>@interpolator/linear_out_slow_in.xml</code></li>
</ul>
<p>可以传递一个 PathInterpolator 对象到 Animator.setInterpolator() 方法。</p>
<p>ObjectAnimator 类有新的构造器来支持一次性使用2个或多个属性，与路径一起来推动坐标。例如，下面的动画会之气使用一个 Path 对象来推动视图的 X 和 Y 属性：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator mAnimator<span class="comment">;</span></span><br><span class="line">mAnimator = ObjectAnimator.ofFloat(view, View.X, View.Y, path)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">mAnimator.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画视图状态改变">动画视图状态改变</h2><p>StateListAnimator 类定义视图状态改变时运行的动画。下面的实例展示如何在 XML 资源中定义一个 StateListAnimator 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- animate the translationZ property of a view when pressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">selector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:state_pressed</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">objectAnimator</span> <span class="attribute">android:propertyName</span>=<span class="value">"translationZ"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"@android:integer/config_shortAnimTime"</span></span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"2dp"</span></span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">"floatType"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- you could have other objectAnimator elements</span><br><span class="line">             here for "x" and "y", or other properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:state_enabled</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:state_pressed</span>=<span class="value">"false"</span></span><br><span class="line">    <span class="attribute">android:state_focused</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">objectAnimator</span> <span class="attribute">android:propertyName</span>=<span class="value">"translationZ"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"100"</span></span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"0"</span></span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">"floatType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要为视图关联自定义视图状态动画，需要在 XML 资源文件中使用 <code>selector</code> 元素来定义动画绘制器，并将它分配到视图的 <code>android:stateListAnimator</code> 属性。通过代码来分配一个状态列表动画绘制器到视图，则使用 AnimationInflater.loadStateListAnimator() 方法，分配动画绘制器到视图使用 View.setStateListAnimator() 方法。</p>
<p>当你的主题继承自 material 主题，按钮默认由 Z 动画。要禁用按钮的行为，需要设置 <code>android:stateListAnimatro</code> 属性为 <code>@null</code>。</p>
<p>AnimatedStateListDrawable 类可以创建图片用来显示关联视图的状态变化的动画。某些 Android 5.0 上的系统组件默认使用这些动画。下面的实例展示如何使用 XML 资源定义一个 AnimatedStateListDrawable 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animated-selector</span></span><br><span class="line">  <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 为每种状态提供不同的图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@+id/pressed"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableP"</span></span><br><span class="line">      <span class="attribute">android:state_pressed</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@+id/focused"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableF"</span></span><br><span class="line">      <span class="attribute">android:state_focused</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:id</span>=<span class="value">"@id/default"</span></span><br><span class="line">      <span class="attribute">android:drawable</span>=<span class="value">"@drawable/drawableD"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 指定转场效果 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">transition</span> <span class="attribute">android:fromId</span>=<span class="value">"@+id/default"</span> <span class="attribute">android:toId</span>=<span class="value">"@+id/pressed"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">animation-list</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:duration</span>=<span class="value">"15"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/dt1"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:duration</span>=<span class="value">"15"</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/dt2"</span>/&gt;</span></span><br><span class="line">          ...</span><br><span class="line">      <span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">transition</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">animated-selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动画矢量图片">动画矢量图片</h2><p>矢量图片在缩放过程中不会丢失清晰度。 AnimatedVectorDrawable 类定义了矢量图片的属性。</p>
<p>通常可以在三个 XML 文件中定义动画矢量图片：</p>
<ul>
<li>在 <code>res/drawable/</code> 中的使用 <code>&lt;vector&gt;</code> 元素定义矢量图片。</li>
<li>在 <code>res/drawable/</code> 中使用 <code>&lt;animated-vector&gt;</code> 元素来定义动画矢量图片。</li>
<li>在 <code>res/anim/</code> 中使用 <code>&lt;objectAnimator&gt;</code> 元素定义一个或多个对象的动画绘制器。</li>
</ul>
<p>动画矢量图片可以推动 <code>&lt;group&gt;</code> 和 <code>&lt;path&gt;</code> 元素的属性。 <code>&lt;group&gt;</code> 元素定义路径或者子组的集合， <code>&lt;path&gt;</code> 元素定义需要绘制的路径。</p>
<p>当你定义一个你需要动画的矢量图片时，使用 <code>android:name</code> 属性来为组和路径分配唯一的名称，这样就可以从动画器的定义中应用他们。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- res/drawable/vectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:height</span>=<span class="value">"64dp"</span></span><br><span class="line">    <span class="attribute">android:width</span>=<span class="value">"64dp"</span></span><br><span class="line">    <span class="attribute">android:viewportHeight</span>=<span class="value">"600"</span></span><br><span class="line">    <span class="attribute">android:viewportWidth</span>=<span class="value">"600"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">group</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"rotationGroup"</span></span><br><span class="line">        <span class="attribute">android:pivotX</span>=<span class="value">"300.0"</span></span><br><span class="line">        <span class="attribute">android:pivotY</span>=<span class="value">"300.0"</span></span><br><span class="line">        <span class="attribute">android:rotation</span>=<span class="value">"45.0"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">path</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"v"</span></span><br><span class="line">            <span class="attribute">android:fillColor</span>=<span class="value">"#000000"</span></span><br><span class="line">            <span class="attribute">android:pathData</span>=<span class="value">"M300,70 l 0,-70 70,70 0,0 -70,70z"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在矢量图片中，动画矢量图片定义通过名称与组和路径相关联：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/animvectordrawable.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animated-vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"><span class="attribute">android:drawable</span>=<span class="value">"@drawable/vectordrawable"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">target</span></span><br><span class="line">      <span class="attribute">android:name</span>=<span class="value">"rotationGroup"</span></span><br><span class="line">      <span class="attribute">android:animation</span>=<span class="value">"@anim/rotation"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">target</span></span><br><span class="line">      <span class="attribute">android:name</span>=<span class="value">"v"</span></span><br><span class="line">      <span class="attribute">android:animation</span>=<span class="value">"@anim/path_morph"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动画定义为 ObjectAnimator 或者 AnimatorSet 对象。这个实例中的第一个动画绘制器将目标组旋转 360 度：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/rotation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">  <span class="attribute">android:duration</span>=<span class="value">"6000"</span></span><br><span class="line">  <span class="attribute">android:propertyName</span>=<span class="value">"rotation"</span></span><br><span class="line">  <span class="attribute">android:valueFrom</span>=<span class="value">"0"</span></span><br><span class="line">  <span class="attribute">android:valueTo</span>=<span class="value">"360"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第二个动画绘制器改变矢量图片的路径从一种形状到另一种。两条路径需要匹配改变：他们需要相同数量的命名，并且每个命令要有相同数量的参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/anim/path_morph.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">      <span class="attribute">android:duration</span>=<span class="value">"3000"</span></span><br><span class="line">      <span class="attribute">android:propertyName</span>=<span class="value">"pathData"</span></span><br><span class="line">      <span class="attribute">android:valueFrom</span>=<span class="value">"M300,70 l 0,-70 70,70 0,0   -70,70z"</span></span><br><span class="line">      <span class="attribute">android:valueTo</span>=<span class="value">"M300,70 l 0,-70 70,0  0,140 -70,0 z"</span></span><br><span class="line">      <span class="attribute">android:valueType</span>=<span class="value">"pathType"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 AnimatedVectorDrawable 的 API 参考文档。</p>
<p>原文：<a href="https://developer.android.com/training/material/animations.html" target="_blank" rel="external">Defining Custom Animations</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 中的动画能够让应用程序给予用户对于动作的反馈，提供用户交互的视觉持续性。 Material 主题为按钮和活动转场效果提供默认的动画， Android 5.0 (API 21) 以上版本可以定制这些动画，并创建新的：</p>
<ul>
<li>触摸反馈</li>
<li>圆形波纹</li>
<li>活动转场效果</li>
<li>曲线移动</li>
<li>视图状态改变</li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="动画" scheme="http://linfuyan.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用图片]]></title>
    <link href="http://linfuyan.com/material-design-training/working-with-drawables/"/>
    <id>http://linfuyan.com/material-design-training/working-with-drawables/</id>
    <published>2015-10-24T05:00:00.000Z</published>
    <updated>2015-11-03T09:21:09.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>图片所具有的下面能力可以帮助你在应用程序中实现 material design。</p>
<ul>
<li>图片着色。</li>
<li>抽取主色彩。</li>
<li>矢量图片。</li>
</ul>
<p>这节课程教你如何在应用程序中使用这些特性。</p>
<a id="more"></a>
<h2 id="对图片资源进行着色">对图片资源进行着色</h2><p>在 Android 5.0 ( API 21) 及以上，你可以定义透明度对位图和 9 patch 图片进行着色。你可以使用颜色资源或者对应颜色资源的主题属性(如 <code>?android:attr/colorPrimary</code> )对他们进行着色。通常，你只需要一次创建这些资源并对他们自动着色来适应你的主题。</p>
<p>通过 setTint() 方法可以对 BitmapDrawable， NinePatchDrawable 或 VectorDrawable 对象应用着色。也可以在布局中使用 <code>android:tint</code> 和 <code>android:tintMode</code> 属性来设置着色的颜色和模式。</p>
<h2 id="从图片中抽取主色彩">从图片中抽取主色彩</h2><p>在 Android Support 库 r21 及以上版本中包含有 Palette 类，可以从一张图片中抽取主色彩。这个类可以抽取下面的突出色彩：</p>
<ul>
<li></li>
<li></li>
</ul>
<p>要抽取这些色彩，当你在加载图片时在后台线程里面传递 Bitmap 对象到 Palette.generate() 静态方法中。如果你没有使用线程，那边调用 Palette.generateAsync() 方法并提供一个监听器。</p>
<p>在 Palette 类中，使用获取方法来从图片获取主要色彩，如 <code>Palette.getVibrantColor</code> 。</p>
<p>在项目中使用 Palette 类时，需要添加下面的 Gradle 依赖到应用程序模块：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:palette-v7:21.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看 API 参考中的 Palette 类。</p>
<h2 id="创建矢量图片">创建矢量图片</h2><p>在 Android 5.0 (API 21) 及以上，你可以定义矢量图片，这些图片在缩放过程中不会丢失清晰度。对应于每种屏幕密度需要一个位图文件，所有的屏幕密度仅需要一个矢量文件。要创建矢量图片，你需要在 XML 文件中的 <code>&lt;vector&gt;</code> 元素中定义形状细节。</p>
<p>下面的实例定义了一个心形的矢量图片：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- res/drawable/heart.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">vector</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">  &lt;!<span class="attribute">--</span> <span class="attribute">intrinsic</span> <span class="attribute">size</span> <span class="attribute">of</span> <span class="attribute">the</span> <span class="attribute">drawable</span> <span class="attribute">--</span>&gt;</span></span><br><span class="line">  android:height="256dp"</span><br><span class="line">  android:width="256dp"</span><br><span class="line">  <span class="comment">&lt;!-- size of the virtual canvas --&gt;</span></span><br><span class="line">  android:viewportWidth="32"</span><br><span class="line">  android:viewportHeight="32"&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- draw a path --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">path</span> <span class="attribute">android:fillColor</span>=<span class="value">"#8fff"</span></span><br><span class="line">    <span class="attribute">android:pathData</span>=<span class="value">"M20.5,9.5</span><br><span class="line">                      c-1.955,0,-3.83,1.268,-4.5,3</span><br><span class="line">                      c-0.67,-1.732,-2.547,-3,-4.5,-3</span><br><span class="line">                      C8.957,9.5,7,11.432,7,14</span><br><span class="line">                      c0,3.53,3.793,6.257,9,11.5</span><br><span class="line">                      c5.207,-5.242,9,-7.97,9,-11.5</span><br><span class="line">                      C25,11.432,23.043,9.5,20.5,9.5z"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">vector</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>矢量图片在 Android 中表现为 VectorDrawable 对象。关于 <code>pathData</code> 语法的更多信息，可以查看 <a href="http://www.w3.org/TR/SVG11/paths.html#PathData" target="_blank" rel="external">SVG 路径</a>。矢量图片中动画属性相关的更多信息，可以查看<a href="">动画矢量图片</a>。</p>
<p>原文：<a href="https://developer.android.com/training/material/drawables.html" target="_blank" rel="external">Working with Drawables</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>图片所具有的下面能力可以帮助你在应用程序中实现 material design。</p>
<ul>
<li>图片着色。</li>
<li>抽取主色彩。</li>
<li>矢量图片。</li>
</ul>
<p>这节课程教你如何在应用程序中使用这些特性。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="图片" scheme="http://linfuyan.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义阴影与裁剪视图]]></title>
    <link href="http://linfuyan.com/material-design-training/defining-shadows-and-clipping-views/"/>
    <id>http://linfuyan.com/material-design-training/defining-shadows-and-clipping-views/</id>
    <published>2015-10-24T04:00:00.000Z</published>
    <updated>2015-11-03T09:13:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 为 UI 元素引入了海拔的概念。海拔能够帮助用户理解每个元素的相对重要程度，并关注正在运行的任务。</p>
<p>视图的海拔有 Z 属性来表示，决定它的阴影的视觉展示：拥有更高 Z 值的视图打造更大，更软的阴影。拥有更高 Z 值的视图会挡住低 Z 值的视图，视图的 Z 值多少并不影响视图的尺寸。</p>
<p>阴影由被抬起视图的父视图来绘制，并默认由父视图进行视图裁剪。</p>
<p>在某些动作中，当控件临时上升到其他普通视图之上时。海拔对于创建动画非常有用。</p>
<p>Material design 中海拔相关的更多信息，可以查看 <a href="http://www.google.com/design/spec/what-is-material/objects-in-3d-space.html" target="_blank" rel="external">3D 空间中的物体</a>。</p>
<a id="more"></a>
<h2 id="为视图设置海拔">为视图设置海拔</h2><p>视图的 Z 值有两个组件：</p>
<ul>
<li>海拔：静态组件。</li>
<li>变换：用于动画的动态组件。</li>
</ul>
<blockquote>
<p>Z = elevation + translationZ</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/shadows-depth.png" alt="不同视图海拔的阴影"></p>
<p>在布局定义中设置视图的海拔，使用 <code>android:elevation</code> 属性。在活动的代码中设置视图的海拔，使用 View.setElevation() 方法。</p>
<p>设置视图的变换使用 View.setTranslationZ() 方法。</p>
<p>新的 ViewPropertyAnimator.z() 和 ViewPropertyAnimator.translationZ() 方法使得视图海拔的动画变得简单。更多信息可以查看开发者指南中的 ViewPropertyAnimator 和 Property Animation。</p>
<p>你可以使用 StateListAnimator 来以声明的方式指定这些动画。当在状态的变化中出发动画时，这将非常有用，例如当用户按下按钮时。更多信息，可以查看 <a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="external">动画视图状态改变</a>。</p>
<p>测量 Z 值的单位是 dp。</p>
<h2 id="自定义视图阴影和轮廓">自定义视图阴影和轮廓</h2><p>视图背景图片的边沿决定了它的阴影的默认形状。轮廓代表了图形对象的外围形状并定义了触摸反馈的波纹区域。</p>
<p>假设下面的视图，定义了背景图片：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="property">id</span>=<span class="string">"@+id/myview"</span></span><br><span class="line">    ...</span><br><span class="line">    android:elevation=<span class="string">"2dp"</span></span><br><span class="line">    android:background=<span class="string">"@drawable/myrect"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>背景图片定义为具有圆角的矩形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/drawable/myrect.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">shape</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">     <span class="attribute">android:shape</span>=<span class="value">"rectangle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">solid</span> <span class="attribute">android:color</span>=<span class="value">"#42000000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">corners</span> <span class="attribute">android:radius</span>=<span class="value">"5dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>视图打造了具有圆角的阴影，背景图片定义了视图的轮廓。</p>
<p>提供自定义的轮廓来覆盖视图阴影的默认形状。</p>
<p>在代码中为视图定义自定义的轮廓：</p>
<ol>
<li>继承 ViewOutlineProvider 类。</li>
<li>覆盖 getOutline() 方法。</li>
<li>通过 View.setOutlineProvider() 方法为视图设置新的轮廓提供者。</li>
</ol>
<p>使用 Outline 类中的方法可以来创建椭圆形或者带有圆角的矩形轮廓。视图默认的轮廓提供者从视图的背景中获取轮廓。要阻止视图生成阴影，只要将它的轮廓提供者设置为 <code>null</code> 就可以了。</p>
<h2 id="裁剪视图">裁剪视图</h2><p>裁剪视图让改变视图的形状变得简单。你可以通过裁剪视图让其与其他设计元素之间保持一致，也可以改变视图的形状来反应用户输入。通过 View.setClipToOutline() 方法或者 <code>android:clipToOutline</code> 属性来对视图的轮廓区域进行裁剪。只有矩形，圆形和圆角矩形轮廓支持裁剪，能否裁剪是由 Outline.canClip() 方法决定的。</p>
<p>要裁剪视图中图片的形状，需要将图片设置为视图的背景，并调用 View.setClipToOutline() 方法。</p>
<p>裁剪视图是一个代价昂贵的操作，因此不要对用于裁剪视图的形状做动画。要达到这样的效果，可以使用<br> <a href="https://developer.android.com/training/material/animations.html#Reveal" target="_blank" rel="external">Reveal Effect</a> 动画。</p>
<p> 原文：<a href="https://developer.android.com/training/material/shadows-clipping.html" target="_blank" rel="external">Defining Shadows and Clipping Views</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 为 UI 元素引入了海拔的概念。海拔能够帮助用户理解每个元素的相对重要程度，并关注正在运行的任务。</p>
<p>视图的海拔有 Z 属性来表示，决定它的阴影的视觉展示：拥有更高 Z 值的视图打造更大，更软的阴影。拥有更高 Z 值的视图会挡住低 Z 值的视图，视图的 Z 值多少并不影响视图的尺寸。</p>
<p>阴影由被抬起视图的父视图来绘制，并默认由父视图进行视图裁剪。</p>
<p>在某些动作中，当控件临时上升到其他普通视图之上时。海拔对于创建动画非常有用。</p>
<p>Material design 中海拔相关的更多信息，可以查看 <a href="http://www.google.com/design/spec/what-is-material/objects-in-3d-space.html">3D 空间中的物体</a>。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="视图" scheme="http://linfuyan.com/tags/%E8%A7%86%E5%9B%BE/"/>
    
      <category term="阴影" scheme="http://linfuyan.com/tags/%E9%98%B4%E5%BD%B1/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建列表和卡片]]></title>
    <link href="http://linfuyan.com/material-design-training/creating-lists-and-cards/"/>
    <id>http://linfuyan.com/material-design-training/creating-lists-and-cards/</id>
    <published>2015-10-24T03:00:00.000Z</published>
    <updated>2015-11-03T09:20:03.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>在应用程序中要创建具备 material design 风格的复杂列表和卡片，可以使用 RecyclerView 和 CardView 组件。</p>
<a id="more"></a>
<h2 id="创建列表">创建列表</h2><p>RecyclerView 组件是一个更加高级，更加灵活的 ListView 版本。这个组件是这样一个容器，可以用来显示大量的数据集，并且通过维护有限数量的视图来非常高效的滚动。当你拥有大量的数据集，且其中的元素基于用户操作或者网络数据而在运行时改变时，使用 RecyclerView。</p>
<p>RecyclerView 通过提供以下两点来简化显示并处理大数据集：</p>
<ul>
<li>布局管理器来定位数据项</li>
<li>为公共数据项的操作定义默认动画，如删除或者新增数据项</li>
</ul>
<p>你可以灵活地为 RecyclerView 组件定义自定义的布局管理器和动画。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/RecyclerView.png" alt="RecyclerView 组件"></p>
<p>使用 RecyclerView 组件时，需要制定一个适配器和布局管理器。继承 <code>RecyclerView.Adapter</code> 类来创建一个适配器。具体的实现则依赖于特定的数据集和视图的类型。更多信息，可以查看下面的实例。</p>
<p><strong>布局管理器</strong>在 RecyclerView 中定位项的视图，并决定当项的视图对用户不可见后何时被复用。要复用(或者回收)一个视图，布局管理器会要求适配从数据集中用一个不同的元素来替换视图的内容。用这种方式来复用视图可以避免由于不必要的视图创建和执行昂贵的 <code>findViewById()</code> 操作，从而提升性能。</p>
<p>RecyclerView 内置了下面的布局管理器：</p>
<ul>
<li>LinearLayoutManager：在垂直或者水平滚动列表中显示项。</li>
<li>GridLayoutManager：通过网格显示项。</li>
<li>StaggeredGridLayout：在错落的网格中显示项。</li>
</ul>
<p>继承 RecyclerView.LayoutManager 类来创建自定义的布局管理器。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/list_mail.png" alt="Lists with RecyclerView"></p>
<h3 id="动画">动画</h3><p>在 RecyclerView 中添加和移除项的动画是默认支持的。要自定义这些动画，继承 RecyclerView.ItemAnimator 类并使用 RecyclerView.setItemAnimator() 方法。</p>
<h3 id="实例">实例</h3><p>下面的代码实例展示如何添加 RecyclerView 到布局：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A RecyclerView with some commonly used attributes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">  <span class="attribute">android:id</span>=<span class="value">"@+id/my_recycler_view"</span></span><br><span class="line">  <span class="attribute">android:scrollbars</span>=<span class="value">"vertical"</span></span><br><span class="line">  <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">  <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦添加一个 RecyclerView 组件到布局中，获得一个对象的句柄，并连接到布局管理器，然后关联一个需要显示的数据的适配器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span> mRecyclerView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">Adapter</span> mAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RecyclerView</span>.<span class="type">LayoutManager</span> mLayoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.my_activity);</span><br><span class="line">        mRecyclerView = (<span class="type">RecyclerView</span>) findViewById(<span class="type">R</span>.id.my_recycler_view);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果你已知 RecyclerView 的内容改变不会改变布局尺寸，使用这个设置可以提升效率。</span></span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线性布局管理器</span></span><br><span class="line">        mLayoutManager = <span class="keyword">new</span> <span class="type">LinearLayoutManager</span>(<span class="keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 制定适配器</span></span><br><span class="line">        mAdapter = <span class="keyword">new</span> <span class="type">MyAdapter</span>(myDataset);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适配器提供对数据集中数据项的访问，为数据项创建视图，并且当原始数据项不再可见时使用新的数据项来替换这些视图的内容。下面的代码实例展示一个有字符串数组组成且使用 TextView 控件显示的简单数据集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mDataset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个数据项的视图提供一个引用。复杂的数据项可能需要多余一个视图，并且在一个 view holder中为每个数据项的所有视图进行访问。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个实例中，每个数据项是仅仅是一个字符串</span></span><br><span class="line">        <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">            mTextView = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供一个合适的构造方法(这取决于数据集类型)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(String[] myDataset)</span> </span>&#123;</span><br><span class="line">        mDataset = myDataset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的视图(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyAdapter.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,</span><br><span class="line">                                                   <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建视图</span></span><br><span class="line">        View v = LayoutInflater.from(parent.getContext())</span><br><span class="line">                               .inflate(R.layout.my_text_view, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置视图的尺寸，外边距，内边距和布局参数</span></span><br><span class="line">        ...</span><br><span class="line">        ViewHolder vh = <span class="keyword">new</span> ViewHolder(v);</span><br><span class="line">        <span class="keyword">return</span> vh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换视图的内容(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// - 从数据集中获取当前位置的元素</span></span><br><span class="line">        <span class="comment">// - 用该元素替换视图的内容</span></span><br><span class="line">        holder.mTextView.setText(mDataset[position]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据集的大小(由布局管理器调用)</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDataset.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建卡片">创建卡片</h2><p>CardView 集成自 FrameLayout 类，能够使显示在卡片中的信息在多个平台上拥有一致的外观。 CardView 控件可以拥有阴影和圆角。</p>
<p>使用 <code>card_view:cardElevation</code> 属性来创建带圆角的卡片。 CardView 在 Android 5.0 ( API 21) 及以上版本使用真正的海拔和动态阴影，在早先的版本中则使用可编程的阴影实现。更多信息，查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
<p>使用下面的属性来自定义 CardView 组件的外观：</p>
<ul>
<li>在布局中使用 <code>card_view:cardCornerRadius</code> 属性来设置圆角半径。</li>
<li>在代码中使用 <code>CardView.setRadius</code> 方法来设置圆角半径。</li>
<li>使用 <code>card_view:cardBackgroundColor</code> 属性来设置卡片的背景色。</li>
</ul>
<p>下面的代码实例展示如何在布局中包含 CardView 控件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">xmlns:card_view</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- A CardView that contains a TextView --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v7.widget.CardView</span></span><br><span class="line">        <span class="attribute">xmlns:card_view</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/card_view"</span></span><br><span class="line">        <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"200dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"200dp"</span></span><br><span class="line">        <span class="attribute">card_view:cardCornerRadius</span>=<span class="value">"4dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/info_text"</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多信息，查看 CardView 的 API 引用。</p>
<h2 id="添加依赖">添加依赖</h2><p>RecyclerView 和 CardView 控件是 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Supprot V7 兼容包</a>中的一部分。要在项目中使用这些组件，需要添加下面的 Gradle 依赖到应用模块中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:cardview-v7:21.0.+'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>在应用程序中要创建具备 material design 风格的复杂列表和卡片，可以使用 RecyclerView 和 CardView 组件。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="CardView" scheme="http://linfuyan.com/tags/CardView/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="RecyclerView" scheme="http://linfuyan.com/tags/RecyclerView/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Material 主题]]></title>
    <link href="http://linfuyan.com/material-design-training/using-the-material-theme/"/>
    <id>http://linfuyan.com/material-design-training/using-the-material-theme/</id>
    <published>2015-10-24T02:00:35.000Z</published>
    <updated>2015-11-03T09:26:29.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>新的 material 主题提供：</p>
<ul>
<li>可以设置调色板的系统组件。</li>
<li>系统组件的触摸反馈动画。</li>
<li>活动转场效果动画。</li>
</ul>
<a id="more"></a>
<p>使用调色板，你可以根据自己的品牌标识来自定义 material 主题的外观。可以通过主题属性来为状态栏和 action bar 着色，如下图所示。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/ThemeColors.png" alt="自定义 material 主题"></p>
<p>系统组件拥有新的设计以及触摸反馈动画。你可以自定义应用程序的调色板，触摸反馈动画以及活动转场效果。</p>
<p>Material 主题定义如下：</p>
<ul>
<li><code>@android:style/Theme.Material</code>: 深色版本</li>
<li><code>@android:style/Theme.Material.Light</code>: 浅色版本</li>
<li><code>@android:style/Theme.Material.Light.DarkActionBar</code></li>
</ul>
<p>可使用的 material 风格列表，可以查看 R.style 的 API 引用。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/MaterialDark.png" alt="图1 深色 material 主题"></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/MaterialLight.png" alt="图2 浅色 material 主题"></p>
<blockquote>
<p><strong>注意：</strong> Material 主题仅仅在 Android 5.0 (API 21) 及以上系统版本可用。 <a href="https://developer.android.com/tools/support-library/features.html#v7" target="_blank" rel="external">Support V7 兼容包</a> 为一些组件提供了具备 material 设计风格的主题，以及自定义调色板的支持。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
</blockquote>
<h2 id="自定义调色板">自定义调色板</h2><p>为了自定义主题的基本颜色来适应自己的品牌，需要继承 material 主题，并使用主题属性来定义自己的自定义颜色。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  &lt;!<span class="comment">-- inherit from the material theme --&gt;</span></span><br><span class="line">  &lt;style <span class="property">name</span>=<span class="string">"AppTheme"</span> parent=<span class="string">"android:Theme.Material"</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">-- Main theme colors --&gt;</span></span><br><span class="line">    &lt;!<span class="comment">--   your app branding color for the app bar --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorPrimary"</span>&gt;@color/primary&lt;/<span class="property">item</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">--   darker variant for the status bar and contextual app bars --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorPrimaryDark"</span>&gt;@color/primary_dark&lt;/<span class="property">item</span>&gt;</span><br><span class="line">    &lt;!<span class="comment">--   theme UI controls like checkboxes and text fields --&gt;</span></span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:colorAccent"</span>&gt;@color/accent&lt;/<span class="property">item</span>&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<h2 id="自定义状态栏">自定义状态栏</h2><p>Material 主题可以很方便的自定义状态栏，因此你可以指定一个颜色来适应自己的品牌并提供足够的对比来显示白色的状态栏图标。继承 material 主题，并且使用 <code>android:statusBarColr</code> 属性来为状态来设置自定义颜色。默认情况下， <code>android:statusBarColor</code> 继承 <code>android:colorPrimaryDark</code> 的值。</p>
<p>你也可以自己在状态栏上进行绘制。例如，你想要在一张照片上显示透明的状态栏，并且使用微薄的深色渐变来确保白色的状态栏图标可见。要实现这个功能，将 <code>android.statusBarColor</code> 属性设置为 <code>@android:color/transparent</code> 并且根据要求设置窗口标识。可以使用 Window.setStatusBarColor() 方法来设置动画或者淡出。</p>
<blockquote>
<p><strong>注意</strong>：状态栏大部分情况下应该有区别于主要工具栏的明显轮廓，除非你需要在工具栏后显示丰富的意象或者媒体内容，并且所使用的渐变需要保证图标依然可见。</p>
</blockquote>
<p>当你自定义导航栏和状态栏时，你可以使两者都是透明的或者仅仅修改状态栏。其他情况下导航栏需要保持黑色。</p>
<h2 id="主题个性视图">主题个性视图</h2><p>定义在 XML 布局中的元素可以指定 <code>android:theme</code> 属性，用来引用一个主题资源。这个属性为元素和其子元素修改主题，当要替换界面的某个部分的主题调色板时，这是很有用的。</p>
<p>原文：<a href="https://developer.android.com/training/material/theme.html" target="_blank" rel="external">Using the Material Theme</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>新的 material 主题提供：</p>
<ul>
<li>可以设置调色板的系统组件。</li>
<li>系统组件的触摸反馈动画。</li>
<li>活动转场效果动画。</li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="主题" scheme="http://linfuyan.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[准备开始]]></title>
    <link href="http://linfuyan.com/material-design-training/get-started/"/>
    <id>http://linfuyan.com/material-design-training/get-started/</id>
    <published>2015-10-24T01:00:01.000Z</published>
    <updated>2015-11-03T09:09:23.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>创建具有 material design 特性的应用程序，步骤如下：</p>
<ol>
<li>审查 <a href="">material design 规范</a>。</li>
<li>应用 material <strong>主题</strong>到应用程序。</li>
<li>根据 material design 指南创建<strong>布局</strong>。</li>
<li>确定视图的<strong>海拔</strong>来打造阴影。</li>
<li>为列表和卡片使用系统<strong>组件</strong>。</li>
<li>在应用程序中自定义<strong>动画</strong>。</li>
</ol>
<a id="more"></a>
<h3 id="维持向后兼容">维持向后兼容</h3><p>你可以为应用程序添加许多 material design 特性，同时对低于 Android 5.0 的版本保持兼容。更多信息，可以查看 <a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a>。</p>
<h3 id="升级应用程序使之具备_material_design">升级应用程序使之具备 material design</h3><p>要升级已经存在的应用程序来包含 material design，根据 material design 指南来升级布局。同时确保包含深度，触摸反馈和动画。</p>
<h3 id="创建具备_material_design_的新应用程序">创建具备 material design 的新应用程序</h3><p>如果要创建一个具备 material design 特性的应用程序，<a href="http://www.google.com/design/spec" target="_blank" rel="external">material design 指南</a> 提供了一个紧密结合的设计框架。按照这些指南，使用 Android 框架中的新特性来设计和开发应用程序。</p>
<h2 id="应用_material_主题">应用 material 主题</h2><p>要应用 material 主要到应用程序中，需要指定一种风格继承自 <code>android:Theme.Material</code> :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/values/styles.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- your theme inherits from the material theme --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"android:Theme.Material"</span>&gt;</span><span class="css"></span><br><span class="line">    &lt;!<span class="tag">--</span> <span class="tag">theme</span> <span class="tag">customizations</span> <span class="tag">--</span>&gt;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Material 主题提供了升级过的系统组件来为触摸反馈和活动的转场效果设置调色和默认动画。更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="external">使用 Material 主题</a>。</p>
<h2 id="设计布局">设计布局</h2><p>除了应用和自定义 material 主题之外，布局需要与 material design 指南保持一致。在设计布局时，需要注意下面几点：</p>
<ul>
<li>基线表格</li>
<li>注解行</li>
<li>空白</li>
<li>触摸目标尺寸</li>
<li>布局结构</li>
</ul>
<h2 id="指定视图的海拔">指定视图的海拔</h2><p>视图可以打造阴影，视图的海拔值决定它的阴影尺寸以及它的绘制顺序。在布局中使用 <code>android:elevation</code> 属性来设置视图的海拔。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:<span class="property">id</span>=<span class="string">"@+id/my_textview"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="type">text</span>=<span class="string">"@string/next"</span></span><br><span class="line">    android:background=<span class="string">"@color/white"</span></span><br><span class="line">    android:elevation=<span class="string">"5dp"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>新的 <code>translationZ</code> 属性可以用来创建动画来反映视图海拔的临时变化。当<a href="https://developer.android.com/training/material/animations.html#ViewState" target="_blank" rel="external">响应触摸事件</a>时，海拔的改变会非常有用。</p>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="external">定义阴影及裁剪视图</a>。</p>
<h2 id="创建列表和卡片">创建列表和卡片</h2><p>RecyclerView 是一个更加具有可插拔性的 ListView 版本，支持不同的布局类型，提供性能改进。 CardView 可以为不同的应用程序中在卡片内显示的信息提供一致的外观。下面的实例代码展示如何在布局中包含 CardView 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.CardView</span></span><br><span class="line">    android:id=<span class="string">"@+id/card_view"</span></span><br><span class="line">    android:layout_width=<span class="string">"200dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"200dp"</span></span><br><span class="line">    card_view:cardCornerRadius=<span class="string">"3dp"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.CardView</span>&gt;</span><br></pre></td></tr></table></figure>
<p>更多信息，可以查看<a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="external">创建列表和卡片</a>。</p>
<h2 id="自定义动画">自定义动画</h2><p>Android 5.0 (API 21) 包含用来在应用程序中创建自定义动画的新的 API 。例如，你可以在一个活动中启用活动的转场效果并定义一个退出的转场效果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// enable transitions</span></span><br><span class="line">        getWindow().requestFeature(<span class="type">Window</span>.<span class="type">FEATURE_CONTENT_TRANSITIONS</span>);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_my);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onSomeButtonClicked(<span class="type">View</span> view) &#123;</span><br><span class="line">        getWindow().setExitTransition(<span class="keyword">new</span> <span class="type">Explode</span>());</span><br><span class="line">        <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="keyword">this</span>, <span class="type">MyOtherActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">        startActivity(intent,</span><br><span class="line">                      <span class="type">ActivityOptions</span></span><br><span class="line">                          .makeSceneTransitionAnimation(<span class="keyword">this</span>).toBundle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你从这个活动启动另外一个活动时，退场效果将会被激活。</p>
<p>可以查看<a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="external">定义自定义动画</a>来学些更多新的动画 API 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>创建具有 material design 特性的应用程序，步骤如下：</p>
<ol>
<li>审查 <a href="">material design 规范</a>。</li>
<li>应用 material <strong>主题</strong>到应用程序。</li>
<li>根据 material design 指南创建<strong>布局</strong>。</li>
<li>确定视图的<strong>海拔</strong>来打造阴影。</li>
<li>为列表和卡片使用系统<strong>组件</strong>。</li>
<li>在应用程序中自定义<strong>动画</strong>。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Material Design 概览]]></title>
    <link href="http://linfuyan.com/material-design-training/training-index/"/>
    <id>http://linfuyan.com/material-design-training/training-index/</id>
    <published>2015-10-24T00:00:35.000Z</published>
    <updated>2015-11-03T09:18:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 是一种为视觉，动作和交互而设计的规范，易于理解，跨平台、跨设备。要在 Android 应用程序中使用 material design，需要参照 [material design 规范] 中描述的指南，并使用 Android 5.0 ( API 21) 上的新组件和功能。</p>
<a id="more"></a>
<p>这个课程展示如何通过下面的元素来创建具备 material design 的应用程序。</p>
<ul>
<li>Material 主题</li>
<li>列表及卡片组件</li>
<li>自定义阴影和视图裁剪</li>
<li>矢量图片</li>
<li>自定义动画</li>
</ul>
<p>这个课程同时讲授在你的应用中使用 material design 时如何对低于 Android 5.0 (API 21) 版本进行兼容。</p>
<h2 id="课程">课程</h2><h3 id="准备开始"><a href="http://www.linfuyan.com/material-design-training/get-started/" target="_blank" rel="external">准备开始</a></h3><p>学习如何将应用程序升级到使用 material design。</p>
<h3 id="使用_Material_主题"><a href="http://www.linfuyan.com/material-design-training/using-the-material-theme/" target="_blank" rel="external">使用 Material 主题</a></h3><p>学习如何应用 material design 样式到应用程序。</p>
<h3 id="创建列表和卡片"><a href="http://www.linfuyan.com/material-design-training/creating-lists-and-cards/" target="_blank" rel="external">创建列表和卡片</a></h3><p>学习如何使用系统组件来创建具有统一观感的列表和卡片。</p>
<h3 id="定义阴影和裁剪视图"><a href="http://www.linfuyan.com/material-design-training/defining-shadows-and-clipping-views/" target="_blank" rel="external">定义阴影和裁剪视图</a></h3><p>学习如何设置视图的海拔来创建自定义阴影及如何裁剪视图。</p>
<h3 id="使用图片"><a href="http://www.linfuyan.com/material-design-training/working-with-drawables/" target="_blank" rel="external">使用图片</a></h3><p>学习如何创建矢量图片及如何给图片资源着色。</p>
<h3 id="定义自定义动画"><a href="http://www.linfuyan.com/material-design-training/defining-custom-animations/" target="_blank" rel="external">定义自定义动画</a></h3><p>学习如何创建视图的自定义动画以及具有共享元素的活动转场效果。</p>
<h3 id="保持兼容性"><a href="http://www.linfuyan.com/material-design-training/maintaining-compatibility/" target="_blank" rel="external">保持兼容性</a></h3><p>学习如何对低于 Android 5.0 的系统维持兼容性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这是来自 Google 官方的 Material Design 培训教程的翻译，受个人水平所限，难免有翻译不对的地方，欢迎交流指正。</p>
</blockquote>
<p>Material design 是一种为视觉，动作和交互而设计的规范，易于理解，跨平台、跨设备。要在 Android 应用程序中使用 material design，需要参照 [material design 规范] 中描述的指南，并使用 Android 5.0 ( API 21) 上的新组件和功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://linfuyan.com/tags/Material-Design/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="概览" scheme="http://linfuyan.com/tags/%E6%A6%82%E8%A7%88/"/>
    
      <category term="教程" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="官方 Material Design 培训" scheme="http://linfuyan.com/categories/%E6%95%99%E7%A8%8B/%E5%AE%98%E6%96%B9-Material-Design-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用 Git 命令使用教程]]></title>
    <link href="http://linfuyan.com/git-cmd-user-guide/"/>
    <id>http://linfuyan.com/git-cmd-user-guide/</id>
    <published>2015-10-14T02:00:00.000Z</published>
    <updated>2015-10-16T04:01:02.000Z</updated>
    <content type="html"><![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>
<a id="more"></a>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-cmd-user-guide.png" alt="常用 Git 命令使用教程"></p>
<h2 id="Git_配置">Git 配置</h2><p>1. 在安装完成 Git 后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱。</p>
<p>设置的主要命令是 <code>git config</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"your name"</span>  	<span class="comment">// 设置全局用户名</span></span><br><span class="line">git config --global user<span class="class">.email</span> <span class="string">"your email"</span>	<span class="comment">// 设置邮箱</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>--global</code> 指定为全局配置，不使用该参数，则为当前所在仓库配置。</p>
<p>2. 除了用户名、邮箱之外，还有很多的配置可以用来自定义 Git，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="attribute">color</span><span class="class">.ui</span> true		<span class="comment">// 让 Git 显示不同的颜色</span></span><br><span class="line">git config core<span class="class">.ignorecase</span> true			<span class="comment">// 让 Git 对仓库中的文件大小写敏感</span></span><br></pre></td></tr></table></figure>
<p>3. 查看所有的已经做出的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-config.gif" alt="git config"></p>
<h2 id="基础操作">基础操作</h2><h3 id="创建_Git_版本库">创建 Git 版本库</h3><p>在本地创建 Git 版本库，需要使用 <code>git init</code> 命令。</p>
<p>首先，你需要新建一个存放版本库的目录，然后进入到该目录所在路径，然后执行：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> init</span><br></pre></td></tr></table></figure>
<p>然后查看目录结构中，就可以看到包含有 <code>.git</code> 子目录，这就说明创建版本库成功了。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-init.gif" alt="git init"></p>
<h3 id="将文件添加到版本库">将文件添加到版本库</h3><p>要将一个文件纳入到版本库管理，首先要将其添加到暂存区(这里不做深入介绍)，然后才能提交到仓库中。</p>
<p>1. 将文件添加到暂存区，使用的是 <code>git add</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> Readme.md	<span class="comment">	// 添加单个文件到暂存区</span></span><br><span class="line">git <span class="built_in">add</span> .			<span class="comment">	// 将当前目录下所有修改添加到暂存区，除按照规则忽略的之外</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边空文件夹是不会被添加到暂存区中的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-add.gif" alt="git add"></p>
<p>2. 将暂存区中的文件，提交到仓库中。需要使用 <code>git commit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">commit</span>		// 如果暂存区有文件，则将其中的文件提交到仓库</span><br><span class="line">git <span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">'your comments'</span> 		// 带评论提交，用于说明提交内容、变更、作用等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这边直接用 <code>git commit</code> 提交，会先弹出添加评论的页面。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-commit.gif" alt="git commit"></p>
<h3 id="查看仓库的状态">查看仓库的状态</h3><p>不论我们是新建了文件，将文件加入暂存区，或者其他的修改等等，我们都可以通过：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">status</span></span><br></pre></td></tr></table></figure>
<p>来随时查看仓库中文件的状态。这个应该是使用 Git 做版本控制过程中，我使用最多的一个命令。</p>
<h3 id="查看仓库中的具体修改">查看仓库中的具体修改</h3><p>很经常的，我们对某个文件做了修改，但过不久就忘记了。这时候就可以通过 <code>git diff</code> 来查看具体的修改内容。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff	<span class="comment">// 查看版本库中所有的改动</span></span><br><span class="line">git diff Readme<span class="class">.md</span>		<span class="comment">// 查看具体文件的改动</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-diff.gif" alt="git diff"></p>
<h3 id="查看提交历史记录">查看提交历史记录</h3><p>有的时候，你会需要查看自己做过哪些提交，来回顾自己完成的部分。或者需要寻找某个具体的提交来查看当时的代码。这里需要用到：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">	// 显示所有提交的历史记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline	// 单行显示提交历史记录的内容</span></span><br></pre></td></tr></table></figure>
<p>在 <code>git log</code> 的输出内容中，可以看到每次提交的 ID，是一个 40 位的字符串。</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-log.gif" alt="git log"></p>
<h3 id="版本回退">版本回退</h3><p>有了 <code>git log</code> 来查看提交的历史记录，我们就可以通过 <code>git reset --hard</code> 来回退到我们需要的特定版本，然后使用当时的代码进行各种操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard HEAD^		// 回退到上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD^^		// 回退到上上一个提交版本</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 'commit_id'	// 会退到 commit_id 指定的提交版本</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-1.gif" alt="git reset --hard"></p>
<h3 id="回到未来的某个提交">回到未来的某个提交</h3><p>当退回到某个提交的版本以后，再通过 <code>git log</code> 是无法显示在这之后的提交信息的。但是，通过 <code>git reflog</code> 可以获取到操作命令的历史。</p>
<p>因此，想要回到未来的某个提交，先通过 <code>git reflog</code> 从历史命令中找到想要回到的提交版本的 ID，然后通过 <code>git reset --hard</code> 来切换。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git <span class="keyword">reset</span> --hard <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reflog.gif" alt="git reflog"></p>
<h3 id="撤销修改">撤销修改</h3><p>撤销修改同样包括两方面的内容，由于仓库中的文件在提交之前，可能在工作区中，尚未在版本控制范围内，也可能在暂存区中。</p>
<p>1. 丢弃工作区中文件的修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- Readme<span class="class">.md</span>	<span class="comment">// 如果 Readme.md 文件在工作区，则丢弃其修改</span></span><br><span class="line">git checkout -- .			<span class="comment">// 丢弃当前目录下所有工作区中文件的修改</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git checkout --</code> 中的 <code>--</code> 是必须的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-checkout-1.gif" alt="git checkout --"></p>
<p>2. 丢弃已经进入暂存区的修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="keyword">HEAD</span> Readme.md 	// 将 Readme.md 恢复到 <span class="keyword">HEAD</span> 提交版本的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-reset-head.gif" alt="git reset HEAD"></p>
<h3 id="删除文件">删除文件</h3><p>在文件未添加到暂存区之前，对想删除文件可以直接物理删除。或者通过 <code>git checkout -- file</code> 来丢弃。如果文件已经被提交，则需要 <code>git rm</code> 来删除：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm Readme<span class="class">.md</span> 	<span class="comment">// 删除已经被提交过的 Readme.md</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git rm</code> 只能删除已经提交到版本库中的文件。其他状态的文件直接用这个命令操作是出错的。</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/git-rm.gif" alt="git rm"></p>
<p><strong><code>git rm</code> 与 先 rm 然后 <code>git add</code> 的区别</strong></p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/rm-and-git-add.gif" alt="rm and git add"></p>
<p>更详细的可以参考：<a href="http://yang3wei.github.io/blog/2013/02/03/git-rm-he-rm-de-qu-bie/" target="_blank" rel="external">“git rm” 和 “rm” 的区别</a></p>
<blockquote>
<p>注意：上图中的结果是在 git 1.9.1 版本上的操作。在 git 2.0 以上两者没有区别了。</p>
</blockquote>
<h2 id="分支管理">分支管理</h2><p>分支是版本控制系统中很重要的一个概念，在 Git 中新建、合并等分支的操作非常轻量便捷，因此我们会很经常的用到。</p>
<h3 id="查看分支">查看分支</h3><p>查看分支使用 <code>git branch</code>：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch		<span class="comment">// 查看本地分支信息</span></span><br><span class="line">git branch -v 	<span class="comment">// 查看相对详细的本地分支信息</span></span><br><span class="line">git branch -av 	<span class="comment">// 查看包括远程仓库在内的分支信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 <code>git branch</code> 的输出内容中，有一个分支，前面带有 <code>*</code> 号，这标识我们当前所在的分支。</p>
</blockquote>
<h3 id="创建分支">创建分支</h3><p>当我们要修复一个 Bug，或者开发一个新特性，甚至是在初学的时候怕打乱原来的代码，都可以新建一个分支来避免对原来代码的影响。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">dev</span>	<span class="comment">// 新建一个名称为 dev 的分支</span></span><br></pre></td></tr></table></figure>
<h3 id="切换分支">切换分支</h3><p>当我们创建完分支以后，我们需要切换到新建的分支，否则，所有的修改，还是在原来的分支上。事实上，所有的改动，只能影响到当前所在的分支。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">dev</span>	<span class="comment">// 新建完 dev 分支以后，通过该命令切换到 dev 分支</span></span><br></pre></td></tr></table></figure>
<h3 id="创建并切换分支">创建并切换分支</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="tag">b</span> dev		<span class="comment">// 新建 dev 分支，并切换到该分支上</span></span><br></pre></td></tr></table></figure>
<p>这个命令合并了前两个独立的命令，平常使用中一般这样使用。</p>
<h3 id="合并分支">合并分支</h3><p>当我们修复完成一个 Bug，或者开发完成一个新特性，我们就会把相关的 Bug 或者 特性的上修改合并回原来的主分支上，这时候就需要 <code>git merge</code> 来做分支的合并。</p>
<p>首先需要切换回最终要合并到的分支，如 <code>master</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master	<span class="comment">	// 切换回 master 分支</span></span><br><span class="line">git <span class="built_in">merge</span> dev		<span class="comment">	// 将 dev 分钟中的修改合并回 master 分支</span></span><br></pre></td></tr></table></figure>
<p>合并回主分支的时候，后面可能会面临到冲突的问题。冲突的解决暂不在这里说明。</p>
<h3 id="删除分支">删除分支</h3><p>当之前创建的分支，完成了它的使命，如 Bug 修复完，分支合并以后，这个分支就不在需要了，就可以删除它。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">dev</span>		<span class="comment">// 删除 dev 分支</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库">远程仓库</h2><p>上面的所有命令都是针对本地仓库的操作。当我们希望多个人来协作时，会将代码发布到一个统一的远程仓库，然后多个人在本地操作以后，在推送到远程仓库。其他人协作时，需要先同步远程仓库的内容，再推送自己的修改。</p>
<h3 id="从远程仓库克隆">从远程仓库克隆</h3><p>如果你本地没有仓库，希望从已有的远程仓库上复制一份代码，那么你需要 <code>git clone</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/git/git.git 	// 通过 https 协议，克隆 Github 上 git 仓库的源码</span></span><br><span class="line">git clone linfuyan<span class="annotation">@github</span>.com<span class="regexp">/git/</span>git.git	<span class="comment">// 通过 ssh 协议，克隆 Github 上 git 仓库的源码</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git clone</code> 后面的仓库地址，可以支持多种协议，如 https， ssh 等。</p>
</blockquote>
<h3 id="添加远程仓库">添加远程仓库</h3><p>如果你已经有了一个本地仓库，如之前创建的 <code>git-guide</code>，然后你打算将它发布到远程，供其他人协作。那么使用：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin your_remote_git_repo	<span class="comment">	// 为本地仓库添加远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="推送本地的内容到远程仓库">推送本地的内容到远程仓库</h3><p>当本地仓库中，代码完成提交，就需要将代码等推送到远程仓库，这样其他协作人员可以从远程仓库同步内容。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> -u origin master <span class="comment">// 第一次推送时使用，可以简化后面的推送或者拉取命令使用</span></span><br><span class="line">git <span class="keyword">push</span> origin master	<span class="comment">// 将本地 master 分支推送到 origin 远程分支</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： <code>git push -u origin master</code>，第一次使用时，带上 <code>-u</code> 参数，在将本地的 master 分支推送到远程新的 master 分支的同时，还会把本地的 master 分支和远程的 master 分支关联起来。</p>
</blockquote>
<h3 id="从远程仓库获取最新内容">从远程仓库获取最新内容</h3><p>在多人协作过程中，当自己完成了本地仓库中的提交，想要向远程仓库推送前，需要先获取到远程仓库的最新内容。</p>
<p>可以通过 <code>git fetch</code> 和 <code>git pull</code> 来获取远程仓库的内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> fetch origin master	</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p><code>git fetch</code> 和 <code>git pull</code> 之间的区别：</p>
<ol>
<li><code>git fetch</code> 是仅仅获取远程仓库的更新内容，并不会自动做合并。</li>
<li><code>git pull</code> 在获取远程仓库的内容后，会自动做合并，可以看成 <code>git fetch</code> 之后 <code>git merge</code>。</li>
</ol>
<blockquote>
<p>注意：建议多使用 <code>git fetch</code>。</p>
</blockquote>
<h3 id="查看远程仓库信息">查看远程仓库信息</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="attr_selector">[-v]</span>		<span class="comment">// 显示远程仓库信息</span></span><br></pre></td></tr></table></figure>
<h3 id="建立本地分支和远程分支的关联">建立本地分支和远程分支的关联</h3><p>在本地仓库中的分支和远程仓库中的分支是对应的。一般情况下，远程仓库中的分支名称和本地仓库中的分支名称是一致的。</p>
<p>有的时候，我们会需要指定本地分支与远程分支的关联。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream <span class="string">'local_branch'</span> origin/remote_branch</span><br></pre></td></tr></table></figure>
<h3 id="修改本地仓库对应的远程仓库地址">修改本地仓库对应的远程仓库地址</h3><p>当远程的仓库地址发生变化时，需要修改本地仓库对应的远程仓库的地址。主要应用在<a href="http://blog.csdn.net/hongshan50/article/details/23663043" target="_blank" rel="external">工程迁移</a>过程中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="operator"><span class="keyword">set</span>-<span class="keyword">url</span> origin <span class="keyword">url</span></span></span><br></pre></td></tr></table></figure>
<h2 id="标签管理">标签管理</h2><p>在项目开发过程中，当一个版本发布完成时，是需要对代码打上标签，便于后续检索。获取处于其他的原因，需要对某个提交打上特定的标签。</p>
<h3 id="创建标签">创建标签</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="tag">a</span> <span class="string">'tagname'</span> -m <span class="string">'comment'</span> <span class="string">'commit_id'</span></span><br></pre></td></tr></table></figure>
<p><code>-a</code> 参数指定标签名， <code>-m</code> 添加备注信息， ‘commit_id’ 指定打标签的提交。</p>
<h3 id="查看所有标签">查看所有标签</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">tag</span>		<span class="comment">// 查看本地仓库中的所有标签</span></span><br></pre></td></tr></table></figure>
<h3 id="查看具体标签信息">查看具体标签信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> shwo tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除本地标签">删除本地标签</h3><p>如果打的标签出错，或者不在需要某个标签，则可以删除它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="operator">-d</span> tagname</span><br></pre></td></tr></table></figure>
<h3 id="删除远程标签">删除远程标签</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/tagname</span></span><br></pre></td></tr></table></figure>
<h3 id="推送标签到远程仓库">推送标签到远程仓库</h3><p>打完标签以后，有需要推送到远程仓库。</p>
<p>1. 推送单个标签到远程仓库</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">git</span> <span class="keyword">push </span>origin tagname</span><br></pre></td></tr></table></figure>
<p>2. 一次性推送所有标签到远程仓库。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="comment">--tags</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶操作">进阶操作</h2><h3 id="临时保存修改">临时保存修改</h3><p>在执行很多的 Git 操作的时候，是需要保持当前操作的仓库/分支处于 clean 状态，及没有未提交的修改。如 <code>git pull</code>， <code>git merge</code> 等等，如果有未提交的修改，这些将无法操作。</p>
<p>但是做这些事情的时候，你可能修改了比较多的代码，却又不想丢弃它。那么，你需要把这些修改临时保存起来，这就需要用到 <code>git stash</code>。</p>
<p>1. <strong>临时保存修改</strong>，这样仓库就可以回到 clean 状态。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  stash		<span class="comment">// 保存本地仓库中的临时修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以多次的 <code>git stash</code> 来保存不同的临时修改。</p>
</blockquote>
<p>2. <strong>查看临时保存</strong>。当你临时保存以后，后面还是要取回来的，那它们在哪里呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">list</span>	<span class="comment">// 显示所有临时修改</span></span><br></pre></td></tr></table></figure>
<p>3. 当我们处理完其他操作时，想要恢复临时保存的修改。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash apply		<span class="comment">// 恢复所有保存的临时修改</span></span><br><span class="line">git stash <span class="keyword">pop</span>		<span class="comment">// 恢复最近一次保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>4. 或者，我们后面觉得临时保存不想要了，那可以丢弃它。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="built_in">clear</span>	<span class="comment">	// 丢弃所有保存的临时修改</span></span><br></pre></td></tr></table></figure>
<p>这些是我目前在项目中经常会用到的操作，这里整理下来，可以作为一个手册。对于 Git 的理解或者更多的解释，并不在这里体现。大家可以参考其他更多的资料。</p>
<p>更多阅读：</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a><br><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="external">Git Community Book 中文版</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4233881.html" target="_blank" rel="external">Git 对象模型</a><br><a href="http://www.cnblogs.com/zhongxinWang/p/4235448.html" target="_blank" rel="external">探索 .git 目录</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面整理一下自己在开发过程中经常使用到的 Git 命令。使用 GUI 工具的同学，也可以对照起来看看。</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://linfuyan.com/tags/Git/"/>
    
      <category term="命令" scheme="http://linfuyan.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="指南" scheme="http://linfuyan.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="教程" scheme="http://linfuyan.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不懂技术的人不要对懂技术的人说这很容易实现]]></title>
    <link href="http://linfuyan.com/im-sure-it-will-only-take-you-a-few-days-to-code/"/>
    <id>http://linfuyan.com/im-sure-it-will-only-take-you-a-few-days-to-code/</id>
    <published>2015-10-11T10:36:09.000Z</published>
    <updated>2015-10-11T10:56:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/non-technical-people-cant-estimate-developmen.jpg" alt=""></p>
<p>“这个网站相当简单，所有你需要做的就是完成 X，Y，Z。你看起来应该是技术很好，所以，我相信，你不需要花费太多时间就能把它搭建起来。”</p>
<p>我时不时的就会收到这样的 Email 。写这些邮件的人几乎都是跟技术不沾边的人，或正在研究他们的第一个产品。起初，当听到人们这样的话，我总是十分的恼怒。他们在跟谁辩论软件开发所需要的时间？但后来我意识到，即使我自己对自己的项目预测要花去多少开发时间,我也是一筹莫展。如果连我自己都做不好，我何必对那些人恼怒呢？</p>
<a id="more"></a>
<p>真正让我郁闷的不是他们预估的错误。问题在于他们竟然认为自己可以做出正确的估计。作为开发人员，我们经常会发现，在软件开发的问题上，一个外行人会很自然的把复杂的事情估计的很简单。</p>
<p>这并不是为我们的愤怒找借口。但这引起了另外一个有趣的问题：为什么我们天生的预测复杂性的能力在遇到编程问题时会失灵？</p>
<p>为了回答这个问题，让我们来认识一下我们的大脑如何估计事情的。有些事情对于一些没有经验的人也很容易预估正确，但有些事情则不然。</p>
<p>我们来想想观看一个人弹吉他。即使你从来没有弹过吉他，在观看了一场弹奏《玛丽有只小羊羔( Mary had a Little Lamb )》的吉他表演后，你也能大概推测出这很简单，一个人不需要太高的技术就能演奏出来。同样，当观看了有人演奏 D 大调的《卡农( Pachabel’s Canon )》后，你也很容易推测出，这很复杂，需要很长时间的练习才能演奏的出来。</p>
<p>为什么我们能够很迅速准确的预估这两首曲子的复杂性呢？这是跟我们用来判断一个事情简单和还是复杂的方法有关的。我们的大脑有一些现成的模式来完成这些事情，首先一个就是根据速度。这种情况下，大脑会辨别每秒钟演奏的东西。根据每秒钟演奏了多少东西，我们很容易有一个直观的判断曲子的复杂度。因为用吉他演奏一首歌是一种物理过程，一种感官上的活动，我们的大脑很容易依此来推测速度，继而转换成复杂度。</p>
<p>我们还有另外一个天生的推测依据：体积。想想把一个帐篷和一栋公寓放在一起对比。即使一个人从来没有学过建筑学，他也能告诉你通常设计和建造一个帐篷会比设计和建造一栋公寓要简单。为什么？因为我们天生的会使用物理体积作为事物复杂性的一个指标。</p>
<p>当然。上面说的这两种逻辑分析并不是总是100%的有效。但大多数情况下，人们就是这样干，而且很成功。大多数情况中，我们在对物理过程评估时，我们的大脑会对物理事物进行有效的关联，不需要依赖之前的经验。</p>
<p>现在让我们来谈谈软件。当一个不懂技术的人试图对软件开发时间进行评估时，有两个很基本的直观指标在辅助他们：以体积为指标的复杂度和以速度为指标的复杂度。但他们没有意识到，软件跟他们想象的不一样。软件本质上不是有形物质。没有体积和速度。它的极小的组成部分可能会时不时的在电脑屏幕上闪现。正因为如此，当面对开发一个 web 应用时(或任何类型的软件)，我们的基本直观感觉失效了。</p>
<p>这第一点，速度，很显然根本不可能被外行人拿来对软件进行评估。于是很自然的，他们倾向于使用体积指标进行评估。要么是根据描述文档的页数，要么是根据软件的功能用例数或特征数。</p>
<p>有时候，这种评估手段确实有效！当面对一个静态网站，没有特别的设计要求，外行人很容易用这种方法估计出开发时间。但是，通常情况下，对于软件开发，体积并不能真实有效的反映复杂度。</p>
<p>不幸的是，对于软件的复杂度，唯一有效的推测方法是依据经验。而且还不是时时都好用。作为一个程序员，我知道，根据我之前开发过的相似的功能特征，我可以估计出现在的这些功能特征各自要多少开发时间。然后，我把总时间加起来，这就得到了完成整个项目需要的大致时间。然而，事实情况中，每个项目在开发过程中都遇到二、三个瓶颈。这些瓶颈会肆意的消耗程序员的大量时间，你在遇到它们之前根本不会有所预见。它们会拖住整个项目，致使工期延后数周甚至数月。</p>
<p>这些是没有经验的人在评估复杂度时不会理解的。他们不明白在其他事情上都很灵的方法，为什么放到软件开发上就不灵了。所以，下一次当你听到有人说”我想你几天时间就能把它开发出来”时，不管是谁说的，都不要懊恼。深呼吸一下，告诉他这篇文章的地址，自己该干什么还干什么。</p>
<p>译文来自：<a href="http://www.vaikan.com/im-sure-it-will-only-take-you-a-few-days-to-code/" target="_blank" rel="external">不懂技术的人不要对懂技术的人说这很容易实现</a><br>英文原文：<a href="http://danshipper.com/non-technical-people-cant-estimate-developmen" target="_blank" rel="external">I’m Sure It Will Only Take You A Few Days To Code</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/non-technical-people-cant-estimate-developmen.jpg" alt=""></p>
<p>“这个网站相当简单，所有你需要做的就是完成 X，Y，Z。你看起来应该是技术很好，所以，我相信，你不需要花费太多时间就能把它搭建起来。”</p>
<p>我时不时的就会收到这样的 Email 。写这些邮件的人几乎都是跟技术不沾边的人，或正在研究他们的第一个产品。起初，当听到人们这样的话，我总是十分的恼怒。他们在跟谁辩论软件开发所需要的时间？但后来我意识到，即使我自己对自己的项目预测要花去多少开发时间,我也是一筹莫展。如果连我自己都做不好，我何必对那些人恼怒呢？</p>]]>
    
    </summary>
    
      <category term="周期" scheme="http://linfuyan.com/tags/%E5%91%A8%E6%9C%9F/"/>
    
      <category term="开发" scheme="http://linfuyan.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="程序员" scheme="http://linfuyan.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="评估" scheme="http://linfuyan.com/tags/%E8%AF%84%E4%BC%B0/"/>
    
      <category term="软件" scheme="http://linfuyan.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="深度文摘" scheme="http://linfuyan.com/categories/%E6%B7%B1%E5%BA%A6%E6%96%87%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 如何保持页面文件不被渲染]]></title>
    <link href="http://linfuyan.com/keep-pages-at-your-hexo-blog/"/>
    <id>http://linfuyan.com/keep-pages-at-your-hexo-blog/</id>
    <published>2015-10-10T16:35:14.000Z</published>
    <updated>2015-10-10T16:50:54.000Z</updated>
    <content type="html"><![CDATA[<p>假设要保持 keep.html 文件原样输出，不被渲染：</p>
<p>1. 将 keep.html 文件放在 <code>source</code> 目录下。</p>
<p>2. 打开 <code>_confi.yml</code> 配置文件，添加 <code>skip_render:</code>，并声明 keep.html 文件如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">skip_render</span>: <span class="string">keep.html</span></span><br></pre></td></tr></table></figure>
<p>3. 如果需要保持多个文件，可以按照如下声明：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">skip_render</span>: <span class="string">[file1, files, ...]</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>假设要保持 keep.html 文件原样输出，不被渲染：</p>
<p>1. 将 keep.html 文件放在 <code>source</code> 目录下。</p>
<p>2. 打开 <code>_confi.yml</code> 配置文件，添加 <code>skip_]]>
    </summary>
    
      <category term="Hexo" scheme="http://linfuyan.com/tags/Hexo/"/>
    
      <category term="skip render" scheme="http://linfuyan.com/tags/skip-render/"/>
    
      <category term="渲染" scheme="http://linfuyan.com/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="页面" scheme="http://linfuyan.com/tags/%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="FAQ" scheme="http://linfuyan.com/categories/FAQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 6.0 特性及主要 API 变更]]></title>
    <link href="http://linfuyan.com/android-m-changes/"/>
    <id>http://linfuyan.com/android-m-changes/</id>
    <published>2015-10-10T03:52:00.000Z</published>
    <updated>2015-10-10T14:49:19.000Z</updated>
    <content type="html"><![CDATA[<p>伴随着新的特性和功能， Android 6.0 (API 级别 23)带来了一系列系统和 API 行为的变更。这篇文章中将介绍一些在应用程序中需要理解和注意的主要变更点。</p>
<blockquote>
<p>如果你之前已经发布过 Android 应用程序，要意识到这些变更对应用程序的影响。</p>
</blockquote>
<a id="more"></a>
<h2 id="运行时权限">运行时权限</h2><p>这个版本中引入了新的权限模型，现在用户可以在运行时直接管理应用程序的权限。这个模型基于用户对权限控制的更多可见性，同时为应用程序的开发者提供更流畅的应用安装和自动升级。用户可以为已安装的每个应用程序独立的授予或者取消权限。</p>
<p>在运行于目标版本 Android 6.0 (API 级别 23) 及以上的应用程序中，必须在运行时检查并请求权限。通过新的 <code>checkSelfPermission()</code> 方法来确定你的应用程序是否已经被授权。通过新的 <code>requestPermissions()</code> 方法来请求权限。即使你的应用程序运行的目标版本不是 Android 6.0 (API 级别 23)，你也应该在新的授权模型下来测试应用程序。</p>
<p>在应用程序中支持新的权限模型的更多详细信息，可以查看<a href="https://developer.android.com/training/permissions/index.html" target="_blank" rel="external">使用系统权限</a>。如何在应用程序中使用权限，相关提示可以查看<a href="https://developer.android.com/training/permissions/best-practices.html#testing" target="_blank" rel="external">权限最佳实践</a>。</p>
<h2 id="休眠与应用挂起(_Doze_and_App_Standby_)">休眠与应用挂起( Doze and App Standby )</h2><p>这个版本为空闲的设备和应用程序引入了电源节能优化。这个特性将影响所有应用程序，故确保自己的应用程序在这些新模式下进行测试。</p>
<ul>
<li><p><strong>休眠</strong>：如果用户将设备拔下，并将其静置，关闭屏幕，经过一段时间，设备将进入休眠模式。这时候，设备试图让系统保持在一个睡眠的状态。这种模式下，设备周期性的恢复平常的操作，以便应用程序同步，系统则可以处理一些延时的操作。</p>
</li>
<li><p><strong>应用挂起</strong>：应用挂起则允许系统当用户不再使用应用程序时，将其定义为空闲。当用户经过一段时间没有触摸应用程序时，系统可以做这个决定。设备被拔线时，系统禁用网络访问，停止应用程序的同步及操作，则被认为是空闲。</p>
</li>
</ul>
<p>学习更多关于电源节能的变更，查看<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对休眠与应用挂起的优化</a>。</p>
<h2 id="移除_Apache_HTTP_客户端">移除 Apache HTTP 客户端</h2><p>Android 6.0 发布版移除了对 Apache HTTP 客户端的支持。如果你的应用程序使用该客户端，并且目标运行版本为 Android 2.3 (API 级别9) 及以上，需要使用 <code>HttpURLConnection</code> 类来代替。这个 API 更加的高效，因为它通过对用户透明的压缩、响应缓存来减少网络开销，并最小化电量消耗。要继续使用 Apache HTTP 的 API，你需要在 <code>build.gradle</code> 文件中声明下面的编译期依赖：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">useLibrary</span> <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BoringSSL">BoringSSL</h2><p>Android 从 OpenSSL 转移到了 <a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="external">BoringSSL</a> 库。如果你在应用程序中使用 Android NDK，千万不要将加密库链接到除 NDK API 之外的任何库，如 <code>libcrypto.so</code> 和 <code>libssl.so</code>。这些库不是公开 API，有可能在没有收到通知的情况下在发布版和设备间发生变更或中断。这种情况你将把自己暴露在安全威胁下。你应该修改自己的本地代码来通过 JNI 调用 Java 加密 API 或者静态链接你选择的一个加密库。</p>
<h2 id="访问硬件标识符">访问硬件标识符</h2><p>为了给用户更多的数据保护，从这个版本开始， Android 移除了通过 WiFi 和蓝牙 API 来在应用程序中可编程的访问本地硬件标示符。现在 <code>WifiInfo.getMacAddress()</code> 和 <code>BluetoothAdapter.getAddress()</code> 方法都将返回 <code>02:00:00:00:00:00</code> 常量。</p>
<p>要通过蓝牙和 WiFi 扫描来访问附近外部设备的硬件标示符，应用程序需要 <code>ACCESS_FINE_LOCATION</code> 和 <code>ACCESS_COARSE_LOCATION</code> 权限：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/net/wifi/WifiManager.html#getScanResults\(\" target="_blank" rel="external"><code>WifiManager.getScanResults()</code></a>)</li>
<li><a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#ACTION_FOUND" target="_blank" rel="external"><code>BluetoothDevice.ACTION_FOUND</code></a></li>
<li><a href="https://developer.android.com/reference/android/bluetooth/le/BluetoothLeScanner.html#startScan\(android.bluetooth.le.ScanCallback\" target="_blank" rel="external"><code>BluetoothLeScanner.startScan()</code></a>)</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在一个运行 Android 6.0 (API 级别 23) 的设备初始化后台的 WiFi 或蓝牙扫描时，操作对于外部设备是可见的，且被赋予一个随机的 MAC 地址。</p>
</blockquote>
<h2 id="通知">通知</h2><p>这个版本移除了 <code>Notification.setLatestEventInfo()</code> 方法。使用 Notification.Builder 类来代替构造方法。要重复的更新通知，要重用 Notification.Builder 实例。调用 build() 方法来获取更新过的 Notification 实例。</p>
<p><code>adb shell dumpsys nnotification</code> 命令不在答应通知文本。使用 <code>adb shell dumpsys notification --noredcat</code> 命令来在同志对象中打印文本。</p>
<h2 id="AudioManager_变更">AudioManager 变更</h2><p>通过 AudioManager 类来直接设置音量或者使流静音已经不再支持。 setStreamSolo() 方法被弃用，你需要调用 requestAudioFocus() 来代替。类似的， setStreamMute() 方法被弃用，替换为 adjustStreamVolume() 方法并传递方向值 ADJUST_MUTE 或 ADJUST_UNMUTE。</p>
<h2 id="文本选择">文本选择</h2><p>当用户在应用程序中选择文本时，你可以在<a href="http://www.google.com/design/spec/patterns/selection.html#selection-text-selection" target="_blank" rel="external">悬浮工具栏</a>中显示文本选择工作，如剪切、复制、粘贴。用户交互实现与<a href="https://developer.android.com/guide/topics/ui/menus.html#CABforViews" target="_blank" rel="external">为独立视图启动上下文动作模式</a>中描述的上下文动作栏类似。</p>
<p>为文本选择实现悬浮工具栏，需要在已存在的应用程序中做如下修改：</p>
<ol>
<li><p>在 View 或者 Activity 对象中，通过修改 <code>startActionMode(Callback)</code> 为 <code>startActionMode(Callback, ActionMode.TYPE_FLOATING)</code> 来改变 ActionMode。 </p>
</li>
<li><p>使已经存在的 <code>ActionMode.Callback</code> 的实现继承自 ActionMode.Callback2 。</p>
</li>
<li><p>重载 onGetContentRect() 方法来提供内容 Rect 对象(如文本选择矩形)在视图中的坐标。</p>
</li>
<li><p>如果矩形位置不在有效，并且这是需要刷新的唯一元素，则调用 invalidateContentRect() 方法。</p>
</li>
</ol>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/text-selection.gif" alt="文本选择"></p>
<p>如果你在使用 Android 22.2 修订版的兼容包，悬浮工具栏不是向后兼容的，且使用默认的 ActionMode 对象。这导致悬浮工具栏无法显示。在 AppCompatActivity 中启用 ActionMode，首先调用 getDelegate() ，然后在返回的 AppCompatDelegate 对象中调用 setHandleNativeActionModesEnabled()，并设置输入参数为 <code>false</code>。这个调用为框架返回可控的 ActionMode 对象。在运行 Android 6.0 (API 级别 23) 的设备上，这允许框架支持 ActionBar 或悬浮工具栏模式。在 Android 5.1 (API 级别 22) 或更低版本，只有 ActionBar 是支持的。</p>
<h2 id="浏览器书签变更">浏览器书签变更</h2><p>这个版本移除了对全局书签的支持。 <code>android.provider.Browser.getAllBookmark()</code> 和 <code>android.provider.Browser.saveBookmark()</code> 方法被移除。同样的， <code>READ_HISTORY_BOOKMARKS</code> 和 <code>WRITE_HISTORY_BOOKMARKS</code> 权限被移除。如果你的应用程序的目标运行版本为 Android 6.0 (API 级别 23) 或者更高，不要从全局提供者访问书签或者使用书签权限。现在，你的应用程序需要内部保存书签数据。</p>
<h2 id="Android_Keystore_变更">Android Keystore 变更</h2><p>在这个版本中， <a href="https://developer.android.com/training/articles/keystore.html" target="_blank" rel="external">Android Keystore 提供器</a> 不在支持 DSA。 ECDSA 则仍然被支持。</p>
<p>当安全锁屏被禁用或重置时，不要求加密的 key 将不再被删除。要求加密的 key 则会在这些事件中被删除。</p>
<h2 id="Wi-Fi_和_网络变更">Wi-Fi 和 网络变更</h2><p>这个版本为 Wi-Fi 和 网络 API 引入了下面的行为变更：</p>
<ul>
<li>应用程序只有在创建了 WifiConfiguration 对象以后，才能更变这些对象的状态。当 WifiConfiguration 被用户或者其他应用程序创建时，你将不允许修改和删除这些 WifiConfiguration 对象。</li>
<li>在之前的版本中，如果应用程序使用 enableNetwork() ，并设置 <code>disableAllOthers=true</code> 来强制设备连接到指定的 Wi-Fi 网络，设备将和其他网络断开。这个版本中，这些设备将不再和其他网络断开。如果应用程序的 <code>targetSdkVersion</code> 是 20 或者更低，则会连接被选中的 Wi-Fi 网络。如果应用程序的 <code>targetSdkVersion</code> 是 21 或者更高，使用多网络 API (如 openConnection()， bindSocket() 及新的 bindProcessToNetwork() 方法)来确保它的网络通信是发给被选中的网络。</li>
</ul>
<h2 id="摄像头服务变更">摄像头服务变更</h2><p>在这个版本中，在摄像头服务中访问共享资源的模式发生了变更，不再是以前的”先到先得”，而是具备高优先级的将优先处理。服务行为的变更包括：</p>
<ul>
<li><p>访问摄像头子系统的资源，包括打开和配置摄像设备，依赖于客户端应用进程的优先级。用户可见或者在前台活动的应用程序进程往往具备更高的优先级，使得摄像资源更易获得，也更加可靠。</p>
</li>
<li><p>当更高优先级的应用程序视图使用摄像头时，具有低权限的活动摄像头客户端应用程序可能被中断。在被弃用的 Camera API 中，错误会在被中断客户端的 onError() 中被调用。在 Camera2 API 中，错误结果则在 onDisconnected() 中被调用。</p>
</li>
<li><p>在具备适合摄像头硬件的设备上，不同的应用进程可以同时独立地打开和使用独立的摄像头设备。虽然如此，多进程使用时，同时访问摄像头会造成设备性能的急剧下降，这将被摄像头服务所检测到并不被允许。这个变更使得由于较低优先级而被中断的客户端，即使当没有其他应用直接访问时，也会试图访问一样的设备。</p>
</li>
<li><p>改变当前用户会导致之前用户账号的应用程序中活动那个的摄像头客户端被中断。对摄像头的访问是被当前设备用户所限制的。实际上，这意味着当用户切换到不同的账户下时，原来的”访客”账号所使用的摄像头子系统是不可能继续运行的。</p>
</li>
</ul>
<h2 id="运行时">运行时</h2><p>通过 newInstance() 方法 ART 运行时现在正确的实现了访问规则。这个变更修复了之前版本中 Dalvik 检查访问规则时的错误。如果你的应用程序使用 newInstance() 方法，且你想要覆盖访问检查，调用 setAccessible() 方便，并设置参数为 <code>true</code>。如果你的应用程序使用 <a href="https://developer.android.com/tools/support-library/features.html#v7-appcompat" target="_blank" rel="external">v7 兼容库</a> 和 <a href="https://developer.android.com/tools/support-library/features.html#v7-recyclerview" target="_blank" rel="external">v7 recyclerview 库</a>。你需要升级应用程序中的相关库到最新版本。否则，需要确保 XML 中所引用的自定义类已经被升级，其构造方法是可访问的。</p>
<p>这个版本升级了动态链接器的行为。动态连接器现在可以理解库的 <code>soname</code> 和 它的路径之间的区别，且实现了通过 <code>soname</code> 来搜索。在加载时，之前可用的应用程序可能会被提示具有不可用的 <code>DT_NEEDED</code> 条目(通常是在构建机器文件系统中的绝对路径)。</p>
<p><code>dlopen(3) RTLD_LOCAL</code> 标志现在被正确实现了。 <code>RTLD_LOCAL</code> 是默认的，因此调用 <code>dlopen(3)</code> 是不明确使用 <code>RTLD_LOCAL</code> 是有效的(除非应用之前有明确使用 <code>RTLD_GLOBAL</code> )。使用 <code>RTLD_LOCAL</code> ，标记在调用 <code>dlopen(3)</code> 加载库之前是不可用的(这与被 <code>DT_NEEDED</code> 条目引用恰恰相反)。</p>
<p>在之前版本的 Android，如果你的应用请求系统来加载包含文本重定位段的动态链接库，系统会显示警告，但允许继续加载库。从这个版本开始，如果你的目标运行 SDK 版本为 23 或以上，系统会拒绝这个库。为了辅助检测库是否被成功加载，应用程序需要为 <code>dlopen(3)</code> 失败添加日志，并在 <code>dlerror(3)</code> 返回值中包含问题的描述文本。学习更多关于如何处理文本重定位段，可以查看这个<a href="https://wiki.gentoo.org/wiki/Hardened/Textrels_Guide" target="_blank" rel="external">指南</a>。</p>
<h2 id="APK_验证">APK 验证</h2><p>Android 平台现在执行更加严格的 APK 验证。如果一个文件在清单文件中被声明，但在 APK 中却没有，那么这个 APK 被认为是无效的。如果任意的内容被移除， APK 需要重新签名。</p>
<h2 id="USB_连接">USB 连接</h2><p>通过 USB 端口的设备连接现在默认被设置为充电模式。想要通过 USB 连接来访问设备和它的内容，用户需要为这些交互提供明确的授权。如果你的应用程序支持用户通过 USB 端口与设备交互，需要确保这些交互被明确启用。</p>
<h2 id="Android_for_Work_变更">Android for Work 变更</h2><p>这个版本包括下面的 Android for Work 行为变更：</p>
<ul>
<li><p><strong>个人上下文中的联系人</strong>。Google 拨号器通话记录现在可以在用户查看已通话记录时显示当前联系人。在 Google 拨号器中通过设置 <code>setCrossProfileCallerIdDisabled()</code> 为 <code>true</code> 来隐藏当前联系人。当设置 <code>setBluetoothContactSharingDisabled()</code> 为 <code>false</code> 时，当前联系人能通过蓝牙显示在设备联系人中。默认情况下，其设置为 <code>true</code>。</p>
</li>
<li><p><strong>移除 Wi-Fi 配置</strong>：由外部拥有者添加(如通过 addNetworkd() 方法)的 Wi-Fi 配置现在在当前 profile 被删除时也将被移除。</p>
</li>
<li><p><strong>紧闭 Wi-Fi 配置</strong>：如果 <code>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</code> 为非空时，任何由活动的设备拥有者创建的 Wi-Fi 配置将不能用户被修改和删除。用户可以创建和修改自己的 Wi-Fi 配置。活动的设备拥有者拥有编辑和移除任意 Wi-Fi 配置的特权，包括不是由他们创建的配置。</p>
</li>
<li><p><strong>通过 Google 账号下载使用策略控制器</strong>：当一个要求 WPC 应用程序来管理的 Google 账号被添加到管理上下文之外的设备中时，添加账号流程会提示用户安装合适的 WPC。这些行为也可以应用到通过在初始设备创建向导中 <strong>设置 &gt; 账号</strong> 添加的账号。</p>
</li>
<li><p><strong>制定 DevicePolicyManager API 行为变更</strong>：</p>
<ul>
<li>调用 <code>setCameraDisabled()</code> 方法来影响当前调用用户的摄像头。</li>
<li>此外， <code>setKeyguardDisabledFeatures()</code> 方法对 Profile 用户是可用的，与设备拥有者一样。</li>
<li>Profile 拥有者可以设置键盘守卫的约束：<ul>
<li>KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT 将影响到 profile 父用户的键盘守卫设置。</li>
<li>KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS 只会影响在 profile 中由应用程序生成的通知。</li>
</ul>
</li>
<li>createAndInitializeUser() 和 createUser() 方法已经被弃用。</li>
<li>当给定用户的应用程序在前台运行时， setScreenCaptureDisabled() 方法将阻塞辅助结构。</li>
<li>SHA-256 的默认值为 EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 。为保持兼容性， SHA-1 仍然被支持，但在将来会被移除。 EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM 则仅接受 SHA-256。</li>
<li>原来存在的设备初始化 API 在 Android 6.0 (API 级别 23) 中被移除了。</li>
<li>EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 被移除，因此 NFC bump provisioning 无法通过编程的方式解锁重置被保护的设备。</li>
<li>现在在被管理的设备中通过 NFC 可以使用 EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE 来传递数据给设备拥有者的应用程序。</li>
<li>Android M 上的 Android for Work API 是经过优化的，包括 Work 配置，辅助层及其他。新的 DevicePolicyManager 权限 API 不会影响 Android 之前版本的应用程序。</li>
<li>当用户通过 ACTION_PROVISION_MANAGED_PROFILE 或者 ACTION_PROVISION_MANAGED_DEVICE 意图，从创建流程中的同步部分返回时，系统将返回 RESULT_CANCELED 结果码。</li>
</ul>
</li>
<li><p><strong>其他 API 变更</strong>：</p>
<ul>
<li>数据用法： <code>android.app.usage.NetworkUsageStates</code> 类重命名为 NetworkStats。</li>
</ul>
</li>
<li><strong>全局设置变更</strong>：<ul>
<li>下面的设置不能继续通过 setGlobalSettings() 方法设置：<ul>
<li><code>BLUETOOTH_ON</code></li>
<li><code>DEVELOPMENT_SETTINGS_ENABLED</code></li>
<li><code>MODE_RINGER</code></li>
<li><code>NETWORK_PREFERENCE</code></li>
<li><code>WIFI_ON</code></li>
</ul>
</li>
<li>下面全局设置可以通过 setGlobalSettings() 方法设置：<ul>
<li>WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原文：<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 Changes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>伴随着新的特性和功能， Android 6.0 (API 级别 23)带来了一系列系统和 API 行为的变更。这篇文章中将介绍一些在应用程序中需要理解和注意的主要变更点。</p>
<blockquote>
<p>如果你之前已经发布过 Android 应用程序，要意识到这些变更对应用程序的影响。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="6" scheme="http://linfuyan.com/tags/6/"/>
    
      <category term="API" scheme="http://linfuyan.com/tags/API/"/>
    
      <category term="Android" scheme="http://linfuyan.com/tags/Android/"/>
    
      <category term="Marshmallow" scheme="http://linfuyan.com/tags/Marshmallow/"/>
    
      <category term="变更" scheme="http://linfuyan.com/tags/%E5%8F%98%E6%9B%B4/"/>
    
      <category term="更新" scheme="http://linfuyan.com/tags/%E6%9B%B4%E6%96%B0/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Android" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 配置 scheme 及 configuration]]></title>
    <link href="http://linfuyan.com/iOS-scheme-and-configuration-setting/"/>
    <id>http://linfuyan.com/iOS-scheme-and-configuration-setting/</id>
    <published>2015-09-29T08:24:00.000Z</published>
    <updated>2015-11-03T08:28:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="新建共享_scheme">新建共享 scheme</h4><p>Xcode -&gt; Manage schemes…</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/scheme-manage-1.png" alt=""></p>
<p>点击左下角的 + 来添加新的 scheme。添加成功以后，勾选新的 scheme 后面的 Shared 将scheme 设置为共享，这样在版本控制系统中可以包含这个项目设置。参与协作的人获得这份代码，就可以共享这个 scheme。</p>
<h4 id="新建_Configuration">新建 Configuration</h4><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/scheme-manage-2.png" alt=""></p>
<ol>
<li>打开项目 Project 的 info 标签。</li>
<li>点击2中的 <code>+</code>，选择 <code>Duplicate &quot;Release&quot; Configuraton</code>。</li>
<li>修改新建的 Configuration 的名称，本文中为 InHouse。</li>
</ol>
<h4 id="设置_Configuration_对应的签名及_Profile">设置 Configuration 对应的签名及 Profile</h4><p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/scheme-manage-3.png" alt=""></p>
<ol>
<li>打开项目中 Target 的 Build Setting 标签。</li>
<li>在 Code Signing 栏目中设置对应的签名和 Profile，其中2和3是 Jenkins 打包中需要用到的，设置为正式签名及企业账号导出的 Profile。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="新建共享_scheme">新建共享 scheme</h4><p>Xcode -&gt; Manage schemes…</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/sch]]>
    </summary>
    
      <category term="configuration" scheme="http://linfuyan.com/tags/configuration/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/tags/iOS/"/>
    
      <category term="scheme" scheme="http://linfuyan.com/tags/scheme/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[响应式编程2分钟简介]]></title>
    <link href="http://linfuyan.com/2-minute-introduction-to-rx/"/>
    <id>http://linfuyan.com/2-minute-introduction-to-rx/</id>
    <published>2015-09-28T03:40:00.000Z</published>
    <updated>2015-09-28T03:44:52.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877" target="_blank" rel="external">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>
<a id="more"></a>
<p>现在来考虑包含鼠标位置信息的点击事件。如果你把这些事件画在一条时间轴上，则看起来像这样：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<p>这是个事件流( <em>stream</em> of <em>event</em> )，或者叫” <strong>Observable</strong> “。</p>
<p>这些点击事件来自于鼠标，因此整个事件流是不可变的，这种情况下，当它被定义，你无法从中添加或者删除。</p>
<p>但是，如果我们仅仅对 <code>x &lt; 250</code> 的点击事件感兴趣呢？我们能否通过过滤来建立一个新的流，就像我们之前对数组所做的那样呢？</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_1.png" alt="click event with cursor position data on a timeline"></p>
<blockquote>
<p>filter((event) -&gt; event.x &lt; 250)</p>
</blockquote>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/2_minute_rx_2.png" alt="click event after filter"></p>
<p>既然这样，不可变数组与 <strong>Obserable</strong> 有什么不同呢？不仅仅这样，你可以应用 map、 filter、 reduce 等操作到这两者上。对于 <strong>Obserable</strong> ，你还可以应用这些操作： <code>merge</code>,  <code>delay</code>,  <code>concat</code>,  <code>buffer</code>,  <code>distinct</code>,  <code>first</code>,  <code>last</code>,  <code>zip</code>,  <code>startWith</code>,  <code>window</code>,  <code>takeUntil</code>,  <code>skip</code>,  <code>scan</code>,  <code>sample</code>,  <code>amb</code>,  <code>join</code>,  <code>flatMap</code> 等。</p>
<p><strong>把它想象成异步的不可变数组。</strong></p>
<p>在 underscore.js 中 Rx 被认为是事件。但想一想，到底什么是事件呢？你的应用中的大部分东西能否是个事件呢？</p>
<p>“应用启动”事件，”接口数据返回”事件，”按键按下”事件，”界面刷新”事件，”设备休眠”事件，等等。</p>
<p>实际上，几乎所有的东西都可以看做是事件的流。问题只在于如何以合适的方式来组合它们。</p>
<p>这就是响应式编程的2分钟介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877">https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877</a></p>
<p>可能你已经读过我之前写的<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">教程</a>。太长了？好吧。响应式编程也不是很难，甚至你自己也曾经发明了它。我们继续往后看。</p>
<p>你知道数组吗？当然，你完全知道。这下面的便是。</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
</blockquote>
<p>如果我告诉 你这是个<strong>不可变的数组</strong>，并让你拿走其中所有的奇数，你会怎么做？下面是比较流行的做法：</p>
<blockquote>
<p>[14, 9, 5, 2, 10, 13, 4]</p>
<p>filter((x) -&gt; x%2 == 0)</p>
<p>[14, 2, 10, 4]</p>
</blockquote>
<p>这些其实都不是新东西。这些在 underscore.js，ECMAScript 5.1， LINQ，Guava 等当中都是司空见惯的东西。它来自函数式编程范式。</p>]]>
    
    </summary>
    
      <category term="rx" scheme="http://linfuyan.com/tags/rx/"/>
    
      <category term="响应式" scheme="http://linfuyan.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="编程" scheme="http://linfuyan.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发技术" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="响应式编程" scheme="http://linfuyan.com/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Ubuntu 14.04 上通过 apt-get 安装 Apache Tomcat 7]]></title>
    <link href="http://linfuyan.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/"/>
    <id>http://linfuyan.com/how-to-install-apache-tomcat7-on-ubuntu-14-04-via-apt-get/</id>
    <published>2015-09-26T15:32:00.000Z</published>
    <updated>2015-09-26T15:46:19.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>
<a id="more"></a>
<h3 id="步骤一_-_先决条件">步骤一 - 先决条件</h3><p>在你开始这个向导之前，在你的服务器上需要配置一个独立的非 root 用户账号。你可以按照 Ubuntu 14.04 上搭建服务器中的 1-4 步来学习完成它。我们这里使用创建的 <code>demo</code> 用户来完成后续的教程。</p>
<h3 id="步骤二_-_安装_Tomcat">步骤二 - 安装 Tomcat</h3><p>首先，你需要升级 apt-get 软件包列表：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<p>现在你已经准备好安装 Tomcat。运行以下命令，开始安装：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install tomcat7</span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装 Tomcat 。这将同时安装 Tomcat 和它的依赖，例如 Java，同时，它将创建一个 <code>tomcat7</code> 用户，并以默认设置启动 Tomcat 。</p>
<p>这时候， Tomcat 并没有完全安装完成，但你可以通过在浏览器中输入本地域名或IP地址之后加 <code>:8080</code> 的方法来访问默认页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your_ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你会看到一个闪屏页面，显示 “It works” ，和其他附加信息。现在，我们要深入到 Tomcat 的安装过程。</p>
<h3 id="步骤三_-_安装额外软件包">步骤三 - 安装额外软件包</h3><p><em>注意：</em>如果你对 Tomcat 足够了解，且不需要 Web 管理接口，文档和示例，那这个章节不是必须的。如果你是第一次接触 Tomcat ，请继续。</p>
<p>通过以下代码，你将安装 Tomcat 的在线文档， Web接 口（管理 Web 应用），以及一些示例应用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> tomcat7-docs tomcat7-<span class="keyword">admin</span> tomcat7-examples</span></span><br></pre></td></tr></table></figure>
<p>输入 <code>yes</code> 来安装这些软件包。后面我们会讲到这些工具的用法和配置。接下来，我们要安装 JDK 。</p>
<h3 id="步骤四_-_安装_JDK_(可选)">步骤四 - 安装 JDK (可选)</h3><p>如果你打算在服务器上开发应用，你需要安装本章节中提到的软件。</p>
<p>JDK 确保我们可以开发运行在 Tomcat 服务器上的 Java 应用。运行以下命令来安装 <code>openjdk-7-jdk</code>:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">default</span>-jdk</span><br></pre></td></tr></table></figure>
<p>作为 JDK 的附件， Tomcat 文档上建议同时安装用来构建 Java 应用 Apache Ant 工具及包括 Git 在内的源码控制系统。通过下面的命令来安装它们：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install ant git</span><br></pre></td></tr></table></figure>
<p>Apache Ant 的更多信息，可查阅其<a href="http://ant.apache.org/manual/index.html" target="_blank" rel="external">官方文档</a>。 Git 使用教程可以参考<a href="https://www.digitalocean.com/community/articles/how-to-use-git-effectively" target="_blank" rel="external">这里</a>。</p>
<h3 id="步骤五_-_配置_Tomcat_Web_管理器">步骤五 - 配置 Tomcat Web 管理器</h3><p>想要使用步骤三中安装的 Web 应用管理器，需要先登录到 Tomcat 服务器。首先需要编辑修改 <code>tomcat-users.xml</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>tomcat7<span class="regexp">/tomcat-users.xml</span></span><br></pre></td></tr></table></figure>
<p>该文件充满了用于说明如何配置的注释。你需要删除下面两行之间的所有注释。如需要用作参考，则保留。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;tomcat-users&gt;</span></span><br><span class="line"><span class="tag">&lt;/tomcat-users&gt;</span></span><br></pre></td></tr></table></figure>
<p>你需要添加一个用户，可以访问 <code>manager-gui</code> 和 <code>admin-gui</code> （我们在步骤三种安装的管理界面）。你可以通过如下的配置来定义一个用户。如果需要，确保修改用户名和密码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tomcat-users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">user</span> <span class="attribute">username</span>=<span class="value">"admin"</span> <span class="attribute">password</span>=<span class="value">"password"</span> <span class="attribute">roles</span>=<span class="value">"manager-gui,admin-gui"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存并退出 <code>tomcat-users.xml</code> 文件。重启 Tomcat 服务，以便修改配置生效。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> service tomcat7 restart</span><br></pre></td></tr></table></figure>
<h3 id="步骤六_-_访问_Web_界面">步骤六 - 访问 Web 界面</h3><p>现在，我们已经配置了一个管理员用户，从 Web 浏览器访问 Web 管理器页面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//your-ip_address:8080</span></span><br></pre></td></tr></table></figure>
<p>你可以看到的页面如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_3.png" alt="image"></p>
<p>从上面可以看到，里面有四个链接到步骤三中安装的软件包：</p>
<ul>
<li>tomcat7-docs: Tomcat 的在线文档。通过 <code>http://your_ip_address:8080/docs/</code> 来访问</li>
<li>tomcat7-examples: Tomcat 7 Servlet 和 JSP 示例。你可以点击这些示例 Web 应用来了解它们是怎么工作的（通过源码可以了解它们是怎么实现的）。通过 <code>http://your_ip_address:8080/examples/</code> 来访问</li>
<li>tomcat7-admin ( Web 应用管理器): Tomcat Web 应用管理器。通过这里来管理你的 Java 应用。</li>
<li>tomcat7-admin (主机管理器): Tomcat 虚拟主机管理器。</li>
</ul>
<p>通过打开链接 <code>http://your_ip_address:8080/manager/html</code> ，来查看 Web 应用管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_1.png" alt="image"></p>
<p>这个Web应用管理器使用来管理Java应用的。你可以在这里执行应用的启动，停止，重新加载，部署，下架等操作。还可以对应用做一些诊断（如内存泄露）。最后，你服务器的相关信息被显示在页面的最底部。</p>
<p>通过打开链接 <code>http://your_ip_address:8080/host-manager/html</code> ，来查看虚拟主机管理器：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/tomcat7_ubuntu1404_2.png" alt="image"></p>
<p>在虚拟主机管理页面，你可以为应用程序添加虚拟主机。</p>
<h3 id="结束">结束</h3><p>Tomcat 的安装到此结束。你现在就可以免费得来部署自己的 Web 应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get">https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-7-on-ubuntu-14-04-via-apt-get</a></p>
<h4 id="关于_Apache_Tomcat">关于 Apache Tomcat</h4><p>Apache Tomcat 是一个服务器应用，通常用来部署 Java 应用到 Web 。 Tomcat 是 Java Servlet 与 JSP 技术的一个开源实现，由 Apache 软件基金会发布。</p>
<p>这个教程涵盖了在 Ubuntu 14.04 上 Tomcat 7.0.x 版本的安装和基础配置。</p>
<p>有两种基本的途径来安装 Tomcat 到 Ubuntu 上：</p>
<ul>
<li>通过 apt-get 工具来安装，这是最简单的方法。</li>
<li>从 Apache Tomcat 网站下载二进制发布包。本教程不涵盖这种方法。</li>
</ul>
<p>在这个教程中，我们将使用最简单地方法： <code>apt-get</code> 。这将从官方的 Ubuntu 资源仓库安装最新的 Tomcat 发布包，这个包可能不是 Tomcat 的最新发布版本。如果你想要确保安装 Tomcat 的最新版，你可以下载最新的二进制发布包。</p>]]>
    
    </summary>
    
      <category term="14.04" scheme="http://linfuyan.com/tags/14-04/"/>
    
      <category term="Ant" scheme="http://linfuyan.com/tags/Ant/"/>
    
      <category term="Apache" scheme="http://linfuyan.com/tags/Apache/"/>
    
      <category term="Git" scheme="http://linfuyan.com/tags/Git/"/>
    
      <category term="JDK" scheme="http://linfuyan.com/tags/JDK/"/>
    
      <category term="Java" scheme="http://linfuyan.com/tags/Java/"/>
    
      <category term="Linux" scheme="http://linfuyan.com/tags/Linux/"/>
    
      <category term="Tomcat" scheme="http://linfuyan.com/tags/Tomcat/"/>
    
      <category term="Ubuntu" scheme="http://linfuyan.com/tags/Ubuntu/"/>
    
      <category term="Web" scheme="http://linfuyan.com/tags/Web/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="tomcat" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/tomcat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是 Jenkins?]]></title>
    <link href="http://linfuyan.com/what-is-jenkins/"/>
    <id>http://linfuyan.com/what-is-jenkins/</id>
    <published>2015-09-26T15:13:09.000Z</published>
    <updated>2015-09-26T15:26:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
<ul>
<li><strong>持续构建/测试软件项目</strong>，类似于 <code>CruiseControl</code> 或者 <code>DamageControl</code> 。简而言之， Jenkins 提供一个使用简单地持续集成系统，使得开发人员更方便的集成项目修改，让用户更容易地获取较新的构建版本。自动化持续构建极大提高了生产力。</li>
<li><strong>监控外部运行任务的执行</strong>，比如配置在本地或者远程的 <code>cron</code> 或 <code>procmail</code> 任务。拿 <code>cron</code> 举个例子，你将收到的是一些包含输出结果的常规电子邮件，提醒你勤快地处理它们，当它们出错时，也可以第一时间提醒你。 Jenkins 保存这些输出，并使得出现问题时的通知变得简单。</li>
</ul>
<h3 id="特性">特性</h3><p>Jenkins 所提供(拥有)的特性如下：</p>
<ol>
<li><strong>易于安装</strong>：只需要一个名为 jenkins.war 的 Java jar 包，或者将它发布到 servlet 容器。不需要其他附件安装，不需要数据库。</li>
<li><strong>易于配置</strong>：整个 Jenkins 的配置都可以通过它友好的 Web 界面来完成。不在需要别扭的 XML 手动配置，如果你依然愿意，可以继续使用。</li>
<li><strong>修改设置的支持</strong>： Jenkins 可以从 <code>Subversion/CVS</code> 生成一系列的修改列表来完成构建。这种方式也非常的前卫，因为减少了从存储库加载资源的步骤。</li>
<li><strong>永久的链接地址</strong>： Jenkins 为大部分的页面提供了简洁可读的 URL ，包括诸如” <code>latest build/latest successful build</code> “这样的永久性链接，可以很轻易的从其他地方链接过来。</li>
<li><strong>RSS/邮件/即时通行集成</strong>：通过 RSS 或者邮件来获取失败时的实时通知，轻而易举地监控构建结果。</li>
<li><strong>标记构建过程</strong>：当构建完成以后，可以对其进行标记存储。</li>
<li><strong>JUnit/TestNG 测试报告</strong>： JUnit 的测试报告及历史信息，可以表格形式总结与展示，比如构建在什么时候开始出错等等。历史趋势以图表形式绘制出来。</li>
<li><strong>分布式构建</strong>： Jenkins 可以分配构建/测试到多台电脑商。</li>
<li><strong>文件指纹</strong>： Jenkins 可以跟踪那次构建生成了哪些 jar 包，哪些构建使用了哪个版本的 jar 包等等。这些对不是 Jenkins 内部产生的 jar 包也有效，非常适合于项目中的依赖跟踪。</li>
<li><strong>插件支持</strong>： Jenkins 可以轻易地通过第三方插件进行扩展。你甚至可以为自己的团队使用编写合适的 Jenkins 插件。</li>
</ol>
<h3 id="Jenkins_由来">Jenkins 由来</h3><p>目前持续集成（ CI ）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，只在缓和和稳固软件的构建过程，并且能够帮助你的开发团队应对如下挑战：</p>
<ul>
<li>软件构建自动化：配置完成后， CI 系统会依照预先定制的时间表，或者针对某一特定事件，对目标软件进行构建。</li>
<li>构建可持续的自动化检查： CI 系统能持续地获取新增或者修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时， CI 系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力。</li>
<li>构建可持续的自动化测试：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知给相关的当事人。</li>
<li>生成后后续过程的自动化：当自动化检查和测试成功完成以后，软件构建的周期中可能需要一些额外的任务，诸如生成文档，打包软件，部署构建到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。</li>
</ul>
<p>部署一个 CI 系统需要的最低要求是，一个可获取的源代码仓库，一个包含构建脚本的项目。</p>
<p>CI 系统的基本结构，如下：</p>
<p><img src="http://7sbydj.com1.z0.glb.clouddn.com/static/images/jenkins-basic-structure.jpg" alt="image"></p>
<p>该系统的各个组成部分是按如下顺序发挥作用的：</p>
<ol>
<li>开发这检入代码到源代码仓库。</li>
<li>CI 系统会为每一个项目创建一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</li>
<li>CI 系统会在对应的工作区内执行构建过程。</li>
<li>如果配置存在，构建完成后， CI 系统会在一个新的构建中执行定义的一套测试。完成后出发通知（RSS，邮箱等等）给相关的当事人。</li>
<li>如果配置存在，在构建成功后，这个构建会被打包并转移到一个部署目标（如应用服务器）或存储为软件仓库中的一个新版本。软件仓库可以是 CI 系统的一部分，也可以是一个外部的仓库，诸如一个文件或者服务器或者像 Java.net 、 SourceForge 之类的网站。</li>
<li>CI 系统通常会根据请求发起相应地操作，诸如及时构建、生成报告，或者检索一些构建好的构件。</li>
</ol>
<p>Jenkins 就是这样的一个 CI 系统。它的主要目标在于监控软件开发流程，快速显示问题。所以能保证开发人员以及相关人员省时省力提高开发效率。</p>
<p>在整个开发过程中， CI 的作用主要是控制：当系统在代码库中探测到修改是，它将运行构建的任务委托给构建过程本身。如果构建失败了，那么 CI 将通知相关人员，然后继续监视存储库。</p>
<h4 id="参考">参考</h4><ol>
<li><a href="http://www.cnblogs.com/zz0412/p/jenkins01.html" target="_blank" rel="external">Jenkins是什么</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins" target="_blank" rel="external">Meet Jenkins</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是Jenkins">什么是Jenkins</h3><p>Jenkins 是一款一流的应用软件，用于监控重复任务的执行，包括一个软件项目的构建、由 <code>cron</code> 执行的工作等。在此基础之上，Jenkins 现在专注于以下两个方向：</p>
]]>
    </summary>
    
      <category term="CI" scheme="http://linfuyan.com/tags/CI/"/>
    
      <category term="jenkins" scheme="http://linfuyan.com/tags/jenkins/"/>
    
      <category term="持续集成" scheme="http://linfuyan.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="构建" scheme="http://linfuyan.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="测试" scheme="http://linfuyan.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化" scheme="http://linfuyan.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="软件工具" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="jenkins" scheme="http://linfuyan.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/jenkins/"/>
    
  </entry>
  
</feed>
